username,userslug,contest_rank,question_id,language,code,submission_id
SR3mix,SR3mix,2,3612,cpp,"class Solution {
public:
    vector<int>dp;
    int n;
    bool check(int m) {
        for (int i = 0; i < n - m; i++) {
            if (dp[i] >= m && dp[i+m] >= m) return true;
        }
        return false;
    }
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        n = nums.size();
        dp = vector<int>(n);
        dp[n-1] = 1;
        for (int i = n-2; i >= 0; i--) {
            if (nums[i] < nums[i+1]) dp[i] = dp[i+1] + 1;
            else dp[i] = 1;
        }
        return check(k);
    }
};",1448188802
SR3mix,SR3mix,2,3619,cpp,"class Solution {
public:
    vector<int>dp;
    int n;
    bool check(int m) {
        for (int i = 0; i < n - m; i++) {
            if (dp[i] >= m && dp[i+m] >= m) return true;
        }
        return false;
    }
    int maxIncreasingSubarrays(vector<int>& nums) {
        n = nums.size();
        dp = vector<int>(n);
        dp[n-1] = 1;
        for (int i = n-2; i >= 0; i--) {
            if (nums[i] < nums[i+1]) dp[i] = dp[i+1] + 1;
            else dp[i] = 1;
        }
        int l = 1, r = n;
        while (l < r) {
            int m = l + (r - l)/2 + (r-l)%2;
            if (check(m)) l =m;
            else r = m-1;
        }
        return l;
    }
};",1448188115
SR3mix,SR3mix,2,3631,cpp,"typedef long long ll;
ll M = 1e9 + 7;
vector<ll>key;
class Solution {
public:
    int reduce(int x) {
        int cnt = 0;
        while (x > 1) {
            x = __builtin_popcount(x);
            cnt++;
        }
        return cnt;
    }
    string r;
    int k;
    ll dp[805][2][805];
    ll compute(int done, bool t2, int cnt) {
        if (done == r.size()) {
            if (cnt == 0) return 0;
            int ops = key[cnt] + 1;
            if (ops <= k) return 1;
            return 0;
        }
        if (dp[done][t2][cnt] != -1) return dp[done][t2][cnt];
        int s = 0;
        int e = 1; if (t2) e = r[done] - '0';
        ll res = 0;
        for (int i = s; i <= e; i++) {
            bool nt2 = (t2 && (r[done] - '0') == i);
            res = (res + compute(done + 1, nt2, cnt + i))%M;
        }
        
        dp[done][t2][cnt] = res;
        return res;
    }
    int countKReducibleNumbers(string s, int kk) {
        r = s; k = kk;
        if (key.size() == 0) {
            key = vector<ll>(805);
            for (int i = 1; i <= 804; i++) key[i] = reduce(i);
        }
        //return 0;
        memset(dp, -1, sizeof(dp));
        ll ans = compute(0, true, 0);
        int cnt = 0; for (auto i : s) cnt += i - '0';
        if (key[cnt]+ 1 <= k) ans--;
        return ans;
    }
};",1448203811
SR3mix,SR3mix,2,3646,cpp,"typedef long long ll;
ll M = 1e9 + 7;
// Z Mod Long Long
const long long PrimeMod = M;
struct MLL
{
    long long x;
    MLL(long long init_val = 0)
    {
        assert(init_val >= 0);
        x = init_val % PrimeMod;
    }
    long long val() {
        return x;
    }
    MLL power(long long exponent) {
        MLL res = 1, a = x; 
        long long b = exponent;
        for (; b; b /= 2, a *= a) {
            if (b % 2) {
                res *= a;
            }
        }
        return res;
    }
    MLL inv() {
        return power(PrimeMod - 2);
    }
    long long norm(long long v) {
        if (v < 0) v += PrimeMod;
        else if (v >= PrimeMod) v -= PrimeMod;
        assert(v >= 0 && v < PrimeMod);
        return v;
    } 
    MLL &operator+=(MLL rhs) &{
        x = norm(x + rhs.x);
        return *this;
    }
    MLL &operator-=(MLL rhs) &{
        x = norm(x - rhs.x);
        return *this;
    }
    MLL &operator*=(MLL rhs) &{
        x = (x * rhs.x)%PrimeMod;
        return *this;
    }
    MLL &operator/=(MLL rhs) &{
        x = (x * rhs.inv().x)%PrimeMod;
        return *this;
    }
    friend MLL operator+(MLL lhs, MLL rhs)
    {
        MLL res = lhs; res += rhs;
        return res;
    }
    friend MLL operator-(MLL lhs, MLL rhs)
    {
        MLL res = lhs; res -= rhs;
        return res;
    }
    friend MLL operator*(MLL lhs, MLL rhs)
    {
        MLL res = lhs; res *= rhs;
        return res;
    }
    friend MLL operator/(MLL lhs, MLL rhs) {
        MLL res = lhs; res /= rhs;
        return res;
    }
    friend bool operator==(MLL lhs, MLL rhs) {
        return lhs.x == rhs.x;
    }
    friend bool operator!=(MLL lhs, MLL rhs) {
        return lhs.x != rhs.x;
    }
    friend std::istream &operator>>(std::istream &is, MLL &a) {
        long long v; is >> v;
        a = MLL(v);
        return is;
    }
    friend std::ostream &operator<<(std::ostream &os, MLL &a) {
        return os << a.val();
    }
};
using Z = MLL;
Z Zpowxy(long long a, long long b) {
    Z x = a;
    return x.power(b);
}
long long int powxy(long long int x, long long int y, long long M) {
    if (y == 0) return 1;
    if (y%2 == 1) return (x*powxy(x, y-1, M))%M;
    long long int t = powxy(x, y/2, M);
    return (t*t)%M;
}
// CREDIT TO JIANGLY FOR THIS TEMPLATE -> https://codeforces.com/profile/jiangly
class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int ma = *max_element(nums.begin(), nums.end());
        vector<Z>dp(ma + 3);
        vector<Z>cnt(ma + 3);
        for (auto x : nums) {
            Z cx = x;
            dp[x + 1] += cx;
            cnt[x + 1] += (Z)1;
            dp[x + 1] += dp[x] + cnt[x] * cx;
            cnt[x + 1] += cnt[x];
            dp[x + 1] += dp[x + 2] + cnt[x + 2] * cx;
            cnt[x + 1] += cnt[x + 2];
        }
        Z ans = 0;
        for (Z t : dp) ans += t;
        return ans.x;
    }
};",1448183572
Ethan,ethanrao,5,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        for (int i = 0; i <= nums.size() - 2 * k; ++i) {
            bool flag1 = true;
            bool flag2 = true;

            for (int j = i; j < i + k - 1; ++j) {
                if (nums[j] >= nums[j + 1]) {
                    flag1 = false;
                    break;
                }
            }

            for (int j = i + k; j < i + 2 * k - 1; ++j) {
                if (nums[j] >= nums[j + 1]) {
                    flag2 = false;
                    break;
                }
            }


            if(flag1 && flag2) return true;
        }

        return false;
    }
};",1448196885
Ethan,ethanrao,5,3619,cpp,"class Solution {
public:
    bool check(vector<int>& nums,vector<int>& lc, int k) {
        int n = nums.size();
        for (int i = 0; i <= n - 2 * k; ++i) {
            if (lc[i] >= k && lc[i + k] >= k) {
                return true;
            }
        }
        return false;
    }
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> lc(n);
        for(int i=0;i<n;i++){
            lc[i] = 0;
        }
        lc[n - 1] = 1;

        for (int i = n - 2; i >= 0; --i) {
            if (nums[i + 1] > nums[i]) {
                lc[i] = lc[i + 1] + 1;
            } else {
                lc[i] = 1;
            }
        }

        int low = 1, high = n / 2, ans = 0;

        while (low <= high) {
            int mid = (low + high) / 2;
            if (check(nums, lc, mid)) {
                ans = mid;
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }

        return ans;
    }


};
",1448204730
Ethan,ethanrao,5,3631,cpp,"class Solution {
public:
    int n, f[805], dp[805][805][2];
    const int mod = 1e9 + 7;
    inline int add(int x, int y){
        return x + y >= mod ? x + y - mod : x + y;
    }
    inline int popcnt(int x){
        int r = 0;
        while(x){
            if(x & 1) r += 1;
            x >>= 1;
        }
        return r;
    }
    int countKReducibleNumbers(string s, int u) {
        n = s.size();
        f[1] = 0;
        for(int i = 2; i <= 800; ++i) f[i] = f[popcnt(i)] + 1;
        dp[0][1][0] = 1;
        dp[0][0][1] = 1;
        for(int i = 1; i < n; ++i){
            int z = s[i] - '0';
            for(int j = 0; j <= i; ++j){
                for(int k = 0; k <= 1; ++k){
                    for(int t = 0; t <= 1; ++t){
                        if(k == 0 && t > z) continue;
                        int nk = k;
                        if(t < z) nk = 1;
                        dp[i][j + t][nk] = add(dp[i][j + t][nk], dp[i - 1][j][k]);
                    }
                }
            }
        }
        int ans = 0;
        for(int i = 1; i <= n; ++i) if(f[i] <= u - 1) ans = add(ans, dp[n - 1][i][1]);
        return ans;
    }
};",1448196025
Ethan,ethanrao,5,3646,cpp,"class Solution {
public:
    int f[100005], g[100005], n, a[100005], h[100005];
    const int mod = 1e9 + 7;
    inline int add(int x, int y){
        return x + y >= mod ? x + y - mod : x + y;
    }
    inline int mul(int x, int y){
        return 1ll * x * y % mod;
    }
    int sumOfGoodSubsequences(vector<int>& nums) {
        n = nums.size();
        for(int i = 1; i <= n; ++i) a[i] = nums[i - 1];
        memset(f, 0, sizeof f);
        for(int i = 1; i <= n; ++i){
            g[i] = add(1, f[a[i] + 1]);
            if(a[i] >= 1) g[i] = add(g[i], f[a[i] - 1]);
            f[a[i]] = add(f[a[i]], g[i]);
        }
        memset(f, 0, sizeof f);
        for(int i = n; i >= 1; --i){
            h[i] = add(1, f[a[i] + 1]);
            if(a[i] >= 1) h[i] = add(h[i], f[a[i] - 1]);
            f[a[i]] = add(f[a[i]], h[i]);
        }
        int ans = 0;
        for(int i = 1; i <= n; ++i){
            
            ans = add(ans, mul(a[i], mul(g[i], h[i])));
        }
        return ans;
    }
};",1448204935
Dylan Smith,DylanSmith,6,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        vector<int> right(nums.size());
        for (int i = (int)nums.size() - 1; i >= 0; i--) {
            right[i] = 1;
            if (i + 1 < (int)nums.size() && nums[i + 1] > nums[i]) right[i] = right[i + 1] + 1;
        }
        int cur = 0;
        int res = 0;
        for (int i = 0; i + 1 < (int)nums.size(); i++) {
            if (i > 0 && nums[i] > nums[i - 1]) cur++;
            else cur = 1;
            if (cur >= k && right[i + 1] >= k) return 1;
        }
        return 0;
    }
};",1448183801
Dylan Smith,DylanSmith,6,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        vector<int> right(nums.size());
        for (int i = (int)nums.size() - 1; i >= 0; i--) {
            right[i] = 1;
            if (i + 1 < (int)nums.size() && nums[i + 1] > nums[i]) right[i] = right[i + 1] + 1;
        }
        int cur = 0;
        int res = 0;
        for (int i = 0; i + 1 < (int)nums.size(); i++) {
            if (i > 0 && nums[i] > nums[i - 1]) cur++;
            else cur = 1;
            res = max(res, min(cur, right[i + 1]));
        }
        return res;
    }
};",1448183121
Dylan Smith,DylanSmith,6,3631,cpp,"typedef long long ll;

#define pb push_back
#define sz(x) (int)x.size()
#define all(x) begin(x),end(x)
#define lb(x,y) lower_bound(all(x),y)-begin(x)
class Solution {
public:
    int mod = 1000000007;
    int countKReducibleNumbers(string s, int k) {
        vector<int> dp(sz(s) + 1, 0);
        dp[0] = 1;
        vector<int> freq(sz(s) + 1, 0);
        for (int i = sz(s) - 1; i >= 0; i--) {
            if (s[i] == '1') {
                int cnt = 0;
                for (int j = 0; j < i; j++) {
                    cnt += s[j] == '1';
                }
                for (int j = 0; j + cnt <= sz(s); j++) {
                    freq[cnt + j] += dp[j];
                    if (freq[cnt + j] >= mod) freq[cnt + j] -= mod;
                }
            }
            for (int j = sz(s); j > 0; j--) {
                dp[j] += dp[j - 1];
                if (dp[j] >= mod) dp[j] -= mod;
            }
        }
        int res = 0;
        for (int i = 1; i <= sz(s); i++) {
            int cur = i;
            for (int j = 0; j < k - 1; j++) {
                int nxt = 0;
                while (cur) {
                    nxt += cur & 1;
                    cur >>= 1;
                }
                cur = nxt;
            }
            if (cur == 1) {
                res += freq[i];
                if (res >= mod) res -= mod;
            }
        }
        return res;
    }
};",1448206247
Dylan Smith,DylanSmith,6,3646,cpp,"class Solution {
public:
    int mod = 1000000007;
    int sumOfGoodSubsequences(vector<int>& nums) {
        map<int, int> cnt, sum;
        for (int i : nums) {
            cnt[i] += (cnt[i - 1] + cnt[i + 1] + 1) % mod;
            cnt[i] %= mod;
            sum[i] += (sum[i - 1] + sum[i + 1]) % mod;
            sum[i] %= mod;
            sum[i] += (long long)(cnt[i - 1] + cnt[i + 1] + 1) % mod * i % mod;
            sum[i] %= mod;
        }
        int res = 0;
        for (auto &p : sum) {
            res += p.second;
            res %= mod;
        }
        return res;
    }
};",1448189947
Nutty Professor,varkatkl,11,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        N = len(nums)
        incr = [1] * N
        for i in range(N - 2, -1, -1):
            if nums[i] < nums[i + 1]:
                incr[i] = 1 + incr[i + 1]

        for i in range(N - 2 * k + 1):
            if incr[i] >= k and incr[i + k] >= k:
                return True
        return False
",1448181997
Nutty Professor,varkatkl,11,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        N = len(nums)
        r_incr = [1] * N
        l_incr = [1] * N
        for i in range(1, N):
            if nums[i] > nums[i - 1]:
                l_incr[i] = l_incr[i - 1] + 1

        for i in range(N - 2, -1, -1):
            if nums[i] < nums[i + 1]:
                r_incr[i] = 1 + r_incr[i + 1]

        ret = 1
        for i in range(N - 1):
            ret = max(ret, min(l_incr[i], r_incr[i + 1]))

        return ret
",1448185336
Nutty Professor,varkatkl,11,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        MOD = (10 ** 9) + 7
        N = len(s)

        def reduce(x):
            ret = 0
            while x > 0:
                ret += x % 2
                x //= 2
            return ret

        min_ops = [0] * 801
        min_ops[0] = 10
        for i in range(1, 801):
            c, x = 0, i
            while x > 1:
                x = reduce(x)
                c += 1
            min_ops[i] = c

        @functools.lru_cache(maxsize=None)
        def f(i, lesser, bits):
            if i == N:
                return 1 if (lesser and min_ops[bits] < k) else 0
            ret = f(i + 1, lesser or s[i] == '1', bits)
            if lesser or s[i] == '1':
                ret += f(i + 1, lesser, bits + 1)
            ret %= MOD
            return ret

        return f(0, False, 0)
",1448213368
Nutty Professor,varkatkl,11,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        N = len(nums)
        MOD = (10 ** 9) + 7
        MAX = 100010
        total = [0] * MAX
        count = [0] * MAX

        for i in range(N - 1, -1, -1):
            a = nums[i]
            count[a] += 1
            count[a] += count[a + 1]
            if a - 1 >= 0:
                count[a] += count[a - 1]
            count[a] %= MOD

            total[a] += a
            total[a] += total[a + 1] + count[a + 1] * a
            if a - 1 >= 0:
                total[a] += total[a - 1] + count[a - 1] * a
            total[a] %= MOD

        return sum(total) % MOD
",1448195442
LayCurse,LayCurse,12,3612,cpp,"#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")
#include<bits/stdc++.h>
using namespace std;
template<class T> struct cLtraits_identity{
  using type = T;
}
;
template<class T> using cLtraits_try_make_signed =
  typename conditional<
    is_integral<T>::value,
    make_signed<T>,
    cLtraits_identity<T>
    >::type;
template <class S, class T> struct cLtraits_common_type{
  using tS = typename cLtraits_try_make_signed<S>::type;
  using tT = typename cLtraits_try_make_signed<T>::type;
  using type = typename common_type<tS,tT>::type;
}
;
template<class S, class T> inline auto min_L(S a, T b)
-> typename cLtraits_common_type<S,T>::type{
  return (typename cLtraits_common_type<S,T>::type) a <= (typename cLtraits_common_type<S,T>::type) b ? a : b;
}
template<class S, class T> inline S chmax(S &a, T b){
  if(a<b){
    a=b;
  }
  return a;
}
#define main dummy_main
int main(){
  return 0;
}
#undef main
class Solution{
  public:
  bool hasIncreasingSubarrays(vector<int>& A, int k){
    int i;
    int N = A.size();
    int res = 0;
    static int dp1[1000000];
    static int dp2[1000000];
    dp1[0] = 1;
    for(i=(1);i<(N);i++){
      if(A[i] > A[i-1]){
        dp1[i] =dp1[i-1]+1;
      }
      else{
        dp1[i] =1;
      }
    }
    dp2[N-1] = 1;
    for(i=(N-1)-1;i>=(0);i--){
      if(A[i] < A[i+1]){
        dp2[i] =dp2[i+1]+1;
      }
      else{
        dp2[i] =1;
      }
    }
    for(i=(1);i<(N);i++){
      chmax(res, min_L(dp1[i-1], dp2[i]));
    }
    return res >= k;
  }
}
;
// cLay version 20241019-1

// --- original code ---
// #define main dummy_main
// {}
// #undef main
// 
// class Solution {
// public:
//   bool hasIncreasingSubarrays(vector<int>& A, int k) {
//     int N = A.size();
//     int res = 0;
//     static int dp1[1d6], dp2[1d6];
// 
//     dp1[0] = 1;
//     rep(i,1,N) dp1[i] = if[A[i] > A[i-1], dp1[i-1]+1, 1];
// 
//     dp2[N-1] = 1;
//     rrep(i,N-1) dp2[i] = if[A[i] < A[i+1], dp2[i+1]+1, 1];
// 
//     rep(i,1,N) res >?= min(dp1[i-1], dp2[i]);
// 
//     return res >= k;
//   }
// };
",1448194012
LayCurse,LayCurse,12,3619,cpp,"#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")
#include<bits/stdc++.h>
using namespace std;
template<class T> struct cLtraits_identity{
  using type = T;
}
;
template<class T> using cLtraits_try_make_signed =
  typename conditional<
    is_integral<T>::value,
    make_signed<T>,
    cLtraits_identity<T>
    >::type;
template <class S, class T> struct cLtraits_common_type{
  using tS = typename cLtraits_try_make_signed<S>::type;
  using tT = typename cLtraits_try_make_signed<T>::type;
  using type = typename common_type<tS,tT>::type;
}
;
template<class S, class T> inline auto min_L(S a, T b)
-> typename cLtraits_common_type<S,T>::type{
  return (typename cLtraits_common_type<S,T>::type) a <= (typename cLtraits_common_type<S,T>::type) b ? a : b;
}
template<class S, class T> inline S chmax(S &a, T b){
  if(a<b){
    a=b;
  }
  return a;
}
#define main dummy_main
int main(){
  return 0;
}
#undef main
class Solution{
  public:
  int maxIncreasingSubarrays(vector<int>& A){
    int i;
    int N = A.size();
    int res = 0;
    static int dp1[1000000];
    static int dp2[1000000];
    dp1[0] = 1;
    for(i=(1);i<(N);i++){
      if(A[i] > A[i-1]){
        dp1[i] =dp1[i-1]+1;
      }
      else{
        dp1[i] =1;
      }
    }
    dp2[N-1] = 1;
    for(i=(N-1)-1;i>=(0);i--){
      if(A[i] < A[i+1]){
        dp2[i] =dp2[i+1]+1;
      }
      else{
        dp2[i] =1;
      }
    }
    for(i=(1);i<(N);i++){
      chmax(res, min_L(dp1[i-1], dp2[i]));
    }
    return res;
  }
}
;
// cLay version 20241019-1

// --- original code ---
// #define main dummy_main
// {}
// #undef main
// 
// class Solution {
// public:
//   int maxIncreasingSubarrays(vector<int>& A) {
//     int N = A.size();
//     int res = 0;
//     static int dp1[1d6], dp2[1d6];
// 
//     dp1[0] = 1;
//     rep(i,1,N) dp1[i] = if[A[i] > A[i-1], dp1[i-1]+1, 1];
// 
//     dp2[N-1] = 1;
//     rrep(i,N-1) dp2[i] = if[A[i] < A[i+1], dp2[i+1]+1, 1];
// 
//     rep(i,1,N) res >?= min(dp1[i-1], dp2[i]);
// 
//     return res;
//   }
// };
",1448192601
LayCurse,LayCurse,12,3631,cpp,"#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")
#include<bits/stdc++.h>
using namespace std;
#define MD (1000000007U)
struct Modint{
  unsigned val;
  Modint(){
    val=0;
  }
  Modint(int a){
    val = ord(a);
  }
  Modint(unsigned a){
    val = ord(a);
  }
  Modint(long long a){
    val = ord(a);
  }
  Modint(unsigned long long a){
    val = ord(a);
  }
  inline unsigned ord(unsigned a){
    return a%MD;
  }
  inline unsigned ord(int a){
    a %= (int)MD;
    if(a < 0){
      a += MD;
    }
    return a;
  }
  inline unsigned ord(unsigned long long a){
    return a%MD;
  }
  inline unsigned ord(long long a){
    a %= (int)MD;
    if(a < 0){
      a += MD;
    }
    return a;
  }
  inline unsigned get(){
    return val;
  }
  inline Modint &operator++(){
    val++;
    if(val >= MD){
      val -= MD;
    }
    return *this;
  }
  inline Modint &operator--(){
    if(val == 0){
      val = MD - 1;
    }
    else{
      --val;
    }
    return *this;
  }
  inline Modint operator++(int a){
    Modint res(*this);
    val++;
    if(val >= MD){
      val -= MD;
    }
    return res;
  }
  inline Modint operator--(int a){
    Modint res(*this);
    if(val == 0){
      val = MD - 1;
    }
    else{
      --val;
    }
    return res;
  }
  inline Modint &operator+=(Modint a){
    val += a.val;
    if(val >= MD){
      val -= MD;
    }
    return *this;
  }
  inline Modint &operator-=(Modint a){
    if(val < a.val){
      val = val + MD - a.val;
    }
    else{
      val -= a.val;
    }
    return *this;
  }
  inline Modint &operator*=(Modint a){
    val = ((unsigned long long)val*a.val)%MD;
    return *this;
  }
  inline Modint &operator/=(Modint a){
    return *this *= a.inverse();
  }
  inline Modint operator+(Modint a){
    return Modint(*this)+=a;
  }
  inline Modint operator-(Modint a){
    return Modint(*this)-=a;
  }
  inline Modint operator*(Modint a){
    return Modint(*this)*=a;
  }
  inline Modint operator/(Modint a){
    return Modint(*this)/=a;
  }
  inline Modint operator+(int a){
    return Modint(*this)+=Modint(a);
  }
  inline Modint operator-(int a){
    return Modint(*this)-=Modint(a);
  }
  inline Modint operator*(int a){
    return Modint(*this)*=Modint(a);
  }
  inline Modint operator/(int a){
    return Modint(*this)/=Modint(a);
  }
  inline Modint operator+(long long a){
    return Modint(*this)+=Modint(a);
  }
  inline Modint operator-(long long a){
    return Modint(*this)-=Modint(a);
  }
  inline Modint operator*(long long a){
    return Modint(*this)*=Modint(a);
  }
  inline Modint operator/(long long a){
    return Modint(*this)/=Modint(a);
  }
  inline Modint operator-(void){
    Modint res;
    if(val){
      res.val=MD-val;
    }
    else{
      res.val=0;
    }
    return res;
  }
  inline operator bool(void){
    return val!=0;
  }
  inline operator int(void){
    return get();
  }
  inline operator long long(void){
    return get();
  }
  inline Modint inverse(){
    int a = val;
    int b = MD;
    int u = 1;
    int v = 0;
    int t;
    Modint res;
    while(b){
      t = a / b;
      a -= t * b;
      swap(a, b);
      u -= t * v;
      swap(u, v);
    }
    if(u < 0){
      u += MD;
    }
    res.val = u;
    return res;
  }
  inline Modint pw(unsigned long long b){
    Modint a(*this);
    Modint res;
    res.val = 1;
    while(b){
      if(b&1){
        res *= a;
      }
      b >>= 1;
      a *= a;
    }
    return res;
  }
  inline bool operator==(int a){
    return ord(a)==val;
  }
  inline bool operator!=(int a){
    return ord(a)!=val;
  }
}
;
inline Modint operator+(int a, Modint b){
  return Modint(a)+=b;
}
inline Modint operator-(int a, Modint b){
  return Modint(a)-=b;
}
inline Modint operator*(int a, Modint b){
  return Modint(a)*=b;
}
inline Modint operator/(int a, Modint b){
  return Modint(a)/=b;
}
inline Modint operator+(long long a, Modint b){
  return Modint(a)+=b;
}
inline Modint operator-(long long a, Modint b){
  return Modint(a)-=b;
}
inline Modint operator*(long long a, Modint b){
  return Modint(a)*=b;
}
inline Modint operator/(long long a, Modint b){
  return Modint(a)/=b;
}
inline int BIT_popcount_L(const int x){
  return __builtin_popcount(x);
}
inline int BIT_popcount_L(const long long x){
  return __builtin_popcountll(x);
}
#define main dummy_main
int main(){
  return 0;
}
#undef main
class Solution{
  public:
  int countKReducibleNumbers(string s, int k){
    int i, j, m;
    int N = s.size();
    static int go[1000][6];
    static int gof;
    static Modint dp[2][1000];
    static Modint nx[2][1000];
    Modint res = 0;
    if(gof==0){
      int i, j;
      gof = 1;
      for(i=(0);i<(1000);i++){
        go[i][0] = i;
      }
      for(j=(0);j<(5);j++){
        for(i=(0);i<(1000);i++){
          go[i][j+1] =BIT_popcount_L(go[i][j]);
        }
      }
    }
    for(i=(0);i<(2);i++){
      int j;
      for(j=(0);j<(N+1);j++){
        dp[i][j] = 0;
      }
    }
    dp[0][0] = 1;
    for(m=(0);m<(N);m++){
      int j;
      for(i=(0);i<(2);i++){
        int j;
        for(j=(0);j<(N+1);j++){
          nx[i][j] = 0;
        }
      }
      for(j=(0);j<(N+1);j++){
        if(dp[0][j] || dp[1][j]){
          int x;
          for(x=(0);x<(2);x++){
            nx[1][j+x] += dp[1][j];
          }
          if(s[m]=='0'){
            nx[0][j] += dp[0][j];
          }
          else{
            nx[1][j] += dp[0][j];
            nx[0][j+1] += dp[0][j];
          }
        }
      }
      for(i=(0);i<(2);i++){
        for(j=(0);j<(N+1);j++){
          dp[i][j] = nx[i][j];
        }
      }
    }
    for(j=(0);j<(N+1);j++){
      if(go[j][k-1]==1){
        res += dp[1][j];
      }
    }
    return res;
  }
}
;
// cLay version 20241019-1

// --- original code ---
// #define main dummy_main
// {}
// #undef main
// 
// class Solution {
// public:
//   int countKReducibleNumbers(string s, int k) {
//     int N = s.size();
//     static int go[1000][6], gof;
//     static Modint dp[2][1000], nx[2][1000];
//     Modint res = 0;
// 
//     if(gof==0){
//       gof = 1;
//       rep(i,1000) go[i][0] = i;
//       rep(j,5) rep(i,1000){
//         go[i][j+1] = BIT_popcount(go[i][j]);
//       }
//     }
// 
//     rep(i,2) rep(j,N+1) dp[i][j] = 0;
//     dp[0][0] = 1;
// 
//     rep(m,N){
//       rep(i,2) rep(j,N+1) nx[i][j] = 0;
//       rep(j,N+1) if(dp[0][j] || dp[1][j]){
//         rep(x,2) nx[1][j+x] += dp[1][j];
//         if(s[m]=='0'){
//           nx[0][j] += dp[0][j];
//         } else {
//           nx[1][j] += dp[0][j];
//           nx[0][j+1] += dp[0][j];
//         }
//       }
//       rep(i,2) rep(j,N+1) dp[i][j] = nx[i][j];
//     }
// 
//     rep(j,N+1) if(go[j][k-1]==1) res += dp[1][j];
//     return res;
//   }
// };
",1448213752
LayCurse,LayCurse,12,3646,cpp,"#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")
#include<bits/stdc++.h>
using namespace std;
#define MD (1000000007U)
struct Modint{
  unsigned val;
  Modint(){
    val=0;
  }
  Modint(int a){
    val = ord(a);
  }
  Modint(unsigned a){
    val = ord(a);
  }
  Modint(long long a){
    val = ord(a);
  }
  Modint(unsigned long long a){
    val = ord(a);
  }
  inline unsigned ord(unsigned a){
    return a%MD;
  }
  inline unsigned ord(int a){
    a %= (int)MD;
    if(a < 0){
      a += MD;
    }
    return a;
  }
  inline unsigned ord(unsigned long long a){
    return a%MD;
  }
  inline unsigned ord(long long a){
    a %= (int)MD;
    if(a < 0){
      a += MD;
    }
    return a;
  }
  inline unsigned get(){
    return val;
  }
  inline Modint &operator++(){
    val++;
    if(val >= MD){
      val -= MD;
    }
    return *this;
  }
  inline Modint &operator--(){
    if(val == 0){
      val = MD - 1;
    }
    else{
      --val;
    }
    return *this;
  }
  inline Modint operator++(int a){
    Modint res(*this);
    val++;
    if(val >= MD){
      val -= MD;
    }
    return res;
  }
  inline Modint operator--(int a){
    Modint res(*this);
    if(val == 0){
      val = MD - 1;
    }
    else{
      --val;
    }
    return res;
  }
  inline Modint &operator+=(Modint a){
    val += a.val;
    if(val >= MD){
      val -= MD;
    }
    return *this;
  }
  inline Modint &operator-=(Modint a){
    if(val < a.val){
      val = val + MD - a.val;
    }
    else{
      val -= a.val;
    }
    return *this;
  }
  inline Modint &operator*=(Modint a){
    val = ((unsigned long long)val*a.val)%MD;
    return *this;
  }
  inline Modint &operator/=(Modint a){
    return *this *= a.inverse();
  }
  inline Modint operator+(Modint a){
    return Modint(*this)+=a;
  }
  inline Modint operator-(Modint a){
    return Modint(*this)-=a;
  }
  inline Modint operator*(Modint a){
    return Modint(*this)*=a;
  }
  inline Modint operator/(Modint a){
    return Modint(*this)/=a;
  }
  inline Modint operator+(int a){
    return Modint(*this)+=Modint(a);
  }
  inline Modint operator-(int a){
    return Modint(*this)-=Modint(a);
  }
  inline Modint operator*(int a){
    return Modint(*this)*=Modint(a);
  }
  inline Modint operator/(int a){
    return Modint(*this)/=Modint(a);
  }
  inline Modint operator+(long long a){
    return Modint(*this)+=Modint(a);
  }
  inline Modint operator-(long long a){
    return Modint(*this)-=Modint(a);
  }
  inline Modint operator*(long long a){
    return Modint(*this)*=Modint(a);
  }
  inline Modint operator/(long long a){
    return Modint(*this)/=Modint(a);
  }
  inline Modint operator-(void){
    Modint res;
    if(val){
      res.val=MD-val;
    }
    else{
      res.val=0;
    }
    return res;
  }
  inline operator bool(void){
    return val!=0;
  }
  inline operator int(void){
    return get();
  }
  inline operator long long(void){
    return get();
  }
  inline Modint inverse(){
    int a = val;
    int b = MD;
    int u = 1;
    int v = 0;
    int t;
    Modint res;
    while(b){
      t = a / b;
      a -= t * b;
      swap(a, b);
      u -= t * v;
      swap(u, v);
    }
    if(u < 0){
      u += MD;
    }
    res.val = u;
    return res;
  }
  inline Modint pw(unsigned long long b){
    Modint a(*this);
    Modint res;
    res.val = 1;
    while(b){
      if(b&1){
        res *= a;
      }
      b >>= 1;
      a *= a;
    }
    return res;
  }
  inline bool operator==(int a){
    return ord(a)==val;
  }
  inline bool operator!=(int a){
    return ord(a)!=val;
  }
}
;
inline Modint operator+(int a, Modint b){
  return Modint(a)+=b;
}
inline Modint operator-(int a, Modint b){
  return Modint(a)-=b;
}
inline Modint operator*(int a, Modint b){
  return Modint(a)*=b;
}
inline Modint operator/(int a, Modint b){
  return Modint(a)/=b;
}
inline Modint operator+(long long a, Modint b){
  return Modint(a)+=b;
}
inline Modint operator-(long long a, Modint b){
  return Modint(a)-=b;
}
inline Modint operator*(long long a, Modint b){
  return Modint(a)*=b;
}
inline Modint operator/(long long a, Modint b){
  return Modint(a)/=b;
}
#define main dummy_main
int main(){
  return 0;
}
#undef main
class Solution{
  public:
  int sumOfGoodSubsequences(vector<int>& A){
    int i;
    int N = A.size();
    map<int,Modint> c;
    map<int,Modint> s;
    Modint res = 0;
    Modint tc;
    Modint ts;
    for(i=(0);i<(N);i++){
      tc = ts = 0;
      if(c.count(A[i]-1)){
        tc += c[A[i]-1];
        ts += s[A[i]-1];
      }
      if(c.count(A[i]+1)){
        tc += c[A[i]+1];
        ts += s[A[i]+1];
      }
      tc++;
      ts += tc * A[i];
      res += ts;
      c[A[i]] += tc;
      s[A[i]] += ts;
    }
    return res;
  }
}
;
// cLay version 20241019-1

// --- original code ---
// #define main dummy_main
// {}
// #undef main
// 
// class Solution {
// public:
//   int sumOfGoodSubsequences(vector<int>& A) {
//     int N = A.size();
//     map<int,Modint> c, s;
//     Modint res = 0, tc, ts;
// 
//     rep(i,N){
//       tc = ts = 0;
//       if(c.count(A[i]-1)){
//         tc += c[A[i]-1];
//         ts += s[A[i]-1];
//       }
//       if(c.count(A[i]+1)){
//         tc += c[A[i]+1];
//         ts += s[A[i]+1];
//       }
//       tc++;
//       ts += tc * A[i];
//       res += ts;
//       c[A[i]] += tc;
//       s[A[i]] += ts;
//     }
// 
//     return res;
//   }
// };
",1448184044
Ma Lin,Ma_Lin,13,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& a, int K) {
        int i, j, k, n = a.size();
        for (i = 0; i + K + K - 1 < n; ++i){
            bool ky = true;
            for (j = i + 1; j < i + K; ++j)
                if (a[j] <= a[j - 1]) ky = false;
            for (j = i + K + 1; j < i + K + K; ++j)
                if (a[j] <= a[j - 1]) ky = false;
            if (ky) return true;
        }
            
        return false;
    }
};",1448181616
Ma Lin,Ma_Lin,13,3619,cpp,"class Solution {
public:
    int f[200005], sum[200005];
    int maxIncreasingSubarrays(vector<int>& a) {
        int st = 2, ed, K, i, j, res = 1, n = a.size();
        ed = n / 2;
        while (st <= ed){
            K = (st + ed) / 2;
            sum[0] = f[0] = 0;
            for (i = 1; i < n; ++i){
                f[i] = 0;
                if (a[i] > a[i - 1]) f[i] = 1;
                sum[i] = sum[i - 1] + f[i];
            }
            
            bool yes = false;
            for (i = 0; i + K + K - 1 < n; ++i)
                if (sum[i + K - 1] - sum[i] == K - 1 && sum[i + K + K - 1] - sum[i + K] == K - 1){
                    yes = true;
                    break;
                }
                
            if (yes){
                res = K;
                st = K + 1;
            }
            else ed = K - 1;
        }
        
        return res;
    }
};",1448187198
Ma Lin,Ma_Lin,13,3631,cpp,"class Solution {
public:
    int n, C[805][805], f[805], mo = 1000000007;
    
    void calc_C(){
        int i, j;
        C[0][0] = 1; 
        for (i = 1; i <= n; ++i){
            C[i][0] = C[i][i] = 1;
            for (j = 1; j < i; ++j) C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mo;
        }
    }
    
    void calc_f(){
        int i, ge;
        f[1] = 0;
        for (i = 2; i <= n; ++i){
            ge = __builtin_popcount(i);
            f[i] = f[ge] + 1;
        }
    }
    
    int countKReducibleNumbers(string s, int K) {
        int i, j, k, L, yj = 0, res = 0;
        if (s == ""1"" || s == ""0"") return 0;
        n = s.size();
        calc_C();
        calc_f();
        for (i = 0; i < n; ++i)
            if (s[i] == '1'){
                L = n - 1 - i;
                for (j = 0; j <= L; ++j)
                    if ((yj + j) > 0 && f[yj + j] + 1 <= K)
                        res = (res + 1LL * C[L][j]) % mo;
                ++yj;
            }
        
        return res;
    }
};",1448214080
Ma Lin,Ma_Lin,13,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& a) {
        int mo = 1000000007;
        int n = a.size(), i, j, k, res = 0, t;
        map<int, int> ge, sum;
        for (auto x : a){
            ge[x] = (0LL + ge[x - 1] + ge[x + 1] + 1LL + ge[x]) % mo;
            sum[x] = (0LL + sum[x] + sum[x - 1] + 1LL * x * ge[x - 1] + sum[x + 1] + 1LL * x * ge[x + 1] + x) % mo;
        }
        
        for (auto p : sum) res = (res + p.second) % mo;
        return res;
    }
};",1448194288
Yiming Li,lympanda,14,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& a, int k) {
        int i,j,n,b1;
        n=a.size();
        for (i=0;i+k+k<=n;i++)
        {
            b1=1;
            for (j=0;j+1<k;j++)
                if (a[i+j]>=a[i+j+1]) b1=0;
            for (j=0;j+1<k;j++)
                if (a[i+k+j]>=a[i+k+j+1]) b1=0;
            if (b1==1) return true;
            
        }
        return false;
    }
};",1448181990
Yiming Li,lympanda,14,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& a) {
        int i,j,k,n,prev,cnt,ans;
        n=a.size();
        prev=0;
        cnt=0;
        ans=0;
        for (i=0;i+1<n;i++)
        {
            if (a[i+1]>a[i]) cnt++;
            else
            {
                ans=max(ans,min(cnt+1,prev+1));
                ans=max(ans,(cnt+1)/2);
                prev=cnt;
                cnt=0;
            }
        }
        ans=max(ans,min(cnt+1,prev+1));
        ans=max(ans,(cnt+1)/2);
        return ans;        
    }
};",1448184454
Yiming Li,lympanda,14,3631,cpp,"#define _int64 long long
#define mo 1000000007


#define faclim 110000

_int64 fac[faclim];
_int64 invfac[faclim];

_int64 pow1(int x,int y)
{
	int i;
	_int64 ret;
	ret=1;
	for (i=30;i>=0;i--)
	{
		ret=ret*ret%mo;
		if (((1<<i)&y)!=0) ret=ret*x%mo;
	}
	return ret;
}
_int64 inv(int x)
{
	return pow1(x,mo-2);
}
_int64 c(int x,int y)
{
	return fac[x]*invfac[y]%mo*invfac[x-y]%mo;
}
void init()
{
	int i;
	fac[0]=1;
	for (i=1;i<faclim;i++)
		fac[i]=fac[i-1]*i%mo;
	invfac[faclim-1]=inv(fac[faclim-1]);
	for (i=faclim-1;i>0;i--)
		invfac[i-1]=invfac[i]*i%mo;
}

int inited=0;
int d[1000];

class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        int i,j,n,cnt,o,tmp,rem;
        _int64 ans;
        if (inited==0)
        {
            init();
            inited=1;
        }
        n=s.length();
        for (i=1;i<=n;i++)
        {
            tmp=i;
            for (o=0;o+1<k;o++)
                tmp=__builtin_popcount(tmp);
            if (tmp==1) d[i]=1;
            else d[i]=0;
        }
        ans=0;
        cnt=0;
        for (i=0;i<n;i++)
        {
            if (s[i]=='1')
            {
                rem=n-1-i;
                for (j=0;j<=rem;j++)
                {
                    if (d[cnt+j]==1)
                    {
                        ans+=c(rem,j);
                        ans%=mo;
                    }
                }
                cnt++;
            }
        }
        return ans;
        
    }
};",1448209606
Yiming Li,lympanda,14,3646,cpp,"#define _int64 long long
#define mo 1000000007

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& a) {
        int i,j,k,n;
        _int64 ans,tmp1,tmp2;
        map<int,pair<_int64,_int64> > mp;
        pair<_int64,_int64> tmp,v;
        n=a.size();
        mp.clear();
        ans=0;
        for (i=0;i<n;i++)
        {
            tmp=make_pair(0,0);
            if (mp.find(a[i]-1)!=mp.end())
            {
                v=mp[a[i]-1];
                tmp.first+=v.first;
                tmp.first%=mo;
                tmp.second+=v.second;
                tmp.second%=mo;
            }
            if (mp.find(a[i]+1)!=mp.end())
            {
                v=mp[a[i]+1];
                tmp.first+=v.first;
                tmp.first%=mo;
                tmp.second+=v.second;
                tmp.second%=mo;
            }
            tmp.second+=tmp.first*a[i];
            tmp.second+=a[i];
            tmp.second%=mo;
            tmp.first++;
            tmp.first%=mo;
            ans+=tmp.second;
            ans%=mo;
            mp[a[i]].first+=tmp.first;
            mp[a[i]].first%=mo;
            mp[a[i]].second+=tmp.second;
            mp[a[i]].second%=mo;
        }
        return ans;
    }
};",1448194209
PyIsTheBestLang,PyIsTheBestLang,15,3612,python3,"
class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        post = [0]*n
        post[n-1] = 1
        for i in range(n-2, -1 ,-1):
            if nums[i] < nums[i+1]:
                post[i] = post[i+1]+1
            else:
                post[i] = 1
            if post[i] >= k and i+2*k<=n and post[i+k] >= k:
                return True
        return False",1448210092
PyIsTheBestLang,PyIsTheBestLang,15,3619,python3,"class BinarySearch:
    def __init__(self):
        return

    @staticmethod
    def find_int_left(low: int, high: int, check) -> int:
        """"""find the minimum int x which make check true""""""
        while low < high:
            mid = low + (high - low) // 2
            if check(mid):
                high = mid
            else:
                low = mid + 1
        return low

    @staticmethod
    def find_int_right(low: int, high: int, check) -> int:
        """"""find the maximum int x which make check true""""""
        while low < high:
            mid = low + (high - low + 1) // 2
            if check(mid):
                low = mid
            else:
                high = mid - 1
        return high

    @staticmethod
    def find_float_left(low: float, high: float, check, error=1e-6) -> float:
        """"""find the minimum float x which make check true""""""
        while low < high - error:
            mid = low + (high - low) / 2
            if check(mid):
                high = mid
            else:
                low = mid
        return low if check(low) else high

    @staticmethod
    def find_float_right(low: float, high: float, check, error=1e-6) -> float:
        """"""find the maximum float x which make check true""""""
        while low < high - error:
            mid = low + (high - low) / 2
            if check(mid):
                low = mid
            else:
                high = mid
        return high if check(high) else low


class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        
    
        n = len(nums)
        def check(k):
            post = [0]*n
            post[n-1] = 1
            for i in range(n-2, -1 ,-1):
                if nums[i] < nums[i+1]:
                    post[i] = post[i+1]+1
                else:
                    post[i] = 1
                if post[i] >= k and i+2*k<=n and post[i+k] >= k:
                    return True
            return False
        ans = BinarySearch().find_int_right(0, n//2, check)
        return ans",1448209854
PyIsTheBestLang,PyIsTheBestLang,15,3631,python3,"
@lru_cache(None)
def check(num):
    if num == 1:
        return 0
    return check(num.bit_count()) + 1


mod = 10**9 + 7
class Solution:

    def countKReducibleNumbers2(self, s: str, k: int) -> int:
        n = int(""0b""+s, 2)
        n -= 1
        s = bin(n)[2:]
        m = len(s)
        ans2 = sum(check(x)<=k for x in range(1, n+1))
        return ans2

    def countKReducibleNumbers(self, s: str, k: int) -> int:
        n = int(""0b""+s, 2)
        n -= 1
        s = bin(n)[2:]
        m = len(s)

        @lru_cache(None)
        def dfs(i, is_limit, is_num, cnt):
            if i == m:
                return check(cnt) + 1 <= k if is_num and cnt else 0
            res = 0
            if not is_num:
                res += dfs(i + 1, False, False, cnt)
            low = 0 if is_num else 1
            high = int(s[i]) if is_limit else 1
            for x in range(low, high + 1):
                res += dfs(i + 1, is_limit and high == x, True, cnt + int(x == 1))
            return res % mod


        ans2 = dfs(0, True, False, 0)
        dfs.cache_clear()
        ans2 %= mod
        return ans2
",1448211034
PyIsTheBestLang,PyIsTheBestLang,15,3646,python3,"mod = 10**9 + 7
class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:

        ans = 0
        cnt = defaultdict(int)
        ss = defaultdict(int)
        for num in nums:
            pre = cnt[num-1]+cnt[num+1]
            pre_ss = ss[num-1] + ss[num+1]
            pre += 1
            pre_ss += pre*num
            pre_ss %= mod
            cnt[num] += pre
            cnt[num] %= mod
            ss[num] += pre_ss
            ss[num] %= mod
        return sum(ss.values()) % mod",1448209536
nguyen31hoang08minh2003,nguyen31hoang08minh2003,16,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& a, int k) {
        int n = a.size();
        auto f = [&](int l, int r) -> bool {
            for (int i = l + 1; i <= r; ++i)
                if (a[i - 1] >= a[i])
                    return false;
            return true;
        };
        for (int l = 0, m = k - 1, r = m + k; r < n; ++l, ++m, ++r)
            if (f(l, m) && f(m + 1, r))
                return true;
        return false;
    }
};",1448181823
nguyen31hoang08minh2003,nguyen31hoang08minh2003,16,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& a) {
        int n = a.size();
        vector<int> p(n);

        auto s = [&](int l, int r) -> int {
            return p[r] - p[l];
        };

        auto f = [&](int l, int r) -> bool {
            return s(l, r) == r - l;  
        };

        auto check = [&](int k) -> bool {
            for (int l = 0, m = k - 1, r = m + k; r < n; ++l, ++m, ++r)
                if (f(l, m) && f(m + 1, r))
                    return true;
            return false;
        };
        
        for (int i = 1; i < n; ++i) {
            p[i] = p[i - 1];
            if (a[i - 1] < a[i])
                ++p[i];
        }

        int low = 1, high = n + 1, middle;

        for (; low + 1 < high;) {
            middle = low + high >> 1;
            if (check(middle))
                low = middle;
            else
                high = middle;
        }
        
        return low;
    }
};",1448185422
nguyen31hoang08minh2003,nguyen31hoang08minh2003,16,3631,cpp,"class Solution {
protected:

    const int MOD = 1E9 + 7;

private:

    int n, k;
    string u;
    vector<int> d;
    vector<vector<vector<int> > > f;

    int add(int x, int y) {
        if ((x += y) >= MOD)
            x -= MOD;
        return x;
    }

    int mul(long long x, long long y) {
        return x * y % MOD;
    }

    int F(int i, int j, bool r) {
        if (i >= n)
            return r && j && (1 + d[j] <= k);
        if (f[i][j][r] < 0) {
            const int t = r ? 1 : (u[i] - '0');
            f[i][j][r] = 0;
            for (int d = 0; d <= t; ++d)
                f[i][j][r] = add(f[i][j][r], F(i + 1, j + d, r || (d < t)));
        }
        return f[i][j][r];
    }

public:

    int countKReducibleNumbers(string s, int k) {
        n = s.size();
        d.resize(n + 1);
        for (int i = 2, j, x; i <= n; ++i) {
            for (j = 0, x = i; x; x -= x & -x)
                ++j;
            d[i] = d[j] + 1;
        }
        u = s;
        this -> k = k;
        f.resize(n + 1, vector<vector<int> >(n + 1, vector<int>(2, -1)));
        return F(0, 0, false);
    }
};",1448219518
nguyen31hoang08minh2003,nguyen31hoang08minh2003,16,3646,cpp,"class Solution {
protected:

    const int MOD = 1E9 + 7;

private:

    int add(int x, int y) {
        if ((x += y) >= MOD)
            x -= MOD;
        return x;
    }

    int mul(long long x, long long y) {
        return x * y % MOD;
    }

public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        map<int, int> f;
        int n = nums.size();
        map<int, int>::iterator e;
        vector<int> l(n), r(n);
        int result = 0;
        
        for (int i = 0; i < n; ++i) {
            const auto &x = nums[i];
            l[i] = 1;
            e = f.find(x - 1);
            if (e != f.end())
                l[i] = add(l[i], e -> second);
            e = f.find(x + 1);
            if (e != f.end())
                l[i] = add(l[i], e -> second);
            f[x] = add(f[x], l[i]);
        }

        f.clear();

        for (int i = n - 1; i >= 0; --i) {
            const auto &x = nums[i];
            r[i] = 1;
            e = f.find(x - 1);
            if (e != f.end())
                r[i] = add(r[i], e -> second);
            e = f.find(x + 1);
            if (e != f.end())
                r[i] = add(r[i], e -> second);
            f[x] = add(f[x], r[i]);
            result = add(result, mul(mul(l[i], r[i]), x));
        } 

        return result;
    }
};",1448202234
Yang Xiao,sheepforever,17,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        for (int i = 0; i + 2 * k - 1 < nums.size(); ++i) {
            bool ok = true;
            for (int j = 0; j + 1 < k; ++j) {
                if (nums[i + j] >= nums[i + j + 1]) {
                    ok = false;
                    break;
                }
                if (nums[i + k + j] >= nums[i + k + j + 1]) {
                    ok = false;
                    break;
                }
            }
            if (ok) {
                return true;
            }
        }
        return false;
    }
};",1448182341
Yang Xiao,sheepforever,17,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> len(n, 0), to(n, -1);
        int ans = 0;
        for (int i = n - 1; i >= 0; --i) {
            to[i] = i;
            len[i] = 1;
            if (i + 1 < n && nums[i] < nums[i + 1]) {
                len[i] = len[i + 1] + 1;
                to[i] = to[i + 1];
            }
            
            ans = max(ans, len[i] / 2);
            if (to[i] != -1 && to[i] + 1 < n) {
                ans = max(ans, min(len[i], len[to[i] + 1]));
            }
        }
        return ans;
    }
};",1448185060
Yang Xiao,sheepforever,17,3631,cpp,"const int N = 807;
const int MOD = 1000000007;

int steps[N];
bool inited = false;

int dp[N][2][N];

class Solution {
public:
    int countKReducibleNumbers(string s, int kk) {
        if (!inited) {
            inited = true;
            for (int i = 2; i < N; ++i) {
                steps[i] = steps[__builtin_popcount(i)] + 1;
            }
        }
        
        int n = s.size();
        for (int i = 0; i <= n; ++i) {
            for (int j = 0; j < 2; ++j) {
                for (int k = 0; k <= n; ++k) {
                    dp[i][j][k] = 0;
                }
            }
        }
        
        dp[0][0][0] = 1;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < 2; ++j) {
                for (int k = 0; k < n; ++k) {
                    if (dp[i][j][k] == 0) continue;
                    for (int p = 0; p < 2; ++p) {
                        if (p == 1 && j == 0 && s[i] == '0') continue;
                        
                        int nj = j;
                        if (s[i] == '1' && p == 0) nj = 1;
                        
                        dp[i + 1][nj][k + p] = (dp[i + 1][nj][k + p] + dp[i][j][k]) % MOD;
                    }
                }
            }
        }
        
        int ans = 0;
        for (int k = 1; k <= n; ++k) {
            if (steps[k] + 1 <= kk) {
                ans = (ans + dp[n][1][k]) % MOD;
            }
        }
        
        
        return ans;
    }
};",1448212295
Yang Xiao,sheepforever,17,3646,cpp,"const int MOD = 1000000007;

void add(int& x, int y) {
    x += y;
    if (x >= MOD) x -= MOD;
}

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        unordered_map<int, int> count;
        unordered_map<int, int> sum;
        for (int val : nums) {
            int& res = count[val];
            int& s = sum[val];
            add(res, 1);
            add(s, val);
            
            auto it = count.find(val - 1);
            if (it != count.end()) {
                add(res, it->second);
                add(s, (sum[val - 1] + it->second * 1LL * val % MOD) % MOD);
            }
            it = count.find(val + 1);
            if (it != count.end()) {
                add(res, it->second);
                add(s, (sum[val + 1] + it->second * 1LL * val % MOD) % MOD);
            }
        }
        
        int ans = 0;
        for (auto it : sum) {
            add(ans, it.second);
        }
        return ans;
    }
};",1448195832
Abhishek Choudhary,theabbie,20,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        dp = [1] * n
        for i in range(n - 2, -1, -1):
            if nums[i] < nums[i + 1]:
                dp[i] = 1 + dp[i + 1]
        for i in range(n - 2 * k + 1):
            if dp[i] >= k and dp[i + k] >= k:
                return True
        return False",1448206225
Abhishek Choudhary,theabbie,20,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        dp = [1] * n
        for i in range(n - 2, -1, -1):
            if nums[i] < nums[i + 1]:
                dp[i] = 1 + dp[i + 1]
        beg = 1
        end = n // 2
        while beg <= end:
            mid = (beg + end) // 2
            pos = False
            for i in range(n - 2 * mid + 1):
                if dp[i] >= mid and dp[i + mid] >= mid:
                    pos = True
                    break
            if pos:
                beg = mid + 1
            else:
                end = mid - 1
        return beg - 1",1448204688
Abhishek Choudhary,theabbie,20,3631,python3,"M = 10 ** 9 + 7

class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        @lru_cache(maxsize = None)
        def count(x):
            if x <= 1:
                return 0
            return 1 + count(x.bit_count())
        cache = {}
        def dp(i, ctr, tight):
            if i >= len(s):
                return int(1 + count(ctr) <= k and not tight)
            key = (i, ctr, tight)
            if key in cache:
                return cache[key]
            up = 1
            if tight:
                up = int(s[i])
            res = 0
            for d in range(0, up + 1):
                res += dp(i + 1, ctr + d, tight and d == up)
                res %= M
            cache[key] = res
            return res
        return (dp(0, 0, True) - 1) % M",1448222527
Abhishek Choudhary,theabbie,20,3646,python3,"M = 10 ** 9 + 7

class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        n = len(nums)
        s = [0] * (n + 1)
        ctr = [0] * (n + 1)
        ssum = Counter()
        csum = Counter()
        for j in range(n):
            ctr[j] = 1 + csum[nums[j] - 1] + csum[nums[j] + 1]
            s[j] = ssum[nums[j] - 1] + ssum[nums[j] + 1] + nums[j] * ctr[j]
            s[j] %= M
            ctr[j] %= M
            ssum[nums[j]] += s[j]
            csum[nums[j]] += ctr[j]
            ssum[nums[j]] %= M
            csum[nums[j]] %= M
        return sum(s) % M",1448195869
scanhex,scanhex,22,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
                int n = nums.size();
        vector<int> pref(n);
        for (int i = 0; i < n - 1; ++i) 
            pref[i + 1] = pref[i] + (nums[i + 1] <= nums[i]);
        int maxk = 1;
        for (int c = 0; c < n - 1; ++c) {
            int L = 0, R = n - 1;
            while (R - L > 1){
                int M = (L + R ) / 2;
                bool ok = true;
                if (c - M < 0 || c + M + 1 >= n) {
                    ok = false;
                } else {
                    ok &= pref[c] - pref[c - M] == 0 && pref[c + M + 1] - pref[c + 1] == 0;
                }
                if (ok) L = M;
                else
                    R = M;
            }
            maxk = max(maxk, L + 1);
        }
        return maxk >= k;

    }
};",1448214937
scanhex,scanhex,22,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> pref(n);
        for (int i = 0; i < n - 1; ++i) 
            pref[i + 1] = pref[i] + (nums[i + 1] <= nums[i]);
        int maxk = 1;
        for (int c = 0; c < n - 1; ++c) {
            int L = 0, R = n - 1;
            while (R - L > 1){
                int M = (L + R ) / 2;
                bool ok = true;
                if (c - M < 0 || c + M + 1 >= n) {
                    ok = false;
                } else {
                    ok &= pref[c] - pref[c - M] == 0 && pref[c + M + 1] - pref[c + 1] == 0;
                }
                if (ok) L = M;
                else
                    R = M;
            }
            maxk = max(maxk, L + 1);
        }
        return maxk;
    }
};
",1448214366
scanhex,scanhex,22,3631,cpp,"class Solution {
public:
  const int mod = 1e9 + 7;
  int countKReducibleNumbers(string s, int k) {
    vector<vector<vector<int>>> dp(
        s.size() + 1, vector<vector<int>>(s.size() + 1, vector<int>(2)));
    int n = s.size();
    dp[0][0][0] = 1;
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j <= i; ++j) {
            for (int k = 0; k < 2; ++k) {
                if (dp[i][j][k] == 0) {
                    continue;
                }
                for (int d = 0; d <= (k ? 1 : s[i] - '0'); ++d) {
                    int nk = k || (d < s[i] - '0');
                    int nj = j + (d == 1);
                    dp[i + 1][nj][nk] += dp[i][j][k];
                    if (dp[i + 1][nj][nk] >= mod) {
                        dp[i + 1][nj][nk] -= mod;
                    }
                }
            }
        }
    }
    vector<int> c(s.size() + 1);
    c[1] = 0;
    for (int i = 2; i <= s.size(); ++i) {
        c[i] = c[__builtin_popcount(i)] + 1;
    }
    int ans = 0;
    for (int i = 1; i <= s.size(); ++i) {
        if (c[i] <= k - 1) {
            ans += dp[s.size()][i][1];
            if (ans >= mod) {
                ans -= mod;
            }
        }
    }
    return ans;
  }
};
",1448194370
scanhex,scanhex,22,3646,cpp,"class Solution {
public:
  const int mod = 1e9 + 7;
  int mu(int a, int b) { return (a * 1LL * b) % mod; }
  void ad(int &x, int y) {
    x += y;
    if (x >= mod)
      x -= mod;
  }
  int sumOfGoodSubsequences(vector<int> &nums) {
    int n = nums.size();
    map<int, int> cnt, sm;
    for (int x : nums) {
      int c = 1, su = 0;
      ad(c, cnt[x - 1]);
      ad(c, cnt[x + 1]);
      ad(su, sm[x - 1]);
      ad(su, sm[x + 1]);
      ad(su, mu(c, x));
      ad(cnt[x], c);
      ad(sm[x], su);
    }
    int ans = 0;
    for (auto p : sm)
      ad(ans, p.second);
    return ans;
  }
};
",1448205732
aqxa2k,aqxa2k,26,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& a, int k) {
        int n = a.size(); 
        vector<int> g(n, 1); 
        for (int i = 1; i < n; ++i) {
            if (a[i] > a[i - 1]) g[i] += g[i - 1]; 
        }
        for (int i = 0; i + k < n; ++i) {
            if (g[i + k]>= k && g[i] >= k) {
                return true; 
            }
        }
        return false; 
    }
};",1448182391
aqxa2k,aqxa2k,26,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& a) {
        int n = a.size(); 
        vector<int> g(n, 1); 
        for (int i = 1; i < n; ++i) {
            if (a[i] > a[i - 1]) g[i] += g[i - 1]; 
        }
        int lo = 1, hi = n / 2; 
        while (lo < hi) {
            int md = (lo + hi + 1) / 2; 
            int ok = 0; 
            for (int i = 0; i + md < n; ++i) {
                if (g[i] >= md && g[i + md] >= md) {
                    ok = 1; 
                }
            }
            if (ok) lo = md; 
            else hi = md - 1; 
        }
        return lo; 
    }
};",1448183666
aqxa2k,aqxa2k,26,3631,cpp,"template <typename T>
T inverse(T a, T m) {
	T u = 0, v = 1;
	while (a != 0) {
		T t = m / a;
		m -= t * a; swap(a, m);
		u -= t * v; swap(u, v);
	}
	assert(m == 1);
	return u;
}

template<class T>
T power(T a, long long b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}

template <typename T>
class Modular {
    public:
    using Type = typename decay<decltype(T::value)>::type;

    constexpr Modular() : value() {}
    template <typename U>
    Modular(const U& x) {
        value = normalize(x);
    }

    template <typename U>
    static Type normalize(const U& x) {
        Type v;
        if (-mod() <= x && x < mod()) v = static_cast<Type>(x);
        else v = static_cast<Type>(x % mod());
        if (v < 0) v += mod();
        return v;
    }

    const Type& operator()() const { return value; }
    template <typename U>
    explicit operator U() const { return static_cast<U>(value); }
    constexpr static Type mod() { return T::value; }

    Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }
    Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }
    template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }
    template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }
    Modular& operator++() { return *this += 1; }
    Modular& operator--() { return *this -= 1; }
    Modular operator++(int) { Modular result(*this); *this += 1; return result; }
    Modular operator--(int) { Modular result(*this); *this -= 1; return result; }
    Modular operator-() const { return Modular(-value); }

    template <typename U = T>
    typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {

    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));

        return *this;
    }
    template <typename U = T>
    typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {
            long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());
            value = normalize(value * rhs.value - q * mod());
            return *this;
    }
    template <typename U = T>
    typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {
            value = normalize(value * rhs.value);
            return *this;
    }

    Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }

    friend const Type& abs(const Modular& x) { return x.value; }

    template <typename U>
    friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);

    template <typename U>
    friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);

    template <typename V, typename U>
    friend V& operator>>(V& stream, Modular<U>& number);

    private:
    Type value;
};
template <typename T> bool operator>(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value > rhs.value; }
template <typename T, typename U> bool operator>(const Modular<T>& lhs, U rhs) { return lhs > Modular<T>(rhs); }
template <typename T, typename U> bool operator>(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) > rhs; }

template <typename T> bool operator>=(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value >= rhs.value; }
template <typename T, typename U> bool operator>=(const Modular<T>& lhs, U rhs) { return lhs >= Modular<T>(rhs); }
template <typename T, typename U> bool operator>=(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) >= rhs; }
 
template <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }
template <typename T, typename U> bool operator<(const Modular<T>& lhs, U rhs) { return lhs < Modular<T>(rhs); }
template <typename T, typename U> bool operator<(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) < rhs; }

template <typename T> bool operator<=(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value <= rhs.value; }
template <typename T, typename U> bool operator<=(const Modular<T>& lhs, U rhs) { return lhs <= Modular<T>(rhs); }
template <typename T, typename U> bool operator<=(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) <= rhs; }

template <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }
template <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }
template <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }
 
template <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }
template <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }
template <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }
 
template <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }
template <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }
template <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }
 
template <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }
template <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }
template <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }
 
template <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }
template <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }
template <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }
 
template <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }
template <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }
template <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }

template <typename T>
bool IsZero(const Modular<T>& number) {
    return number() == 0;
}
 
template <typename T>
string to_string(const Modular<T>& number) {
    return to_string(number());
}
 
// U == std::ostream? but done this way because of fastoutput
template <typename U, typename T>
U& operator<<(U& stream, const Modular<T>& number) {
    return stream << number();
}
 
// U == std::istream? but done this way because of fastinput
template <typename U, typename T>
U& operator>>(U& stream, Modular<T>& number) {
    typename common_type<typename Modular<T>::Type, long long>::type x;
    stream >> x;
    number.value = Modular<T>::normalize(x);
    return stream;
}
 
/*
using ModType = int;
 
struct VarMod { static ModType value; };
ModType VarMod::value;
ModType& md = VarMod::value;
using Mint = Modular<VarMod>;
*/

constexpr int md = 1000000007;
using Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;
 
vector<Mint> fact(1, 1);
vector<Mint> inv_fact(1, 1);

void R(int n) {
    while ((int) fact.size() < n + 1) {
        fact.push_back(fact.back() * (int) fact.size());
        inv_fact.push_back(0); 
    }
    inv_fact[n] = 1 / fact[n]; 
    for (int i = n; i >= 1; --i) {
        inv_fact[i-1] = inv_fact[i] * i; 
    }
}


Mint C(int n, int k) {
    if (k < 0 || k > n) {
        return 0;
    }
    while ((int) fact.size() < n + 1) {
        fact.push_back(fact.back() * (int) fact.size());
        inv_fact.push_back(1 / fact.back());
    }
    return fact[n] * inv_fact[k] * inv_fact[n - k];
}

class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        int n = s.size(); 
        // if (k == 1) {
        //     int ans = 0; 
        //     for (int i = 1; i < n; ++i) {
        //         if (s[i] == '1') ans = 1; 
        //     }
        //     ans += s.size() - 1; 
        //     return ans; 
        // }

        vector<vector<Mint>> dp(n + 1, vector<Mint>(2, 0));
        dp[0][0] = 1; 
        // 0 -> cur equal 
        // 1 -> less than 
        
        for (int i = 0; i < n; ++i) {
            vector<vector<Mint>> dp2(n + 1, vector<Mint>(2, 0)); 
            for (int j = 0; j < n; ++j) {
                dp2[j + 1][1] += dp[j][1]; 
                dp2[j][1] += dp[j][1]; 
                // include the bit 
                if (s[i] == '1') {
                    dp2[j + 1][0] += dp[j][0]; 
                    dp2[j][1] += dp[j][0]; 
                } else {
                    dp2[j][0] += dp[j][0]; 
                }
            }
            dp = dp2; 
        }
        vector<Mint> c(n + 1); 
        for (int i = 1; i <= n; ++i) {
            c[i] = dp[i][1]; 
            // cout << c[i] << "" \n""[i == n];
        }

        k--; 
        while (k--) {
            vector<Mint> c2(n + 1); 
            for (int i = 1; i <= n; ++i) {
                int b = 0; 
                for (int j = 0; j < 15; ++j) {
                    if ((1 << j) & i) b++; 
                }
                c2[b] += c[i]; 
            }
            c = c2; 
        }
        return (int)c[1]; 
    }
};",1448224176
aqxa2k,aqxa2k,26,3646,cpp,"using ll = long long; 
const int md = 1000000007; 

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& a) {
        ll ans = 0; 
        map<int, ll> s; 
        map<int, ll> f; 
        
        for (auto & x: a) {
            for (int i = -1; i <= 1; i += 2) {
                // cout << f[x + i] << ' ' << s[x + i] << '\n';
                f[x] += f[x + i]; 
                ans += f[x + i] * (ll) x; 
                f[x] %= md; 
                ans += s[x + i]; 
                ans %= md; 
                s[x] += s[x + i]; 
                s[x] += f[x + i] * (ll) x; 
                s[x] %= md; 
            }
            // cout << ans << '\n'; 
            ans += x; 
            ans %= md; 
            f[x]++; 
            f[x] %= md; 
            s[x] += x; 
            s[x] %= md;

            cout << ans << '\n'; 
        }
        return ans; 
    }
};",1448198977
Naruto,Naruto_x,27,3612,python3,"class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret

class Solution:
    def maxIncreasingSubarrays(self, arr: List[int]) -> int:
        n = len(arr)
        if n < 2:
            return 0 
        inc = [1] * n
        for i in range(n - 2, -1, -1):
            if arr[i] < arr[i + 1]:
                inc[i] = 1 + inc[i + 1]
            else:
                inc[i] = 1

        low, high = 1, n // 2
        ans = 0

        while low <= high:
            mid = low + (high - low) // 2
            flag = False

            for a in range(n - 2 * mid + 1):
                if inc[a] >= mid and inc[a + mid] >= mid:
                    flag = True
                    break

            if flag:
                ans = mid
                low = mid + 1  
            else:
                high = mid - 1  

        return ans

class Solution:
    def hasIncreasingSubarrays(self, arr: List[int], k: int) -> bool:
        n = len(arr)
        if 2 * k > n:
            return False
        inc = [1] * n 
        
        for i in range(n - 2, -1, -1):
            if arr[i] < arr[i + 1]:
                inc[i] = 1 + inc[i + 1]
            else:
                inc[i] = 1
        for i in range(n):
            pass
        for j in range(n - 2 * k + 1):
            if inc[j] >= k:
                if inc[j + k] >= k:
                    return True  
        return False
",1448216942
Naruto,Naruto_x,27,3619,python3,"class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret

class Solution:
    def maxIncreasingSubarrays(self, arr: List[int]) -> int:
        n = len(arr)
        if n < 2:
            return 0 
        inc = [1] * n
        for i in range(n - 2, -1, -1):
            if arr[i] < arr[i + 1]:
                inc[i] = 1 + inc[i + 1]
            else:
                inc[i] = 1

        low, high = 1, n // 2
        ans = 0

        while low <= high:
            mid = low + (high - low) // 2
            flag = False

            for a in range(n - 2 * mid + 1):
                if inc[a] >= mid and inc[a + mid] >= mid:
                    flag = True
                    break

            if flag:
                ans = mid
                low = mid + 1  
            else:
                high = mid - 1  

        return ans
",1448214894
Naruto,Naruto_x,27,3631,python3,"class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret

class Solution:
    mod = 10**9 + 7
    maxs = 800
    infx = 10**9

    def __init__(self):
        self.stps = [0] * (self.maxs + 1)
        self.dp = {}
        self.k = 0
        self.precompute()

    def precompute(self):
        self.stps[0] = self.infx 
        self.stps[1] = 0   
        for i in range(10):
            pass
        for s in range(2, self.maxs + 1):
            temp = s
            steps = 0
            while temp != 1:
                temp = bin(temp).count('1')
                steps += 1
            self.stps[s] = steps

    def dfs(self, n, pos, t1, count, start1):
        if pos == len(n):
            return 1 if start1 and (1 + self.stps[count]) <= self.k else 0

        if (pos, t1, count, start1) in self.dp:
            return self.dp[(pos, t1, count, start1)]

        res = 0
        maxd = int(n[pos]) if t1 else 1
        for i in range(maxd + 1):
            pass
        for z in range(maxd + 1):
            tnext = t1 and (z == maxd)
            snext = start1 or (z != 0)
            cnext = count + z if snext else 0

            res = (res + self.dfs(n, pos + 1, tnext, cnext, snext)) % self.mod

        self.dp[(pos, t1, count, start1)] = res
        return res

    def countKReducibleNumbers(self, s: str, x: int) -> int:
        self.k = x
        self.dp = {}
        res = self.dfs(s, 0, 1, 0, 0)
        scnt = s.count('1')
        tot = 1 + self.stps[scnt]
        if tot <= self.k:
            res = (res - 1 + self.mod) % self.mod
        return res % self.mod
",1448224249
Naruto,Naruto_x,27,3646,python3,"class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret

class Solution:
    def sumOfGoodSubsequences(self, arr: List[int]) -> int:
        mod = 10**9+7
        maxn = max(arr) if arr else 0
        dpc = [0] * (maxn + 2) 
        dps = [0] * (maxn + 2)   

        ans = 0

        for p in arr:
            cnt1 = 1
            sumx = p

            if p > 0:
                cnt1 = (cnt1 + dpc[p - 1]) % mod
                sumx = (sumx + dps[p - 1] + dpc[p - 1] * p) % mod

            if p < maxn:
                cnt1 = (cnt1 + dpc[p + 1]) % mod
                sumx = (sumx + dps[p + 1] + dpc[p + 1] * p) % mod

            dpc[p] = (dpc[p] + cnt1) % mod
            dps[p] = (dps[p] + sumx) % mod

            ans = (ans + sumx) % mod

        return ans
",1448212511
res,Res1StAnce7,28,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n=len(nums)
        inc=[1]*n
        for i in range(n-2,-1,-1):
            inc[i]=inc[i+1]+1 if nums[i]<nums[i+1] else 1
        return any(inc[a]>=k and inc[a+k]>=k for a in range(n-2*k+1))",1448181398
res,Res1StAnce7,28,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n=len(nums)
        inc=[1]*n
        for i in range(n-2,-1,-1):
            inc[i]=inc[i+1]+1 if nums[i]<nums[i+1] else 1
        l=1
        h=n//2
        res=0
        while l<=h:
            m=(l+h)//2
            if any(inc[a]>=m and a+m<n and inc[a+m]>=m for a in range(n-2*m+1)):
                res=m
                l=m+1
            else:
                h=m-1
        return res",1448183602
res,Res1StAnce7,28,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        mod=10**9+7
        memo={}
    
        def f(x):
            if x==1:
                memo[x]=0
                return 0
            if x in memo:
                return memo[x]
            memo[x]=1+f(bin(x).count('1'))
            return memo[x]
    
        for x in range(1,2049):
            f(x)
    
        cs=[c for c in range(1,2049) if memo.get(c,2048)<=k-1]
        n_val=int(s,2)
        if n_val==0:
            return 0
        n_val-=1
        s=bin(n_val)[2:].zfill(len(s))
        n=len(s)
        dp={}
    
        def count_bits(i,cnt,tight):
            if i==n:
                return 1 if cnt in cs else 0
            key=(i,cnt,tight)
            if key in dp:
                return dp[key]
            res=0
            limit=int(s[i]) if tight else 1
            for bit in range(0,limit+1):
                new_tight=tight and (bit==limit)
                new_cnt=cnt+bit
                if new_cnt>2048:
                    continue
                res+=count_bits(i+1,new_cnt,new_tight)
                res%=mod
            dp[key]=res
            return res
    
        return count_bits(0,0,True)%mod",1448216260
res,Res1StAnce7,28,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        mod=10**9+7
        cnt=defaultdict(int)
        sm=defaultdict(int)
        total=0
        for x in nums:
            c1=cnt[x-1]
            c2=cnt[x+1]
            s1=sm[x-1]
            s2=sm[x+1]
            ns=(s1+s2+x*(c1+c2+1))%mod
            nc=(c1+c2+1)%mod
            cnt[x]=(cnt[x]+nc)%mod
            sm[x]=(sm[x]+ns)%mod
            total=(total+ns)%mod
        return total",1448186905
physics0523,physics0523,29,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n=nums.size();
        vector<int> sgn(n+5,0);
        for(int i=1;i<n;i++){
            if(nums[i-1]<nums[i]){sgn[i]++;}
        }
        for(int i=1;i<n;i++){
            sgn[i]+=sgn[i-1];
        }
        for(int i=0;i+2*k<=n;i++){
            int j=i+k;
            bool ok=true;
            if(sgn[i+k-1]-sgn[i] != (k-1)){ok=false;}
            if(sgn[j+k-1]-sgn[j] != (k-1)){ok=false;}
            if(ok){return true;}
        }
        return false;
    }
};",1448184834
physics0523,physics0523,29,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n=nums.size();
        vector<int> sgn(n+5,0);
        for(int i=1;i<n;i++){
            if(nums[i-1]<nums[i]){sgn[i]++;}
        }
        for(int i=1;i<n;i++){
            sgn[i]+=sgn[i-1];
        }
        int res=1;
        for(int i=1;i<n;i++){
            int l=1,r=min(i,n-i);
            while(l<=r){
                int te=(l+r)/2;
                if(((sgn[i-1]-sgn[i-1-(te-1)])==(te-1)) && (sgn[i+(te-1)]-sgn[i]==(te-1))){l=te+1;}
                else{r=te-1;}
            }
            res=max(res,r);
        }
        return res;
    }
};",1448196325
physics0523,physics0523,29,3631,cpp,"#define mod 1000000007

int f(int x){
    return __builtin_popcount(x);
}

class Solution {
public:
    int countKReducibleNumbers(string s, int k){
        // cout << f(6) << ""\n"";
        // cout << f(2) << ""\n"";
        // cout << f(7) << ""\n"";
        
        int n=s.size();
        vector<long long> dp(2*n+6,0);
        dp[1]=1;
        for(int pos=0;pos<n;pos++){
            vector<long long> ndp(2*n+6,0);
            for(int i=0;i<dp.size();i++){
                if(dp[i]==0){continue;}
                int c=(i/2);
                int f=(i%2);
                for(int ap=0;ap<=1;ap++){
                    int nc=c+ap;
                    int nf=f;
                    if(f==1){
                        if((s[pos]-'0')==0 && ap==1){continue;}
                        if((s[pos]-'0')==1 && ap==0){nf=0;}
                    }
                    int tg=(nc*2)+nf;
                    ndp[tg]+=dp[i];
                    ndp[tg]%=mod;
                }
            }
            dp=ndp;
        }
        
        long long res=0;
        for(int i=2;i<dp.size();i+=2){
            int x=(i/2);
            for(int tr=2;tr<=k;tr++){x=f(x);}
            if(x==1){res+=dp[i]; res%=mod;}
        }
        return (res%mod);
    }
};",1448224939
physics0523,physics0523,29,3646,cpp,"#define mod 1000000007

using pl=pair<long long,long long>;

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums){
        unordered_map<long long,pl> mp;
        for(auto &ix : nums){
            long long x=ix;
            if(mp.find(x-1)==mp.end()){mp[x-1]={0,0};}
            if(mp.find(x)==mp.end()){mp[x]={0,0};}
            if(mp.find(x+1)==mp.end()){mp[x+1]={0,0};}

            pl del={1,x};
            pl ml=mp[x-1];
            pl mr=mp[x+1];
            ml.first+=mr.first; ml.first%=mod;
            ml.second+=mr.second; ml.second%=mod;
            del.first+=ml.first; del.first%=mod;
            del.second+=ml.second; del.second%=mod;
            del.second+=(x*ml.first); del.second%=mod;
            mp[x].first+=del.first;
            mp[x].second+=del.second;
        }
        long long res=0;
        for(auto &nx : mp){
            res+=nx.second.second; res%=mod;
        }
        return res;
    }
};",1448208838
Anuj Anand,coleworld223,31,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
      int n = nums.size();
      vector <int> dpf (n), dpb (n);
      for (int i = 0; i < n; ++i) {
        dpf[i] = 1;
        if (i and nums[i] > nums[i - 1]) { dpf[i] += dpf[i - 1]; } 
      }
      for (int i = n - 1; i >= 0; i--) {
        dpb[i] = 1;
        if (i + 1 < n and nums[i + 1] > nums[i]) { dpb[i] += dpb[i + 1]; }
      }
      bool ok = 0;
      for (int i = 0; i < n; ++i) {
        if (i + 1 < n and dpf[i] >= k and dpb[i + 1] >= k) { ok = 1; }
      }
      return ok;
    }
};",1448189361
Anuj Anand,coleworld223,31,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
      int n = nums.size();
      vector <int> dpf (n), dpb (n);
      for (int i = 0; i < n; ++i) {
        dpf[i] = 1;
        if (i and nums[i] > nums[i - 1]) { dpf[i] += dpf[i - 1]; } 
      }
      for (int i = n - 1; i >= 0; i--) {
        dpb[i] = 1;
        if (i + 1 < n and nums[i + 1] > nums[i]) { dpb[i] += dpb[i + 1]; }
      }
      int ans = 0;
      for (int i = 0; i < n; ++i) {
        if (i + 1 < n) {
          ans = max(ans, min(dpf[i], dpb[i + 1]));
        }
      }
      return ans;
    }
};",1448187598
Anuj Anand,coleworld223,31,3631,cpp,"const int MOD = 1e9 + 7;
long long dp[801][2][801];
class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
      using i64 = long long;
      int siz = s.size();
      memset(dp, -1, sizeof(dp));
      auto F = [&] (auto &&F, int idx, int f, int cnt, string&s) -> i64 {
        int siz = s.size();
        if (cnt < 0) { return 0; }
        if (idx == s.size()) {
          if (cnt == 0) { return 1; }
          return 0;
        }
        if (dp[idx][f][cnt] != -1) { return dp[idx][f][cnt]; }
        i64 res = 0;
        int till = (f ? 1 : s[idx] - '0');
        for (int take = 0; take <= till; take++) {
          bool nf = (f or (take < (s[idx] - '0')));
          res += F(F, idx + 1, nf, cnt - take, s);
          res %= MOD;
        }
        return dp[idx][f][cnt] = res;
      };
      
      auto op = [&] (int x) -> int {
        int lft = k - 1;
        while (lft > 0 and x != 1) {
          lft--;
          int c = 0;
          while (x) {
            if (x & 1) c += 1;
            x >>= 1;
          }
          x = c;
        }
        return x == 1;
      };
      
      i64 ans = 0;
      for (int cnt = 1; cnt <= siz; cnt++) {
        i64 num = F(F, 0, 0, cnt, s);
        if (op(cnt)) { ans += num; ans %= MOD; }
      }
      int c_n = count(s.begin(), s.end(), '1');
      if (op(c_n)) ans--;
      ans += MOD;
      ans %= MOD;
      return ans;
    }
};",1448225554
Anuj Anand,coleworld223,31,3646,cpp,"// dp[s] = ending with s , all posssubseq sum
// dp[s] = s + dp[s - 1] + cnt[s - 1] * s + s * cnt[s + 1]

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
      using i64 = long long;
      const int MOD = 1e9 + 7;
      const int siz = 1e5;
      vector <i64> dp (siz + 5), cnt (siz + 5);
      int n = nums.size();
      for (int i = 0; i < n; ++i) {
        int s = nums[i];
        dp[s] += s;
        if (s > 0) dp[s] += dp[s - 1];
        dp[s] += dp[s + 1];
        dp[s] %= MOD;
        if (s > 0) dp[s] += s * cnt[s - 1];
        dp[s] += s * cnt[s + 1];
        cnt[s] += 1 + (s - 1 >= 0 ? cnt[s - 1] : 0) + cnt[s + 1];
        cnt[s] %= MOD;
      }
      i64 res = 0;
      for (int i = 0; i <= siz; ++i) {
        res += dp[i];
        res %= MOD;
      }
      return res;
    }
};",1448201458
user5860c,user5860c,35,3612,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;
const char en = '\n';

class Solution {
public:
    int hasIncreasingSubarrays(vector<int>& v, int k) {
        vi bl(sz(v));
        vi br(sz(v));
        FOR(i, sz(v)) {
            if (i == 0) {
                bl[i] = 1;
            } else {
                if (v[i] > v[i-1]) {
                    bl[i] = bl[i-1] + 1;
                } else {
                    bl[i] = 1;
                }
            }
        }
        for (int i=sz(v)-1;i>=0;--i) {
            if (i == sz(v) - 1) {
                br[i] = 1;
            } else {
                if (v[i] < v[i+1]) {
                    br[i] = br[i+1] + 1;
                } else {
                    br[i] = 1;
                }
            }
        }
        int ret = 0;
        for (int i=0;i<sz(v)-1;++i) {
            ret = max(ret, min(bl[i], br[i+1]));
        }
        return ret >= k;
    }
};
",1448219921
user5860c,user5860c,35,3619,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;
const char en = '\n';

class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& v) {
        vi bl(sz(v));
        vi br(sz(v));
        FOR(i, sz(v)) {
            if (i == 0) {
                bl[i] = 1;
            } else {
                if (v[i] > v[i-1]) {
                    bl[i] = bl[i-1] + 1;
                } else {
                    bl[i] = 1;
                }
            }
        }
        for (int i=sz(v)-1;i>=0;--i) {
            if (i == sz(v) - 1) {
                br[i] = 1;
            } else {
                if (v[i] < v[i+1]) {
                    br[i] = br[i+1] + 1;
                } else {
                    br[i] = 1;
                }
            }
        }
        int ret = 0;
        for (int i=0;i<sz(v)-1;++i) {
            ret = max(ret, min(bl[i], br[i+1]));
        }
        return ret;
    }
};",1448218731
user5860c,user5860c,35,3631,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;
const char en = '\n';
#define MOD 1000000007
template<int MODX>
struct ModInt {
  unsigned x;
  ModInt() : x(0) { }
  ModInt(signed sig) : x(((sig%MODX)+MODX)%MODX) {  }
  ModInt(signed long long sig) : x(((sig%MODX)+MODX)%MODX) { }
  int get() const { return (int)x; }
  ModInt pow(ll p) { ModInt res = 1, a = *this; while (p) { if (p & 1) res *= a; a *= a; p >>= 1; } return res; }
 
  ModInt &operator+=(ModInt that) { if ((x += that.x) >= MODX) x -= MODX; return *this; }
  ModInt &operator-=(ModInt that) { if ((x += MODX - that.x) >= MODX) x -= MODX; return *this; }
  ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MODX; if (x < 0) x += MODX; return *this; }
  ModInt &operator/=(ModInt that) { return (*this) *= that.pow(MODX - 2); }
 
  ModInt operator+(ModInt that) const { return ModInt(*this) += that; }
  ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }
  ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }
  ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }
  bool operator<(ModInt that) const { return x < that.x; }
  friend ostream& operator<<(ostream &os, ModInt a) { os << a.x; return os; }
};
typedef ModInt<MOD> mint; 

string s;

mint best[808][808][2];

int calc(int d) {
    if (d == 1) return 1;
    return 1 + calc(__popcount(d));
}

class Solution {
public:
    int countKReducibleNumbers(string sx, int k) {
        
        s = sx;
        int N = sz(sx);
        FOR(i, N+2) {
            FOR(j, N+2) {
                FOR(b,2) {
                    best[i][j][b] = 0;
                }
            }
        }
        best[0][0][1] = 1;
        for (int i=0;i<sz(sx);++i) {
            for (int j=0;j<=i;++j) {
                for (int b=0;b<2;++b) {
                    //if (best[i][j][b].x == 0) continue;
                    if (b == 0) {
                        best[i+1][j+1][b] += best[i][j][b];
                        best[i+1][j][b] += best[i][j][b];
                    } else if (b == 1) {
                        if (s[i] == '1') {
                            best[i+1][j+1][1] += best[i][j][b];
                            best[i+1][j][0] += best[i][j][b];
                        } else {
                            best[i+1][j][1] += best[i][j][b];
                        }
                    }
                }
            }
        }        
        mint ret = 0;
        for (int i=1;i<=sz(sx);++i) {
            if (calc(i) <= k) {
                ret += best[sz(sx)][i][0];
            }
        }
        return ret.x;
    }
};",1448203247
user5860c,user5860c,35,3646,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;
const char en = '\n';

#define MOD 1000000007
template<int MODX>
struct ModInt {
  unsigned x;
  ModInt() : x(0) { }
  ModInt(signed sig) : x(((sig%MODX)+MODX)%MODX) {  }
  ModInt(signed long long sig) : x(((sig%MODX)+MODX)%MODX) { }
  int get() const { return (int)x; }
  ModInt pow(ll p) { ModInt res = 1, a = *this; while (p) { if (p & 1) res *= a; a *= a; p >>= 1; } return res; }
 
  ModInt &operator+=(ModInt that) { if ((x += that.x) >= MODX) x -= MODX; return *this; }
  ModInt &operator-=(ModInt that) { if ((x += MODX - that.x) >= MODX) x -= MODX; return *this; }
  ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MODX; if (x < 0) x += MODX; return *this; }
  ModInt &operator/=(ModInt that) { return (*this) *= that.pow(MODX - 2); }
 
  ModInt operator+(ModInt that) const { return ModInt(*this) += that; }
  ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }
  ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }
  ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }
  bool operator<(ModInt that) const { return x < that.x; }
  friend ostream& operator<<(ostream &os, ModInt a) { os << a.x; return os; }
};
typedef ModInt<MOD> mint;

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& v) {
        map<int,pair<mint,mint>> h;
        for (auto x : v) {
            auto cnt = h[x];
            
            cnt.fs += 1;
            cnt.fs += h[x-1].fs;
            cnt.fs += h[x+1].fs;
            cnt.sc += x;
            cnt.sc += h[x+1].sc + h[x+1].fs * x;
            cnt.sc += h[x-1].sc + h[x-1].fs * x;
            h[x] = cnt;
            //cout << cnt.fs << "" "" << cnt.sc << endl;
        }
        
        mint ret = 0;
        for (auto x : h) {
            ret += x.sc.sc;
        }
        return ret.x;
    }
};",1448215188
washedup,rejudge_thiz,37,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> pref(n);
        for(int i=0;i+1<n;i++) pref[i+1]=pref[i]+(nums[i+1]>nums[i]);
        for(int i=0;i+2*k<=n;i++){
            if(pref[i+k-1]-pref[i]==k-1 && pref[i+2*k-1]-pref[i+k]==k-1) return true;
        }
        return false;
    }
};",1448184221
washedup,rejudge_thiz,37,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> pref(n);
        for(int i=0;i+1<n;i++) pref[i+1]=pref[i]+(nums[i+1]>nums[i]);
        int l=1,r=n/2;
        while(l<r){
            int m=(l+r+1)/2;
            bool good=false;
            for(int i=0;i+2*m<=n;i++){
                if(pref[i+m-1]-pref[i]==m-1 && pref[i+2*m-1]-pref[i+m]==m-1) good=true;
            }
            if(good) l=m;
            else r=m-1;
        }
        return l;
    }
};",1448186424
washedup,rejudge_thiz,37,3631,cpp,"template <typename T> T mod_inv_in_range(T a, T m) {
  // assert(0 <= a && a < m);
  T x = a, y = m;
  // coeff of a in x and y
  T vx = 1, vy = 0;
  while (x) {
    T k = y / x;
    y %= x;
    vy -= k * vx;
    std::swap(x, y);
    std::swap(vx, vy);
  }
  assert(y == 1);
  return vy < 0 ? m + vy : vy;
}
template <int MOD_> struct modnum {
    static constexpr int MOD = MOD_;
    static_assert(MOD_ > 0, ""MOD must be positive"");

private:
    int v;

public:

    modnum() : v(0) {}
    modnum(int64_t v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }
    explicit operator int() const { return v; }
    friend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }
    friend std::istream& operator >> (std::istream& in, modnum& n) { int64_t v_; in >> v_; n = modnum(v_); return in; }

    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }
    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }

    modnum inv() const {
        modnum res;
        res.v = mod_inv_in_range(v, MOD);
        return res;
    }
    friend modnum inv(const modnum& m) { return m.inv(); }
    modnum neg() const {
        modnum res;
        res.v = v ? MOD-v : 0;
        return res;
    }
    friend modnum neg(const modnum& m) { return m.neg(); }

    modnum operator- () const {
        return neg();
    }
    modnum operator+ () const {
        return modnum(*this);
    }

    modnum& operator ++ () {
        v ++;
        if (v == MOD) v = 0;
        return *this;
    }
    modnum& operator -- () {
        if (v == 0) v = MOD;
        v --;
        return *this;
    }
    modnum& operator += (const modnum& o) {
        v -= MOD-o.v;
        v = (v < 0) ? v + MOD : v;
        return *this;
    }
    modnum& operator -= (const modnum& o) {
        v -= o.v;
        v = (v < 0) ? v + MOD : v;
        return *this;
    }
    modnum& operator *= (const modnum& o) {
        v = int(int64_t(v) * int64_t(o.v) % MOD);
        return *this;
    }
    modnum& operator /= (const modnum& o) {
        return *this *= o.inv();
    }

    friend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }
    friend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }
    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }
    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }
    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }
    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }
};
class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        const int mx=801;
        vector<int> tok(mx);
        for(int i=1;i<mx;i++){
            int temp=i;
            for(int _=0;_+1<k;_++) temp=__builtin_popcount(temp);
            tok[i]=temp==1;
        }
        using num=modnum<1'000'000'007>;
        int n=s.size();
        vector<array<num,mx>> d(n);
        d[0][0]+=1;
        for(int i=1;i<n;i++){
            d[i]=d[i-1];
            for(int j=0;j<=i;j++) d[i][j+1]+=d[i-1][j];
        }
        int s1=0;num re{};
        for(int i=0;i<n;i++){
            if(s[i]=='1'){
                for(int j=s1;j<mx;j++) if(tok[j]) re+=d[n-1-i][j-s1];
                s1++;
            }
        }
        return (int)re;
    }
};",1448229216
washedup,rejudge_thiz,37,3646,cpp,"template <typename T> T mod_inv_in_range(T a, T m) {
  // assert(0 <= a && a < m);
  T x = a, y = m;
  // coeff of a in x and y
  T vx = 1, vy = 0;
  while (x) {
    T k = y / x;
    y %= x;
    vy -= k * vx;
    std::swap(x, y);
    std::swap(vx, vy);
  }
  assert(y == 1);
  return vy < 0 ? m + vy : vy;
}
template <int MOD_> struct modnum {
    static constexpr int MOD = MOD_;
    static_assert(MOD_ > 0, ""MOD must be positive"");

private:
    int v;

public:

    modnum() : v(0) {}
    modnum(int64_t v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }
    explicit operator int() const { return v; }
    friend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }
    friend std::istream& operator >> (std::istream& in, modnum& n) { int64_t v_; in >> v_; n = modnum(v_); return in; }

    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }
    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }

    modnum inv() const {
        modnum res;
        res.v = mod_inv_in_range(v, MOD);
        return res;
    }
    friend modnum inv(const modnum& m) { return m.inv(); }
    modnum neg() const {
        modnum res;
        res.v = v ? MOD-v : 0;
        return res;
    }
    friend modnum neg(const modnum& m) { return m.neg(); }

    modnum operator- () const {
        return neg();
    }
    modnum operator+ () const {
        return modnum(*this);
    }

    modnum& operator ++ () {
        v ++;
        if (v == MOD) v = 0;
        return *this;
    }
    modnum& operator -- () {
        if (v == 0) v = MOD;
        v --;
        return *this;
    }
    modnum& operator += (const modnum& o) {
        v -= MOD-o.v;
        v = (v < 0) ? v + MOD : v;
        return *this;
    }
    modnum& operator -= (const modnum& o) {
        v -= o.v;
        v = (v < 0) ? v + MOD : v;
        return *this;
    }
    modnum& operator *= (const modnum& o) {
        v = int(int64_t(v) * int64_t(o.v) % MOD);
        return *this;
    }
    modnum& operator /= (const modnum& o) {
        return *this *= o.inv();
    }

    friend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }
    friend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }
    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }
    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }
    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }
    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }
};
class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        using num=modnum<1'000'000'007>;
        const int mx=100'001;
        array<num,mx> cnt{},su{};
        for(int i:nums){
            su[i]+=i,cnt[i]+=1;
            if(i>0) su[i]+=su[i-1]+i*cnt[i-1],cnt[i]+=cnt[i-1];
            if(i+1<mx) su[i]+=su[i+1]+i*cnt[i+1],cnt[i]+=cnt[i+1];
        }
        num re{};
        for(auto i:su) re+=i;
        return (int)re;
    }
};",1448200112
Dhruv Pasricha,pasricha_dhruv,39,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> pre(n, 1), suf(n, 1);
        for(int i = 1; i < n; ++i)
        {
            if(nums[i] > nums[i - 1])
            {
                pre[i] += pre[i - 1];
            }
        }
        for(int i = n - 2; i >= 0; --i)
        {
            if(nums[i + 1] > nums[i])
            {
                suf[i] += suf[i + 1];
            }
        }
        int ans = 1;
        for(int i = 0; i + 1 < n; ++i)
        {
            int cur = min(pre[i], suf[i + 1]);
            ans = max(ans, cur);
        }
        return ans >= k;
    }
};",1448229720
Dhruv Pasricha,pasricha_dhruv,39,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> pre(n, 1), suf(n, 1);
        for(int i = 1; i < n; ++i)
        {
            if(nums[i] > nums[i - 1])
            {
                pre[i] += pre[i - 1];
            }
        }
        for(int i = n - 2; i >= 0; --i)
        {
            if(nums[i + 1] > nums[i])
            {
                suf[i] += suf[i + 1];
            }
        }
        int ans = 1;
        for(int i = 0; i + 1 < n; ++i)
        {
            int cur = min(pre[i], suf[i + 1]);
            ans = max(ans, cur);
        }
        return ans;
    }
};",1448228632
Dhruv Pasricha,pasricha_dhruv,39,3631,cpp,"int cnt[810], dp[810][2][810];
string s;
int k;

const int mod = 1e9 + 7;

int f(int pos, bool tight, int setBits)
{
    if(pos == s.size())
    {
        if(tight or setBits == 0) return false;
        return cnt[setBits] < k;
    }

    if(dp[pos][tight][setBits] != -1) return dp[pos][tight][setBits];

    int lb = 0;
    int ub = tight ? s[pos] - '0' : 1;

    int ans = 0;
    for(int i = lb; i <= ub; ++i)
    {
        ans += f(pos + 1, tight and i == ub, setBits + (i == 1));
        ans %= mod;
    }

    return dp[pos][tight][setBits] = ans;
}

class Solution 
{
public:
    int countKReducibleNumbers(string S, int K) 
    {
        for(int i = 2; i <= 800; ++i)
        {
            cnt[i] = 1 + cnt[__builtin_popcount(i)];
        }

        memset(dp, -1, sizeof dp);
        
        s = S;
        k = K;

        return f(0, true, 0);
    }
};",1448220455
Dhruv Pasricha,pasricha_dhruv,39,3646,cpp,"const int N = 1e5 + 10, mod = 1e9 + 7;
long long dp[N + 1], dp2[N + 1];
class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        #define int long long

        int n = nums.size();
        memset(dp, 0, sizeof dp);
        memset(dp2, 0, sizeof dp2);

        int ans = 0;
        for(int i = 0; i < n; ++i)
        {
            int num = nums[i];
        
            dp[num] += num;
            dp2[num] += 1;
            
            if(num - 1 >= 0)
            {
                dp[num] += dp[num - 1];
                dp[num] += (dp2[num - 1] * num) % mod;
                dp[num] %= mod;
            
                dp2[num] += dp2[num - 1];
                dp2[num] %= mod;
            }
        
            dp[num] += dp[num + 1];
            dp[num] += (dp2[num + 1] * num) % mod;
            dp[num] %= mod;
        
            dp2[num] += dp2[num + 1];
            dp2[num] %= mod;
        }

        for(int i = 0; i <= N; ++i)
        {
            ans += dp[i];
            ans %= mod;
        }

        #undef int

        return ans;
    }
};",1448199994
BERNARD BRAHIMCHA,BERNARB01,42,3612,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

class Solution {
 public:
  bool hasIncreasingSubarrays(vector<int>& a, int k) {
    int n = int(a.size());
    vector<int> v;
    int beg = 0;
    while (beg < n) {
      int end = beg;
      while (end + 1 < n && a[end + 1] > a[end]) {
        end += 1;
      }
      v.push_back(end - beg + 1);
      beg = end + 1;
    }
    int ans = 0;
    for (int i = 0; i < int(v.size()); i++) {
      ans = max(ans, v[i] / 2);
    }
    for (int i = 1; i < int(v.size()); i++) {
      ans = max(ans, min(v[i - 1], v[i]));
    }
    return (ans >= k);
  }
};

#ifdef B01
int main() {
  Solution sl;
}
#endif
",1448230687
BERNARD BRAHIMCHA,BERNARB01,42,3619,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

class Solution {
 public:
  int maxIncreasingSubarrays(vector<int>& a) {
    int n = int(a.size());
    vector<int> v;
    int beg = 0;
    while (beg < n) {
      int end = beg;
      while (end + 1 < n && a[end + 1] > a[end]) {
        end += 1;
      }
      v.push_back(end - beg + 1);
      beg = end + 1;
    }
    int ans = 0;
    for (int i = 0; i < int(v.size()); i++) {
      ans = max(ans, v[i] / 2);
    }
    for (int i = 1; i < int(v.size()); i++) {
      ans = max(ans, min(v[i - 1], v[i]));
    }
    return ans;
  }
};

#ifdef B01
int main() {
  Solution sl;
}
#endif
",1448229414
BERNARD BRAHIMCHA,BERNARB01,42,3631,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

const int md = int(1e9) + 7;

inline void add(int& a, int b) {
  a += b;
  if (a >= md) a -= md;
}

inline void sub(int& a, int b) {
  a -= b;
  if (a < 0) a += md;
}

inline int mul(int a, int b) {
  return int(int64_t(a) * b % md);
}

int n, k;
string s;
int dp[801][801][2];
int dp2[801][5];

int sol2(int i, int j) {
  int& ret = dp2[i][j];
  if (ret != -1) {
    return ret;
  }
  if (j == 0) {
    ret = (i == 1);
  } else {
    ret = sol2(__builtin_popcount(i), j - 1);
  }
  return ret;
}

int sol(int i, int j, int e) {
  if (i == n) {
    return (e == 0 && j > 0 ? sol2(j, k - 1) : 0);
  }
  int& ret = dp[i][j][e];
  if (ret != -1) {
    return ret;
  }
  ret = 0;
  if (e) {
    if (s[i] == '1') {
      add(ret, sol(i + 1, j, 0));
      add(ret, sol(i + 1, j + 1, e));
    } else {
      add(ret, sol(i + 1, j, e));
    }
  } else {
    add(ret, sol(i + 1, j, 0));
    add(ret, sol(i + 1, j + 1, 0));
  }
  return ret;
}

class Solution {
 public:
  int countKReducibleNumbers(string s_, int k_) {
    s = s_;
    k = k_;
    n = int(s.length());
    memset(dp, -1, sizeof dp);
    memset(dp2, -1, sizeof dp2);
    return sol(0, 0, 1);
  }
};

#ifdef B01
int main() {
  Solution sl;
  deb(sl.countKReducibleNumbers(""1000"", 2));
}
#endif
",1448212713
BERNARD BRAHIMCHA,BERNARB01,42,3646,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

const int md = int(1e9) + 7;

inline void add(int& a, int b) {
  a += b;
  if (a >= md) a -= md;
}

inline void sub(int& a, int b) {
  a -= b;
  if (a < 0) a += md;
}

inline int mul(int a, int b) {
  return int(int64_t(a) * b % md);
}

class Solution {
 public:
  int sumOfGoodSubsequences(vector<int>& a) {
    int n = int(a.size());
    const int N = int(1e5) + 1;
    vector<int> cnt(N);
    vector<int> sum(N);
    for (int i = 0; i < n; i++) {
      int z = 1;
      int x = 0;
      if (a[i] > 0) {
        add(z, cnt[a[i] - 1]);
        add(x, sum[a[i] - 1]);
      }
      if (a[i] + 1 < N) {
        add(z, cnt[a[i] + 1]);
        add(x, sum[a[i] + 1]);
      }
      add(x, mul(a[i], z));
      add(sum[a[i]], x);
      add(cnt[a[i]], z);
    }
    int res = 0;
    for (int i = 0; i < N; i++) {
      add(res, sum[i]);
    }
    return res;
  }
};

#ifdef B01
int main() {
  Solution sl;
}
#endif
",1448224710
Upayan De,twoplusthree,43,3612,cpp,"class Solution {
public:
  bool hasIncreasingSubarrays(vector<int>& nums, int k) {
    int n = (int)nums.size();
    vector<int> pot;
    int siz = 1;
    for(int i = 1; i < n; i++) {
      if(nums[i - 1] < nums[i]) {
        siz++;
      } else {
        pot.push_back(siz);
        siz = 1;
      }
    }
    pot.push_back(siz);
    int ans = 0;
    int m = pot.size();
    for(int i = 0; i < m; i++) {
      ans = max(ans, pot[i] / 2);
    }
    for(int i = 1; i < m; i++) {
      ans = max(ans, min(pot[i - 1], pot[i]));
    }
    return (k <= ans);
  }
};",1448189233
Upayan De,twoplusthree,43,3619,cpp,"class Solution {
public:
  int maxIncreasingSubarrays(vector<int> &nums) {
    int n = (int)nums.size();
    vector<int> pot;
    int siz = 1;
    for(int i = 1; i < n; i++) {
      if(nums[i - 1] < nums[i]) {
        siz++;
      } else {
        pot.push_back(siz);
        siz = 1;
      }
    }
    pot.push_back(siz);
    int ans = 0;
    int m = pot.size();
    for(int i = 0; i < m; i++) {
      ans = max(ans, pot[i] / 2);
    }
    for(int i = 1; i < m; i++) {
      ans = max(ans, min(pot[i - 1], pot[i]));
    }
    return ans;
  }
};",1448187469
Upayan De,twoplusthree,43,3631,cpp,"class Solution {
public:
  int countKReducibleNumbers(string s, int k) {
    const int MOD = 1e9 + 7;
    int n = (int)s.size();
    vector<vector<int>> dp(n + 1, vector<int>(2, 0));
    dp[0][0] = dp[0][1] = 1;
    for(int i = n - 1; i >= 0; i--) {
      for(int j = n; j >= 0; j--) {
        for(int f = 0; f < 2; f++) {
          if(f) {
            if(j - 1 >= 0) {
              dp[j][1] += dp[j - 1][1];
              dp[j][1] %= MOD;
            }
          } else {
            dp[j][0] = dp[j][s[i] == '1' ? 1 : 0];
            if(s[i] == '1' && j - 1 >= 0) {
              dp[j][0] += dp[j - 1][0];
              dp[j][0] %= MOD;
            }
          }
        }
      }
    }
    vector<int> cnt(n + 1, 0);
    cnt[1] = 0;
    for(int i = 2; i <= n; i++) {
      cnt[i] = 1 + cnt[__builtin_popcount(i)];
    }
    int ans = 0;
    for(int i = 1; i <= n; i++) {
      if(1 + cnt[i] <= k) {
        ans += dp[i][0];
        ans %= MOD;
      }
    }
    int q = 0;
    for(int i = 0; i < n; i++) {
      if(s[i] == '1') {
        q++;
      }
    }
    if(1 + cnt[q] <= k) {
      ans += MOD - 1; ans %= MOD;
    }
    return ans;
  }
};",1448222991
Upayan De,twoplusthree,43,3646,cpp,"class Solution {
public:
  int sumOfGoodSubsequences(vector<int> &nums) {
    const int MOD = 1e9 + 7, _ = 1e5 + 5;
    int n = (int)nums.size();
    vector<int> dpf(n), dpb(n);
    vector<int> f(_, 0);
    for(int i = 0; i < n; i++) {
      dpb[i] = 1;
      if(nums[i] - 1 >= 0) {
        dpb[i] += f[nums[i] - 1]; dpb[i] %= MOD;
      }
      if(nums[i] + 1 < _) {
        dpb[i] += f[nums[i] + 1]; dpb[i] %= MOD;
      }
      f[nums[i]] += dpb[i]; f[nums[i]] %= MOD;
    }
    f.assign(_, 0);
    for(int i = n - 1; i >= 0; i--) {
      dpf[i] = 1;
      if(nums[i] - 1 >= 0) {
        dpf[i] += f[nums[i] - 1]; dpf[i] %= MOD;
      }
      if(nums[i] + 1 < _) {
        dpf[i] += f[nums[i] + 1]; dpf[i] %= MOD;
      }
      f[nums[i]] += dpf[i]; f[nums[i]] %= MOD;
    }
    long long ans = 0;
    for(int i = 0; i < n; i++) {
      long long foo = (long long)dpb[i] * dpf[i]; foo %= MOD;
      foo *= nums[i]; foo %= MOD;
      ans += foo; ans %= MOD;
    }
    return ans;
  }
};",1448205858
Xiaomeng Yang,yangxm,44,3612,cpp,"constexpr int MAX = 128;

int a[MAX];

class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
      int n = nums.size();
      a[0] = 0;
      a[1] = 1;
      for (int i = 1; i < n; ++i) {
        if (nums[i] > nums[i - 1]) {
          a[i + 1] = a[i] + 1;
        } else {
          a[i + 1] = 1;
        }
      }
      for (int i = 1; i <= n; ++i) {
        if (a[i] >= k && a[i - k] >= k) {
          return true;
        }
      }
      return false;
    }
};",1448184619
Xiaomeng Yang,yangxm,44,3619,cpp,"constexpr int MAX = 200010;

int a[MAX];

bool Check(int n, int k) {
  for (int i = 1; i <= n; ++i) {
    if (a[i] >= k && a[i - k] >= k) {
      return true;
    }
  }
  return false;
}

class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
      int n = nums.size();
      a[0] = 0;
      a[1] = 1;
      for (int i = 1; i < n; ++i) {
        if (nums[i] > nums[i - 1]) {
          a[i + 1] = a[i] + 1;
        } else {
          a[i + 1] = 1;
        }
      }
      int l = 1, r = n, ret = -1;
      while (l < r) {
        int mid = l + (r - l) / 2;
        if (Check(n, mid)) {
          ret = mid;
          l = mid + 1;
        } else {
          r = mid;
        }
      }
      return ret;
    }
};",1448188009
Xiaomeng Yang,yangxm,44,3631,cpp,"using i64 = long long;

constexpr int MAX = 1024;
constexpr int INF = 0x3F3F3F3F;
constexpr int MOD = 1000000007;

int w[MAX], d[MAX];
i64 dp[MAX][MAX];

void Init() {
  w[0] = INF;
  w[1] = 0;
  for (int i = 2; i < MAX; ++i) {
    int c = __builtin_popcount(i);
    w[i] = w[c] + 1;
  }
}

i64 DFS(int k, int p, int cnt, bool lim) {
  if (p == -1) {
    return w[cnt] <= k;
  }
  if (!lim && ~dp[p][cnt]) {
    return dp[p][cnt];
  }
  int m = lim ? d[p] : 1;
  i64 ret = 0;
  for (int i = 0; i <= m; ++i) {
    i64 cur = DFS(k, p - 1, cnt + i, lim && i == m);
    ret = (ret + cur) % MOD;
  }
  if (!lim) {
    dp[p][cnt] = ret;
  }
  return ret;
}

class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
      static bool init = []() {
        Init();
        return true;
      }();

      int n = s.length(), cnt = 0;
      for (int i = 0; i < n; ++i) {
        int v = s[i] - '0';
        d[n - 1 - i] = v;
        cnt += v;
      }
      for (int i = 0; i <= n; ++i) {
        fill(dp[i], dp[i] + n + 1, -1);
      }
      i64 ret = DFS(k - 1, n - 1, 0, true);
      if (w[cnt] < k) {
        ret = (ret - 1 + MOD) % MOD;
      }
      return ret;
    }
};",1448223757
Xiaomeng Yang,yangxm,44,3646,cpp,"using i64 = long long;

constexpr int MAX = 100010;
constexpr int MOD = 1000000007;

using i64 = long long;

i64 dp[MAX][2];

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
      int n = nums.size(), m = *max_element(nums.begin(), nums.end());
      memset(dp, 0, sizeof(dp));
      for (int x : nums) {
        dp[x][0] = (dp[x][0] + 1) % MOD;
        dp[x][1] = (dp[x][1] + x) % MOD;
        if (x > 0) {
          dp[x][0] = (dp[x][0] + dp[x - 1][0]) % MOD;
          dp[x][1] = (dp[x][1] + dp[x - 1][1] + dp[x - 1][0] * (i64)x) % MOD;
        }
        if (x < m) {
          dp[x][0] = (dp[x][0] + dp[x + 1][0]) % MOD;
          dp[x][1] = (dp[x][1] + dp[x + 1][1] + dp[x + 1][0] * (i64)x) % MOD;
        }
      }
      int ret = 0;
      for (int i = 0; i <= m; ++i) {
        ret = (ret + dp[i][1]) % MOD;
      }
      return ret;
    }
};",1448203110
Julian,juliany2,45,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();

        vector<int> len(n);
        len[n - 1] = 1;
        for (int i = n - 2; i >= 0; i--) {
            len[i] = (nums[i] < nums[i + 1] ? len[i + 1] + 1 : 1);
        }

        int mid = k;
            bool f = 0;
            for (int i = 0; i + mid < n; i++) {
                f |= len[i] >= mid && len[i + mid] >= mid;
            }

        return f;
    }
};",1448207863
Julian,juliany2,45,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();

        vector<int> len(n);
        len[n - 1] = 1;
        for (int i = n - 2; i >= 0; i--) {
            len[i] = (nums[i] < nums[i + 1] ? len[i + 1] + 1 : 1);
        }

        int lo = 1, hi = n / 2;
        while (lo < hi) {
            int mid = (lo + hi + 1) / 2;

            bool f = 0;
            for (int i = 0; i + mid < n; i++) {
                f |= len[i] >= mid && len[i + mid] >= mid;
            }

            if (f)
                lo = mid;
            else
                hi = mid - 1;
        }
        return lo;
    }
};",1448206635
Julian,juliany2,45,3631,cpp,"class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        const int mod = 1e9 + 7;
        using ll = long long;
        int n = s.size();

        auto binpow = [&](ll x, ll y) {
            ll res = 1;
            for (; y; y >>= 1, (x *= x) %= mod)
                if (y & 1)
                    (res *= x) %= mod;
            return res;
        };

        vector<ll> fac(n + 1), ifac(n + 1);
        fac[0] = ifac[0] = 1;
        for (int i = 1; i <= n; i++) {
            fac[i] = fac[i - 1] * i % mod;
            ifac[i] = binpow(fac[i], mod - 2);
        }
        
        auto nck = [&](int n, int k) {
            return fac[n] * ifac[n - k] % mod * ifac[k] % mod;
        };

        // ways to start with i zeros
        vector<ll> ways(n + 1);

        int seen = 0;
        for (int i = 0; i < n; i++) {
            if (s[i] == '1') {
                int rem = n - i - 1;
                for (int j = 0; j <= rem; j++) {
                    (ways[seen + j] += nck(rem, j)) %= mod;
                    //cout << ""adding: "" << seen + j << ' ' << nck(rem, j) << '\n';
                }
                seen++;
            }
        }

        ll ans = 0;
        for (int i = 1; i <= n; i++) {
            int here = i, steps = 1;
            while (here > 1) {
                here = __builtin_popcount(here);
                steps++;
            }

            if (steps <= k)
                (ans += ways[i]) %= mod;
        }
        return ans;
    }
};",1448193048
Julian,juliany2,45,3646,cpp,"class Solution {
using ll = long long;
ll cnt[100007], sum[100007];

public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        const int mod = 1e9 + 7;

        for (int &x : nums) {
            x += 5;
            sum[x] = cnt[x] = 0;
        }

        ll ans = 0;
        for (int x : nums) {
            ll ways = (cnt[x - 1] + cnt[x + 1] + 1) % mod;
            ll here = (sum[x - 1] + sum[x + 1] + ways * (x - 5) % mod) % mod;
            (ans += here) %= mod;
            (cnt[x] += ways) %= mod;
            (sum[x] += here) %= mod;
        }

        return ans;
    }
};",1448201869
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,46,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        def isinc(x):
            for i in range(len(x) - 1):
                if x[i+1] <= x[i]:
                    return False
            return True
        
        for i in range(len(nums) - 2 * k + 1):
            a, b = nums[i:i+k], nums[i+k:i+2*k]
            if isinc(a) and isinc(b):
                return True
        return False",1448183128
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,46,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        inc = []
        cur = -inf
        r = 0
        for x in nums:
            if x > cur:
                r += 1
            else:
                r = 1
            cur = x
            inc.append(r)

        def check(x):
            for i in range(2*x - 1, len(nums)):
                if inc[i] >= x and inc[i-x] >= x:
                    return True
            return False

        a, b = 1, len(nums)//2
        while a < b:
            mi = (a + b + 1) // 2
            if check(mi):
                a = mi
            else:
                b = mi - 1
        return a",1448193906
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,46,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        MOD = 10**9+7
        
        @cache
        def dist(x):
            if x == 0:
                return inf
            if x == 1:
                return 0
            t = x.bit_count()
            return 1 + dist(t)

        @cache
        def ct(idx, limit, amt):
            if idx == len(s):
                return int(dist(amt) <= k - 1)
            if not limit:
                return (ct(idx+1, False, amt+1) + ct(idx+1, False, amt)) % MOD
            else:
                if idx == len(s) - 1:
                    if s[idx] == '1':
                        return (ct(idx+1, False, amt)) % MOD
                    else:
                        return 0
                else:
                    if s[idx] == '1':
                        return (ct(idx+1, True, amt+1) + ct(idx+1, False, amt)) % MOD
                    else:
                        return ct(idx+1, True, amt)

        return ct(0, True, 0) % MOD
        ",1448232620
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,46,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        MOD = 10**9+7
        ret = 0
        d = defaultdict(int)
        sm = defaultdict(int)
        for x in nums:
            v = d[x-1] + d[x+1] + 1
            s = sm[x-1] + sm[x+1] + v * x
            ret += s
            ret %= MOD
            d[x] += v
            d[x] %= MOD
            sm[x] += s
            sm[x] %= MOD
            # print(d, sm, ret)
        return ret
            ",1448205003
mastoori1234,mastoori1234,48,3612,cpp,"typedef long long int ll;

class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& arr, int k) {
        
        ll n = arr.size();
        
        vector<ll> dp( n, 1);
        
        for( ll i=n-2; i>=0; i--) {
            if(arr[i]<arr[i+1]) {
                dp[i] += dp[i+1];
            }
        }
        
        ll sv = k;
        ll ev = k;
        ll ans = 1;
        
        while(sv<=ev) {
            ll mv = (sv+ev)/2;
            bool f = false;
            for( ll i=0; i+mv<n; i++) {
                f = f || ((dp[i]>=mv) && (dp[i+mv]>=mv));
            }
            if(f) {
                return true;
            } else {
                ev = mv - 1;
            }
        }
        
        return false;     
    }
};",1448233240
mastoori1234,mastoori1234,48,3619,cpp,"typedef long long int ll;

class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& arr) {
        
        ll n = arr.size();
        
        vector<ll> dp( n, 1);
        
        for( ll i=n-2; i>=0; i--) {
            if(arr[i]<arr[i+1]) {
                dp[i] += dp[i+1];
            }
        }
        
        ll sv = 1;
        ll ev = n/2;
        ll ans = 1;
        
        while(sv<=ev) {
            ll mv = (sv+ev)/2;
            bool f = false;
            for( ll i=0; i+mv<n; i++) {
                f = f || ((dp[i]>=mv) && (dp[i+mv]>=mv));
            }
            if(f) {
                ans = max( ans, mv);
                sv = mv + 1;
            } else {
                ev = mv - 1;
            }
        }
        
        return ans;
    }
};",1448231246
mastoori1234,mastoori1234,48,3631,cpp,"typedef long long int ll;


class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        
        ll ans = 0;
        
        ll n = s.length();
        const ll mod = 1e9+7;
        
        reverse( s.begin(), s.end());
        
        vector<bool> v(n+1, false);
        
        /*
            idx, bit, sum, 
        */
        vector< vector< vector<ll> > > dp( n, vector< vector<ll> >( 2, vector<ll>(n+1, 0)));
        
        v[1] = true;
        
        for( ll i=1; i<k; i++) {
            for( ll j=n; j>=1; j--) {
                int bc = __builtin_popcount(j);
                v[j] = v[j] || v[bc];
            }   
        }
        
        // for( ll i=1; i<=n; i++) {
        //     if(v[i]) {
        //         cout << i << "" "";
        //     }
        // }
        // cout << ""\n"";
        
        dp[0][1][1] = 1;
        dp[0][0][0] = 1;
        
        for( ll idx=1; idx<n; idx++) {
            for( ll bit=0; bit<2; bit++) {
                for( ll sum=0; sum<=n; sum++) {
                    for( ll nbit=0; nbit<2; nbit++) {
                        if(sum+nbit<=n) {
                            ll & val = dp[idx][nbit][sum+nbit];
                            val += dp[idx-1][bit][sum];
                            val %= mod;
                        }
                    }
                }
            }
        }
        
        for( ll idx=0; idx+1<n; idx++) {
            for( ll sum=1; sum<=n; sum++) {
                ans += (v[sum]*dp[idx][1][sum]);
                ans %= mod;
            }
        }
        
        ll tot = 0;
        for( ll idx=n-1; idx>=0; idx--) {
            if((s[idx]=='1') && (idx<n-1)) {
                for( ll sum=0; sum<=n; sum++) {
                    if((sum+tot<=n) && v[sum+tot]) {
                        ans += dp[idx][0][sum];
                        ans %= mod;
                    }
                }
            }
            tot += (s[idx]=='1'); 
        }
        
        // ans += tot;
        // ans %= mod;
        
        return ans;
    }
};",1448218341
mastoori1234,mastoori1234,48,3646,cpp,"typedef long long int ll;

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& arr) {
        
        ll ans = 0;
        
        const ll mod = 1e9+7;
        
        unordered_map<ll,ll> smp;
        unordered_map<ll,ll> cmp;
        
        for( ll v: arr) {
            ll s = smp[v-1] + smp[v+1];
            ll c = cmp[v-1] + cmp[v+1];
            
            ll ns = s + c*v + v;
            ll nc = c + 1;
            
            ns%=mod;
            nc%=mod;
            
            ans += ns;
            ans %= mod;
            
            smp[v] += ns;
            smp[v] %= mod;
            
            cmp[v] += nc;
            cmp[v] %= mod;
        }
        
        return ans;
    }
};",1448226545
Abhishek Srivastava,Abhi_Srivastava,50,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        for (int i = 0; i + k * 2 <= nums.size(); i++) {
            bool poss = 1;
            for (int j = i + 1; j < i + k; j++)
                if (nums[j] <= nums[j - 1]) {
                    poss = 0;
                    break;
                }
            for (int j = i + k + 1; j < i + k * 2; j++)
                if (nums[j] <= nums[j - 1]) {
                    poss = 0;
                    break;
                }
            if (poss)
                return 1;
        }
        return 0;
    }
};",1448182706
Abhishek Srivastava,Abhi_Srivastava,50,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        vector<int> vec;
        int curr = 1, res;
        for (int i = 1; i < nums.size(); i++) {
            if (nums[i] <= nums[i - 1]) {
                vec.push_back(curr);
                curr = 0;
            }
            curr++;
        }
        vec.push_back(curr);
        res = *max_element(vec.begin(), vec.end()) / 2;
        for (int i = 1; i < vec.size(); i++)
            res = max(res, min(vec[i], vec[i - 1]));
        return res;
    }
};",1448186301
Abhishek Srivastava,Abhi_Srivastava,50,3631,cpp,"const int mod = 1e9 + 7;

bool reducible(int num, int k) {
    for (int i = 0; i < k; i++) 
        num = __builtin_popcount(num);
    return (num == 1);
}

class Solution {
public:
    long long solve(int ind, string& s, bool tight, int setBits, int k, vector<vector<vector<int>>>& dp) {
        if (ind == s.size())
            return reducible(setBits, k);
        if (dp[tight][setBits][ind] != -1)
            return dp[tight][setBits][ind];
        long long res;
        if (tight) {
            if (s[ind] == '0')
                res = solve(ind + 1, s, 1, setBits, k, dp);
            else 
                res = (solve(ind + 1, s, 0, setBits, k, dp) + solve(ind + 1, s, 1, setBits + 1, k, dp)) % mod;
        }
        else 
            res = (solve(ind + 1, s, 0, setBits, k, dp) + solve(ind + 1, s, 0, setBits + 1, k, dp)) % mod;
        return dp[tight][setBits][ind] = res;
    }
    int countKReducibleNumbers(string s, int k) {
        int n = s.size(), bitCnt = 0;
        for (char x : s)
            bitCnt += (x - '0');
        vector<vector<vector<int>>> dp(2, vector<vector<int>>(n + 1, vector<int>(n, -1)));
        return (solve(0, s, 1, 0, k - 1, dp) + mod - reducible(bitCnt, k - 1)) % mod;
    }
};",1448233343
Abhishek Srivastava,Abhi_Srivastava,50,3646,cpp,"const int mod = 1e9 + 7;
class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        map<int, long long> mp, num;
        long long ans = 0;
        for (int x : nums) {
            long long res = x, sub = 1;
            if (mp.find(x + 1) != mp.end()) {
                (res += mp[x + 1]) %= mod;
                (res += num[x + 1] * x) %= mod;
                (sub += num[x + 1]) %= mod;
            }
            if (mp.find(x - 1) != mp.end()) {
                (res += mp[x - 1]) %= mod;
                (res += num[x - 1] * x) %= mod;
                (sub += num[x - 1]) %= mod;
            }
            (num[x] += sub) %= mod;
            (ans += res) %= mod;
            (mp[x] += res) %= mod;
        }
        return ans;
    }
};",1448205705
OTTFF,OTTFF,51,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& a, int k) {
        int n = a.size();
        vector<int> b;
        for (int i = 0; i + k - 1 < n; i++) {
            int f = 1;
            for (int j = i + 1; j < i + k; j++) {
                if (a[j - 1] >= a[j]) {
                    f = 0;
                    break;
                }
            }
            b.push_back(f);
        }
        n = b.size();
        for (int i = 0; i + k < n; i++) {
            if (b[i] && b[i + k]) {
                return true;
            }
        }
        return false;
    }
};",1448183064
OTTFF,OTTFF,51,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& a) {
        int n = a.size();

        vector<int> l(n), r(n);
        l[0] = r[n - 1] = 1;

        for (int i = 1; i < n; i++) {
            if (a[i - 1] < a[i]) {
                l[i] = l[i - 1] + 1;
            } else {
                l[i] = 1;
            }
        }
        for (int i = n - 2; i >= 0; i--) {
            if (a[i] < a[i + 1]) {
                r[i] = r[i + 1] + 1;
            } else {
                r[i] = 1;
            }
        }

        int ans = 0;
        for (int i = 0; i + 1 < n; i++) {
            ans = max(ans, min(l[i], r[i + 1]));
        }
        return ans;
    }
};",1448186726
OTTFF,OTTFF,51,3631,cpp,"template<long long Mo=998244353> struct ModInt {
  static long long MO;
  static void setMo(long long mo) { MO = mo; }
  long long x;
  ModInt(long long x=0) : x(x){ norm(); }
  friend istream &operator>>(istream& in, ModInt &B) { in>>B.x; return in; }
  friend ostream &operator<<(ostream& out, const ModInt &B) { 
    out<<B.x; return out; }
  // ModInt operator=(int x_) { x=x_; norm(); return *this; }
  void norm() { x = (x%MO + MO) % MO; }
  long long get() { return x; }

  ModInt operator-() const { return ModInt(MO - x); }
  ModInt operator+=(const ModInt &B) { x+=B.x; if(x>=MO) x-=MO; return *this; }
  ModInt operator-=(const ModInt &B) { x-=B.x; if(x<0) x+=MO; return *this; }
  ModInt operator*=(const ModInt &B) { x=x*B.x%MO; return *this; }
  ModInt operator+(const ModInt &B) const { ModInt ans=*this; return ans+=B; }
  ModInt operator-(const ModInt &B) const { ModInt ans=*this; return ans-=B; }
  ModInt operator*(const ModInt &B) const { ModInt ans=*this; return ans*=B; }
  ModInt operator^(long long n) const  {
    ModInt a=*this; ModInt ans(1);
    while(n) { if(n&1) ans*=a; a*=a; n>>=1; }
    return ans;
  }
  ModInt inv() const { return (*this)^(MO-2); } // if MO is prime
  ModInt operator/=(const ModInt &B) { (*this)*=B.inv(); return *this; }
  ModInt operator/(const ModInt &B) const { ModInt ans=*this; return ans/=B; }

  bool operator<(const ModInt &B) const { return x<B.x; }
  bool operator==(const ModInt &B) const { return x==B.x; }
  bool operator!=(const ModInt &B) const { return x!=B.x; }
};
template<long long Mo> long long ModInt<Mo>::MO = Mo;
// typedef ModInt<998244353> Mint;
typedef ModInt<1'000'000'007> Mint;

int f = 0;
const int M = 805;
int cnt[M];
void init() {
    if (f) return;
    f = 1;

    for (int i = 2; i < M; i++) {
        cnt[i] = cnt[__builtin_popcount(i)] + 1;
    }
}

Mint dp[M][M][2];
int vis[M][M][2];

class Solution {
public:
    string s;
    int n;

    Mint dfs(int cur, int cnt, int lim) {
        if (cnt < 0) return 0;
        if (cur == n) {
            if (cnt == 0) return 1;
            else return 0;
        }
        if (vis[cur][cnt][lim]) return dp[cur][cnt][lim];
        vis[cur][cnt][lim] = 1;
        dp[cur][cnt][lim] = 0;
        int up = lim ? (s[cur] - '0') : 1;
        for (int i = 0; i <= up; i++) {
            dp[cur][cnt][lim] += dfs(cur + 1, cnt - i, lim && i == up);
        }
        // cout << cur << ' ' << cnt << ' ' << lim << ' ' << dp[cur][cnt][lim] << endl;
        return dp[cur][cnt][lim];
    }

    void solve() {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j <= n; j++) {
                vis[i][j][0] = vis[i][j][1] = 0;
            }
        }
    }

    int countKReducibleNumbers(string s, int k) {
        init();
        
        this->s = s;
        this->n = s.length();

        solve();

        Mint ans = 0;
        for (int i = 1; i <= n; i++) {
            // cout << i << ' ' << cnt[i] << endl;
            if (cnt[i] + 1 <= k) {
                ans += dfs(0, i, 1);
            }
        }

        int c = 0;
        for (int i = 0; i < n; i++) {
            if (s[i] == '1') c++;
        }
        if (cnt[c] + 1 <= k) {
            ans.x -= 1;
        }
        return ans.x;
    }
};",1448233359
OTTFF,OTTFF,51,3646,cpp,"template<long long Mo=998244353> struct ModInt {
  static long long MO;
  static void setMo(long long mo) { MO = mo; }
  long long x;
  ModInt(long long x=0) : x(x){ norm(); }
  friend istream &operator>>(istream& in, ModInt &B) { in>>B.x; return in; }
  friend ostream &operator<<(ostream& out, const ModInt &B) { 
    out<<B.x; return out; }
  // ModInt operator=(int x_) { x=x_; norm(); return *this; }
  void norm() { x = (x%MO + MO) % MO; }
  long long get() { return x; }

  ModInt operator-() const { return ModInt(MO - x); }
  ModInt operator+=(const ModInt &B) { x+=B.x; if(x>=MO) x-=MO; return *this; }
  ModInt operator-=(const ModInt &B) { x-=B.x; if(x<0) x+=MO; return *this; }
  ModInt operator*=(const ModInt &B) { x=x*B.x%MO; return *this; }
  ModInt operator+(const ModInt &B) const { ModInt ans=*this; return ans+=B; }
  ModInt operator-(const ModInt &B) const { ModInt ans=*this; return ans-=B; }
  ModInt operator*(const ModInt &B) const { ModInt ans=*this; return ans*=B; }
  ModInt operator^(long long n) const  {
    ModInt a=*this; ModInt ans(1);
    while(n) { if(n&1) ans*=a; a*=a; n>>=1; }
    return ans;
  }
  ModInt inv() const { return (*this)^(MO-2); } // if MO is prime
  ModInt operator/=(const ModInt &B) { (*this)*=B.inv(); return *this; }
  ModInt operator/(const ModInt &B) const { ModInt ans=*this; return ans/=B; }

  bool operator<(const ModInt &B) const { return x<B.x; }
  bool operator==(const ModInt &B) const { return x==B.x; }
  bool operator!=(const ModInt &B) const { return x!=B.x; }
};
template<long long Mo> long long ModInt<Mo>::MO = Mo;
// typedef ModInt<998244353> Mint;
typedef ModInt<1'000'000'007> Mint;

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        map<int, Mint> cnt;
        map<int, Mint> dp;

        Mint ans = 0;
        for (int i : nums) {
            cnt[i] += cnt[i - 1];
            cnt[i] += cnt[i + 1];
            cnt[i] += 1;

            dp[i] += dp[i - 1] + cnt[i - 1] * i;
            dp[i] += dp[i + 1] + cnt[i + 1] * i;
            dp[i] += i;
            
            // ans += dp[i];
            // cout << i << ' ' << cnt[i] << ' ' << dp[i] << ' ' << ans << endl;
        }
        for (auto [v, c] : dp) {
            ans += c;
        }
        return ans.x;
    }
};",1448201741
Brian Law,lwm7708,54,3612,cpp,"#include <algorithm>
#include <cstdint>
#include <vector>

class Solution {

public:

    bool hasIncreasingSubarrays(std::vector<int>& nums, int k) {

        const std::int32_t n = std::size(nums);

        for (std::int32_t i = 0; i < n; ++i) {
            nums[i] -= i;
        }

        for (std::int32_t i = 0; i <= n - k * 2; ++i) {
            if (
                std::is_sorted(std::begin(nums) + i, std::begin(nums) + i + k) &&
                std::is_sorted(std::begin(nums) + i + k, std::begin(nums) + i + k * 2)
            ) {
                return true;
            }
        }

        return false;

    }

};
",1448183549
Brian Law,lwm7708,54,3619,cpp,"#include <algorithm>
#include <cstdint>
#include <vector>

class Solution {

public:

    int maxIncreasingSubarrays(std::vector<int>& nums) {

        std::int32_t mx = 0;
        const std::int32_t n = std::size(nums);

        std::vector<std::int32_t> dp_1(n);
        std::vector<std::int32_t> dp_2(n);

        dp_1[0] = 1;
        dp_2[n - 1] = 1;

        for (std::int32_t i = 1; i < n; ++i) {
            dp_1[i] = nums[i] > nums[i - 1] ? dp_1[i - 1] + 1 : 1;
        }

        for (std::int32_t i = n - 2; i >= 0; --i) {
            dp_2[i] = nums[i] < nums[i + 1] ? dp_2[i + 1] + 1 : 1;
        }

        for (std::int32_t i = 0; i < n - 1; ++i) {
            mx = std::max(mx, std::min(dp_1[i], dp_2[i + 1]));
        }

        return mx;

    }

};
",1448188883
Brian Law,lwm7708,54,3631,cpp,"#include <array>
#include <cstdint>
#include <string>
#include <utility>
#include <vector>

template <typename T>
std::array<T, 3> extended_gcd(T m, T n) {

    T a = 1;
    T a_in = 0;
    T b = 0;
    T b_in = 1;

    while (n) {
        const T q = m / n;
        a_in = std::exchange(a, a_in) - a_in * q;
        b_in = std::exchange(b, b_in) - b_in * q;
        n = std::exchange(m, n) - n * q;
    }

    return std::array<T, 3>({m, a, b});

}

template <std::int32_t MOD>
class modular_integer {

private:

    static constexpr std::int32_t MODULUS = MOD;

public:

    static std::int32_t get_modulus() {

        return MODULUS;

    }

    std::int32_t val;

    explicit modular_integer() : modular_integer(0) {}

    explicit modular_integer(std::int64_t val) : val(val % get_modulus()) {

        if (this->val < 0) {
            this->val += get_modulus();
        }

    }

    modular_integer operator-() const {

        return modular_integer(-val);

    }

    void operator++() {

        *this += modular_integer(1);

    }

    void operator--() {

        *this -= modular_integer(1);

    }

    void operator+=(modular_integer other) {

        if (other.val >= get_modulus() - val) {
            val -= get_modulus();
        }

        val += other.val;

    }

    void operator-=(modular_integer other) {

        val -= other.val;

        if (val < 0) {
            val += get_modulus();
        }

    }

    void operator*=(modular_integer other) {

        val = (std::int64_t(val) * other.val) % get_modulus();

    }

    void operator/=(modular_integer other) {

        *this *= modular_integer(extended_gcd(other.val, get_modulus())[1]);

    }

    friend modular_integer operator+(modular_integer lhs, modular_integer rhs) {

        lhs += rhs;

        return lhs;

    }

    friend modular_integer operator-(modular_integer lhs, modular_integer rhs) {

        lhs -= rhs;

        return lhs;

    }

    friend modular_integer operator*(modular_integer lhs, modular_integer rhs) {

        lhs *= rhs;

        return lhs;

    }

    friend modular_integer operator/(modular_integer lhs, modular_integer rhs) {

        lhs /= rhs;

        return lhs;

    }

};

class Solution {

public:

    int countKReducibleNumbers(std::string s, int k) {

        static constexpr std::int32_t MOD = 1000000007;

        using num_t = modular_integer<MOD>;

        num_t cnt;
        const std::int32_t sz = std::size(s);

        std::vector<std::array<num_t, 3>> dp(sz + 1);

        dp[0][1] = num_t(1);

        for (std::int32_t i = sz - 1; i >= 0; --i) {
            std::vector<std::array<num_t, 3>> n_dp(sz + 1);
            for (std::int32_t j = 0; j < sz; ++j) {
                for (std::int32_t l = 0; l < 2; ++l) {
                    for (std::int32_t m = 0; m < 3; ++m) {
                        std::int32_t st = m;
                        if (l == 0 && s[i] == '1') {
                            st = 0;
                        } else if (l == 1 && s[i] == '0') {
                            st = 1;
                        }
                        n_dp[j + l][st] += dp[j][m];
                    }
                }
            }
            dp = std::move(n_dp);
        }

        for (std::int32_t i = 1; i <= sz; ++i) {
            std::int32_t bits = i;
            for (std::int32_t j = 0; j < k - 1; ++j) {
                bits = __builtin_popcount(bits);
            }
            if (bits == 1) {
                cnt += dp[i][0];
            }
        }

        return cnt.val;

    }

};
",1448234244
Brian Law,lwm7708,54,3646,cpp,"#include <algorithm>
#include <array>
#include <cstdint>
#include <numeric>
#include <utility>
#include <vector>

template <typename T>
std::array<T, 3> extended_gcd(T m, T n) {

    T a = 1;
    T a_in = 0;
    T b = 0;
    T b_in = 1;

    while (n) {
        const T q = m / n;
        a_in = std::exchange(a, a_in) - a_in * q;
        b_in = std::exchange(b, b_in) - b_in * q;
        n = std::exchange(m, n) - n * q;
    }

    return std::array<T, 3>({m, a, b});

}

template <std::int32_t MOD>
class modular_integer {

private:

    static constexpr std::int32_t MODULUS = MOD;

public:

    static std::int32_t get_modulus() {

        return MODULUS;

    }

    std::int32_t val;

    explicit modular_integer() : modular_integer(0) {}

    explicit modular_integer(std::int64_t val) : val(val % get_modulus()) {

        if (this->val < 0) {
            this->val += get_modulus();
        }

    }

    modular_integer operator-() const {

        return modular_integer(-val);

    }

    void operator++() {

        *this += modular_integer(1);

    }

    void operator--() {

        *this -= modular_integer(1);

    }

    void operator+=(modular_integer other) {

        if (other.val >= get_modulus() - val) {
            val -= get_modulus();
        }

        val += other.val;

    }

    void operator-=(modular_integer other) {

        val -= other.val;

        if (val < 0) {
            val += get_modulus();
        }

    }

    void operator*=(modular_integer other) {

        val = (std::int64_t(val) * other.val) % get_modulus();

    }

    void operator/=(modular_integer other) {

        *this *= modular_integer(extended_gcd(other.val, get_modulus())[1]);

    }

    friend modular_integer operator+(modular_integer lhs, modular_integer rhs) {

        lhs += rhs;

        return lhs;

    }

    friend modular_integer operator-(modular_integer lhs, modular_integer rhs) {

        lhs -= rhs;

        return lhs;

    }

    friend modular_integer operator*(modular_integer lhs, modular_integer rhs) {

        lhs *= rhs;

        return lhs;

    }

    friend modular_integer operator/(modular_integer lhs, modular_integer rhs) {

        lhs /= rhs;

        return lhs;

    }

};

class Solution {

public:

    int sumOfGoodSubsequences(std::vector<int>& nums) {

        static constexpr std::int32_t MOD = 1000000007;

        using num_t = modular_integer<MOD>;

        const std::int32_t mx = *std::max_element(std::begin(nums), std::end(nums));
        const std::int32_t sz = std::size(nums);

        std::vector<num_t> dp(mx + 1);
        std::vector<num_t> sums(sz);

        for (std::int32_t i = 0; i < sz; ++i) {
            const num_t prv = dp[nums[i]];
            if (nums[i]) {
                dp[nums[i]] += dp[nums[i] - 1];
            }
            if (nums[i] < mx) {
                dp[nums[i]] += dp[nums[i] + 1];
            }
            ++dp[nums[i]];
            sums[i] = dp[nums[i]] - prv;
        }

        std::fill_n(std::begin(dp), mx + 1, num_t());

        for (std::int32_t i = sz - 1; i >= 0; --i) {
            const num_t prv = dp[nums[i]];
            if (nums[i]) {
                dp[nums[i]] += dp[nums[i] - 1];
            }
            if (nums[i] < mx) {
                dp[nums[i]] += dp[nums[i] + 1];
            }
            ++dp[nums[i]];
            sums[i] *= dp[nums[i]] - prv;
        }

        for (std::int32_t i = 0; i < sz; ++i) {
            sums[i] *= num_t(nums[i]);
        }

        return std::accumulate(std::begin(sums), std::end(sums), num_t()).val;

    }

};
",1448208806
megaspazz,megaspazz,55,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        def isIncreasing(arr):
            for i in range(1, len(arr)):
                if arr[i - 1] >= arr[i]:
                    return False
            return True
        
        N = len(nums)
        
        for i in range(0, N):
            if i + 2 * k > N:
                break
            if isIncreasing(nums[i:i+k]) and isIncreasing(nums[i+k:i+k+k]):
                return True
        return False",1448183117
megaspazz,megaspazz,55,3619,java,"class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        final int[] A = toIntArray(nums);
        final int N = A.length;
        
        IntDeque incrsLst = new IntDeque();
        int curr = 1;
        for (int i = 1; i < N; ++i) {
            if (A[i] <= A[i - 1]) {
                incrsLst.add(curr);
                curr = 1;
            } else {
                ++curr;
            }
        }
        incrsLst.add(curr);
        
        final int[] incrs = incrsLst.toArray();
        final int K = incrs.length;
        
        int best = 1;
        for (int x : incrs) {
            best = Math.max(best, x >> 1);
        }
        for (int i = 1; i < K; ++i) {
            best = Math.max(best, Math.min(incrs[i - 1], incrs[i]));
        }
        return best;
    }
    
	/**
	 * Circular buffer of int values, can be used as:
	 *   - ArrayList: values are added to end.
	 *   - Queue: values are added to end and removed from front.
	 *   - Stack: values are added to and removed from front.
	 */
	public static class IntDeque {
		private int[] arr;
		private int off;
		private int len;

		public IntDeque() {
			this(2);
		}

		public IntDeque(int capacity) {
			this.arr = new int[capacity];
		}

		public void addFirst(int x) {
			if (len == arr.length) {
				increaseCapacity();
			}
			if (off == 0) {
				off = arr.length;
			}
			arr[--off] = x;
			++len;
		}

		public void addLast(int x) {
			if (len == arr.length) {
				increaseCapacity();
			}
			int idx = index(off + len);
			arr[idx] = x;
			++len;
		}

		public int peekFirst() {
			return arr[off];
		}

		public int peekLast() {
			int idx = index(off + len - 1);
			return arr[idx];
		}

		public int removeFirst() {
			int ans = peekFirst();
			off = index(off + 1);
			--len;
			return ans;
		}

		public int removeLast() {
			int ans = peekLast();
			--len;
			return ans;
		}

		public void add(int x) {
			addLast(x);
		}

		public void offer(int x) {
			addLast(x);
		}

		public int poll() {
			return removeFirst();
		}

		public void push(int x) {
			addFirst(x);
		}

		public int pop() {
			return removeFirst();
		}

		public int peek() {
			return peekFirst();
		}

		public int get(int i) {
			if (i >= len) {
				throw new ArrayIndexOutOfBoundsException(String.format(""index %d out of range [0, %d)"", i, len));
			}
			int idx = index(i + off);
			return arr[idx];
		}

		public void set(int i, int x) {
			if (i >= len) {
				throw new ArrayIndexOutOfBoundsException(String.format(""index %d out of range [0, %d)"", i, len));
			}
			int idx = index(i + off);
			arr[idx] = x;
		}

		public int size() {
			return len;
		}

		public boolean isEmpty() {
			return size() == 0;
		}

		public int[] toArray() {
			if (len == 0) {
				return new int[0];
			}
			int idx = index(off + len);
			if (idx > off) {
				return Arrays.copyOfRange(arr, off, idx);
			}
			int[] A = new int[len];
			int endLen = arr.length - off;
			int startLen = len - endLen;
			System.arraycopy(arr, off, A, 0, endLen);
			System.arraycopy(arr, 0, A, endLen, startLen);
			return A;
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder();
			sb.append('[');
			printToBuffer(sb, "", "");
			sb.append(']');
			return sb.toString();
		}

		private void increaseCapacity() {
			int[] next = new int[arr.length << 1];
			int endLen = arr.length - off;
			System.arraycopy(arr, off, next, 0, endLen);
			System.arraycopy(arr, 0, next, endLen, off);
			arr = next;
			off = 0;
		}

		private int index(int i) {
			if (i >= arr.length) {
				i -= arr.length;
			} else if (i < 0) {
				i += arr.length;
			}
			return i;
		}

		private void printToBuffer(StringBuilder sb, CharSequence sep) {
			for (int i = 0; i < len; ++i) {
				if (i > 0) {
					sb.append(sep);
				}
				sb.append(get(i));
			}
		}

		public static IntDeque of(int... arr) {
			IntDeque deq = new IntDeque();
			for (int x : arr) {
				deq.add(x);
			}
			return deq;
		}
	}
    
    private static int[] toIntArray(List<Integer> lst) {
        final int N = lst.size();
        
        int[] A = new int[N];
        int idx = 0;
        for (int x : lst){
            A[idx++] = x;
        }
        return A;
    }
}",1448188661
megaspazz,megaspazz,55,3631,java,"class Solution {
    private static final int MOD = 1_000_000_007;
    
    private static final int[] R = new int[801];
    static {
        R[0] = 999_999;
        
        for (int i = 2; i < R.length; ++i) {
            R[i] = 1 + R[Integer.bitCount(i)];
        }
    }
    
    private static final long[][] C = computeCombinations(800, MOD);
    
    public int countKReducibleNumbers(String s, int k) {
        return (int) count(s, k, 0);
    }
    
    private static long count(String s, int k, int extraBits) {
        if (s.length() == 0) {
            return 0;
        }
        
        if (s.charAt(0) == '0') {
            return count(s.substring(1), k, extraBits);
        }
        
        long ans = 0;
        int bits = s.length() - 1;
        for (int b = 0; b <= bits; ++b) {
            if (1 + R[b + extraBits] <= k) {
                ans = add(ans, C[bits][b]);
            }
        }
        
        ans = add(ans, count(s.substring(1), k, extraBits + 1));
        
        return ans;
    }

	/**
	 * Computes all the combinations (i.e. Pascal's triangle) for the given levels, modulo some number.
	 * For example, combos[n][k] = (n choose k) % mod.
	 */
	public static long[][] computeCombinations(int n, int mod) {
		long[][] combos = new long[n + 1][n + 1];
		combos[0][0] = 1;
		for (int r = 1; r <= n; r++) {
			combos[r][0] = 1;
			for (int c = 1; c <= r; c++) {
				combos[r][c] = (combos[r - 1][c - 1] + combos[r - 1][c]) % mod;
			}
		}
		return combos;
	}
    
    private static final long RAW_MULTIPLY_MAX = 3037000499L;

    private static final int CHUNK_SIZE = Long.SIZE - Long.numberOfLeadingZeros(Long.MAX_VALUE / MOD) - 1;
    private static final long CHUNK_MASK = (1L << CHUNK_SIZE) - 1;

    @SuppressWarnings(""unused"")
    public static long multiply(long a, long b) {
        if (MOD <= RAW_MULTIPLY_MAX) {
            return a * b % MOD;
        }
        return multiplyInternal(a, b);
    }

    public static long multiply(long... arr) {
        long ans = 1;
        for (long x : arr) {
            ans = multiply(ans, x);
        }
        return ans;
    }

    public static long add(long a, long b) {
        long ans = a + b;
        if (ans >= MOD) {
            ans -= MOD;
        }
        return ans;
    }

    public static long add(long... arr) {
        long ans = 0;
        for (long x : arr) {
            ans = add(ans, x);
        }
        return ans;
    }

    public static long subtract(long a, long b) {
        return add(a, MOD - b);
    }

    private static long normalize(long x) {
        if (x <= -MOD || x >= MOD) {
            x %= MOD;
        }
        if (x < 0) {
            x += MOD;
        }
        return x;
    }

    /**
     * Computes the value of (b ^ e) % MOD.
     */
    public static long modPow(long b, long e) {
        long p = b;
        long ans = 1;
        while (e > 0) {
            if ((e & 1) == 1) {
                ans = multiply(ans, p);
            }
            p = multiply(p, p);
            e >>= 1;
        }
        return ans;
    }

    /**
     * Computes the modular inverse, such that: ak % MOD = 1, for some k.
     * See this page for details:  http://rosettacode.org/wiki/Modular_inverse
     */
    public static long modInverse(long a) {
        long b = MOD;
        long x0 = 0, x1 = 1;
        long t, q;

        while (a > 1) {
            q = a / b;

            t = b;
            b = a % b;
            a = t;

            t = x0;
            x0 = x1 - q * x0;
            x1 = t;
        }

        if (x1 < 0) {
            x1 += MOD;
        }
        return x1;
    }

    private static long multiplyInternal(long a, long b) {
        if (a > b) {
            return multiplyInternal(b, a);
        }
        if (a == 0) {
            return 0;
        }

        long ans = 0;
        while (a > 0) {
            long mask = a & CHUNK_MASK;
            if (mask > 0) {
                ans = add(ans, (mask * b) % MOD);
            }
            b = (b << CHUNK_SIZE) % MOD;
            a >>= CHUNK_SIZE;
        }
        return ans;
    }
}",1448234497
megaspazz,megaspazz,55,3646,java,"class Solution {
    private static final int MOD = 1_000_000_007;
    
    public int sumOfGoodSubsequences(int[] nums) {
        HashMap<Integer, Long> count = new HashMap<>();
        HashMap<Integer, Long> sum = new HashMap<>();
        long total = 0;
        for (int x : nums) {
            total = add(total, sum.getOrDefault(x - 1, 0L), multiply(count.getOrDefault(x - 1, 0L), x));
            total = add(total, sum.getOrDefault(x + 1, 0L), multiply(count.getOrDefault(x + 1, 0L), x));
            total = add(total, x);
            count.put(x, add(count.getOrDefault(x, 0L), 1, count.getOrDefault(x - 1, 0L), count.getOrDefault(x + 1, 0L)));
            sum.put(x, add(
                sum.getOrDefault(x, 0L),
                x,
                sum.getOrDefault(x - 1, 0L),
                multiply(count.getOrDefault(x - 1, 0L), x),
                sum.getOrDefault(x + 1, 0L),
                multiply(count.getOrDefault(x + 1, 0L), x)
            ));
            // System.out.format(""x = %d, total = %d, count = %s, sum = %s%n"", x, total, count, sum);
        }
        return (int) total;
    }
    
    private static final long RAW_MULTIPLY_MAX = 3037000499L;

    private static final int CHUNK_SIZE = Long.SIZE - Long.numberOfLeadingZeros(Long.MAX_VALUE / MOD) - 1;
    private static final long CHUNK_MASK = (1L << CHUNK_SIZE) - 1;

    @SuppressWarnings(""unused"")
    public static long multiply(long a, long b) {
        if (MOD <= RAW_MULTIPLY_MAX) {
            return a * b % MOD;
        }
        return multiplyInternal(a, b);
    }

    public static long multiply(long... arr) {
        long ans = 1;
        for (long x : arr) {
            ans = multiply(ans, x);
        }
        return ans;
    }

    public static long add(long a, long b) {
        long ans = a + b;
        if (ans >= MOD) {
            ans -= MOD;
        }
        return ans;
    }

    public static long add(long... arr) {
        long ans = 0;
        for (long x : arr) {
            ans = add(ans, x);
        }
        return ans;
    }

    public static long subtract(long a, long b) {
        return add(a, MOD - b);
    }

    private static long normalize(long x) {
        if (x <= -MOD || x >= MOD) {
            x %= MOD;
        }
        if (x < 0) {
            x += MOD;
        }
        return x;
    }

    /**
     * Computes the value of (b ^ e) % MOD.
     */
    public static long modPow(long b, long e) {
        long p = b;
        long ans = 1;
        while (e > 0) {
            if ((e & 1) == 1) {
                ans = multiply(ans, p);
            }
            p = multiply(p, p);
            e >>= 1;
        }
        return ans;
    }

    /**
     * Computes the modular inverse, such that: ak % MOD = 1, for some k.
     * See this page for details:  http://rosettacode.org/wiki/Modular_inverse
     */
    public static long modInverse(long a) {
        long b = MOD;
        long x0 = 0, x1 = 1;
        long t, q;

        while (a > 1) {
            q = a / b;

            t = b;
            b = a % b;
            a = t;

            t = x0;
            x0 = x1 - q * x0;
            x1 = t;
        }

        if (x1 < 0) {
            x1 += MOD;
        }
        return x1;
    }

    private static long multiplyInternal(long a, long b) {
        if (a > b) {
            return multiplyInternal(b, a);
        }
        if (a == 0) {
            return 0;
        }

        long ans = 0;
        while (a > 0) {
            long mask = a & CHUNK_MASK;
            if (mask > 0) {
                ans = add(ans, (mask * b) % MOD);
            }
            b = (b << CHUNK_SIZE) % MOD;
            a >>= CHUNK_SIZE;
        }
        return ans;
    }
}",1448208285
Arnab Mondal,arnab_97,56,3612,java,"class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        int n = nums.size();
        if (n < 2 * k) {
            return false;
        }
        if (k == 1) {
            return n >= 2;
        }
        int[] inc = new int[n];
        inc[n - 1] = 1; 
        for (int i = n - 2; i >= 0; i--) {
            if (nums.get(i) < nums.get(i + 1)) {
                inc[i] = inc[i + 1] + 1;
            } else {
                inc[i] = 1;
            }
        }
        for (int a = 0; a <= n - 2 * k; a++) {
            if (inc[a] >= k && inc[a + k] >= k) {
                return true;
            }
        }
        return false;
    }
}",1448187637
Arnab Mondal,arnab_97,56,3619,java,"class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        int n = nums.size();
        if (n < 2) {
            return 0;
        }
        int[] inc = new int[n];
        inc[n - 1] = 1; 
        
        for (int i = n - 2; i >= 0; i--) {
            if (nums.get(i) < nums.get(i + 1)) {
                inc[i] = inc[i + 1] + 1;
            } else {
                inc[i] = 1;
            }
        }
        int left = 1;
        int right = n / 2;
        int maxK = 0;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (existsTwoAdjacentSubarrays(inc, n, mid)) {
                maxK = mid;
                left = mid + 1; 
            } else {
                right = mid - 1; 
            }
        }
        
        return maxK;
    }
    private boolean existsTwoAdjacentSubarrays(int[] inc, int n, int k) {
        for (int a = 0; a <= n - 2 * k; a++) {
            if (inc[a] >= k && inc[a + k] >= k) {
                return true;
            }
        }
        return false;
    }
}",1448193047
Arnab Mondal,arnab_97,56,3631,java,"class Solution {
    public int countKReducibleNumbers(String s, int k) {
        final int MOD = 1_000_000_007;
        int len = s.length();
        long[][] C = new long[len + 1][len + 1];
        C[0][0] = 1;
        for(int i = 1; i <= len; i++) {
            C[i][0] = 1;
            for(int j = 1; j <= i; j++) {
                C[i][j] = (C[i-1][j] + C[i-1][j-1]) % MOD;
            }
        }
        int[] steps = new int[len + 1];
        for(int c = 1; c <= len; c++) {
            int current = c;
            int step = 0;
            while(current != 1) {
                current = Integer.bitCount(current);
                step++;
                if(step > k) {
                    break;
                }
            }
            if(current == 1) {
                steps[c] = step;
            }
            else {
                steps[c] = k + 1; // Indicates steps > k
            }
        }
        long[] counts = new long[len + 1];
        int set_bits_so_far = 0;
        for(int i = 0; i < len; i++) {
            if(s.charAt(i) == '1') {
                int remaining_bits = len - i - 1;
                for(int c = 0; c <= remaining_bits; c++) {
                    if(set_bits_so_far + c > len) continue;
                    counts[set_bits_so_far + c] = (counts[set_bits_so_far + c] + C[remaining_bits][c]) % MOD;
                }
                set_bits_so_far++;
            }
        }
        long total = 0;
        for(int c = 1; c <= len; c++) {
            if(steps[c] <= (k - 1)) {
                total = (total + counts[c]) % MOD;
            }
        }
        
        return (int) total;
    }
}
",1448235238
Arnab Mondal,arnab_97,56,3646,java,"class Solution {
    public int sumOfGoodSubsequences(int[] nums) {
        final int MOD = 1_000_000_007;
        int MAX = 100_002;
        long[] count = new long[MAX];
        long[] sum = new long[MAX];
        long totalSum = 0;
        
        for(int num : nums){
            long count_prev1 = 0;
            long sum_prev1 = 0;
            if(num > 0){
                count_prev1 = count[num -1];
                sum_prev1 = sum[num -1];
            }
            long count_prev2 = 0;
            long sum_prev2 = 0;
            if(num +1 < MAX){
                count_prev2 = count[num +1];
                sum_prev2 = sum[num +1];
            }
            long new_count = (1 + count_prev1 + count_prev2) % MOD;
            long new_sum = (num 
                            + (sum_prev1 + count_prev1 * (long)num) % MOD 
                            + (sum_prev2 + count_prev2 * (long)num) % MOD
                           ) % MOD;
            count[num] = (count[num] + new_count) % MOD;
            sum[num] = (sum[num] + new_sum) % MOD;
            
            totalSum = (totalSum + new_sum) % MOD;
        }
        return (int)totalSum;
    }
}",1448201360
veraci2,veraci2,58,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, A: List[int], K: int) -> bool:
        N = len(A)
        def incr(i, j):
            return all(A[k] < A[k+1] for k in range(i, j - 1))
        for i in range(N - 2 * K + 1):
            if incr(i, i + K) and incr(i + K, i + 2 * K):
                return True
        return False",1448185585
veraci2,veraci2,58,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, A: List[int]) -> int:
        B = [A[i] < A[i+1] for i in range(len(A) - 1)]
        pre = B[:]
        for i in range(1, len(B)):
            if pre[i] and pre[i-1]:
                pre[i] += pre[i-1]
        suf = B[:]
        for i in range(len(B) - 2, -1, -1):
            if suf[i] and suf[i+1]:
                suf[i] += suf[i+1]

        ans = 1
        for i in range(1, len(B) - 1):
            cand = min(pre[i-1], suf[i+1]) + 1
            if cand >ans:ans=cand
        return ans",1448189491
veraci2,veraci2,58,3631,python3,"@cache
def brute(N, K):
    if N == 1:
        return 1
    if K == 0:
        return 0
    return brute(bin(N).count('1'), K - 1)

MOD = 10 ** 9 + 7
class Solution:
    def countKReducibleNumbers(self,S,K) -> int:
        A = list(map(int, S))
        N = len(A)
        
        @cache
        def dp(i, tight, s):
            if i == N:
                return 1 if not tight and brute(s, K - 1) else 0

            high = A[i] if tight else 1
            ans = 0
            for d in range(0, high + 1):
                s2 = s + d
                tight2 = tight and d==A[i]
                ans += dp(i+1, tight2, s2)
                ans %= MOD
            return ans

        return dp(0, 1, 0)",1448213684
veraci2,veraci2,58,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, A: List[int]) -> int:
        count = defaultdict(lambda: [0, 0])
        MOD = 10**9 + 7
        ans = 0
        for x in A:
            s1, w1 = count[x-1]
            s2, w2 = count[x+1]
            s0, w0 = count[x]
            s = s0 + s1 + w1 * x + s2 + w2 * x + x
            s %= MOD
            w = w0 + w1 + w2 + 1
            w %= MOD
            count[x] = [s,w]

        for s,w in count.values():
            ans += s
            ans %=MOD
        return ans",1448227573
hxu10,hxu10,61,3612,python,"class Solution(object):
    def hasIncreasingSubarrays(self, nums, k):
        """"""
        :type nums: List[int]
        :type k: int
        :rtype: bool
        """"""
        n = len(nums)
        for i in range(n-2*k+1):
            if nums[i:i+k]==sorted(nums[i:i+k]) and nums[i+k:i+2*k]==sorted(nums[i+k:i+2*k]):
                if len(set(nums[i:i+k]))==k and len(set(nums[i+k:i+2*k]))==k:
                    return True
            
        return False
    ",1448182401
hxu10,hxu10,61,3619,python,"class Solution(object):
    def maxIncreasingSubarrays(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        n = len(nums)
        diff = [nums[i+1]-nums[i] for i in range(n-1)]
        accu = [0]*(n)
        
        for i in range(n-1):
            accu[i] = accu[i-1]
            if diff[i] > 0:  accu[i] += 1
                
        def search(target):
            for i in range(n-2*target-1):
                if accu[i+target-1] - accu[i-1] == target and accu[i+2*target] - accu[i+target] == target:
                    return True
            return False
        
        front = 1
        rear = n //2 + 1
        
        while front < rear:
            mid = front + (rear-front) // 2
            if search(mid):
                front = mid + 1
            else:
                rear = mid
                
        return front 
    
                
                ",1448190229
hxu10,hxu10,61,3631,python,"

MAX = 1001

dp = [0]*(MAX+1)

dp[0] = 100

for i in range(2,MAX+1):
    count = 0
    for c in bin(i)[2:]:
        count += int(c)
    dp[i] = dp[count] + 1
    
    


    
    


    

    

M = 10**9 + 7

    



class Solution(object):
    def countKReducibleNumbers(self, s, k):
        """"""
        :type s: str
        :type k: int
        :rtype: int
        """"""
        
        dic = {}
        n = len(s)
        
        #print(dp[:10])
        
        def getnext(index,flag,pre):
            if index==n:
                if dp[pre] < k:
                    return 1
                return 0
            
            if (index,flag,pre) in dic:
                return dic[(index,flag,pre)]
            
            

            
            res = 0
            if s[index]=='1':
                res += getnext(index+1, flag, pre+1)
                res += getnext(index+1, False, pre)

            else:
                if flag:
                    res = getnext(index+1, True, pre)
                else:
                    res = getnext(index+1, False, pre+1)
                    res += getnext(index+1, False, pre)
            res %= M
            
            dic[(index,flag,pre)] = res
            
            
           # print(index,flag,pre,res)
            return res
        
        
        ans = getnext(0,True,0) % M
        
        
        count = 0
        for c in s:
            count += int(c)
            
        if dp[count] < k:
            ans -= 1
            ans %= M
    
        
        
        return ans 
                    
                    
            
                    
                
                
            

                
            
                    
            
        

            
        
        
        
        ",1448236270
hxu10,hxu10,61,3646,python,"M = 10**9 + 7

class Solution(object):
    def sumOfGoodSubsequences(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        dic = {}
        
        ans = 0
        
        for num in nums:
            count = 1
            accu = 0
            if num - 1 in dic:
                count += dic[num-1][0]
                accu += dic[num-1][1]
            if num + 1 in dic:
                count += dic[num+1][0]
                accu += dic[num+1][1]
            
            accu = (accu + count * num)%M
            
            count %= M
            accu %= M
            if num not in dic: 
                dic[num] = [0,0]
                
            dic[num][0] = (dic[num][0] + count)%M
            dic[num][1] = (dic[num][1] + accu)%M
            
            ans += accu
            ans %= M
            
           # print(num,ans)
            
        return ans
    
            
        
            
                
        ",1448202698
CHANDRAPRABHU,Chandraprabhu,62,3612,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int ans = 0 ;
        int pre = 0,cur = 0;
        int  pre_val = INT_MIN;
        nums.push_back(INT_MIN);
        for(int i: nums){
            if(i>pre_val){
                cur++;
            }
            else{
                ans = max(ans,cur/2);
                ans = max(ans,min(pre,cur));
                pre = cur;
                cur = 1;
            }
            pre_val = i;
        }
        return ans;
    }
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        return maxIncreasingSubarrays(nums)>=k;
    }
};",1448187257
CHANDRAPRABHU,Chandraprabhu,62,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int ans = 0 ;
        int pre = 0,cur = 0;
        int  pre_val = INT_MIN;
        nums.push_back(INT_MIN);
        for(int i: nums){
            if(i>pre_val){
                cur++;
            }
            else{
                ans = max(ans,cur/2);
                ans = max(ans,min(pre,cur));
                pre = cur;
                cur = 1;
            }
            pre_val = i;
        }
        return ans;
    }
};",1448184770
CHANDRAPRABHU,Chandraprabhu,62,3631,cpp,"#define ll long long
const int UL5 = 1e5+10;

const int mod = 1e9+7;
class mint{
    public:
    int val;
    inline mint(){/*val=0;*/}
    inline mint(int _val){ if(_val<mod){ if(_val >=0) val = _val; else { val = _val%mod; if(val<0) val+=mod;} } else val = _val%mod; }
    inline mint(ll _val){ if(_val<mod){ if(_val >=0) val = _val; else { val = _val%mod; if(val<0) val+=mod;} } else val = _val%mod; }
    inline mint& operator+=(const mint& other){ if((val+=other.val) >= mod) val-=mod; return *this; }
    inline mint& operator-=(const mint& other){ if((val-=other.val) < 0) val+=mod; return *this; }
    inline mint& operator*=(const mint& other){ val = ((ll)val*other.val)%mod; return *this; }
    inline mint& operator/=(const mint& other){ (*this)*=inv(other); return *this; }
    inline mint& operator<<=(int exp){ll ans = (ll)val<<exp ; if(ans<mod)val = ans;else val = ans%mod; return *this;}
    inline mint& operator>>=(int exp){val>>=exp; return *this;}
    inline mint& operator%=(const mint& other){val%=other.val;return *this;}
    inline explicit operator bool() const{ return bool(val) ;}
    inline mint inv(mint base,int exp=mod-2) {
        mint res(1);
        while (exp) {
            if (exp&1) res*=base;
            exp >>= 1;
            base *= base;
        }
        return res;
    }
    inline mint& pow(int exp){ return (*this)=exp<0?0:inv(*this,exp); }
};
inline mint operator+(const mint& cur , const mint& other){ return mint(cur)+=other;}
inline mint operator-(const mint& cur , const mint& other){ return mint(cur)-=other;}
inline mint operator*(const mint& cur , const mint& other){ return mint(cur)*=other;}
inline mint operator/(const mint& cur , const mint& other){ return mint(cur)/=other;}
inline bool operator==(const mint& cur , const mint& other){ return cur.val==other.val;}
inline bool operator!=(const mint& cur , const mint& other){ return cur.val!=other.val;}
istream& operator >>(istream& in,mint& other){static ll val;in>>val;other = mint(val);return in; }
ostream& operator <<(ostream& out,const mint& other){ out<<other.val;return out; }

const int UL25 = 810;

mint fac[UL25]={1,1} ;
void fac_init(){
    for(int i = 2;i<UL25;i++) fac[i]=i*fac[i-1];
}
inline mint ncr(int n , int r){ if(r>n)return 0; return fac[n]/fac[r]/fac[n-r]; }


class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        fac_init();
        int n = s.size();
        int dp[UL25] = {};
        for(int i = 2;i<UL25;i++){
            dp[i] = dp[__builtin_popcount(i)]+1;
        }
        mint res = 0;
        int pre_co = 0;
        for(int i = 0 ;i<n;i++){
            if(s[i]=='1'){
                int dig = n-i-1;
                for(int ones = 0 ;ones<=dig;ones++){
                    int cur_ones = pre_co + ones;
                    if(dp[cur_ones]+1<=k){
                        res+=ncr(dig,ones);
                    }
                }
                pre_co+=1;
            }
        }
        res-=1;
        return res.val;
    }
};

",1448228180
CHANDRAPRABHU,Chandraprabhu,62,3646,cpp,"#define ll long long
const int UL5 = 1e5+10;
const int mod = 1e9+7;
class mint{
    public:
    int val;
    inline mint(){/*val=0;*/}
    inline mint(int _val){ if(_val<mod){ if(_val >=0) val = _val; else { val = _val%mod; if(val<0) val+=mod;} } else val = _val%mod; }
    inline mint(ll _val){ if(_val<mod){ if(_val >=0) val = _val; else { val = _val%mod; if(val<0) val+=mod;} } else val = _val%mod; }
    inline mint& operator+=(const mint& other){ if((val+=other.val) >= mod) val-=mod; return *this; }
    inline mint& operator-=(const mint& other){ if((val-=other.val) < 0) val+=mod; return *this; }
    inline mint& operator*=(const mint& other){ val = ((ll)val*other.val)%mod; return *this; }
    inline mint& operator/=(const mint& other){ (*this)*=inv(other); return *this; }
    inline mint& operator<<=(int exp){ll ans = (ll)val<<exp ; if(ans<mod)val = ans;else val = ans%mod; return *this;}
    inline mint& operator>>=(int exp){val>>=exp; return *this;}
    inline mint& operator%=(const mint& other){val%=other.val;return *this;}
    inline explicit operator bool() const{ return bool(val) ;}
    inline mint inv(mint base,int exp=mod-2) {
        mint res(1);
        while (exp) {
            if (exp&1) res*=base;
            exp >>= 1;
            base *= base;
        }
        return res;
    }
    inline mint& pow(int exp){ return (*this)=exp<0?0:inv(*this,exp); }
};
inline mint operator+(const mint& cur , const mint& other){ return mint(cur)+=other;}
inline mint operator-(const mint& cur , const mint& other){ return mint(cur)-=other;}
inline mint operator*(const mint& cur , const mint& other){ return mint(cur)*=other;}
inline mint operator/(const mint& cur , const mint& other){ return mint(cur)/=other;}
inline bool operator==(const mint& cur , const mint& other){ return cur.val==other.val;}
inline bool operator!=(const mint& cur , const mint& other){ return cur.val!=other.val;}
istream& operator >>(istream& in,mint& other){static ll val;in>>val;other = mint(val);return in; }
ostream& operator <<(ostream& out,const mint& other){ out<<other.val;return out; }

//mint fac[UL25]={1,1} ;
//void fac_init(){
//    FOR(i,2,UL25)fac[i]=i*fac[i-1];
//}
//inline mint ncr(int n , int r){ if(r>n)return 0; return fac[n]/fac[r]/fac[n-r]; }
//fac_init();

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int n= nums.size();
        // sum,co
        mint dp[UL5][2];
        memset(dp,0,sizeof(dp));
        for(int i: nums){
            if(i){
                dp[i][1]+=dp[i-1][1];
                dp[i][0]+=dp[i-1][0] + i*dp[i-1][1];
            }
            dp[i][1]+=dp[i+1][1];
            dp[i][0]+=dp[i+1][0] + i*dp[i+1][1];
            
            dp[i][0]+=i;
            dp[i][1]+=1;
        }
        mint res = 0;
        for(int i = 0 ;i<UL5;i++){
            res+=dp[i][0];
        }
        return res.val;
    }
};

",1448201589
Said Abdulaev,said_v15,63,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& v, int k) {
        int n = v.size();

        vector<int> st;
        int cnt = 1;

        for (int i = 1; i < n; i++) {
            if (v[i] > v[i - 1]) {
                cnt++;
                continue;
            }
            st.push_back(cnt);
            cnt = 1;
        }
        st.push_back(cnt);

        int ans = 0, sz = st.size();
        for (int i = 0; i < sz; i++) {
            ans = max(ans, st[i] / 2);
            if (i != sz - 1) ans = max(ans, min(st[i], st[i + 1]));
        }

        return (ans >= k);
    }
};",1448204564
Said Abdulaev,said_v15,63,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& v) {
        int n = v.size();

        vector<int> st;
        int cnt = 1;

        for (int i = 1; i < n; i++) {
            if (v[i] > v[i - 1]) {
                cnt++;
                continue;
            }
            st.push_back(cnt);
            cnt = 1;
        }
        st.push_back(cnt);

        int ans = 0, sz = st.size();
        for (int i = 0; i < sz; i++) {
            ans = max(ans, st[i] / 2);
            if (i != sz - 1) ans = max(ans, min(st[i], st[i + 1]));
        }

        return ans;
    }
};",1448202355
Said Abdulaev,said_v15,63,3631,cpp,"class Solution {
public:
    const int MAXSZ = 1000;
    const int mod = int(1e9) + 7;

    int fact[1010];
    int inv_fact[1010];

    int mul(int a, int b) {
        return (long long) a * b % mod;
    }
    
    int add(int a, int b) {
        long long res = (long long) a + b;
        if (res < 0)
            res += mod;
        else if (res > mod)
            res -= mod;
        return (int) res % mod;
    }
    int bpow(int x, int p) {
        int res = 1;
        while (p) {
            if (p & 1)
                res = mul(res, x);
    
            p >>= 1;
    
            if (p)
                x = mul(x, x);
        }
        return res;
    }
    
    int inv(int x) {
    	return bpow(x, mod - 2);
    }
    
    void calc_fact() {
    	fact[0] = inv_fact[0] = 1;
    	for (int i = 1; i <= MAXSZ; i++) {
    		fact[i] = mul(fact[i - 1], i);
    		inv_fact[i] = inv(fact[i]);
    	}
    }
    
    int cnk(int n, int k) {
    	if (k > n)
    		return 0;
    	return mul(fact[n], mul(inv_fact[k], inv_fact[n - k]));
    }

    int countKReducibleNumbers(string s, int k) {
        calc_fact();
        
        vector<int> st(MAXSZ + 1);
        int n = s.size();

        for (int i = 1; i <= MAXSZ; i++) {
            int cnt = 0, num = i;
            while (num > 1) {
                cnt++;
                num = __builtin_popcount(num);
            }
            if (num == 1) st[i] = cnt;
        }

        // now we need to compute how many numbers are less then s
        // and can be reduced to st[x] such that st[x] + 1 <= k

        s = ""#"" + s; // for balance
        int ans = 0, ones = 0;

        for (int i = 1; i <= n; i++) {
            if (s[i] == '0') continue;
            // try to put lower digit in i-th place
            for (int j = 0; j <= n - i; j++) {
                // how many ones we can place
                if (st[ones + j] + 1 <= k) ans = add(ans, cnk(n - i, j));
            }
            ones++;
        }

        return ans - 1;
        
    }
};",1448236940
Said Abdulaev,said_v15,63,3646,cpp,"class Solution {
public:
    const int mod = int(1e9) + 7;

    int mul(int a, int b) {
        return (long long) a * b % mod;
    }
    
    int add(int a, int b) {
        long long res = (long long) a + b;
        if (res < 0)
            res += mod;
        else if (res > mod)
            res -= mod;
        return (int) res % mod;
    }
    int sumOfGoodSubsequences(vector<int>& v) {
        int n = v.size();
        int sz = 0;
        for (auto &x: v) sz = max(sz, x);

        vector<int> dp(sz + 10), ndp(sz + 10);
        for (int i = 0; i < n; i++) {
            int x = v[i];

            dp[x] = add(dp[x], 1);
            ndp[x] = add(ndp[x], x);
            
            dp[x] = add(dp[x], dp[x + 1]);
            int to = add(ndp[x + 1], mul(dp[x + 1], x));
            ndp[x] = add(ndp[x], to);
            if (x) {
                to = add(ndp[x - 1], mul(dp[x - 1], x));
                dp[x] = add(dp[x], dp[x - 1]);
                ndp[x] = add(ndp[x], to);
            }
        }

        int ans = 0, ways = 0;
        for (int i = 0; i <= sz + 1; i++) {
            ans = add(ans, ndp[i]);
            ways = add(ways, dp[i]);
        }

        // cout << ans << "" "" << ways << ""\n"";
        return ans;
    }
};",1448191942
green_pig,green_pig,64,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        s = [int(a < b) for a, b in zip(nums, nums[1:])] + [1]
        t = list(accumulate(s[::-1], lambda a, b: a * b + 1))[::-1] + [0]
        m = 0
        for i in range(len(s)-k+1):
            if t[i] >= k and t[i+k] >= k:
                return True
        return False",1448190623
green_pig,green_pig,64,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        s = [int(a < b) for a, b in zip(nums, nums[1:])] + [1]
        t = list(accumulate(s[::-1], lambda a, b: a * b + 1))[::-1] + [0]
        m = 0
        for i in range(len(s)):
            m = max(m, t[i] // 2, min(t[i], t[i+t[i]]))
        return m
",1448187652
green_pig,green_pig,64,3631,python3,"P = 1000000007
F = [1] * 900
for i in range(1, len(F)):
    F[i] = F[i-1]*i%P
I = [pow(x, -1, P) for x in F]
C = lambda n, k: F[n] * I[k] * I[n-k] % P if 0 <= k <= n else 0
class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        n = len(s)
        c = [0] * (n+1)
        t = 0
        for i in range(n):
            if s[i] == '1':
                for j in range(n+1-t):
                    c[t+j] += C(n-i-1, j)
                t += 1
        d = [0] * (n+1)
        for i in range(2, n+1):
            d[i] = d[i.bit_count()] + 1
        return sum(c[i] for i in range(1, n+1) if d[i] < k) % P
",1448213261
green_pig,green_pig,64,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        M = 10**9+7
        s = defaultdict(int)
        w = defaultdict(int)
        for n in nums:
            s[n] = (s[n] + (1 + w[n-1] + w[n+1]) * n + s[n-1] + s[n+1]) % M
            w[n] = (w[n] + 1 + w[n-1] + w[n+1]) % M
        return sum(s.values()) % M",1448196810
Shayan_Jahan,Shayan_Jahan,66,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        
        for (int i = 0; i < n - 2 * k + 1; i++) {
            bool flag = true;
            for (int j = i; j < i + k - 1; j++) flag &= (nums[j] < nums[j + 1]);
            for (int j = i + k; j < i + 2 * k - 1; j++) flag &= (nums[j] < nums[j + 1]);

            if (flag) return true;
        }

        return false;
    }
};",1448182505
Shayan_Jahan,Shayan_Jahan,66,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector <int> vec;

        int cnt = 0;
        for (int i = 0; i < n; i++) {
            cnt++;
            if (i == n - 1 || nums[i] >= nums[i + 1]) {
                vec.push_back(cnt);
                cnt = 0;
            }
        }

        int ans = 0;
        for (int i = 0; i < (int)vec.size() - 1; i++)
            ans = max(ans, min(vec[i], vec[i + 1]));

        for (int i = 0; i < vec.size(); i++) 
            ans = max(ans, vec[i] / 2);

        return ans;
    }
};",1448188840
Shayan_Jahan,Shayan_Jahan,66,3631,cpp,"class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        const int N = 800 + 10, mod = 1e9 + 7;

        vector <vector<int>> C;

        for (int i = 0; i < N; i++) {
            vector <int> vec(N);
            C.push_back(vec);

            C[i][0] = C[i][i] = 1;

            for (int j = 1; j < i; j++) {
                C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;
            }
        }
        
        vector <int> dp(N);

        for (int i = 2; i < N; i++) {
            dp[i] = dp[__builtin_popcount(i)] + 1;
        }

        int ans = 0;
        
        int n = s.size(), c0 = 0, c1 = 0;
        for (int i = 0; i < n; i++) {
            if (s[i] == '0') {
                c0++;
                continue;
            }

            c0++;

            for (int j = 0; j < n - i; j++) {
                if (dp[c1 + j] < k) {
                    ans = (ans + C[n - i - 1][j]) % mod;
                }
            }
            
            c0--;
            c1++;
        }

        return (ans + mod - 1) % mod;
    }
};",1448222046
Shayan_Jahan,Shayan_Jahan,66,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        const int N = 1e5 + 20, mod = 1e9 + 7;
        int n = nums.size();
        
        vector <int> cnt(N), sum(N);

        int ans = 0;
        
        for (int i = 0; i < n; i++) {
            int val = 0;
            val = (val + sum[nums[i] + 1]) % mod;
            val = (val + 1ll * nums[i] * cnt[nums[i] + 1]) % mod;
            
            (cnt[nums[i]] += cnt[nums[i] + 1]) %= mod;
            (sum[nums[i]] += val) %= mod;
            (ans += val) %= mod;
            
            if (nums[i] > 0) {
                val = 0;
                val = (val + sum[nums[i] - 1]) % mod;
                val = (val + 1ll * nums[i] * cnt[nums[i] - 1]) % mod;
                
                (cnt[nums[i]] += cnt[nums[i] - 1]) %= mod;
                (sum[nums[i]] += val) %= mod;
                (ans += val) %= mod;                
            }

            (cnt[nums[i]] += 1) %= mod;
            (sum[nums[i]] += nums[i]) %= mod;
            (ans += nums[i]) %= mod;
        }

        return ans;
    }
};",1448204199
Balakrishnan Varadarajan,balakrishnan_v,67,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n=nums.size();
        vector<int> fwd(n);
        for(int i=0;i<n;i++) {
            fwd[i]=1;
            if (i && nums[i]>nums[i-1]) fwd[i]=fwd[i-1]+1;
        }
        vector<int> bck(n);
        for(int i=n-1;i>=0;i--) {
            bck[i]=1;
            if (i+1<n && nums[i]<nums[i+1]) bck[i]=bck[i+1]+1;
        }
        for(int i=1;i<n;i++) {
            int curr = min(fwd[i-1],bck[i]);
            if (curr >= k) return true;
        }
        return false;
    }
    

    
};",1448230208
Balakrishnan Varadarajan,balakrishnan_v,67,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n=nums.size();
        vector<int> fwd(n);
        for(int i=0;i<n;i++) {
            fwd[i]=1;
            if (i && nums[i]>nums[i-1]) fwd[i]=fwd[i-1]+1;
        }
        vector<int> bck(n);
        for(int i=n-1;i>=0;i--) {
            bck[i]=1;
            if (i+1<n && nums[i]<nums[i+1]) bck[i]=bck[i+1]+1;
        }
        int ans=0;
        for(int i=1;i<n;i++) {
            ans=max(ans,min(fwd[i-1],bck[i]));
        }
        return ans;
        
    }
};",1448228340
Balakrishnan Varadarajan,balakrishnan_v,67,3631,cpp,"#define MODD 1000000007
#define MAXN 800
class Solution {
public:
    
    bool Check(int x, int k) {
        if (x==1) return true;
        for(int j=1;j<=k-1;j++) {
            x = __builtin_popcount(x);
            if (x==1) return true;
        }
        return false;
    }
    
    bool is_valid[MAXN+2];
    
    int dp[MAXN+1][MAXN+1][2];
    
    int Solve(const string& s, int pos, int num_ones, bool is_less,  int k) {
        int n=s.size();
        if (pos == n) {
            return is_less && is_valid[num_ones];
        }
        
        int curr = s[pos]-'0';
        if (dp[pos][num_ones][is_less]!=-1) return dp[pos][num_ones][is_less];
        
        int ans=0;
        for(int c : {0,1}) {
            if (!is_less & c > curr) continue;
            ans += Solve(s, pos+1,  num_ones + c, is_less || (c < curr), k);
            if (ans >= MODD) ans -= MODD;
        }
        return dp[pos][num_ones][is_less]=ans;
        
    }
    
    int countKReducibleNumbers(string s, int k) {
        int n=s.size();
        
        for(int o=0;o<=n;o++) {
            is_valid[o]=Check(o,k);
        }
        for(int i=0;i<=n;i++) for(int j=0;j<=n;j++) for(int l : {0,1}) dp[i][j][l]=-1;
        return Solve(s, 0, 0, false, k);
        
    }
};",1448200349
Balakrishnan Varadarajan,balakrishnan_v,67,3646,cpp,"#define ll long long
#define MODD 1000000007
class Solution {
public:
    
    
    int sumOfGoodSubsequences(vector<int>& nums) {
        int maxx = *max_element(nums.begin(),nums.end());
        int n=nums.size();
        vector<pair<ll,ll>> dp(n);
        vector<pair<ll,ll>> summ(maxx+1,{0ll,0ll});
        ll ans = 0;
        for(int i=n-1;i>=0;i--) {
            int x = nums[i];
            // ways, summ
            dp[i]={1, x};
            for(int y : {x-1,x+1}) {
                if (y >= 0 && y <= maxx) {
                    dp[i].first += summ[y].first;
                    dp[i].second += summ[y].second + (ll)summ[y].first * (ll)x%MODD;
                    dp[i].first %= MODD;
                    dp[i].second %= MODD;
                }
            }
            summ[x].first += dp[i].first;
            summ[x].second += dp[i].second;
            summ[x].first %= MODD;
            summ[x].second %= MODD;
            ans += dp[i].second;
            ans %= MODD;
        }
        return ans;
    }
};",1448217004
peace,shankardtu21,70,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& n, int k) {
        if (n.size() < 2 * k) return false;

        for (int i = 0; i <= n.size() - 2 * k; ++i) {
            if (helper(n, i, k) && helper(n, i + k, k)) {
                return true;
            }
        }
        return false;
    }

private:
    bool helper(const vector<int>& n, int s, int k) {
        for (int i = s + 1; i < s + k; ++i) {
            if (n[i - 1] >= n[i]) {
                return false;
            }
        }
        return true;
    }
};
",1448182908
peace,shankardtu21,70,3619,cpp,"#include <vector>
using namespace std;

class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& n) {
        int sz = n.size();
        vector<int> inc(sz, 1);
        for (int i = sz - 2; i >= 0; --i) {
            if (n[i] < n[i + 1]) {
                inc[i] = inc[i + 1] + 1;
            } else {
                inc[i] = 1;
            }
        }
        
        int l = 1, h = sz / 2, ans = 0;
        while (l <= h) {
            int m = l + (h - l) / 2;
            if (helper(n, inc, m)) {
                ans = m;
                l = m + 1;
            } else {
                h = m - 1;
            }
        }
        return ans;
    }
    
private:
    bool helper(const vector<int>& n, const vector<int>& inc, int k) {
        int sz = n.size();
        for (int s = 0; s <= sz - 2 * k; ++s) {
            if (inc[s] >= k && inc[s + k] >= k) {
                return true;
            }
        }
        return false;
    }
};
",1448207152
peace,shankardtu21,70,3631,cpp,"typedef long long ll;
const int M = 1'000'000'007;
class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        int len = s.length();
        
        vector<int> f(801, 0);
        f[1] = 0;
        for (int v = 2; v <= 800; v++) {
            int pc = __builtin_popcount(v);
            f[v] = 1 + f[pc];
        }
        
        vector<int> allowed;
        for (int v = 1; v <= 800; v++) {
            if (f[v] <= k - 1) {
                allowed.push_back(v);
            }
        }
        
        vector<vector<int>> C(801, vector<int>(801, 0));
        C[0][0] = 1;
        for (int i = 1; i <= 800; i++) {
            C[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % M;
            }
        }

        auto count_lt = [&](int ts) -> int {
            if (ts < 0) return 0;
            int cnt = 0, rem = ts;
            for (int i = 0; i < len; i++) {
                if (s[i] == '1') {
                    int br = len - 1 - i;
                    if (br >= rem) {
                        cnt = (cnt + (ll)C[br][rem]) % M;
                    }
                    rem--;
                    if (rem < 0) break;
                }
            }
            return cnt;
        };

        ll total = 0;
        for (auto v : allowed) {
            total = (total + (ll)count_lt(v)) % M;
        }

        if (s == ""1"") return 0;
        return (int)total;
    }
};
",1448223687
peace,shankardtu21,70,3646,cpp,"#include <vector>
using namespace std;

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& n) {
        const int M = 1'000'000'007;

        int m = 0;
        for (auto x : n) {
            if (x > m) m = x;
        }

        vector<long long> c(m + 2, 0), s(m + 2, 0);
        long long t = 0;

        for (auto x : n) {
            long long nc = 0;
            if (x > 0) {
                nc += c[x - 1];
            }
            if (x + 1 <= m + 1) {
                nc += c[x + 1];
            }
            nc += 1;

            long long ns = 0;
            if (x > 0) {
                ns += s[x - 1];
            }
            if (x + 1 <= m + 1) {
                ns += s[x + 1];
            }

            long long add = 0;
            if (x > 0) {
                add += c[x - 1];
            }
            if (x + 1 <= m + 1) {
                add += c[x + 1];
            }
            add += 1;

            ns += add * (long long)x;
            ns %= M;

            t = (t + ns) % M;

            c[x] = (c[x] + nc) % M;
            s[x] = (s[x] + ns) % M;
        }

        return (int)t;
    }
};
",1448201235
Chinnu,chinnu11,73,3612,cpp,"class Solution{
public:
    bool f(const vector<int>&v,int s,int k){
        for(int i=s;i<s+k-1;++i)if(v[i]>=v[i+1])return 0;
        return 1;
    }
    bool hasIncreasingSubarrays(vector<int>&v,int k){
        int n=v.size();
        for(int i=0;i<=n-2*k;++i)if(f(v,i,k)&&f(v,i+k,k))return 1;
        return 0;
    }
};
",1448197943
Chinnu,chinnu11,73,3619,cpp,"class Solution{
public:
    int maxIncreasingSubarrays(vector<int>&v){
        int n=v.size();
        vector<int>inc(n,1);
        for(int i=n-2;i>=0;--i)if(v[i]<v[i+1])inc[i]=inc[i+1]+1;
        int l=1,r=n/2,ans=1;
        while(l<=r){
            int m=l+(r-l)/2,f=0;
            for(int i=0;i<=n-2*m;++i){
                if(inc[i]>=m&&inc[i+m]>=m){f=1;break;}
            }
            if(f)ans=m,l=m+1;
            else r=m-1;
        }
        return ans;
    }
};
",1448202246
Chinnu,chinnu11,73,3631,cpp,"class Solution{
public:
    const long long M=1'000'000'007;
    vector<int>f;
    vector<bool>v;
    
    int cs(int x){
        int c=0;
        while(x){c+=x&1;x>>=1;}
        return c;
    }

    void pf(int sm){
        f=vector<int>(sm+1,-1);
        f[1]=0;
        for(int i=2;i<=sm;i++){
            int c=cs(i);
            f[i]=1+f[c];
        }
    }

    void pv(int sm,int k){
        v=vector<bool>(sm+1,0);
        for(int i=1;i<=sm;i++)if(f[i]<=(k-1))v[i]=1;
    }

    long long dp(int p,int c,bool t,int l,const vector<int>&b,vector<vector<vector<long long>>>&m){
        if(p==l)return c>=1&&v[c];
        if(m[p][c][t]!=-1)return m[p][c][t];
        int lim=t?b[p]:1;
        long long r=0;
        for(int d=0;d<=lim;d++){
            bool nt=t&&(d==b[p]);
            r=(r+dp(p+1,c+d,nt,l,b,m))%M;
        }
        return m[p][c][t]=r;
    }

    int countKReducibleNumbers(string s,int k){
        int sm=800;
        pf(sm);
        pv(sm,k);
        int l=s.size();
        vector<int>b(l);
        for(int i=0;i<l;i++)b[i]=s[i]-'0';
        vector<vector<vector<long long>>>m(l+1,vector<vector<long long>>(l+1,vector<long long>(2,-1)));
        long long r=dp(0,0,1,l,b,m);
        int sc=0;
        for(int i=0;i<l;i++)if(b[i]==1)sc++;
        if(v[sc])r=(r-1+M)%M;
        return r%M;
    }
};",1448241159
Chinnu,chinnu11,73,3646,cpp,"class Solution{
public:
    int sumOfGoodSubsequences(vector<int>&v){
        const int M=1'000'000'007,N=100001;
        vector<long long>c(N+2,0),s(N+2,0);
        long long t=0;
        for(auto &x:v){
            long long nc=1,ns=x;
            if(x>=1){
                nc=(nc+c[x-1])%M;
                ns=(ns+s[x-1]+x*c[x-1]%M)%M;
            }
            if(x+1<=N){
                nc=(nc+c[x+1])%M;
                ns=(ns+s[x+1]+x*c[x+1]%M)%M;
            }
            c[x]=(c[x]+nc)%M;
            s[x]=(s[x]+ns)%M;
            t=(t+ns)%M;
        }
        return t;
    }
};
",1448208381
lukewu28,lukewu28,75,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        stack<int> s;
        int last = -1;
        int n = nums.size();
        vector<int> g(n, 0);
        for(int i = 0; i < n; i++){
            if(nums[i] > last) last = nums[i];
            else{
                while(!s.empty()){
                    g[s.top()] = i - s.top();
                    s.pop();
                }
                last = nums[i];
            }
            s.push(i);
        }
        
        while(!s.empty()){
            g[s.top()] = n - s.top();
            s.pop();
        }
        
        for(int i = 0; i < n - k; i++){
            if(g[i] >= k && g[i + k] >= k) return true;
        }
        return false;
    }
};",1448188354
lukewu28,lukewu28,75,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        stack<int> s;
        int last = -1;
        int n = nums.size();
        vector<int> g(n, 0);
        for(int i = 0; i < n; i++){
            if(nums[i] > last) last = nums[i];
            else{
                while(!s.empty()){
                    g[s.top()] = i - s.top();
                    s.pop();
                }
                last = nums[i];
            }
            s.push(i);
        }
        
        while(!s.empty()){
            g[s.top()] = n - s.top();
            s.pop();
        }
        
        int l = 1, r = n;
        while(l < r){
            int m = (r + l + 1) / 2;
            
            bool ok = 0;
            for(int i = 0; i < n - m; i++){
                if(g[i] >= m && g[i + m] >= m) ok = 1;
            }
            
            if(ok) l = m;
            else r = m - 1;
        }
        
        return l;
    }
};",1448186930
lukewu28,lukewu28,75,3631,cpp,"typedef long long ll;
class Solution {
public:
    const ll MOD = 1000000007;
    const int MAXN = 1000;
    ll fac[1000 + 1], invfac[1000 + 1];
    ll inv(ll x){return x>1?inv(MOD%x)*(MOD-MOD/x)%MOD:x;}
    void factorial() {
        fac[0] = 1;
        for (ll i = 1; i <= MAXN; i++) {
            fac[i] = fac[i - 1] * i % MOD;
        }
    }
    void inverses() {
        invfac[MAXN] = inv(fac[MAXN]);
        for (ll i = MAXN; i >= 1; i--) {
            invfac[i - 1] = invfac[i] * i % MOD;
        }
    }
    ll C(ll g, ll r) {
        return fac[g] * invfac[r] % MOD * invfac[g - r] % MOD;
    }
    int countKReducibleNumbers(string s, int k) {
        factorial();
        inverses();
        bool red[1000][5] = {};
        for(int i = 0 ; i <5; i++) red[1][i] = 1;
        
        for(int i = 2; i < 1000; i++){
            int x = __builtin_popcount(i);
            for(int j = 1; j < 5; j++) red[i][j] = red[x][j - 1];
        }
        
        int n = s.size();
        vector<int> reds;
        for(int i = 1; i < n; i++){
            if(red[i][k - 1]) reds.push_back(i);
        }
        
        ll re = 0;
        int ones = 0;
        for(int i = 0; i < n; i++){
            if(s[i] == '0') continue;
            int cnt = n - i - 1;
            for(int j : reds){
                if(j - ones < 0) continue;
                if(j - ones > cnt) break;
                
                re = (re + C(cnt, j - ones)) % MOD;
            }
            ones++;
        }
        return re;
    }
};",1448234475
lukewu28,lukewu28,75,3646,cpp,"typedef long long ll;
class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        ll n = nums.size();
        ll mx = *max_element(nums.begin(), nums.end());
        vector<ll> dp(mx + 1, 0), cnt(mx + 1, 0);
        const ll mod = 1000000007;
        long long re = 0;
        for(int i = 0; i < n; i++){
            ll x = nums[i];
            if(x != 0) {
                ll tot = cnt[x - 1] * x % mod;
                ll add = (tot + dp[x - 1]) % mod;
                dp[x] = (dp[x] + add) % mod;
                cnt[x] = (cnt[x] + cnt[x - 1]) % mod;
            }
            if(x != mx) {
                ll tot = cnt[x + 1] * x % mod;
                ll add = (tot + dp[x + 1]) % mod;
                dp[x] = (dp[x] + add) % mod;
                cnt[x] = (cnt[x] + cnt[x + 1]) % mod;
            }
            dp[x] += x;
            cnt[x]++;
            
            dp[x] %= mod;
            cnt[x] %= mod;
            
//             for(int j : dp) cout << j << ' ';
//             cout << endl;
            
        }

        
        for(int i = 0; i <= mx; i++){
            re = (re + dp[i]) % mod;
        }
        return re;
    }
};",1448213168
Larry,LarryNY,77,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        N = len(nums)
        
        def good(index):
            streak = 1
            for offset in range(1, k):
                if index + offset < N and nums[index + offset] > nums[index + offset - 1]:
                    streak += 1
                else:
                    return False
            return True
            
        for i in range(N):
            if good(i) and good(i + k):
                return True
        return False
",1448183027
Larry,LarryNY,77,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        N = len(nums)
        
        best = [1] * N
        for i in range(1, N):
            if nums[i] > nums[i - 1]:
                best[i] = best[i - 1] + 1
            else:
                best[i] = 1
                
        mx = 1
        for i in range(1, N):
            start = i - best[i]
            
            if start >= 0:
                mx = max(mx, min(best[start], best[i]))
            mx = max(mx, best[i] // 2)
        
        return mx",1448190831
Larry,LarryNY,77,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        MOD = 10 ** 9 + 7
        s = str(int(s) - 1)
        N = len(s)
        
        lookup = [None] * (N + 2)
        for i in range(1, N + 1):
            lookup[i] = i.bit_count()
            
        steps = [None] * (N + 2)
        steps[1] = 0
        for i in range(2, N + 1):
            steps[i] = steps[i.bit_count()] + 1
        
        # how many with left bits
        @cache
        def go(index, prefix, left):
            if index == N:
                if left == 0:
                    return 1
                return 0
            if left < 0:
                return 0
            
            total = 0
            if prefix:
                if s[index] == ""0"":
                    total += go(index + 1, prefix, left)
                else:
                    total += go(index + 1, False, left)
                    if left - 1 >= 0:
                        total += go(index + 1, prefix, left - 1)
            else:
                total += go(index + 1, False, left)
                if left - 1 >= 0:
                    total += go(index + 1, False, left - 1)
            return total % MOD

        #print(""--"")
        total = 0
        for i in range(1, N + 1):
            if steps[i] < k:
                f = go(0, True, i)
                total = (total + f) % MOD
                #print(i, steps[i], f)
        go.cache_clear()
        
        return total % MOD",1448242374
Larry,LarryNY,77,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        MOD = 10 ** 9 + 7
        
        f = collections.Counter()
        t = collections.Counter()

        total = 0
        for x in nums:
            p = (1 + f[x - 1] + f[x + 1]) % MOD
            f[x] = (1 + f[x] + f[x - 1] + f[x + 1]) % MOD
            t[x] = (p * x + t[x] + t[x - 1] + t[x + 1]) % MOD

        total = 0
        for k, v in t.items():
            total += v
            total %= MOD
        return total % MOD",1448216156
Xianjie Deng,Dengxj,79,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        A = [0] * (n + 1)
        for i in reversed(range(n)):
            if i + 1 < n and nums[i] < nums[i + 1]:
                A[i] = A[i + 1] + 1
            else:
                A[i] = 1
        for i in range(n):
            if i + k < n and A[i] >= k and A[i + k] >= k:
                return True
        return False",1448182976
Xianjie Deng,Dengxj,79,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        A = [0] * (n + 1)
        for i in reversed(range(n)):
            if i + 1 < n and nums[i] < nums[i + 1]:
                A[i] = A[i + 1] + 1
            else:
                A[i] = 1

        def check(k):
            for i in range(n):
                if i + k < n and A[i] >= k and A[i + k] >= k:
                    return True
            return False

        lf, rt = 0, n
        while lf < rt:
            mid = rt - (rt - lf) // 2
            if check(mid):
                lf = mid
            else:
                rt = mid - 1
        return lf",1448185936
Xianjie Deng,Dengxj,79,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        n = len(s)
        M = 10 ** 9 + 7

        def calc(val):
            if val <= 0:
                return -1
            cnt = 0
            while val != 1:
                val = val.bit_count()
                cnt += 1
            return cnt

        @functools.lru_cache(None)
        def rec(pos, tight, ones):
            if pos == n:
                return 1 if not tight and ones > 0 and calc(ones) < k else 0
            d = int(s[pos])
            ret = rec(pos + 1, tight and d == 0, ones)
            if not tight or d == 1:
                ret = (ret + rec(pos + 1, tight and d == 1, ones + 1)) % M
            return ret

        return rec(0, True, 0)
",1448242659
Xianjie Deng,Dengxj,79,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        A = dict()
        M = 10**9+7
        for x in nums:
            a, b = 1, 0
            if x - 1 in A:
                a = (a + A[x - 1][0]) % M
                b = (b + A[x - 1][1]) % M
            if x + 1 in A:
                a = (a + A[x + 1][0]) % M
                b = (b + A[x + 1][1]) % M
            if x not in A:
                A[x] = [0, 0]
            A[x][0] = (A[x][0] + a) % M
            A[x][1] = (A[x][1] + a * x + b) % M
        res = 0
        for _, a in A.values():
            res = (res + a) % M
        return res
",1448215257
Sanath_Kulla,Sanath_Kulla,80,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        vector<int> h;
        int c = 1;
        for(int i = 1 ; i < nums.size() ; i++){
            if(nums[i] <= nums[i-1]){
                h.push_back(c);
                c = 1;
            }else{
                c++;
            }
        }
        h.push_back(c);
        int ans = 0;
        for(int i = 0 ; i < h.size() ; i++){
            ans = max(ans , h[i]/2);
            if(i){
                ans = max(ans , min(h[i] , h[i-1]));
            }
        }
        return ans >= k;
    }
};",1448186910
Sanath_Kulla,Sanath_Kulla,80,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        vector<int> h;
        int c = 1;
        for(int i = 1 ; i < nums.size() ; i++){
            if(nums[i] <= nums[i-1]){
                h.push_back(c);
                c = 1;
            }else{
                c++;
            }
        }
        h.push_back(c);
        int ans = 0;
        for(int i = 0 ; i < h.size() ; i++){
            ans = max(ans , h[i]/2);
            if(i){
                ans = max(ans , min(h[i] , h[i-1]));
            }
        }
        return ans;
    }
};",1448185084
Sanath_Kulla,Sanath_Kulla,80,3631,cpp,"using ll = long long;
const ll mod = 1e9+7;
ll bits(ll x) { ll cnt = 0; while(x > 0) { cnt++; x >>= 1; } return cnt; }
ll setbits(ll x) { ll cnt = 0; while(x > 0) { cnt += (x & 1); x >>= 1; } return cnt; }
ll pow(ll a, ll b) {ll res = 1;while (b > 0) {if (b & 1)res = res * a;a = a * a;b >>= 1;}return res;}
ll pow(ll a, ll b, ll m = mod) {a %= m;ll res = 1;while (b > 0) {if (b & 1)res = res * a % m;a = a * a % m;b >>= 1;}return res;}
ll add(ll a, ll b, ll m = mod){a %= m , b %= m; return (a + b) % m;}
ll sub(ll a, ll b, ll m = mod){a %= m , b %= m; return (a - b + m) % m;}
ll mul(ll a, ll b, ll m = mod){a %= m , b %= m; return (1ll * a * b) % m;}
ll div(ll a, ll b, ll m = mod){a %= m , b %= m; return mul(a , pow(b , m - 2 , m) , m);}
const ll N = 1e3+10;
ll fact[N],inv[N];
ll ncr(ll n,ll r){
   if(r > n || n < 0 || r < 0)return 0;
   return fact[n]*inv[n-r]%mod*inv[r]%mod;
}

auto init_ncr = [](){
  fact[0] = 1;
  ll i;
  for(i = 1;i<N;i++)fact[i] = i*fact[i-1]%mod;
  i--;
  inv[i] = pow(fact[i],mod-2,mod);
  for(i--;i>=0;i--)inv[i] = inv[i+1]*(i+1)%mod;
    return 1;
}();

vector<int> mn(810 , 0);
auto doo = [](){
    mn[1] = 0;
    mn[0] = 300;
    for(int len = 2 ; len <= 800 ; len++){
        ll c = 1;
        ll x = len;
        while(true){
            if(c > 5)break;
            if(x == 1)break;
            x = __builtin_popcount(x);
            c++;
        }
        mn[len] = c;
    }
    return 0;
}();

class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        ll ans = 0;
        ll ex = 0;
        ll n = s.size();
        for(int i = 0 ; i < s.size() ; i++){
                if(s[i] == '1'){
                        ll x = n - i-1;
                        for(ll choose = 0 ; choose <= x ; choose++){
                            ll len = ex + choose;
                            ll ways = ncr(x , choose);
                            if(mn[len] <= k)ans += ways,ans%=mod;
                        }
                    ex++;
                }
        }
        // ans -= 1;
        // ans += mod;
        // ans %= mod;
        return ans;
        
    }
};",1448242743
Sanath_Kulla,Sanath_Kulla,80,3646,cpp,"const int N = 1e5+10;
const int mod = 1e9+7;
using ll = long long;
vector<ll> dp(N , 0);

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        ll n = nums.size();
        vector<ll> p(n , 0) , s(n , 0);
        for(auto it:nums){
            dp[it] = 0;
            if(it-1>=0)dp[it-1] = 0;
            dp[it+1] = 0;
        }
        for(int i = 0;i<n;i++){
            ll ways = 1;
            ll x = nums[i];
            if(x)ways += dp[x-1] , ways %= mod;
            ways += dp[x+1] , ways %= mod;
            p[i] = ways;
            dp[x] += ways;
            dp[x] %= mod;
        }
        for(auto it:nums){
            dp[it] = 0;
                        if(it-1>=0)dp[it-1] = 0;
            dp[it+1] = 0;
        }
        for(int i = n-1;i>=0;i--){
            ll ways = 1;
            ll x = nums[i];
            if(x)ways += dp[x-1] , ways %= mod;
            ways += dp[x+1] , ways %= mod;
            s[i] = ways;
            dp[x] += ways;
            dp[x] %= mod;
        }
        ll ans = 0;
        for(int i = 0 ; i < n ; i++){
            ans += p[i] * s[i] % mod * nums[i] % mod;
            ans %= mod;
        }
        return ans;
    }
};",1448203857
Monik L,monik_gowda_21,81,3612,cpp,"class Solution {
public:
    
    bool forK(int k, vector<int>& p) {
        cout << k << endl;
        
        int n = p.size();
        for(int i=0;i<n;i++) {
            cout << i << "" "" << p[i] << endl;
            if(p[i] < k or ((i+k) >= n))
                continue;
            
            cout << i << endl;
            int next = i + k;
        
            if(p[next] >= k)
                return true;
        }
        
        return false;
    }
    
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        
        int n = nums.size();
        
        vector<int> p(n, 1);
        
        p[n-1] = 1;
        
        for(int i=n-2;i>=0;i--) {
            if(nums[i] < nums[i+1])
                p[i] = p[i+1] + 1;
            else
                p[i] = 1;
        }
        
        for(int i=0;i<n;i++)
            cout<<p[i] << "" "";
        
        return forK(k, p);
    }
};",1448198306
Monik L,monik_gowda_21,81,3619,cpp,"class Solution {
public:
    bool forK(int k, vector<int>& p) {
        int n = p.size();
        for(int i=0;i<n;i++) {
            if(p[i] < k or ((i+k) >= n))
                continue;
            
            int next = i + k;
        
            if(p[next] >= k)
                return true;
        }
        
        return false;
    }
    
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        
        vector<int> p(n, 0);
        
        p[n-1] = 1;
        
        for(int i=n-2;i>=0;i--) {
            if(nums[i] < nums[i+1])
                p[i] = p[i+1] + 1;
            else
                p[i] = 1;
        }
        
        
        
        int low = 1, high = n / 2;
        
        while((high-low) > 1) {
            int mid = (high + low) / 2;
            
            if(forK(mid, p))
                low = mid;
            else
                high = mid - 1;
        }
        
        if(forK(high, p))
            return high;
        
        return low;
    }
};",1448192646
Monik L,monik_gowda_21,81,3631,cpp,"class Solution {
public:
    int n, k;
    string s;
    
    map<int,int> memory;
    
    bool can(int x) {
        if(memory.find(x) != memory.end())
            return memory[x];
        
        int op = 0;
        int tempx = x;
        
        int lastk = x;
        
        while(tempx != 1) {
            lastk = tempx;
            
            tempx = __builtin_popcount(tempx);
            if(tempx == lastk)
                return memory[x] = false;
            
            op++;
        }
        
        if(op < k){
           // cout << x << endl;
            return memory[x] = true;
        }
           // return true;
        
        return memory[x] = false;
    }

    int dp[801][2][801];
    
    int fun(int i, int eq, int sum) {
        if(i >= n) {
            if(can(sum) && (eq==0))
                return 1;
            
            return 0;
        }
        
        if(dp[i][eq][sum] != -1)
            return dp[i][eq][sum];
        
        long long ans = 0;
        int mod = (int)1e9+7;
        
        if(eq == 0) {
            ans = ans + fun(i+1, 0, sum + 1) + fun(i+1, 0, sum);
        } else {
            if(s[i] == '0') {
                ans = ans + fun(i+1, 1, sum);
            } else {
                ans = ans + fun(i+1, 0, sum) + fun(i+1, 1, sum+1);
            }
        }
        
        ans = ans % mod;
        
        return dp[i][eq][sum] = ans;
    }
    
    int countKReducibleNumbers(string s1, int k1) {
        s = s1, k = k1;
        n = s.size();
        
        for(int i=0;i<=n;i++) {
            for(int j=0;j<2;j++) {
                for(int k=0;k<=n;k++) {
                    dp[i][j][k] = -1;
                }
            }
        }
        
        return fun(0, 1, 0);
    }
};",1448235149
Monik L,monik_gowda_21,81,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        map<int,int> ends;
        map<int, long long> sumt;
        
        int mod = (int)1e9+7;
        
        long long ans = 0;
        for(int x: nums) {
            int value1 = x - 1, value2 = x + 1;
            
            int f = (ends[value1] + ends[value2] + 1) % mod;
            
            long long kf = (sumt[value1] + sumt[value2] + (long long)f * x) % mod;
            ans = ans + kf;
            ans = ans % mod;
            sumt[x] += kf;
            sumt[x] %= mod;
            ends[x] += f;
            ends[x] %= mod;
        }
        
        return ans;
    }
};",1448210619
Decision,Decision,82,3612,java,"class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        final int n = nums.size();
        final int[] ns = new int[n], cs = new int[n];
        int p = 0;
        for(int a : nums){
            ns[p++] = a;
        }
        cs[0] = 1;
        for(int i=1;i<n;++i){
            if(ns[i] > ns[i-1]){
                cs[i] = cs[i-1] + 1;
            }else{
                cs[i] = 1;
            }
        }
        boolean res = false;
        for(int i=k+k-1;i<n;++i){
            if(cs[i] >= k && cs[i-k] >= k){
                res = true;
                break;
            }
        }
        return res;
    }
}",1448225113
Decision,Decision,82,3619,java,"class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        final int n = nums.size();
        final int[] ns = new int[n], cs = new int[n];
        int p = 0;
        for(int a : nums){
            ns[p++] = a;
        }
        cs[0] = 1;
        for(int i=1;i<n;++i){
            if(ns[i] > ns[i-1]){
                cs[i] = cs[i-1] + 1;
            }else{
                cs[i] = 1;
            }
        }
        int l=1, r=n/2;
        while(l <= r){
            final int mid = (l+r) >> 1;
            boolean f = false;
            for(int i=mid+mid-1;i<n;++i){
                if(cs[i] >= mid && cs[i-mid] >= mid){
                    f = true;
                    break;
                }
            }
            if(f){
                l = mid + 1;
            }else{
                r = mid - 1;
            }
        }
        return r;
    }
}",1448221226
Decision,Decision,82,3631,java,"class Solution {
    final static int m = 810;
    final static int[] fs = new int[m];
    static{
        for(int i=2;i<m;++i){
            fs[i] = fs[Integer.bitCount(i)] + 1;
        }
    }
    public int countKReducibleNumbers(String s, int k) {
        final int n = s.length(), MODE = 1000000007;;
        final char[] cc = s.toCharArray();
        final long[][] comb = new long[n+1][n+1];
        comb[0][0] = 1L;
        for(int i=1;i<=n;++i){
            comb[i][0] = comb[i][i] = 1L;
            for(int j=1;j<i;++j){
                comb[i][j] = (comb[i-1][j] + comb[i-1][j-1]) % MODE;
            }
        }
        int pre = 0;
        long res = 0;
        for(int i=0;i<n;++i){
            if(cc[i] == '1'){
                int cnt = n-1-i, st = 0;
                while(st <= cnt){
                    if(pre + st > 0 && fs[pre+st] < k){
                        res += comb[cnt][st];
                        res %= MODE;
                    }
                    st++;
                }
                pre++;
            }
        }
        return (int)res;
    }
}",1448209162
Decision,Decision,82,3646,java,"class Solution {
    public int sumOfGoodSubsequences(int[] nums) {
        int m = 0, MODE = 1000000007;
        for(int a : nums){
            m = Math.max(m, a);
        }
        long res = 0;
        final long[] vs = new long[m+1], cs = new long[m+1];
        for(int a : nums){
            long v = a, c = 1;
            if(a-1 >= 0){
                v = (v + vs[a-1]) % MODE;
                v += a * cs[a-1];
                v %= MODE;
                c = (c + cs[a-1]) % MODE;
            }
            if(a+1 <= m){
                v = (v + vs[a+1]) % MODE;
                v += a * cs[a+1];
                v %= MODE;
                c = (c + cs[a+1]) % MODE;
            }
            res = (res + v) % MODE;
            vs[a] = (vs[a] + v) % MODE;
            cs[a] = (cs[a] + c) % MODE;
        }
        return (int)res;
    }
}",1448243219
junbinliang,junbinliang,85,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& a, int k) {
        int n = a.size();
        vector<bool> b(n);
        for(int i = 0; i < a.size(); i++) {
            if(i + k - 1 >= n) break;
            bool ok = true;
            for(int j = i + 1; j <= i + k - 1; j++) {
                if(a[j] <= a[j - 1]) ok = false;
            }
            if(ok) {
                b[i] = true;
                //cout << i << endl;
            }
        }
        
        for(int i = 0; i < b.size(); i++) {
            for(int j = i + 1; j < b.size(); j++) {
                if(b[i] && b[j] && j - i == k) return true;
            }
        }
        return false;
    }
};",1448182679
junbinliang,junbinliang,85,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& a) {
        int n = a.size();
        vector<int> dp(n);
        vector<pair<int, int>> b;
        for(int i = 0; i < n; i++) {
            int j = i + 1;
            int cnt = 1;
            while(j < n && a[j] > a[j - 1]) {
                cnt++;
                j++;
            }
            
            int k = i;
            while(k < j) {
                dp[k] = cnt--;
                k++;
            }
            
            b.push_back({i, j - 1});
            
            i = j - 1;
        }
        
        int ans = 0;
        for(int i = 0; i < b.size(); i++) {
            int l = b[i].first, r = b[i].second;
            int sz = (r - l + 1) / 2;
            ans = max(ans, sz);
            for(int j = l; j <= r; j++) {
                if(r + 1 < n) {
                    ans = max(ans, min(dp[j], dp[r + 1]));
                }
            }
        }
        
        //for(int i = 0; i < n; i++) cout << dp[i] << "" "";
        //cout << endl;
        return ans;
    }
};",1448197374
junbinliang,junbinliang,85,3631,cpp,"const int MOD = 1e9 + 7;
int k;
bool yes = false;
int ok[810][6], c[810][810];
int get(int n) {
    int cnt = 0;
    for(int j = 0; j < 12; j++) {
        if(n & (1 << j)) cnt++;
    }
    return cnt;
}

void init() {
    if(yes) return;
    yes = true;
    for(int i = 1; i <= 800; i++) {
        for(int j = 1; j <= 5; j++) {
            int v = i;
            for(int t = 0; t < j; t++) {
                v = get(v);
            }
            if(v == 1) ok[i][j] = 1;
            else ok[i][j] = 0;
        }
    }
    ok[1][0] = 1;
    
    c[0][0] = 1;
    for(int i = 1;i <= 805; i++) {
      c[i][0]=1;
      for(int j = 1;j <= i;j++) {
        c[i][j] = (c[i-1][j] + c[i-1][j-1] ) % MOD;
      }
    }
}

class Solution {
public:
    int countKReducibleNumbers(string& s, int k) {
        init();
        int n = s.size();
        
        long long ans = 0;
        int cnt = 0;
        for(int i = 0; i < s.size(); i++) {
            //same prefix
            int tot = 0;
            if(s[i] == '1') {
                //replace with 0
                int poslen = s.size() - (i + 1);
                for(int j = 0; j <= poslen; j++) {
                    if(ok[cnt + j][k - 1]) {
                        int w = c[poslen][j];
                        tot += w;
                        tot %= MOD;
                        //cout << i << ""   |"" << cnt << ""  "" << j << ""  ""  << w << endl;
                    }
                }
                ans += tot;
                ans %= MOD;
               // cout << i << "" "" << tot << endl;
            
            } else {
                continue;
            }
            
            if(s[i] == '1') {
                cnt++;
            }
        }
        
        return ans;
    }
};",1448235759
junbinliang,junbinliang,85,3646,cpp,"const int MOD = 1e9 + 7;
const int N = 1e5 + 10;
class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& a) {
        int n = a.size();
        
        unordered_map<int, long long> dp1, dp2;
        for(int i = 0; i < n; i++) {
            int v = a[i];
            long long s = 0, cnt = 0;
            if(dp1.find(v - 1) != dp1.end()) {
                cnt += dp1[v - 1];
                cnt %= MOD;
                s += dp2[v - 1];
                s %= MOD;
            }
            
            if(dp1.find(v + 1) != dp1.end()) {
                cnt += dp1[v + 1];
                cnt %= MOD;
                s += dp2[v + 1];
                s %= MOD;
            }
            
            //single 
            cnt++;
            cnt %= MOD;
            s += ((cnt + 0ll) * a[i]);
            s %= MOD;
            
            if(dp1.find(v) != dp1.end()) {
                cnt += dp1[v];
                cnt %= MOD;
                s += dp2[v];
                s %= MOD;
            }
            
            dp1[v] = cnt;
            dp2[v] = s;
            
            //cout << i << ""   | "" << cnt << "" ""  << s << endl;
            
        }
        
        long long ans = 0;
        for(auto it = dp2.begin(); it != dp2.end(); it++) {
            ans += (it -> second);
            ans %= MOD;
        }
        return ans;
    }
};",1448207195
Nguyễn Thảo,nguyenquocthao00,87,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n=len(nums)
        data=[0]*(n)
        data[n-1]=1
        for i in range(n-2,-1,-1):
            data[i]=1 + (0 if nums[i]>=nums[i+1] else data[i+1])
        # print(data)
        for i in range(n-k):
            if data[i]>=k and data[i+k]>=k: return True
        return False
        ",1448185200
Nguyễn Thảo,nguyenquocthao00,87,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        data,cur = [], 1
        for i in range(1, len(nums)):
            if nums[i]>nums[i-1]: cur+=1
            else: 
                data.append(cur)
                cur=1
        data.append(cur)
        # print(data)
        res=max(v//2 for v in data)
        for i in range(len(data)-1):
            res=max(res, min(data[i], data[i+1]))
        return res

        ",1448189418
Nguyễn Thảo,nguyenquocthao00,87,3631,python3,"MOD = 10**9 + 7
cached=[0]*801
for i in range(2, len(cached)):
    cached[i] = 1+ cached[i.bit_count()]
# @lru_cache(None)
def nre(i):
    return cached[i]
    # if i==1: return 0
    # return 1 + nre(i.bit_count())
class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        n=len(s)
        @lru_cache(None)
        def dp(i, n1, less):
            # print(i,n1,less)
            if i==n:
                if not less: return 0
                if n1>0 and nre(n1)<k: return 1
                return 0
            if less:
                return (dp(i+1, n1, True) + dp(i+1,n1+1,True))%MOD
            if s[i]=='0': return dp(i+1, n1, False)
            if s[i]=='1': return (dp(i+1,n1+1,False) + dp(i+1,n1,True))%MOD
        return dp(0,0,False)
        # for i in range(1,801):
        #     print(i, dp(i))
        # return 0
        
        ",1448236343
Nguyễn Thảo,nguyenquocthao00,87,3646,python3,"MOD = 10**9 + 7
class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        count,m=defaultdict(int),defaultdict(int)
        for v in nums:
            added = 1 + count[v-1] + count[v+1]
            m[v] = (m[v] + added*v + m[v-1] + m[v+1])%MOD
            count[v] = (count[v] + added)%MOD
            
            # print(count, m)
            # m[v]=(v+m[v-1] + m[v+1])%MOD
            # print(v, m)
        return sum(m.values())%MOD
        ",1448209431
Salamander,BelgianSalamander,88,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        vector<int> dpLeft(nums.size(), 1), dpRight(nums.size(), 1);
        
        dpRight[0] = 1;
        for (int i = 1; i < nums.size(); i++) {
            if (nums[i] > nums[i-1]) {
                dpRight[i] = dpRight[i-1]+1;
            }
        }

        dpLeft.back() = 1;
        for (int i = nums.size() - 2; i >= 0; i--) {
            if (nums[i] < nums[i+1]) {
                dpLeft[i] = dpLeft[i+1]+1;
            }
        }

        int res = 0;

        for (int i = 0; i < nums.size() - 1; i++) {
            //cout << dpRight[i] << "" "" << dpLeft[i] << endl;
            res = max(res, min(dpRight[i], dpLeft[i+1]));
        }

        return res >= k;
    }
};",1448236506
Salamander,BelgianSalamander,88,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        vector<int> dpLeft(nums.size(), 1), dpRight(nums.size(), 1);
        
        dpRight[0] = 1;
        for (int i = 1; i < nums.size(); i++) {
            if (nums[i] > nums[i-1]) {
                dpRight[i] = dpRight[i-1]+1;
            }
        }

        dpLeft.back() = 1;
        for (int i = nums.size() - 2; i >= 0; i--) {
            if (nums[i] < nums[i+1]) {
                dpLeft[i] = dpLeft[i+1]+1;
            }
        }

        int res = 0;

        for (int i = 0; i < nums.size() - 1; i++) {
            //cout << dpRight[i] << "" "" << dpLeft[i] << endl;
            res = max(res, min(dpRight[i], dpLeft[i+1]));
        }

        return res;
    }
};",1448235747
Salamander,BelgianSalamander,88,3631,python3,"def reduce(x):
    res = 0
    while x:
        if x % 2:
            res += 1

        x //= 2
    return res

def goes(x):
    res = 0
    while x != 1:
        x = reduce(x)
        res += 1
    return res

MOD = 1000000007

class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        pows = [1] * 1000
        for i in range(1, 1000):
            pows[i] = (pows[i-1] * 2) % MOD

        dp = [[0] * (len(s) + 1) for _ in range((len(s) + 1))]
        dp2 = [[0] * (len(s) + 1) for _ in range((len(s) + 1))]
        dp2[-1] = [1] + [0] * len(s)

        for idx in range(len(s) - 1 , -1, -1):
            left = len(s) - idx - 1

            dp2[idx][0] = 1
            for cnt in range(1, len(s)+1):
                dp2[idx][cnt] = (dp2[idx+1][cnt] + dp2[idx+1][cnt-1]) % MOD


            for cnt in range(len(s)+1):
                if s[idx] == '0':
                    dp[idx][cnt] = dp[idx+1][cnt]
                else:
                    dp[idx][cnt] = (dp2[idx+1][cnt] + (dp[idx+1][cnt-1] if cnt != 0 else 0)) % MOD

        #print(*dp, sep=""\n"")
        #print(*dp2, sep = ""\n"")
            
        res = 0
        for i in range(1, len(s) + 1):
            if goes(i) < k:
                #print(i)
                res = (res + dp[0][i]) % MOD

        return res",1448222058
Salamander,BelgianSalamander,88,3646,python3,"MOD = 1000000007

class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        vals = {}
        res = 0

        for x in nums:
            tot = x
            cnt = 1
            
            if x-1 in vals:
                cnt += vals[x-1][0]
                tot += x * vals[x-1][0] + vals[x-1][1]
            if x+1 in vals:
                cnt += vals[x+1][0]
                tot += x * vals[x+1][0] + vals[x+1][1]

            #print(x, tot, cnt)

            res += tot
            if x in vals:
                vals[x] = (vals[x][0] + cnt, vals[x][1] + tot)
            else:
                vals[x] = (cnt, tot)

        return res % MOD",1448230430
Anonymous,never_seen,89,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        int cnt = 0;
        for (int i = 0; i < n; i++){
            int j = i;
            while (i + 1 < n and nums[i] < nums[i + 1]) ++i;
            if (i - j + 1 >= 2 * k) return true;
            if (i - j + 1 < k) cnt = 0;
            else cnt++;
            if (cnt > 1) return true;
        }
        return false;
    }
};",1448187390
Anonymous,never_seen,89,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        int cnt = 0, ans = 0;
        for (int i = 0; i < n; i++){
            int j = i;
            while (i + 1 < n and nums[i] < nums[i + 1]) ++i;
            ans = max(ans, (i - j + 1) / 2);
            ans = max(ans, min(cnt, i - j + 1));
            cnt = i - j + 1;
        }
        return ans;
    }
};",1448190059
Anonymous,never_seen,89,3631,cpp,"class Solution {
public:
    int p[801][5];
    int dp[800][800][2];
    const int mod = 1e9 + 7;
    int rec(int i, int cnt, bool t, int k, string &s){
        if (i == size(s)) return !t and cnt > 0 and p[cnt][k] == 1;
        int &ans = dp[i][cnt][t];
        if (~ans) return ans;
        ans = 0;
        int x = (t ? s[i] - '0' : 1);
        for (int j = 0; j <= x; j++){
            ans += rec(i + 1, cnt + j, t & (j == x), k, s);
            if (ans >= mod) ans -= mod;
        }
        return ans;
    }
    int countKReducibleNumbers(string s, int k) {
        for (int i = 0; i < 5; i++) p[1][i] = 1;
        for (int i = 2; i <= 800; i++){
            int k = __builtin_popcount(i);
            p[i][0] = i, p[i][1] = k;
            for (int j = 2; j < 5; j++){
                p[i][j] = p[k][1];
                k = p[k][1];
            }
        }
        memset(dp, -1, sizeof dp);
        return rec(0, 0, 1, k - 1, s);
    }
};",1448228781
Anonymous,never_seen,89,3646,cpp,"template <class T, T mod, class U = typename conditional<is_same<T, int32_t>::value, int64_t, __int128_t>::type> 
class modnum{
    T phi = mod - 1, u; // prime mod, a ^ b % mod = a ^ (b % phi) % mod
public: modnum() : modnum(0){}
    modnum(U v) : u(v >= 0 ? v % mod : (mod - (-v) % mod) % mod){}
    modnum(T v) : u(v >= mod ? v - mod : (v < 0 ? v + mod : v)){}
    T val()const{return u;}
    operator bool()const{return u != 0;}
    modnum &operator+=(const modnum &p){u += p.val(); if (u >= mod) u -= mod; return *this;}
    modnum &operator-=(const modnum &p){u += mod - p.val(); if (u >= mod) u -= mod; return *this;}
    modnum &operator*=(const modnum &p){u = T((U)u * (p.val()) % mod); return *this;}
    modnum &operator/=(const modnum &p){return *this *= p.inv();}
    template<class V> modnum &operator+=(const V &val){ return *this += modnum(val);}
    template<class V> modnum &operator-=(const V &val){ return *this -= modnum(val);}
    template<class V> modnum &operator*=(const V &val){ return *this *= modnum(val);}
    template<class V> modnum &operator/=(const V &val){ return *this /= modnum(val);}
    modnum &operator++(){return *this += 1;} 
    modnum &operator--(){return *this -= 1;}
    modnum operator++(T){modnum tmp = *this; ++*this; return tmp;}
    modnum operator--(T){modnum tmp = *this; --*this; return tmp;}
    modnum operator+(const modnum &p)const{return modnum(*this) += p;}
    modnum operator-(const modnum &p)const{return modnum(*this) -= p;}
    modnum operator*(const modnum &p)const{return modnum(*this) *= p;}
    modnum operator/(const modnum &p)const{return modnum(*this) /= p;}
    template<class V> modnum operator+(const V &val)const{return modnum(*this) += val;}
    template<class V> modnum operator-(const V &val)const{return modnum(*this) -= val;}
    template<class V> modnum operator*(const V &val)const{return modnum(*this) *= val;}
    template<class V> modnum operator/(const V &val)const{return modnum(*this) /= val;}
    modnum operator-()const{return modnum(0) - *this;}
    bool operator!()const{return !u;}
    bool operator~()const{return ~u;}
    bool operator==(const modnum &p)const{return u == p.u;}
    template<class V> bool operator==(const V val)const{return *this == modnum(val);}
    template<class V> bool operator!=(const V val)const{return *this != modnum(val);}
    bool operator!=(const modnum &p)const{return u != p.u;} 
    modnum inv()const{assert(*this); return expo(phi - 1);}
    modnum expo(U k)const{modnum now = *this, ret = 1; for (; k; k >>= 1, now *= now) if (k & 1) ret *= now; return ret;}
    modnum pow(U k)const{return k < 0 ? inv().expo(-k) : expo(k);}
    template<class V> friend modnum operator+(V lhs, const modnum& rhs){return rhs + lhs;}
    template<class V> friend modnum operator-(V lhs, const modnum& rhs){return -rhs + lhs;}
    template<class V> friend modnum operator*(V lhs, const modnum& rhs){return rhs * lhs;}
    template<class V> friend modnum operator/(V lhs, const modnum& rhs){return rhs.inv() * lhs;}
    template<class V> friend bool operator==(V lhs, const modnum& rhs){return rhs == lhs;}
    template<class V> friend bool operator!=(V lhs, const modnum& rhs){return rhs != lhs;}
    friend istream &operator>>(istream &is, modnum &p){U a; is >> a; p = a; return is;}
    friend ostream &operator<<(ostream &os, const modnum &p){return os << p.val();}
    friend void __print(modnum &p){cerr << p.val();}
};
const int mod = 1e9 + 7;
using mint = modnum<int32_t, mod>;
class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        const int m = 1e5;
        vector<mint> dp(m + 1), sum(m + 1);
        for (auto &e : nums){
            dp[e]++, sum[e] += e;
            if (e > 0){
                dp[e] += dp[e - 1];
                sum[e] += sum[e - 1] + dp[e - 1] * e;
            }
            if (e < m){
                dp[e] += dp[e + 1];
                sum[e] += sum[e + 1] + dp[e + 1] * e;
            }
        }
        mint ans = 0;
        for (auto &e : sum) ans += e;
        return ans.val();
    }
};",1448200433
Yatin Kwatra,yatin_kwatra,91,3612,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

#define ll                      long long
#define ar                      array
// #define int                     ll
#define sz(v)                   (int)(v.size())
#define FIO                     ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define ld                      long double
#define ull                     unsigned long long
#define endl                    ""\n""
#define fo(i,a,b)               for(int i = a; i<=b ; i++)
#define rfo(i,a,b)              for(int i = a; i>=b ; i--)
#define vii                     vector<int>
#define pq                      priority_queue
#define uomii                   unordered_map<int,int,best_hash>
#define all(v)                  v.begin(),v.end()
#define mp                      make_pair
#define pb                      push_back
#define pob                     pop_back
#define ff                      first
#define ss                      second
#define pii                     pair<int,int>
#define mii                     map<int,int>
#define vvii                    vector<vii>
#define mod                     1000000007
#define inf                     5e18
#define pi                      3.1415926535897932384626433832795
#define cz(x)                   63 - __builtin_clzll(x)



using namespace std;
using namespace __gnu_pbds;
template<class T> using oset =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;


// https://codeforces.com/blog/entry/68809

void __print(int x) {cout << x;}
void __print(long x) {cout << x;}
void __print(unsigned x) {cout << x;}
void __print(unsigned long x) {cout << x;}
void __print(unsigned long long x) {cout << x;}
void __print(float x) {cout << x;}
void __print(double x) {cout << x;}
void __print(long double x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(const char *x) {cout << '\""' << x << '\""';}
void __print(const string &x) {cout << '\""' << x << '\""';}
void __print(bool x) {cout << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << ','; __print(x.second); cout << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cout << '{'; for (auto &i : x) cout << (f++ ? "","" : """"), __print(i); cout << ""}"";}
void _print() {cout << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define pr(x...) cout << ""["" << #x << ""] = [""; _print(x)
#else
#define pr(x...)
#endif

// https://codeforces.com/blog/entry/62393

struct best_hash {
	static uint64_t splitmix64(uint64_t x) {

		x += 0x9e3779b97f4a7c15;
		x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
		x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
		return x ^ (x >> 31);
	}

	size_t operator()(uint64_t x) const {
		static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x + FIXED_RANDOM);
	}
};


/* ------------------------------- REAL CODING STARTS NOW --------------------------- */



class Solution {
public:
	bool hasIncreasingSubarrays(vector<int>& v, int k) {
		int n = sz(v);

		vii suf(n, 1), pre(n, 1);

		rfo(i, n - 2, 0) {
			if (v[i] < v[i + 1]) suf[i] = 1 + suf[i + 1];
		}
		fo(i, 1, n - 1) {
			if (v[i] > v[i - 1]) pre[i] = 1 + pre[i - 1];
		}

		fo(i, 0, n - 1) {
			if (i < k or n - i < k) continue;
			if (min(pre[i - 1], suf[i]) >= k) return true;
		}

		return false;
	}
};",1448190114
Yatin Kwatra,yatin_kwatra,91,3619,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

#define ll                      long long
#define ar                      array
// #define int                     ll
#define sz(v)                   (int)(v.size())
#define FIO                     ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define ld                      long double
#define ull                     unsigned long long
#define endl                    ""\n""
#define fo(i,a,b)               for(int i = a; i<=b ; i++)
#define rfo(i,a,b)              for(int i = a; i>=b ; i--)
#define vii                     vector<int>
#define pq                      priority_queue
#define uomii                   unordered_map<int,int,best_hash>
#define all(v)                  v.begin(),v.end()
#define mp                      make_pair
#define pb                      push_back
#define pob                     pop_back
#define ff                      first
#define ss                      second
#define pii                     pair<int,int>
#define mii                     map<int,int>
#define vvii                    vector<vii>
#define mod                     1000000007
#define inf                     5e18
#define pi                      3.1415926535897932384626433832795
#define cz(x)                   63 - __builtin_clzll(x)



using namespace std;
using namespace __gnu_pbds;
template<class T> using oset =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;


// https://codeforces.com/blog/entry/68809

void __print(int x) {cout << x;}
void __print(long x) {cout << x;}
void __print(unsigned x) {cout << x;}
void __print(unsigned long x) {cout << x;}
void __print(unsigned long long x) {cout << x;}
void __print(float x) {cout << x;}
void __print(double x) {cout << x;}
void __print(long double x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(const char *x) {cout << '\""' << x << '\""';}
void __print(const string &x) {cout << '\""' << x << '\""';}
void __print(bool x) {cout << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << ','; __print(x.second); cout << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cout << '{'; for (auto &i : x) cout << (f++ ? "","" : """"), __print(i); cout << ""}"";}
void _print() {cout << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define pr(x...) cout << ""["" << #x << ""] = [""; _print(x)
#else
#define pr(x...)
#endif

// https://codeforces.com/blog/entry/62393

struct best_hash {
	static uint64_t splitmix64(uint64_t x) {

		x += 0x9e3779b97f4a7c15;
		x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
		x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
		return x ^ (x >> 31);
	}

	size_t operator()(uint64_t x) const {
		static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x + FIXED_RANDOM);
	}
};


/* ------------------------------- REAL CODING STARTS NOW --------------------------- */



class Solution {
public:
	int maxIncreasingSubarrays(vector<int>& v) {
		int n = sz(v);

		vii suf(n, 1), pre(n, 1);

		rfo(i, n - 2, 0) {
			if (v[i] < v[i + 1]) suf[i] = 1 + suf[i + 1];
		}
		fo(i, 1, n - 1) {
			if (v[i] > v[i - 1]) pre[i] = 1 + pre[i - 1];
		}

		int k = 0;

		fo(i, 1, n - 1) {
			k = max(k, min(pre[i - 1], suf[i]));
		}
		return k;
	}
};",1448186409
Yatin Kwatra,yatin_kwatra,91,3631,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

#define ll                      long long
#define ar                      array
// #define int                     ll
#define sz(v)                   (int)(v.size())
#define FIO                     ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define ld                      long double
#define ull                     unsigned long long
#define endl                    ""\n""
#define fo(i,a,b)               for(int i = a; i<=b ; i++)
#define rfo(i,a,b)              for(int i = a; i>=b ; i--)
#define vii                     vector<int>
#define pq                      priority_queue
#define uomii                   unordered_map<int,int,best_hash>
#define all(v)                  v.begin(),v.end()
#define mp                      make_pair
#define pb                      push_back
#define pob                     pop_back
#define ff                      first
#define ss                      second
#define pii                     pair<int,int>
#define mii                     map<int,int>
#define vvii                    vector<vii>
#define mod                     1000000007
#define inf                     5e18
#define pi                      3.1415926535897932384626433832795
#define cz(x)                   63 - __builtin_clzll(x)



using namespace std;
using namespace __gnu_pbds;
template<class T> using oset =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;


// https://codeforces.com/blog/entry/68809

void __print(int x) {cout << x;}
void __print(long x) {cout << x;}
void __print(unsigned x) {cout << x;}
void __print(unsigned long x) {cout << x;}
void __print(unsigned long long x) {cout << x;}
void __print(float x) {cout << x;}
void __print(double x) {cout << x;}
void __print(long double x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(const char *x) {cout << '\""' << x << '\""';}
void __print(const string &x) {cout << '\""' << x << '\""';}
void __print(bool x) {cout << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << ','; __print(x.second); cout << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cout << '{'; for (auto &i : x) cout << (f++ ? "","" : """"), __print(i); cout << ""}"";}
void _print() {cout << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define pr(x...) cout << ""["" << #x << ""] = [""; _print(x)
#else
#define pr(x...)
#endif

// https://codeforces.com/blog/entry/62393

struct best_hash {
	static uint64_t splitmix64(uint64_t x) {

		x += 0x9e3779b97f4a7c15;
		x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
		x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
		return x ^ (x >> 31);
	}

	size_t operator()(uint64_t x) const {
		static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x + FIXED_RANDOM);
	}
};


/* ------------------------------- REAL CODING STARTS NOW --------------------------- */


ll addmod(ll a, ll b) {
	a %= mod;
	b %= mod;
	return (a + b) % mod;
}

ll submod(ll a, ll b) {
	a %= mod;
	b %= mod;
	a -= b;
	return (a % mod + mod) % mod;
}

ll mulmod(ll a, ll b) {
	a %= mod;
	b %= mod;

	return (a * b) % mod;
}


ll power(ll n, ll p) {
	ll res = 1;
	while (p) {
		if (p & 1) res = mulmod(res, n);
		n = mulmod(n, n);
		p /= 2;
	}
	return res;
}


ll divmod(ll a, ll b) {
	a %= mod;
	b %= mod;

	return mulmod(a, power(b, mod - 2));
}

const int N = 802;
int op[N];

void precompute() {
	fo(i, 1, N - 1) {
		int x = i;
		op[i] = 0;
		while (x > 1) {
			op[i]++;
			x = __builtin_popcount(x);
		}
	}
}

int dp[2][N][N];
int n;

class Solution {
public:

	int gino(bool sig, int pos, int sum, string &s, int k) {
		if (pos == n) {
			if (sig) return 0;
			return sum and op[sum] < k;
		}
		int &ans = dp[sig][pos][sum];
		if (ans != -1) return ans;
		ans = 0;

		if (sig) {
			if (s[pos] == '1') {
				ans = addmod(ans, gino(0, pos + 1, sum, s, k));
				ans = addmod(ans, gino(1, pos + 1, sum + 1, s, k));
			}
			else {
				ans = addmod(ans, gino(1, pos + 1, sum, s, k));
			}
		}
		else {
			ans = addmod(ans, gino(0, pos + 1, sum, s, k));
			ans = addmod(ans, gino(0, pos + 1, sum + 1, s, k));
		}
        
		return ans;
	}

	int countKReducibleNumbers(string s, int k) {
		if (!op[2]) precompute();
    
        n = sz(s);
		fo(i, 0, 1) {
			fo(j, 0, n) {
				fo(q, 0, n) {
					dp[i][j][q] = -1;
				}
			}
		}

		return gino(1, 0, 0, s, k);

	}
};













",1448245041
Yatin Kwatra,yatin_kwatra,91,3646,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

#define ll                      long long
#define ar                      array
// #define int                     ll
#define sz(v)                   (int)(v.size())
#define FIO                     ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define ld                      long double
#define ull                     unsigned long long
#define endl                    ""\n""
#define fo(i,a,b)               for(int i = a; i<=b ; i++)
#define rfo(i,a,b)              for(int i = a; i>=b ; i--)
#define vii                     vector<int>
#define pq                      priority_queue
#define uomii                   unordered_map<int,int,best_hash>
#define all(v)                  v.begin(),v.end()
#define mp                      make_pair
#define pb                      push_back
#define pob                     pop_back
#define ff                      first
#define ss                      second
#define pii                     pair<int,int>
#define mii                     map<int,int>
#define vvii                    vector<vii>
#define mod                     1000000007
#define inf                     5e18
#define pi                      3.1415926535897932384626433832795
#define cz(x)                   63 - __builtin_clzll(x)



using namespace std;
using namespace __gnu_pbds;
template<class T> using oset =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;


// https://codeforces.com/blog/entry/68809

void __print(int x) {cout << x;}
void __print(long x) {cout << x;}
void __print(unsigned x) {cout << x;}
void __print(unsigned long x) {cout << x;}
void __print(unsigned long long x) {cout << x;}
void __print(float x) {cout << x;}
void __print(double x) {cout << x;}
void __print(long double x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(const char *x) {cout << '\""' << x << '\""';}
void __print(const string &x) {cout << '\""' << x << '\""';}
void __print(bool x) {cout << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << ','; __print(x.second); cout << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cout << '{'; for (auto &i : x) cout << (f++ ? "","" : """"), __print(i); cout << ""}"";}
void _print() {cout << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define pr(x...) cout << ""["" << #x << ""] = [""; _print(x)
#else
#define pr(x...)
#endif

// https://codeforces.com/blog/entry/62393

struct best_hash {
	static uint64_t splitmix64(uint64_t x) {

		x += 0x9e3779b97f4a7c15;
		x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
		x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
		return x ^ (x >> 31);
	}

	size_t operator()(uint64_t x) const {
		static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x + FIXED_RANDOM);
	}
};


/* ------------------------------- REAL CODING STARTS NOW --------------------------- */





ll addmod(ll a, ll b) {
	a %= mod;
	b %= mod;
	return (a + b) % mod;
}

ll submod(ll a, ll b) {
	a %= mod;
	b %= mod;
	a -= b;
	return (a % mod + mod) % mod;
}

ll mulmod(ll a, ll b) {
	a %= mod;
	b %= mod;

	return (a * b) % mod;
}


ll power(ll n, ll p) {
	ll res = 1;
	while (p) {
		if (p & 1) res = mulmod(res, n);
		n = mulmod(n, n);
		p /= 2;
	}
	return res;
}

ll divmod(ll a, ll b) {
	a %= mod;
	b %= mod;

	return mulmod(a, power(b, mod - 2));
}




const int N = 1e5 + 5;
int nxtBig[N], nxtSmall[N], nxtSame[N];
ar<int, 2> dp[N];
int n;

class Solution {
public:

	ar<int, 2> gino(int pos, vii &v) {
		if (pos == n) return {0, 1};
		auto &ans = dp[pos];
		if (ans[0] != -1) return ans;
		ans = {v[pos], 1};

		if (nxtBig[pos] != -1) {
			auto got = gino(nxtBig[pos], v);
			ans[0] = addmod(ans[0], got[0]);
			ans[0] = addmod(ans[0], mulmod(got[1], v[pos]));
			ans[1] = addmod(ans[1], got[1]);
		}


		if (nxtSmall[pos] != -1) {
			auto got = gino(nxtSmall[pos], v);
			ans[0] = addmod(ans[0], got[0]);
			ans[0] = addmod(ans[0], mulmod(got[1], v[pos]));
			ans[1] = addmod(ans[1], got[1]);
		}


		if (nxtSame[pos] != -1) {
			auto got = gino(nxtSame[pos], v);
			ans[0] = addmod(ans[0], got[0]);
			ans[1] = addmod(ans[1], got[1]);
		}

		return ans;
	}

	int sumOfGoodSubsequences(vector<int>& v) {
		n = sz(v);

		fo(i, 0, n - 1) {
			nxtBig[i] = -1;
			nxtSmall[i] = -1;
			dp[i][0] = dp[i][1] = -1;
			nxtSame[i] = -1;
		}

		uomii pos;

		rfo(i, n - 1, 0) {
			if (pos.count(v[i] + 1)) nxtBig[i] = pos[v[i] + 1];
			if (pos.count(v[i] - 1)) nxtSmall[i] = pos[v[i] - 1];
			if (pos.count(v[i])) nxtSame[i] = pos[v[i]];

			pos[v[i]] = i;
		}

		pos.clear();

		int ans = 0;

		fo(i, 0, n - 1) {
			if (pos.count(v[i])) continue;
			auto got = gino(i, v);
			ans = addmod(ans, got[0]);
			pos[v[i]] = 1;
		}
		return ans;
	}
};",1448216470
furuyarei,furuyarei,92,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        for (int i = 0; i + k * 2 <= n; ++i) {
            bool check = true;
            for (int j = i + 1; j < i + k; ++j) {
                if (nums[j] <= nums[j - 1]) {
                    check = false;
                }
            }
            for (int j = i + k + 1; j < i + k * 2; ++j) {
                if (nums[j] <= nums[j - 1]) {
                    check = false;
                }
            }
            if (check) {
                return true;
            }
        }
        return false;
    }
};",1448234724
furuyarei,furuyarei,92,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> v(n, 1);
        for (int i = n - 2; i >= 0; --i) {
            if (nums[i] < nums[i + 1]) {
                v[i] = v[i + 1] + 1;
            }
        }
        int ans = (*max_element(v.begin(), v.end())) / 2;
        for (int i = 0; i < n; ++i) {
            if (i + v[i] < n && v[i + v[i]] >= v[i]) {
                ans = max(ans, v[i]);
            }
        }
        return ans;
    }
};",1448238232
furuyarei,furuyarei,92,3631,python3,"N = 810
MOD = 10**9 + 7
cc = [[0] * N for _ in range(N)]

for i in range(N):
    cc[i][0] = 1
    for j in range(1, i + 1):
        cc[i][j] = (cc[i - 1][j - 1] + cc[i - 1][j]) % MOD

f = [0] * N
f[1] = 0
for i in range(2, N):
    f[i] = f[i.bit_count()] + 1

def calc(s: str, x: int) -> int:
    if len(s) < x:
        return 0

    ans = 0
    cur = 0
    for i, o in enumerate(s):
        if o == '1':
            ans = (ans + cc[len(s) - i - 1][x - cur]) % MOD
            cur += 1
    return ans

class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        ans = 0
        for i in range(1, N):
            if f[i] <= k - 1:
               ans = (ans + calc(s, i)) % MOD
                
        return ans",1448212561
furuyarei,furuyarei,92,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int mod = 1000000007;
        unordered_map<int, long long> sum, cnt;
        for (int num: nums) {
            sum[num] = (sum[num] + num) % mod;
            cnt[num] = (cnt[num] + 1) % mod;
            
            if (sum.count(num - 1)) {
                sum[num] = (sum[num] + sum[num - 1] + cnt[num - 1] * num) % mod;
                cnt[num] = (cnt[num] + cnt[num - 1]) % mod;
            }
            
            if (sum.count(num + 1)) {
                sum[num] = (sum[num] + sum[num + 1] + cnt[num + 1] * num) % mod;
                cnt[num] = (cnt[num] + cnt[num + 1]) % mod;
            }
        }

        int ans = 0;
        for (auto&& [_, v]: sum) {
            ans = (ans + v) % mod;
        }
        return ans;
    }
};",1448227826
Iakobos,Iakobos,93,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(std::vector<int>& nums, int k) {
        int n = nums.size();
        if (n < 2 * k) return false;  // 需要至少两个长度为k的子数组
        
        // 检查从索引start开始的长度为k的子数组是否严格递增
        auto isStrictlyIncreasing = [&](int start) {
            for (int i = start; i < start + k - 1; ++i) {
                if (nums[i] >= nums[i + 1]) return false;
            }
            return true;
        };

        // 遍历找到两个相邻的严格递增子数组
        for (int i = 0; i <= n - 2 * k; ++i) {
            if (isStrictlyIncreasing(i) && isStrictlyIncreasing(i + k)) {
                return true;
            }
        }
        return false;
    }
};",1448180983
Iakobos,Iakobos,93,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        if (n < 2) return 0;

        vector<int> inc_len(n, 1);
        for (int i = n - 2; i >= 0; --i) {
            if (nums[i] < nums[i + 1]) {
                inc_len[i] = inc_len[i + 1] + 1;
            }
        }

        int low = 1, high = n / 2, result = 0;


        while (low <= high) {
            int mid = low + (high - low) / 2;
            if (check(nums, inc_len, mid)) {
                result = mid;
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }

        return result;
    }

private:
    bool check(vector<int>& nums, vector<int>& inc_len, int k) {
        int n = nums.size();
        for (int i = 0; i <= n - 2 * k; ++i) {
            if (inc_len[i] >= k && inc_len[i + k] >= k) {
                return true;
            }
        }
        return false;
    }
};
",1448216176
Iakobos,Iakobos,93,3631,cpp,"class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        const int MOD = 1e9 + 7;
        int L = s.length();
        vector<int> sp(1001, -1);

        function<int(int)> compute_sp = [&](int p) {
            if (sp[p] != -1) return sp[p];
            if (p == 1) return sp[p] = 0;
            return sp[p] = compute_sp(__builtin_popcount(p)) + 1;
        };

        for (int p = 1; p <= L; ++p) {
            compute_sp(p);
        }

        vector<vector<vector<int>>> dp(L+1, vector<vector<int>>(2, vector<int>(L+1, 0)));
        dp[0][1][0] = 1;

        for (int pos = 0; pos < L; ++pos) {
            for (int tight = 0; tight <= 1; ++tight) {
                for (int ones = 0; ones <= pos; ++ones) {
                    int max_digit = tight ? (s[pos] - '0') : 1;
                    for (int digit = 0; digit <= max_digit; ++digit) {
                        int new_tight = tight && (digit == max_digit);
                        int new_ones = ones + digit;
                        dp[pos+1][new_tight][new_ones] = (dp[pos+1][new_tight][new_ones] + dp[pos][tight][ones]) % MOD;
                    }
                }
            }
        }

        vector<int> count_p(L+1, 0);
        for (int ones = 1; ones <= L; ++ones) {
            int total = (dp[L][0][ones] + dp[L][1][ones]) % MOD;
            count_p[ones] = total;
        }

        int ans = 0;
        for (int p = 1; p <= L; ++p) {
            if (sp[p] <= k - 1) {
                ans = (ans + count_p[p]) % MOD;
            }
        }

        if (s == ""1"") {
            ans = 0;
        } else {
            int total_ones_in_n = 0;
            for (char c : s) {
                if (c == '1') total_ones_in_n++;
            }
            if (sp[total_ones_in_n] <= k - 1) {
                ans = (ans - 1 + MOD) % MOD;
            }
        }

        return ans;
    }
};
",1448230356
Iakobos,Iakobos,93,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        const int MOD = 1e9 + 7;
        unordered_map<int, long long> counts;
        unordered_map<int, long long> sums;

        for (int num : nums) {
            long long temp_count = counts[num];
            long long temp_sum = sums[num];


            long long new_count = temp_count + 1;
            long long new_sum = (temp_sum + num) % MOD;


            if (counts.count(num - 1)) {
                new_count = (new_count + counts[num - 1]) % MOD;
                new_sum = (new_sum + sums[num - 1] + num * counts[num - 1] % MOD) % MOD;
            }

            if (counts.count(num + 1)) {
                new_count = (new_count + counts[num + 1]) % MOD;
                new_sum = (new_sum + sums[num + 1] + num * counts[num + 1] % MOD) % MOD;
            }

            counts[num] = new_count;
            sums[num] = new_sum;
        }

        long long total_sum = 0;
        for (auto& pair : sums) {
            total_sum = (total_sum + pair.second) % MOD;
        }

        return total_sum;
    }
};
",1448213357
Wei Liu,nevergiveup,94,3612,java,"class Solution {

    private boolean check(List<Integer> nums, int l, int r) {
        for (int i = l;i < r;i ++) {
            if (nums.get(i) >= nums.get(i + 1)) {
                return false;
            }
        }
        return true;
    }

    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        int n = nums.size();
        for (int i = 0;i + 2 * k - 1 < n;i ++) {
            if (check(nums, i, i + k -1) && check(nums, i + k, i + 2 * k - 1)) {
                return true;
            }
        }
        return false;
    }

}",1448181973
Wei Liu,nevergiveup,94,3619,java,"class Solution {

    private void build(List<Integer> nums) {
        for (int i = 0;i < nums.size();i ++) {
            dp[i] = 1;
            if (i > 0 && (nums.get(i) > nums.get(i - 1))) {
                dp[i] = dp[i - 1] + 1;
            }
        }
    }

    private static int[] dp = new int[200010];

    private boolean isAsc(int l, int r) {
        int result = dp[r];
        int expect = r - l + 1;
        if (result >= expect) {
            return true;
        } else {
            return false;
        }
    }

    private boolean check(int n, int k) {
        for (int i = 0;i + 2 * k - 1 < n;i ++) {
            if (isAsc(i, i + k - 1) && isAsc(i + k, i + 2 * k - 1)) {
                return true;
            }
        }
        return false;
    }

    public int maxIncreasingSubarrays(List<Integer> nums) {
        build(nums);
        int low = 1, high = 1000_10;
        while (low < high) {
            int mid = (low + high) / 2;
            if (check(nums.size(), mid)) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return high - 1;
    }
}",1448190319
Wei Liu,nevergiveup,94,3631,java,"class Solution {

    private int getBits(int value) {
        int ans = 0;
        while (value > 0) {
            if (value % 2 != 0) {
                ans ++;
            }
            value /= 2;
        }
        return ans;
    }

    private void build(String s) {
        // build result
        result[1] = 1;
        for (int i = 2;i <= 1000;i ++) {
            int bits = getBits(i);
            result[i] = result[bits] + 1;
        }
    }

    private int[] result = new int[1010];
    private static long[][][] dp = new long[1010][1010][2];

    private static final long MOD = 1000_000_007L;

    public int countKReducibleNumbers(String s, int k) {
        Arrays.fill(result, -1);
        build(s);
        for (int i = 0;i < 1010;i ++) {
            for (int j = 0;j < 1010;j ++) {
                for (int less = 0;less < 2;less ++) {
                    dp[i][j][less] = - 1;
                }
            }
        }
        return (int) ((solve(s, 0, 0, 0, k) % MOD));
    }

    private long solve(String s, int cur, int count, int less, int k) {
        if (cur == s.length()) {
            if (result[count] <= k && less > 0 && count > 0) {
                return 1;
            } else {
                return 0;
            }
        }
        if (dp[cur][count][less] >= 0) {
            return dp[cur][count][less];
        }
        long ans = 0;
        if (less > 0) {
            // use one
            ans = (ans + solve(s, cur + 1, count + 1, less, k)) % MOD;
            // use zero
            ans = (ans + solve(s, cur + 1, count, less, k)) % MOD;
        } else {
            int curDigit = s.charAt(cur) - '0';
            if (curDigit == 1) {
                ans = (ans + solve(s, cur + 1, count + 1, 0, k)) % MOD;
                ans = (ans + solve(s, cur + 1, count, 1, k)) % MOD;
            } else {
                ans = (ans + solve(s, cur + 1, count, 0, k)) % MOD;
            }
        }
        return dp[cur][count][less] = ans;
    }

}",1448246769
Wei Liu,nevergiveup,94,3646,java,"class Solution {


    private final long MOD = 1000_000_007L;

    private long[] sum = new long[100010];
    private long[] total = new long[100010];

    public int sumOfGoodSubsequences(int[] nums) {
        long ans = 0;
        for (int i = 0;i < nums.length;i ++) {
            int cur = nums[i];
            if (cur - 1 >= 0) {
                sum[cur] = (sum[cur] + ((((total[cur - 1] * cur) % MOD) + sum[cur - 1]) % MOD)) % MOD;
                total[cur] = (total[cur] + total[cur - 1]) % MOD;
            }
            sum[cur] = (sum[cur] + ((((total[cur + 1] * cur) % MOD) + sum[cur + 1]) % MOD)) % MOD;
            total[cur] = (total[cur] + total[cur + 1]) % MOD;
            // single
            sum[cur] = (sum[cur] + cur) % MOD;
            total[cur] = (total[cur] + 1) % MOD;
        }
        for (int i = 0;i <= 100000;i ++) {
            ans = (ans + sum[i]) % MOD;
        }
        return (int) ans;
    }

}",1448223842
xs_pg,xs_pg,99,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        for i in range(n):
            if i + 2 * k > n:
                return False
            f = True
            for j in range(i, i+k-1):
                if nums[j] >= nums[j+1]:
                    f = False
            for j in range(i+k, i+k+k-1):
                if nums[j] >= nums[j+1]:
                    f = False
            if f:
                return True
        ",1448182353
xs_pg,xs_pg,99,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        v = [1] * n
        for i in range(n-2, -1, -1):
            if nums[i] < nums[i+1]:
                v[i] = v[i+1] + 1
        # print(v)
        
        def check(x):
            for i in range(n):
                if i + 2 * x > n:
                    return False
                if v[i] >= x and v[i+x] >= x:
                    return True
        
        l, r = 1, n // 2
        while l < r:
            mi = (l + r + 1) >> 1
            if check(mi):
                l = mi
            else:
                r = mi - 1
        
        return l
        ",1448192098
xs_pg,xs_pg,99,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        mod = 10 ** 9 + 7
        n = len(s)
        os = 0
        for x in s:
            if x == '1':
                os += 1
        zs = n - os
        
        if k == 1:
            if os == 1:
                return n - 1
            else:
                return n
        
        a = []
        def f(x):
            cnt = 0
            while x != 1:
                x = x.bit_count()
                cnt += 1
            return cnt
        d = defaultdict(list)
        for x in range(1, 802):
            if f(x) < k and x <= n:
                a.append(x)
        # print(a)
        
        C = [[0 for _ in range(n+1)] for _ in range(n+1)]
        C[0][0] = 1
        for i in range(1, n+1):
            for j in range(i+1):
                if j:
                    C[i][j] += C[i-1][j-1]
                if j != i:
                    C[i][j] += C[i-1][j]
                C[i][j] %= mod
        # print(C)
        
        @cache
        def dp(index, left):
            if index + left > n:
                return 0
            if left == 0:
                return 1
            if s[index] == '0':
                return dp(index+1, left)
            else:
                return dp(index+1, left-1) + C[n-index-1][left] % mod
        
        ans = 0
        for x in a:
            # print(x, dp(0, x))
            ans += dp(0, x)
        
        if f(os) < k:
            ans -= 1
        
        return ans % mod
        
        
",1448247934
xs_pg,xs_pg,99,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        n = len(nums)
        mod = 10 ** 9 + 7
        
        cs = defaultdict(int)
        vs = defaultdict(int)
        
        for i in range(n):
            x = nums[i]
            cs[x] += 1
            vs[x] += x
            for y in [x-1, x+1]:
                if y not in cs:
                    continue
                c, v = cs[y], vs[y]
                cs[x] += c
                vs[x] += v + x * c
            cs[x] %= mod
            vs[x] %= mod
        
        ans = 0
        for k in vs:
            ans += vs[k]
        return ans % mod
                
        ",1448213317
parallel_stream,parallel_stream,101,3612,java,"class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        return IntStream.rangeClosed(0, nums.size() - 2 * k)
                .anyMatch(i -> isStrictlyIncreasing(nums.subList(i, i + k)) && isStrictlyIncreasing(nums.subList(i + k, i + 2 * k)));
    }

    private boolean isStrictlyIncreasing(List<Integer> sublist) {
        return IntStream.range(0, sublist.size() - 1)
                .allMatch(i -> sublist.get(i) < sublist.get(i + 1));
    }
}",1448183475
parallel_stream,parallel_stream,101,3619,java,"class Solution {
  public int maxIncreasingSubarrays(List<Integer> nums) {
    int n = nums.size();
    int[] left = new int[n];
    int[] right = new int[n];
    IntStream.range(0, n)
        .forEach(i -> left[i] = (i == 0 || nums.get(i) <= nums.get(i - 1)) ? 1 : left[i - 1] + 1);
    IntStream.iterate(n - 1, i -> i >= 0, i -> i - 1)
        .forEach(i -> right[i] = (i == n - 1 || nums.get(i) >= nums.get(i + 1)) ? 1 : right[i + 1] + 1);
    return IntStream.range(1, n).map(i -> Math.min(left[i - 1], right[i])).max().orElse(0);
  }
}",1448190507
parallel_stream,parallel_stream,101,3631,java,"class Solution {
  private static final int MOD = 1_000_000_007;

  public int countKReducibleNumbers(String s, int k) {
    int n = s.length();
    int[] steps = new int[n + 1];
    steps[1] = 0;
    IntStream.rangeClosed(2, n).forEach(c -> steps[c] = 1 + (c > 0 ? steps[popCount(c)] : 0));
    long[][][] dp = new long[n + 1][2][2];
    dp[0][1][0] = 1;
    for (int i = 0; i < n; i++) {
      long[][][] dpn = new long[n + 1][2][2];
      int bit = s.charAt(i) - '0';
      for (int c = 0; c <= n; c++) {
        for (int p = 0; p <= 1; p++) {
          for (int q = 0; q <= 1; q++) {
            if (dp[c][p][q] != 0) {
              int limit = p == 1 ? bit : 1;
              for (int r = 0; r <= limit; r++) {
                int np = (p == 1 && r == limit) ? 1 : 0;
                int nq = (q == 1 || r == 1) ? 1 : 0;
                int nc = nq == 1 ? c + r : 0;
                if (nc <= n) {
                  dpn[nc][np][nq] = (dpn[nc][np][nq] + dp[c][p][q]) % MOD;
                }
              }
            }
          }
        }
      }
      dp = dpn;
    }
    long ans = 0;
    for (int c = 1; c <= n; c++) {
      if (steps[c] <= k - 1) {
        ans = (ans + dp[c][0][1] + dp[c][1][1]) % MOD;
      }
    }
    int count = 0;
    for (char ch : s.toCharArray()) {
      if (ch == '1') {
        count++;
      }
    }
    if (count > 0 && steps[count] <= k - 1) {
      ans = (ans - 1 + MOD) % MOD;
    }
    return (int) ans;
  }

  private int popCount(int x) {
    int count = 0;
    while (x > 0) {
      count += x & 1;
      x >>= 1;
    }
    return count;
  }
}",1448241323
parallel_stream,parallel_stream,101,3646,java,"class Solution {

  private static final int MOD = 1_000_000_007;
  private static final int MAX = 100001;
  
  public int sumOfGoodSubsequences(int[] nums) {
    long[] c = new long[MAX];
    long[] s = new long[MAX];
    AtomicLong ans = new AtomicLong();
    Arrays.stream(nums).forEach(num -> {
      long cnt = (1 + (num > 0 ? c[num - 1] : 0) + (num < 100000 ? c[num + 1] : 0)) % MOD;
      long sm = (num + (num > 0 ? s[num - 1] : 0) + (num > 0 ? (num * c[num - 1]) % MOD : 0)
          + (num < 100000 ? s[num + 1] : 0) + (num < 100000 ? (num * c[num + 1]) % MOD : 0)) % MOD;
      c[num] = (c[num] + cnt) % MOD;
      s[num] = (s[num] + sm) % MOD;
      ans.set((ans.get() + sm) % MOD);
    });
    return (int) ans.get();
  }
}",1448202499
arignote,arignote,102,3612,java,"class Solution {

    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        return maxIncreasingSubarrays(nums) >= k;
    }

    public int maxIncreasingSubarrays(List<Integer> nums) {
        int max = 1;
        for (int i = 1, j = 0, k = 0; i <= nums.size(); i++) {
            if (i == nums.size() || nums.get(i) <= nums.get(i - 1)) {
                max = Math.max(max, Math.max((i - j) / 2, Math.min(k, i - j)));
                k = i - j;
                j = i;
            }
        }
        return max;
    }
}",1448241663
arignote,arignote,102,3619,java,"class Solution {

    public int maxIncreasingSubarrays(List<Integer> nums) {
        int max = 1;
        for (int i = 1, j = 0, k = 0; i <= nums.size(); i++) {
            if (i == nums.size() || nums.get(i) <= nums.get(i - 1)) {
                max = Math.max(max, Math.max((i - j) / 2, Math.min(k, i - j)));
                k = i - j;
                j = i;
            }
        }
        return max;
    }
}",1448241339
arignote,arignote,102,3631,java,"class Solution {

    public int countKReducibleNumbers(String s, int k) {
        return countKReducibleNumbers(0, 1, 0, s, k, new Integer[s.length()][s.length()][2]);
    }

    private int countKReducibleNumbers(int i, int flag, int count, String s, int k, Integer[][][] dp) {
        if (i == s.length()) {
            for (int j = 1; j < k; j++) {
                count = Integer.bitCount(count);
            }
            return flag < 1 && count == 1 ? 1 : 0;
        } else if (dp[i][count][flag] == null) {
            dp[i][count][flag] = (countKReducibleNumbers(i + 1, flag > 0 && s.charAt(i) == '0' ? 1 : 0, count, s, k, dp) + (flag == 0 || s.charAt(i) > '0' ? countKReducibleNumbers(i + 1, flag > 0 && s.charAt(i) > '0' ? 1 : 0, count + 1, s, k, dp) : 0)) % 1000000007;
        }
        return dp[i][count][flag];
    }
}",1448241037
arignote,arignote,102,3646,java,"class Solution {

    public int sumOfGoodSubsequences(int[] nums) {
        HashMap<Integer, long[]> map = new HashMap<>();
        for (int num : nums) {
            map.put(num, new long[] { (map.getOrDefault(num, new long[2])[0] + map.getOrDefault(num - 1, new long[2])[0] + map.getOrDefault(num + 1, new long[2])[0] + (map.getOrDefault(num - 1, new long[2])[1] + map.getOrDefault(num + 1, new long[2])[1] + 1) * num) % 1000000007, (map.getOrDefault(num, new long[2])[1] + map.getOrDefault(num - 1, new long[2])[1] + map.getOrDefault(num + 1, new long[2])[1] + 1) % 1000000007 });
        }
        long sum = 0;
        for (long[] i : map.values()) {
            sum += i[0];
        }
        return (int) (sum % 1000000007);
    }
}",1448240721
Ashwanth K,ashwanthkannan,104,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
         int n = nums.size();
        vector<int> dp(n , 0);
        
        dp[n-1] = 1;
        
        for(int i = n-2 ; i >= 0 ; i --)
        {
            if(nums[i] < nums[i+1])
            {
                dp[i] = 1 + dp[i+1];
            }
            else
            {
                dp[i] = 1;
            }
        }
        
        
        for(int i = 0 ; i+k < n ; i ++)
        {
            if((dp[i] >= k) && (dp[i+k] >= k)) return true;
        }
        return false;
    }
};",1448249626
Ashwanth K,ashwanthkannan,104,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        
        
        int n = nums.size();
        vector<int> dp(n , 0);
        
        dp[n-1] = 1;
        
        for(int i = n-2 ; i >= 0 ; i --)
        {
            if(nums[i] < nums[i+1])
            {
                dp[i] = 1 + dp[i+1];
            }
            else
            {
                dp[i] = 1;
            }
            
            
            
           // cout << dp[i] << "" "";
        }
        
        //cout << endl;
        
        int fans = 0;
        
        int j = -1;
        for(int i = n-1 ; i >= 0 ; i --)
        {
            if(i+1 < n  && nums[i] >= nums[i+1])
            {
                j = i+1;
            }
            
            fans = max(fans , dp[i]/2);
            if(j != -1)
            {
                int k = j-i;
                if((dp[i] >= k) && (dp[j] >= k))
                {
                    fans = max(fans , k);
                }
                
              //  cout << i << j << endl;
            }
            
        }
        
        return fans;
        
    }
};",1448247600
Ashwanth K,ashwanthkannan,104,3631,cpp,"#define ll long long

class Solution {
public:
    
    int precalc[1000];
    int K;
    string ss;
    
    
    ll dp[1005][1005][2];
    ll mod = 1e9 + 7;
    
    ll recur(int i , int sb , bool tight)
    {   
        
        if(i == -1)
        {
            return (!tight) && (precalc[sb] <= K);
        }
        
        
        if(dp[i][sb][tight]  != -1) return dp[i][sb][tight];
    
        ll ans = 0;
        for(int b = 0 ; b < 2 ; b ++)
        {
            bool allow = (!tight) || (b <= (ss[i]-'0')); 
            if(allow)
            {
                bool newtight = tight & ((ss[i] - '0') == b); 
                ans += recur(i-1  , sb + ((b ==1)?1:0) , newtight);
            }
        }
        
        
        if(ans >= mod) ans -= mod;
        
        return dp[i][sb][tight] = ans;
    }
    
    int countKReducibleNumbers(string s, int k) {
        
        int n = s.length();
        ss = s;
        K = k;
        reverse(ss.begin() , ss.end());
        
        
        
        for(int i = 0 ; i <= n ; i ++)
        {
            for(int j = 0 ; j <= n ; j ++)
            {
                dp[i][j][0] = -1;
                dp[i][j][1] = -1;
            }
        }
        
        precalc[1] = 1;
        precalc[0] = 1500;
        
        for(int i = 2 ; i <= n ; i ++)
        {
            precalc[i] = 1 + precalc[__builtin_popcountl(i)];
        }
        
        ll ans = recur(n-1 , 0 , 1);
        ans %= mod;
        if(ans < 0) ans += mod;
        
        return ans;
        
    }
};",1448216809
Ashwanth K,ashwanthkannan,104,3646,cpp,"#define ll long long


ll mod = 1e9 + 7;

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        
        ll n = nums.size();
        ll pref[n];
        ll suff[n];
        
        map<ll  , ll> info;
        
        for(int i = 0 ; i < n ; i ++)
        {
            ll v = info[nums[i]-1] + info[nums[i]+1] + 1;
            info[nums[i]] += v;
            info[nums[i]] %=mod;
            pref[i] = v;
        }
        
        
        info.clear();
        
        for(int i = n-1; i >=0 ; i --)
        {
            ll v = info[nums[i]-1] + info[nums[i]+1] + 1;
            info[nums[i]] += v;
            info[nums[i]] %=mod;
            suff[i] = v;
        }
        
        
        
        ll ans = 0;
        for(int i = 0 ; i < n ; i ++)
        {
            ans += (((nums[i]*pref[i])%mod)*suff[i])%mod;
            ans %= mod;
        }
        
        
        return ans;
    }
};",1448188337
turneja,turneja,105,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& a, int k) {
        int n = a.size();
        vector<int> pos;
        for (int i = 1; i < n; i++) {
            if (a[i] <= a[i - 1]) {
                pos.push_back(i);
            }
        }
        if (pos.empty()) {
            int ans = n / 2;
            if (ans >= k) {
                return true;
            }
            return false;
        }
        int ans = 1;
        for (int i = 0; i < n; i++) {
            int j = lower_bound(pos.begin(), pos.end(), i + 1) - pos.begin();
            if (j == pos.size()) {
                ans = max(ans, (n - i) / 2);
                continue;
            }
            int l = pos[j] - 1, r = ((j == pos.size() - 1) ? n - 1 : pos[j + 1] - 1);
            ans = max(ans, (l - i + 1) / 2);
            ans = max(ans, min(l - i + 1, r - l));
        }
        if (ans >= k) {
            return true;
        }
        return false;
    }
};",1448198724
turneja,turneja,105,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& a) {
        int n = a.size();
        vector<int> pos;
        for (int i = 1; i < n; i++) {
            if (a[i] <= a[i - 1]) {
                pos.push_back(i);
            }
        }
        if (pos.empty()) {
            int ans = n / 2;
            return ans;
        }
        int ans = 1;
        for (int i = 0; i < n; i++) {
            int j = lower_bound(pos.begin(), pos.end(), i + 1) - pos.begin();
            if (j == pos.size()) {
                ans = max(ans, (n - i) / 2);
                continue;
            }
            int l = pos[j] - 1, r = ((j == pos.size() - 1) ? n - 1 : pos[j + 1] - 1);
            ans = max(ans, (l - i + 1) / 2);
            ans = max(ans, min(l - i + 1, r - l));
        }
        return ans;
    }
};",1448195983
turneja,turneja,105,3631,cpp,"const int N = 805;
const long long M = 1e9 + 7;
long long dp[N][N][3];
class Solution {
public:
    bool dfs(int n, int k) {
        if (k == 0) {
            return n == 1;
        }
        n = __builtin_popcount(n);
        return dfs(n, k - 1);
    }
    
    long long calc(string s, int k) {
        int n = s.size();
        if (s[0] == '1') {
            dp[0][1][2] = 1;
        } else {
            dp[0][1][1] = 1;
        }
        
        for (int i = 1; i < n; i++) {
            for (int j = 1; j <= i + 1; j++) {
                if (s[i] == '1') {
                    dp[i][j][0] = (dp[i][j][0] + dp[i - 1][j - 1][0]) % M;
                    dp[i][j][1] = (dp[i][j][1] + dp[i - 1][j - 1][1]) % M;
                    dp[i][j][2] = (dp[i][j][2] + dp[i - 1][j - 1][2]) % M;
                    
                    dp[i][j][1] = (dp[i][j][1] + dp[i - 1][j][1]) % M;
                    dp[i][j][0] = (dp[i][j][0] + dp[i - 1][j][0] + dp[i - 1][j][2]) % M;
                } else {
                    dp[i][j][0] = (dp[i][j][0] + dp[i - 1][j - 1][0]) % M;
                    dp[i][j][1] = (dp[i][j][1] + dp[i - 1][j - 1][1] + dp[i - 1][j - 1][2]) % M;
                    
                    dp[i][j][0] = (dp[i][j][0] + dp[i - 1][j][0]) % M;
                    dp[i][j][1] = (dp[i][j][1] + dp[i - 1][j][1]) % M;
                    dp[i][j][2] = (dp[i][j][2] + dp[i - 1][j][2]) % M;
                    
                }
            }
        }
        long long ans = 0;
        for (int j = 1; j <= n; j++) {
            bool can = dfs(j, k - 1);
            if (!can) {
                continue;
            }
            for (int i = 0; i < n; i++) {
                ans = (ans + dp[i][j][0]) % M;
                if (i != n - 1) {
                    ans = (ans + dp[i][j][1] + dp[i][j][2]) % M;
                }
            }
        }
        return ans;
        
    }
        
    int countKReducibleNumbers(string s, int k) {
        long long ans = calc(s, k);
        int n = s.size();
        for (int i = 0; i < n; i++) {
            for (int j = 1; j <= n; j++) {
                dp[i][j][0] = 0;
                dp[i][j][1] = 0;
                dp[i][j][2] = 0;
            }
        }
        return ans % M;
    }
};",1448242299
turneja,turneja,105,3646,cpp,"const int M = 1e9 + 7;
const int N = 1e5 + 5;
class Solution {
public:
    pair<long long, long long> dp[N];
    bool seen[N];
    
    int sumOfGoodSubsequences(vector<int>& a) {
        int n = a.size();
        for (int i = 0; i < n; i++) {
            if (a[i] != 0) {
                dp[a[i]].first = (dp[a[i]].first + dp[a[i] - 1].first) % M;
                dp[a[i]].second = (dp[a[i]].second + dp[a[i] - 1].first * a[i] + dp[a[i] - 1].second) % M;
            }
            dp[a[i]].first = (dp[a[i]].first + dp[a[i] + 1].first) % M;
            dp[a[i]].second = (dp[a[i]].second + dp[a[i] + 1].first * a[i] + dp[a[i] + 1].second) % M;
            dp[a[i]].first = (dp[a[i]].first + 1) % M;
            dp[a[i]].second = (dp[a[i]].second + a[i]) % M;
        }
        long long ans = 0;
        for (int i = 0; i < n; i++) {
            if (!seen[a[i]]) {
                seen[a[i]] = true;
                ans += dp[a[i]].second;
            }
        }
        return ans % M;
    }
};",1448214181
hanbro0112,hanbro0112,108,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        cnt = [1] * len(nums)
        i = 0
        while i < n:
            j = i
            s = 1
            while j + 1 < n and nums[j] < nums[j + 1]:
                s += 1
                j += 1
            for t in range(i, i + s):
                cnt[t] = s - (t - i)
            i = j + 1
        return any(cnt[i] >= k and cnt[i + k] >= k for i in range(n - k))",1448188603
hanbro0112,hanbro0112,108,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        cnt = [1] * len(nums)
        i = 0
        while i < n:
            j = i
            s = 1
            while j + 1 < n and nums[j] < nums[j + 1]:
                s += 1
                j += 1
            for t in range(i, i + s):
                cnt[t] = s - (t - i)
            i = j + 1
        
        ans = i = 0
        for j in range(n):
            ans = max(ans, min(j - i, cnt[j]))
            if i + cnt[i] <= j:
                i = j
            
        return ans",1448198445
hanbro0112,hanbro0112,108,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        MOD = 10 ** 9 + 7
        n = len(s)
        op = [0] * (n + 1)
        for num in range(2, n + 1):
            x = num
            while x != 1:
                op[num] += 1
                x = x.bit_count()
        @cache
        def dfs(i, count, isLimit, isNum) -> int: 
            if i == n:  
                return int(isNum and 1 + op[count] <= k)
            res = 0
            if not isNum:
                res += dfs(i + 1, count, False, False)
            low = 0 if isNum else 1
            up = int(s[i]) if isLimit else 1
            for d in range(low, up + 1):
                if isNum or d == 1:
                    res += dfs(i + 1, count + d, isLimit and d == up, True)
            return res % MOD
        
        return dfs(0, 0, True, False) - int(1 + op[s.count('1')] <= k)",1448243198
hanbro0112,hanbro0112,108,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        MOD = 10 ** 9 + 7
        cnt = Counter()
        value = Counter()
        ans = 0
        for x in nums:
            upVal = (value[x + 1] + x * cnt[x + 1]) % MOD
            downVal = (value[x - 1] + x * cnt[x - 1]) % MOD
            cnt[x] = (cnt[x] + cnt[x + 1] + cnt[x - 1] + 1) % MOD
            value[x] = (value[x] + upVal + downVal + x) % MOD
            ans = (ans + upVal + downVal + x) % MOD
        return ans",1448214710
HFDnpkp1cs,HFDnpkp1cs,109,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        for(int i = 0; i + 2 * k - 1 < n; i++) {
            if(check(nums, i, i + k - 1) && check(nums, i + k, i + 2 * k - 1))
                return true;
        }
        return false;
    }

    bool check(vector<int>& nums, int lo, int hi) {
        int val = nums[lo];
        for(int i = lo + 1; i <= hi; i++) {
            if(nums[i] <= val)
                return false;
            val = nums[i];
        }
        return true;
    }
};",1448182920
HFDnpkp1cs,HFDnpkp1cs,109,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp(n, 1);

        for(int i = 1; i < n; i++) {
            if(nums[i] > nums[i - 1]) {
                dp[i] = max(dp[i], dp[i - 1] + 1);
            }
        }

        int lo = 1, hi = n / 2;
        while(lo < hi) {
            int mid = (lo + hi + 1) / 2;
            if(check(dp, mid)) {
                lo = mid;
            }
            else {
                hi = mid - 1;
            }
        }
        return lo;
    }

    bool check(vector<int>& dp, int len) {
        int n = dp.size();
        for(int i = 0; i + 2 * len - 1 < n; i++) {
            int a = dp[i + len - 1], b = dp[i + 2 * len - 1];
            if(a >= len && b >= len)
                return true;
        }
        return false;
    }
};",1448188227
HFDnpkp1cs,HFDnpkp1cs,109,3631,cpp,"using ll = long long;
ll mod = 1e9 + 7;

ll dp[810];
ll dp2[810][810];

ll mem[810][810];

ll nCr(ll n, ll r) 
{
    if (r == 0 || r == n)
        return 1;
    if(mem[n][r] > 0)
        return mem[n][r];
    mem[n][r] = (nCr(n-1, r-1) + nCr(n-1, r)) % mod;
    return mem[n][r];
}

class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        if(s == ""0"")
            return 0;
        
        int n = s.size();

        memset(dp, 0x3f, sizeof(dp));
        memset(dp2, 0, sizeof(dp2));
        
        dp[1] = 0;
        for(int i = 2; i <= 800; i++) {
            int cnt = __builtin_popcount(i);
            dp[i] = 1 + dp[cnt];
        }

        for(int i = 0; i <= n; i++)
            dp2[i][0] = 1;

        for(int i = n - 1; i >= 0; i--) {
            for(int j = 1; j <= n - i; j++) {
                if(s[i] == '0') {
                    dp2[i][j] = dp2[i + 1][j];
                }
                else {
                    dp2[i][j] = dp2[i + 1][j - 1];
                    if(j <= n - i - 1) {
                        dp2[i][j] = (dp2[i][j] + nCr(n - i - 1, j)) % mod;
                    }
                }
            }
        }

        ll ret = 0;
        for(int i = 1; i <= n; i++) {
            if(dp[i] < k) {
                // cout << i << "" "" << dp[i] << "" "" << dp2[0][i] << endl;
                ret = (ret + dp2[0][i]) % mod;
            }
        }

        int cnt = 0;
        for(auto c : s) {
            if(c == '1')
                cnt++;
        }
        if(dp[cnt] < k)
            ret--;
        if(ret < 0)
            ret += mod;

        return ret;
    }
};",1448251252
HFDnpkp1cs,HFDnpkp1cs,109,3646,cpp,"using ll = long long;
ll mod = 1e9 + 7;

ll cnt[100010];
ll sum[100010];

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        ll n = nums.size();
        memset(cnt, 0, sizeof(cnt));
        memset(sum, 0, sizeof(sum));

        for(int i = 0; i < n; i++) {
            int val = nums[i];
            if(val - 1 >= 0) {
                sum[val] = (sum[val] + cnt[val - 1] * val % mod + sum[val - 1]) % mod;
                cnt[val] = (cnt[val] + cnt[val - 1]) % mod;
            }
            if(val + 1 <= 1e5) {
                sum[val] = (sum[val] + cnt[val + 1] * val % mod + sum[val + 1]) % mod;
                cnt[val] = (cnt[val] + cnt[val + 1]) % mod;
            }
            sum[val] = (sum[val] + val) % mod;
            cnt[val] = (cnt[val] + 1) % mod;
        }

        ll ret = 0;
        for(int i = 0; i <= 1e5; i++) {
            ret = (ret + sum[i]) % mod;
        }
        return ret;
    }
};",1448199620
g129512,g129512,111,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n=len(nums)
        pre=[1]*n
        suf=[1]*n
        for i in range(1,n):
            if nums[i]>nums[i-1]:
                pre[i]=pre[i-1]+1
        res=1
        for i in range(n-2,0,-1):
            if nums[i]<nums[i+1]:
                suf[i]=suf[i+1]+1
            res=max(res,min(pre[i-1],suf[i]))
        return res>=k",1448244871
g129512,g129512,111,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n=len(nums)
        pre=[1]*n
        suf=[1]*n
        for i in range(1,n):
            if nums[i]>nums[i-1]:
                pre[i]=pre[i-1]+1
        res=1
        for i in range(n-2,0,-1):
            if nums[i]<nums[i+1]:
                suf[i]=suf[i+1]+1
            res=max(res,min(pre[i-1],suf[i]))
        return res",1448244530
g129512,g129512,111,3631,python3,"from collections import Counter
from functools import cache


class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        n=len(s)
        M=10**9+7
        @cache
        def dfs(i,lim):
            if i==n:
                res = [0]*(n+1)
                res[0]=1
                return res

            dp1=dfs(i+1,lim and s[i]=='0')
            res=[*dp1]
            if not lim or s[i]=='1':
                dp2=dfs(i+1, lim and s[i]=='1')
                for j in range(n):
                    res[j+1]+=dp2[j]
                    res[j+1]%=M
            return res
        
        def red(x):
            res=0
            while x>1:
                x=x.bit_count()
                res+=1
            return res

        dp=dfs(0,True)
        dp[Counter(s)['1']]-=1
        res=0
        for i in range(1,n):
            if red(i)<k:
                res+=dp[i]
            res%=M
        return res",1448242457
g129512,g129512,111,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        mx=max(nums)
        n=len(nums)
        dp=[[0,0] for _ in range(mx+1)]
        M=10**9+7
        for i in range(n):
            ns,nc=0,0
            if nums[i]>0:
                s,c=dp[nums[i]-1]
                nc+=c
                ns+=c*nums[i]+s
            if nums[i]+1<=mx:
                s,c=dp[nums[i]+1]
                nc+=c
                ns+=c*nums[i]+s
            nc+=1
            ns+=nums[i]
            dp[nums[i]][0]+=ns
            dp[nums[i]][1]+=nc
            dp[nums[i]][0]%=M
            dp[nums[i]][1]%=M
        res=0
        for i in range(mx+1):
            res+=dp[i][0]
        return res%M
        ",1448242651
Sergei Sobol,sobols,112,3612,cpp,"class Solution {
public:
    int FindK(const vector<int>& nums) {
        int n = nums.size();
        int last = -1;
        int res = 0;
        for (int i = 0; i < n; ) {
            int j = i + 1;
            while (j < n && nums[j-1] < nums[j]) {
                ++j;
            }
            int len = j - i;
            res = max(res, len / 2);
            if (last != -1) {
                res = max(res, min(last, len));
            }
            last = len;
            i = j;
        }
        return res;
    }

    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        return k <= FindK(nums);
    }
};",1448193278
Sergei Sobol,sobols,112,3619,cpp,"class Solution {
public:
    int FindK(const vector<int>& nums) {
        int n = nums.size();
        int last = -1;
        int res = 0;
        for (int i = 0; i < n; ) {
            int j = i + 1;
            while (j < n && nums[j-1] < nums[j]) {
                ++j;
            }
            int len = j - i;
            res = max(res, len / 2);
            if (last != -1) {
                res = max(res, min(last, len));
            }
            last = len;
            i = j;
        }
        return res;
    }

    int maxIncreasingSubarrays(vector<int>& nums) {
        return FindK(nums);
    }
};",1448191907
Sergei Sobol,sobols,112,3631,cpp,"constexpr int MOD = 1'000'000'007;

void Add(int& x, int y) {
    x += y;
    if (x >= MOD) {
        x -= MOD;
    }
}

class Solution {
public:
    bool IsKReducible(int n, int k) {
        while (n != 1 && k > 0) {
            n = popcount((unsigned)n);
            k--;
        }
        return n == 1;
    }

    int countKReducibleNumbers(string s, int k) {
        const int len = s.size();
        vector<bool> r(len + 1);
        for (int i = 0; i <= len; ++i) {
            r[i] = IsKReducible(i, k - 1);
        }
        
        vector<vector<int>> c(len + 1, vector<int>(len + 1));
        for (int i = 0; i <= len; ++i) {
            c[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                Add(c[i][j], c[i-1][j]);
                Add(c[i][j], c[i-1][j-1]);
            }
        }
        
        int prev = 0;
        int ans = 0;
        for (int i = 0; i < len; ++i) {
            if (s[i] == '1') {
                int rest = len - 1 - i;

                for (int j = 0; j <= rest; ++j) {
                    if (r[prev + j]) {
                        Add(ans, c[rest][j]);
                    }
                }
                
                prev++;
            }
        }
        return ans;
    }
};",1448252669
Sergei Sobol,sobols,112,3646,cpp,"constexpr int MOD = 1'000'000'007;

void Add(int& x, int y) {
    x += y;
    if (x >= MOD) {
        x -= MOD;
    }
}

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        unordered_map<int, pair<int, int>> f; // (count, sum)
        int ans = 0;
        for (int x : nums) {
            auto& res = f[x];
            Add(res.first, 1);
            Add(res.second, x);
            
            for (int y : {x-1, x+1}) {
                if (auto it = f.find(y); it != f.end()) {
                    const auto& val = it->second;
                    Add(res.first, val.first);
                    Add(res.second, val.second);
                    Add(res.second, ((long long)x * val.first) % MOD);
                }
            }
        }
        for (const auto& [x, res] : f) {
            Add(ans, res.second);
        }
        return ans;
    }
};",1448217408
Superultra,Superultra,113,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& A, int k) {
        int n = A.size();
        vector<int> P(n), S(n);

        int l = 0;
        for (int i = 0; i < n; i++){
            if (i and A[i] <= A[i - 1])
                l = i;
            P[i] = i - l + 1;
        }

        int r = n - 1;
        for (int i = n - 1; i >= 0; i--){
            if (i + 1 < n and A[i] >= A[i + 1])
                r = i;
            S[i] = r - i + 1;
        }

        for (int i = 0; i < n; i++){
            int v1 = P[i];
            int v2 = (i + 1 < n ? S[i + 1] : 0);
            if (v1 >= k and v2 >= k)
                return true;
        }
        return false;
    }
};",1448245336
Superultra,Superultra,113,3619,cpp,"#include <bits/stdc++.h>
using namespace std;

#define FOR(i, x, y) for (int i = x; i < y; i++)

#define ll long long

#define pb push_back
#define all(x) x.begin(), x.end()
#define sz(x) x.size()

#define pii pair<int, int>
#define f first
#define s second
#define mp make_pair

const int MOD = 1e9 + 7;

class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& A) {
        int n = A.size();
        vector<int> P(n), S(n);

        int l = 0;
        for (int i = 0; i < n; i++){
            if (i and A[i] <= A[i - 1])
                l = i;
            P[i] = i - l + 1;
        }

        int r = n - 1;
        for (int i = n - 1; i >= 0; i--){
            if (i + 1 < n and A[i] >= A[i + 1])
                r = i;
            S[i] = r - i + 1;
        }

        int ans = 0;

        for (int i = 0; i < n; i++){
            ans = max(ans, min(P[i], (i + 1 < n ? S[i + 1] : 0)));
        }
        return ans;
    }
};",1448243472
Superultra,Superultra,113,3631,cpp,"#include <bits/stdc++.h>
using namespace std;

#define FOR(i, x, y) for (int i = x; i < y; i++)

#define ll long long

#define pb push_back
#define all(x) x.begin(), x.end()
#define sz(x) x.size()

#define pii pair<int, int>
#define f first
#define s second
#define mp make_pair

const int MOD = 1e9 + 7;

class Solution {
public:
    int countKReducibleNumbers(string S, int k) {
        int n = S.size();

        vector<vector<ll>> choose(n + 5, vector<ll>(n + 5, 0));

        for (int i = 0; i <= n and (choose[i][0] = 1); i++)
            for (int j = 1; j <= i; j++)
                choose[i][j] = (choose[i - 1][j] + choose[i - 1][j - 1]) % MOD;

        auto countNums = [&](int bits){
            int cnt = 0;
            ll ret = 0;

            for (int i = 0; i < n; i++){
                if (S[i] == '1'){
                    // If this is the first one we turn to 0
                    int rem = n - i - 1;

                    if (bits - cnt >= 0)
                        ret = (ret + choose[rem][bits - cnt]) % MOD;
                    
                    cnt++;
                }
            }
            // include the number itself
            // if (cnt == bits)
                // ret = (ret + 1) % MOD;
            
            return ret;
        };
        ll ans = 0;

        for (int i = 1; i <= n; i++){
            // can we reduce i in k - 1 moves
            int moves = 0;
            int num = i;

            while (num != 1){
                num = __builtin_popcount(num);
                moves++;
            }

            // All numbers with i bits
            if (moves + 1 <= k){
                // cout << i << "": "" << countNums(i) << endl;
                ans = (ans + countNums(i)) % MOD;
            }
        }

        return ans;
    }
};",1448210983
Superultra,Superultra,113,3646,cpp,"#include <bits/stdc++.h>
using namespace std;

#define FOR(i, x, y) for (int i = x; i < y; i++)

#define ll long long

#define pb push_back
#define all(x) x.begin(), x.end()
#define sz(x) x.size()

#define pii pair<int, int>
#define f first
#define s second
#define mp make_pair

const int MOD = 1e9 + 7;

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& A) {
        // number of ss ending at i
        unordered_map<int, ll> ways, dp;
        ll ans = 0;
        
        for (int i : A){
            ll nw = ((dp[i - 1] + i * ways[i - 1]) + (dp[i + 1] + i * ways[i + 1]) + i) % MOD;
            dp[i] = (dp[i] + nw) % MOD;

            ll nwWays = (ways[i - 1] + ways[i + 1] + 1) % MOD;
            ways[i] = (ways[i] + nwWays) % MOD;
        }
        for (auto [_, v] : dp)
            ans = (ans + v) % MOD;
        return ans;
    }
};",1448234980
Abhay Singh,FSPINDLE,115,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
          int n = nums.size() , ans = 1;
            
             vector <int> A(n , 1) , B(n , 1) ;
            
             for(int i = 1 ; i < n ; i ++){
                    if(nums[i] > nums[i - 1]) A[i] = A[i - 1] + 1 ;
             }
             for(int i = n - 2 ; i >= 0 ; i --){
                       if(nums[i] < nums[i + 1]) B[i] = B[i + 1] + 1 ;
             }
            
             for(int i = 1  ; i < n; i ++){
                      ans = max(ans , min(B[i] , A[i - 1])) ;
             }
            return ans >= k;
    }
};",1448186698
Abhay Singh,FSPINDLE,115,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
                    
             int n = nums.size() , ans = 1;
            
             vector <int> A(n , 1) , B(n , 1) ;
            
             for(int i = 1 ; i < n ; i ++){
                    if(nums[i] > nums[i - 1]) A[i] = A[i - 1] + 1 ;
             }
             for(int i = n - 2 ; i >= 0 ; i --){
                       if(nums[i] < nums[i + 1]) B[i] = B[i + 1] + 1 ;
             }
            
             for(int i = 1  ; i < n; i ++){
                      ans = max(ans , min(B[i] , A[i - 1])) ;
             }
            return ans;
    }
};",1448185919
Abhay Singh,FSPINDLE,115,3631,cpp,"class Solution {
public:
         int dp[801][801][3] ;
         const int mod = 1e9 + 7 ; 
        
    int countKReducibleNumbers(string s, int k) {
                   
               int n = s.size() ;
               memset(dp , -1 , sizeof(dp)) ;
            
                auto solve = [&](auto &&solve , int cnt , int k ){
                         
                           if(cnt == 1) return true ;
                           if(k == 0 || cnt == 0) return false ;
                           k -- ;
                         return solve(solve ,  __builtin_popcount(cnt) , k) ;
                }; 
            
               auto func = [&](auto &&func , int idx , int cnt , bool f) -> int{
                       
                         if(idx == n){
                                 if(f) return 0 ;
                                 return solve(solve , cnt , k - (cnt != 1)) ;
                         } 
                       
                           if(dp[idx][cnt][f] != -1) return dp[idx][cnt][f] ;     
                       
                       int ret  = 0 ;
                        if(f){
                            if(s[idx] == '1'){
                                 ret =  (func(func , idx + 1 , cnt + 1 , f) + func(func , idx + 1 , cnt , !f)) % mod ;     
                            } 
                            else{
                                ret = func(func , idx + 1 , cnt , f) % mod;    
                            }
                        }
                       else{
                              ret =  (func(func , idx + 1 , cnt + 1 , f) + func(func , idx + 1 , cnt , f)) % mod;       
                       }
                       return  dp[idx][cnt][f] =  ret ;
                       
               };
             
              int ans = func(func , 0 , 0 , 1) ;
            return ans;
    }
};",1448253196
Abhay Singh,FSPINDLE,115,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
                     
             int n = nums.size() ;
             int mx = *max_element(nums.begin() , nums.end()) + 10;
            
             vector <long long> dp1(mx) , dp2(mx) ;
            const int mod =1e9 + 7 ;
            
             for(auto num : nums){
                       

                     int prev = num - 1 ;
                     
                     if(prev >= 0){
                     dp1[num] += dp1[prev] ;
                     dp2[num] += (dp1[prev] *1ll* num) % mod  + dp2[prev];
                     }
                     prev = num + 1 ;
                     dp1[num] += dp1[prev]  ;
                     dp2[num] += (dp1[prev] *1ll* num ) % mod + dp2[prev] ;
                     dp2[num] += num ;
                     dp1[num] = 1 + dp1[num] ;
                     dp1[num] %= mod ;
                     dp2[num] %= mod ;
                                       
             }
            
             int ans = 0 ;
          //  for(auto num : {1 , 2}) cout << dp2[num] << endl;
            
            for(int i = 0 ; i < mx ; i ++) {
                   ans = (ans + dp2[i]) % mod ;
            }
            return ans ;
    } 
};",1448221440
yu46656,yu46656,118,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(std::vector<int>& nums, int k) {
        int n{ static_cast<int>(nums.size()) };

        std::vector<int> segs;

        int acc{ 1 };

        for (int i{ 1 }; i < n; ++i) {
            if (nums[i - 1] < nums[i]) {
                ++acc;
            } else {
                segs.push_back(acc);
                acc = 1;
            }
        }

        segs.push_back(acc);

        int ret{ 0 };

        for (auto seg : segs) { ret = std::max(ret, seg / 2); }

        int s{ static_cast<int>(segs.size()) };

        for (int i{ 1 }; i < s; ++i) {
            ret = std::max(ret, std::min(segs[i - 1], segs[i]));
        }

        return k <= ret;
    }
};
",1448187462
yu46656,yu46656,118,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(std::vector<int>& nums) {
        int n{ static_cast<int>(nums.size()) };

        std::vector<int> segs;

        int acc{ 1 };

        for (int i{ 1 }; i < n; ++i) {
            if (nums[i - 1] < nums[i]) {
                ++acc;
            } else {
                segs.push_back(acc);
                acc = 1;
            }
        }

        segs.push_back(acc);

        int ret{ 0 };

        for (auto seg : segs) { ret = std::max(ret, seg / 2); }

        int s{ static_cast<int>(segs.size()) };

        for (int i{ 1 }; i < s; ++i) {
            ret = std::max(ret, std::min(segs[i - 1], segs[i]));
        }

        return ret;
    }
};
",1448186438
yu46656,yu46656,118,3631,cpp,"class Solution {
public:
    static constexpr long long M{ 1000000007 };

    long long PowerMod(long long base, long long exp) {
        long long ret{ 1 };

        for (; 0 < exp; exp /= 2) {
            if (exp % 2 == 1) { ret = (ret * base) % M; }
            base = (base * base) % M;
        }

        return ret;
    }

    long long Factorial(long long x) {
        static std::vector<long long> table{ 1, 1, 2, 6 };

        while (static_cast<long long>(table.size()) <= x) {
            table.push_back(
                (table.back() * static_cast<long long>(table.size())) % M);
        }

        return table[x];
    }

    long long InvFactorial(long long x) {
        static std::unordered_map<long long, long long> table;

        auto iter{ table.find(x) };

        if (iter == table.end()) {
            iter = table.insert({ x, PowerMod(Factorial(x), M - 2) }).first;
        }

        return iter->second;
    }

    long long Combination(long long n, long long k) {
        return (Factorial(n) * ((InvFactorial(k) * InvFactorial(n - k)) % M)) %
               M;
    }

    long long Count(const std::string& s, int* cnts) {
        long long ret{ 0 };

        for (char c : s) {
            if (c == '0') {
                if (cnts[0] == 0) { break; }
                --cnts[0];
                continue;
            }

            if (0 < cnts[0]) {
                ret = (ret + Combination(cnts[0] + cnts[1] - 1, cnts[1])) % M;
            }

            if (cnts[1] == 0) { break; }

            --cnts[1];
        }

        return ret;
    }

    int GetK(int x) {
        int ret{ 0 };
        for (; 1 < x; x = __builtin_popcount(x)) { ++ret; }
        return ret;
    }

    int countKReducibleNumbers(const std::string& s, int k) {
        int n{ static_cast<int>(s.size()) };

        long long ret{ 0 };

        int cnts[2];

        for (int x{ 1 }; x <= n; ++x) {
            if (GetK(x) <= k - 1) {
                cnts[0] = n - x;
                cnts[1] = x;
                ret = (ret + Count(s, cnts)) % M;
            }
        }

        return ret;
    }
};
",1448246904
yu46656,yu46656,118,3646,cpp,"class Solution {
public:
    static constexpr long long M{ 1000000007 };

    template <typename Cntr, typename Key, typename Value>
    const Value& Find(const Cntr& cntr, const Key& key, const Value& value) {
        auto iter{ cntr.find(key) };
        return iter == cntr.end() ? value : iter->second;
    }

    int sumOfGoodSubsequences(std::vector<int>& nums) {
        int n{ static_cast<int>(nums.size()) };

        long long ret{ 0 };

        std::unordered_map<int, std::pair<long long, long long>> dp;

        for (auto num : nums) {
            auto l_iter{ dp.find(num - 1) };
            auto r_iter{ dp.find(num + 1) };

            long long cur_cnt{ 1 };
            long long cur_sum{ 0 };

            if (l_iter != dp.end()) {
                cur_cnt += l_iter->second.first;
                cur_sum += l_iter->second.second;
            }

            if (r_iter != dp.end()) {
                cur_cnt += r_iter->second.first;
                cur_sum += r_iter->second.second;
            }

            cur_cnt %= M;
            cur_sum = (cur_sum + num * cur_cnt) % M;

            ret = (ret + cur_sum) % M;

            auto& p{ dp.insert({ num, { 0, 0 } }).first->second };

            p.first = (p.first + cur_cnt) % M;
            p.second = (p.second + cur_sum) % M;
        }

        return static_cast<int>(ret);
    }
};
",1448212572
dirigibility,dirigibility,119,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        for i in range(len(nums)-2*k+1):
            if all(nums[j] < nums[j+1] for x in (i,i+k) for j in range(x,x+k-1)):
                return True
        return False",1448182278
dirigibility,dirigibility,119,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        runs = [1]
        for a,b in pairwise(nums):
            if a < b:
                runs[-1] += 1
            else:
                runs.append(1)
        return max(max(runs)//2,max((min(a,b) for a,b in pairwise(runs)),default=0))",1448185948
dirigibility,dirigibility,119,3631,python3,"mod = 10**9+7
@cache
def c(n,k):
    if n == k == 0:
        return 1
    if not 0 <= k <= n:
        return 0
    return (c(n-1,k-1)+c(n-1,k))%mod

@cache
def f(n):
    if n == 0:
        return inf
    if n == 1:
        return 0
    return f(n.bit_count())+1
    
class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        l = len(s)
        n = 0
        total = 0
        for i,b in enumerate(s,1):
            if b == '1':
                total += sum(c(l-i,j) for j in range(l-i+1) if f(n+j) < k)
                total %= mod
                n += 1
        return total
                ",1448240042
dirigibility,dirigibility,119,3646,python3,"mod = 10**9+7
class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        c = Counter()
        s = Counter()
        for n in nums:
            s[n] += s[n-1]+s[n+1]+n*(c[n-1]+c[n+1]+1)
            c[n] += c[n-1]+c[n+1]+1
            s[n] %= mod
            c[n] %= mod
        return s.total()%mod",1448199344
Jiabei Zhu,zzjjbb,121,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k) -> int:
        nums.append(nums[-1])
        diff = [j - i for i, j in pairwise(nums)]
        diff.append(-1)
        curr = 0
        gl = []
        for i in diff:
            curr += 1
            if i <= 0:
                gl.append(curr)
                curr = 0
        ans = 0
        for i in pairwise(gl):
            ans = max(ans, max(i) // 2)
            ans = max(ans, min(i))
        return ans >= k",1448192001
Jiabei Zhu,zzjjbb,121,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        nums.append(nums[-1])
        diff = [j - i for i, j in pairwise(nums)]
        diff.append(-1)
        curr = 0
        gl = []
        for i in diff:
            curr += 1
            if i <= 0:
                gl.append(curr)
                curr = 0
        ans = 0
        for i in pairwise(gl):
            ans = max(ans, max(i) // 2)
            ans = max(ans, min(i))
        return ans
            ",1448190918
Jiabei Zhu,zzjjbb,121,3631,python3,"M = 1_000_000_007
comb = [[None] * 810 for _ in range(810)]
fact = [1]
for i in range(1, 1700):
    fact.append(fact[-1] * i % M)
for i in range(810):
    for j in range(810):
        comb[i][j] = fact[i + j] * pow(fact[i] * fact[j], -1, M) % M

def red(i):
    out = 0
    while i > 1:
        i = f'{i:b}'.count('1')
        out += 1
    return out
cnt = [red(i) for i in range(810)]
cnt[0] = 10
    
class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        sbs = [1]
        for i, si in enumerate(s[::-1]):
            # print(sbs)
            if si != '1':
                sbs.append(0)
                continue
            sbs = [0] + sbs
            for j in range(i + 1):
                # print(i, j)
                sbs[j] = (sbs[j] + comb[j][i - j]) % M
            # print(sbs)
        sbs[s.count('1')] -= 1
        # print(cnt)
        ans = 0
        for i, si in enumerate(sbs):
            if cnt[i] < k:
                ans = (ans + sbs[i]) % M
        return ans
                ",1448255708
Jiabei Zhu,zzjjbb,121,3646,python3,"M = 1_000_000_007
class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        endby = defaultdict(int)
        endsum = defaultdict(int)
        ans = 0
        for i in nums:
            eb = endby[i - 1] + endby[i + 1] + 1
            curr = endsum[i - 1] + endsum[i + 1] + eb * i
            endby[i] += eb
            endsum[i] = (endsum[i] + curr) % M
            ans = (ans + curr) % M
            # print(endby, endsum)
        return ans",1448203772
raincoat911,raincoat911,122,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        vector<int> dp(nums.size());
        int n = 0;
        for (int i = 0; i < nums.size(); i++) {
            if (i == 0 || nums[i] > nums[i - 1]) n++;
            else n = 1;
            dp[i] = n;
        }
        for (int i = k - 1; i < nums.size() - k; i++) {
            if (dp[i] >= k && dp[i + k] >= k) return true;
        }
        return false;
    }
};",1448182510
raincoat911,raincoat911,122,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        vector<int> dp(nums.size());
        int n = 0;
        for (int i = 0; i < nums.size(); i++) {
            if (i == 0 || nums[i] > nums[i - 1]) n++;
            else n = 1;
            dp[i] = n;
        }
        int lo = 1, hi = nums.size() / 2 + 1;
        while (lo < hi) {
            int mid = (lo + hi) / 2;
            if (f(dp, mid)) lo = mid + 1;
            else hi = mid;
        }
        return lo - 1;
    }
    
private:
    
    bool f(vector<int>& dp, int k) {
        for (int i = k - 1; i < dp.size() - k; i++) {
            if (dp[i] >= k && dp[i + k] >= k) return true;
        }
        return false;
    }
    
};",1448184399
raincoat911,raincoat911,122,3631,cpp,"class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        vector<int> arr(s.size() + 1);
        for (int i = 2; i < arr.size(); i++) {
            arr[i] = arr[f(i)] + 1;
            // if (arr[i] == k) a.push_back(i);
            // if (arr[i] < k) b.push_back(i);
        }
        // for (int i = 1; i < arr.size)
        int res = 0;
        int n = 0;
        dp.resize(s.size(), vector<int>(s.size()));
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == '0') continue;
            for (int l = 0; l < s.size() - i; l++) {
                if (arr[l + n] < k) {
                    res += cnk(s.size() - i - 1, l);
                    res %= M;
                }
            }
            // cout << res << "", "";
            n++;
        }
        return res - 1;
    }
    
private:
    vector<vector<int>> dp;
    int M = 1e9 + 7;
    
    int f(int n) {
        int res = 0;
        while (n) {
            res += n & 1;
            n >>= 1;
        }
        return res;
    }
    
    int cnk(int n, int k) {
        if (n == k || k == 0) return 1;
        if (dp[n][k] != 0) return dp[n][k];
        return dp[n][k] = (cnk(n - 1, k - 1) + cnk(n - 1, k)) % M;
    }
};",1448240515
raincoat911,raincoat911,122,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        vector<int> left = f(nums);
        reverse(nums.begin(), nums.end());
        vector<int> right = f(nums);
        reverse(right.begin(), right.end());
        reverse(nums.begin(), nums.end());
        int res = 0;
        for (int i = 0; i < nums.size(); i++) {
            res += (long) left[i] * right[i] % M * nums[i] % M;
            // cout << num
            // cout << left[i] << "" "" << right[i] << "" "" << ((long) left[i] * right[i] % M * nums[i]) << endl;
            res %= M;
        }
        return res;
    }
    
private:
    int M = 1e9 + 7;
    
    vector<int> f(vector<int>& nums) {
        unordered_map<int, int> m;
        vector<int> dp(nums.size());
        for (int i = 0; i < nums.size(); i++) {
            int n = nums[i];
            int cur = 1;
            if (m.count(n - 1)) cur += m[n - 1];
            if (m.count(n + 1)) cur += m[n + 1];
            cur %= M;
            dp[i] = cur;
            m[n] += cur;
            m[n] %= M;
        }
        return dp;
    }
};",1448197461
fxfxxxfxx,fxfxxxfxx,123,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        auto f = [&](int a) {
            if (a + 2*k > n) return false;
            for (int i = a+1; i < a+k; i++)
                if (nums[i] <= nums[i-1]) return false;
            for (int i = a+k+1; i < a+2*k; i++)
                if (nums[i] <= nums[i-1]) return false;
            return true;
        };
        for (int i = 0; i < n; i++)
            if (f(i)) return true;
        return false;
    }
};",1448184065
fxfxxxfxx,fxfxxxfxx,123,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> V(n);
        V[0] = 1;
        int count = 1;
        for (int i = 1; i < n; i++) {
            if (nums[i] > nums[i-1]) count += 1;
            else count = 1;
            V[i] = count;
        }
        
        auto f = [&](int k) {
            for (int i = 2*k-1; i < n; i++)
                if (V[i] >= k && V[i-k] >= k) return true;
            return false;
        };

        int low = 0, high = n;
        while (low < high) {
            int mid = low + (high - low) / 2;
            if (!f(mid)) high = mid;
            else low = mid + 1;
        }
        return low - 1;
    }
};",1448191496
fxfxxxfxx,fxfxxxfxx,123,3631,cpp,"template<int M>
struct mint {
private:
    int pow(int a, int b) {
        int64_t res = 1, mul = a;
        while (b) {
            if (b & 1) res = (res * mul) % M;
            mul = (mul * mul) % M;
            b >>= 1;
        }
        return res;
    }
public:
    int x;
    mint() : x(0) {}
    mint(int x) : x(x) {}
    mint& operator +=(mint o) {
        x = (x + o.x) % M;
        x = (x + M) % M;
        return *this;
    }
    mint& operator -=(mint o) {
        x = (x - o.x) % M;
        x = (x + M) % M;
        return *this;
    }
    mint& operator *=(mint o) {
        x = int64_t(x) * o.x % M;
        x = (x + M) % M;
        return *this;
    }
    mint& operator ^=(mint o) {
        x = pow(x, o.x);
        x = (x + M) % M;
        return *this;
    }
    mint& operator /=(mint o) {
        int rev_y = pow(o.x, M - 2);
        x = int64_t(x) * rev_y % M;
        x = (x + M) % M;
        return *this;
    }

    friend mint operator +(const mint x, const mint y) { return mint(x) += y; }
    friend mint operator -(const mint x, const mint y) { return mint(x) -= y; }
    friend mint operator *(const mint x, const mint y) { return mint(x) *= y; }
    friend mint operator /(const mint x, const mint y) { return mint(x) /= y; }
    friend mint operator ^(const mint x, const mint y) { return mint(x) ^= y; }
    friend bool operator <(const mint x, const mint y) { return x.x < y.x; }
    friend bool operator <=(const mint x, const mint y) { return x.x <= y.x; }
    friend bool operator >(const mint x, const mint y) { return x.x > y.x; }
    friend bool operator >=(const mint x, const mint y) { return x.x >= y.x; }
    friend bool operator ==(const mint x, const mint y) { return x.x == y.x; }
    friend bool operator !=(const mint x, const mint y) { return x.x != y.x; }
    explicit operator int() { return x; }
};

template<int M>
struct Factorial {
    using Mint = mint<M>;

    int N;
    std::vector<Mint> fact, ifact, rev;

    Factorial(int n): N(n + 1), fact(n + 1), ifact(n + 1), rev(n + 1) {
        fact[0] = fact[1] = 1;
        ifact[0] = ifact[1] = 1;
        rev[0] = rev[1] = 1;
        for (int i = 2; i < N; i++) {
            fact[i] = fact[i-1] * i;
            rev[i] = rev[M % i] * (M - M/i);
            ifact[i] = ifact[i-1] * rev[i];
        }
    }

    Mint F(int n) {
        assert(n >= 0);
        return fact[n];
    }

    Mint C(int n, int k) {
        assert(n < N);
        assert(n >= k);
        return fact[n] * ifact[n-k] * ifact[k];
    }

    Mint H(int n, int k) {
        // a_1 + ... + a_n = k
        // a_i >= 0
        return C(n - 1 + k, k);
    }
};

class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        constexpr int M = 1000000007;
        static Factorial<M> F(801);
        static constexpr auto V = []{
            array<int, 801> ret = {};
            for (uint32_t r = 2; r <= 800; r++)
                ret[r] = ret[std::popcount(r)] + 1;
            return ret;
        }();

        using Mint = mint<M>;
        vector<Mint> A(801);
        int total = 0, n = s.size();
        for (int i = 0; i < n; i++) {
            char c = s[i];
            if (c == '0') continue;
            int n_free = n - (i + 1);
            for (int v = 0; v <= n_free; v++)
                A[v+total] += F.C(n_free, v);
            total += 1;
        }

        Mint ans = 0;
        for (int v = 1; v <= 800; v++)
            if (V[v] < k) ans += A[v];
        return int(ans);
        
    }
};",1448248258
fxfxxxfxx,fxfxxxfxx,123,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        using T = pair<int,int>;
        constexpr int M = 1000000007;
        constexpr int N = 100000;
        vector<T> DP(N+1); // count, sum
        auto Add = [&](T x, T y) {
            return T{(x.first + y.first) % M, (x.second + y.second) % M};
        };

        int n = nums.size();
        for (int x : nums) {
            T res = {1, x}; // self
            if (x > 0) {
                res = Add(res, DP[x-1]);
                res.second += (int64_t{DP[x-1].first} * x) % M;
                res.second %= M;
            }
            if (x < N) {
                res = Add(res, DP[x+1]);
                res.second += (int64_t{DP[x+1].first} * x) % M;
                res.second %= M;
            }
            DP[x] = Add(res, DP[x]);
        }

        int ans = 0;
        for (int v = 0; v <= N; v++)
            ans = (ans + DP[v].second) % M;
        return ans;
    }
};",1448215740
rithwikgupta,rithwikgupta,126,3612,cpp,"class Solution {
public:
    int hasIncreasingSubarrays(vector<int>& a, int k) {
        int n = a.size();
        vector<int> seq;
        int cur = 1;
        for (int i = 1; i < n; i++) {
            if (a[i] > a[i-1]) cur++;
            else {
                seq.push_back(cur);
                cur = 1;
            }
        }     
        seq.push_back(cur);
        int res = 0;

        for (int i = 0; i < seq.size(); i++) {

            res = max(res, seq[i]/2);
            if (i) res = max(res, min(seq[i], seq[i-1]));
        }
        return res >= k;
    }
};",1448226321
rithwikgupta,rithwikgupta,126,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& a) {
        int n = a.size();
        vector<int> seq;
        int cur = 1;
        for (int i = 1; i < n; i++) {
            if (a[i] > a[i-1]) cur++;
            else {
                seq.push_back(cur);
                cur = 1;
            }
        }     
        seq.push_back(cur);
        int res = 0;

        for (int i = 0; i < seq.size(); i++) {

            res = max(res, seq[i]/2);
            if (i) res = max(res, min(seq[i], seq[i-1]));
        }
        return res;
    }
};",1448225206
rithwikgupta,rithwikgupta,126,3631,cpp,"class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        vector<int> done(801);
        int MOD = 1e9 + 7;
        for (int i = 1; i < 801; i++) {
            int cur = i;
            while (cur != 1) {
                done[i] += 1;
                int res = 0;
                for (int b = 0; b < 10; b++) {
                    if ((1 << b) & cur) res++;
                }
                cur=res;
            }
        }
        int n = s.size();
        
        vector<vector<vector<int> > > dp(n+1, vector<vector<int> >(n+1, vector<int>(2))); // 0 is less than
        s = ' ' + s;
        dp[0][0][1]=1;
        for (int dig = 1; dig <= n; dig++) {
            for (int sm = 0; sm <= n; sm++) {
                dp[dig][sm][0] = dp[dig-1][sm][0];
                if (sm) dp[dig][sm][0] = (dp[dig][sm][0] + dp[dig-1][sm-1][0]) % MOD;
                
                if (s[dig] == '1') {
                    dp[dig][sm][0] = (dp[dig-1][sm][1] + dp[dig][sm][0]) % MOD;
                    // if (sm) dp[dig][sm][0] = (dp[dig][sm][0] + dp[dig-1][sm-1][0]) % MOD;
                    if (sm) dp[dig][sm][1] = dp[dig-1][sm-1][1];
                } else {
                    dp[dig][sm][1] = dp[dig-1][sm][1];
                }
                // cout << dig << sm << ' ' << dp[dig][sm][0] << endl;
            }
        }
        long long res = 0;
        for (int i = 1; i <= n; i++) {
            // cout << i << done[i] << endl;
            if (done[i] + 1 <= k) {
                // cout << i << endl;
                res = (res + dp[n][i][0]) % MOD;
            }
        }

        return res;
    }
};",1448200403
rithwikgupta,rithwikgupta,126,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int mx = 1e5 + 10;
        long long MOD = 1e9 +7 ;
        vector<long long > ans(mx);
        vector<long long> sm(mx);
        long long res = 0;
        for (int i = nums.size() - 1; i >= 0; i--) {
            nums[i]++;
            res = (res + (ans[nums[i] + 1] + ans[nums[i]-1] + 1) * (nums[i]-1) + sm[nums[i] + 1] + sm[nums[i] - 1]) % MOD;
            ans[nums[i]] = (ans[nums[i]] + ans[nums[i] + 1] + ans[nums[i]-1] + 1) % MOD;
            sm[nums[i]] = (sm[nums[i]] + (ans[nums[i] + 1] + ans[nums[i]-1] + 1) * (nums[i]-1) + sm[nums[i] + 1] + sm[nums[i] - 1]) % MOD;
            // cout << i << res << endl;
        }
        // ans = vector<int>(mx, 0);
        // for (int i = 0; i < nums.size(); i++) {
        //     res = (res + (ans[nums[i] + 1] + ans[nums[i]-1] + 1) * nums[i]) % MOD;
        //     ans[nums[i]] = (ans[nums[i]] + ans[nums[i] + 1] + ans[nums[i]-1] + 1) % MOD;
        //     // cout << i << res << endl;
        // }
        return res;

        // for (int i = nums.size()-1; i >= 0; i--) {
        //     where[nums[i]].push_back(i);
        // }

        // vector<pair<int, int> > layer;
    
        // long long res = 0;
        // for (int i = mx-1; i >= 0; i--) {
        //     vector<pair<int, int> > new_layer;
        //     int p = layer.size()-1;
        //     int cur = 1;
        //     for (auto val: where[i]) {
        //         if (p != -1 && layer[p].first > val) {
        //             cur+=layer[p].second;
        //             p--;
        //         }
        //         new_layer.push_back({val, cur});
        //         res = (res + i * cur) % MOD;
        //     }
            
        //     layer = new_layer;
        // }
        // return res;
    }
};",1448219206
Ryan,ryanwong0127,128,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
    
        for a in range(0, n - 2 * k + 1):
            b = a + k 
            a1 = nums[a : a + k]
            a2 = nums[b : b + k]

            def func(sub):
                for i in range(1, len(sub)):
                    if sub[i] <= sub[i - 1]:
                        return False
                return True

            if func(a1) and func(a2):
                return True  

        return False ",1448182459
Ryan,ryanwong0127,128,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        run_length = [1] * n   
        for i in range(n - 2, -1, -1):
            if nums[i] < nums[i + 1]:
                run_length[i] = run_length[i + 1] + 1
            else:
                run_length[i] = 1

        l, r, res = 1, n // 2, 0

        while l <= r:
            mid = (l + r) // 2
            found = False
            for a in range(n - 2 * mid + 1):
                if run_length[a] >= mid and run_length[a + mid] >= mid:
                    found = True
                    break 

            if found:
                res = mid
                l = mid + 1
            else:
                r = mid - 1 
        return res",1448185279
Ryan,ryanwong0127,128,3631,python3,"MOD = 10**9 + 7
def precompute_steps(max_x):
    step = [0] * (max_x + 1)
    step[1] = 0 
    for x in range(2, max_x + 1):
        pop = bin(x).count('1')
        if pop <= max_x:
            step[x] = 1 + step[pop]
        else:
            step[x] = 1 + step[max_x]
    return step

MAX_X = 800
STEP = precompute_steps(MAX_X)
class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        bits = list(map(int, s))
        L = len(bits)

        dp_prev = [[0] * 2 for _ in range(L + 1)]
        dp_prev[0][1] = 1  

        for pos in range(L):
            dp = [[0] * 2 for _ in range(L + 1)]
            for cnt in range(0, L + 1):
                for t in [0, 1]:
                    if dp_prev[cnt][t] == 0:
                        continue
                    max_bit = bits[pos] if t else 1
                    for bit in [0, 1]:
                        if bit > max_bit:
                            continue
                        new_t = t and (bit == max_bit)
                        new_cnt = cnt + bit
                        if new_cnt > L:
                            continue
                        dp[new_cnt][new_t] = (dp[new_cnt][new_t] + dp_prev[cnt][t]) % MOD
            dp_prev = dp

        cnt = [0] * (L + 1)
        for c in range(1, L + 1):
            cnt[c] = (dp_prev[c][0] + dp_prev[c][1]) % MOD

        res = 0
        for x in range(1, L + 1):
            if x <= MAX_X:
                if STEP[x] <= k -1:
                    res = (res + cnt[x]) % MOD

        x_n = sum(bits)
        if x_n <= MAX_X:
            step_n = 1 + STEP[x_n]
        else:
            step_n = 1 + STEP[MAX_X]

        if step_n <= k:
            res = (res - 1) % MOD

        return res",1448257595
Ryan,ryanwong0127,128,3646,cpp,"#include <bits/stdc++.h>
#pragma GCC optimize(2)
#define rep(i, a, b) for (int i = (a); i < (b); ++i)
#define rep_(i, a, b) for (int i = (a); i > (b); i--)
#define CEIL_DIV(a, b) ((b) == 0 ? 0 : (((a) >= 0) ? ((a) + (b) - 1) / (b) : (a) / (b)))
#define FLOOR_DIV(a, b) (((a) / (b)) - ((a) % (b) != 0 &&(((a) < 0) != ((b) < 0))))
#define mst(x, a) memset(x, a, sizeof(x))
#define all(a) begin(a), end(a)
#define lowbit(x) ((x) & (-(x)))
#define bitcnt(x) (__builtin_popcountll(x))
#define se second
#define fi first
#define pb push_back
#define maxe max_element
#define mine min_element
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<ll, ll> pll;
typedef pair<int, ll> pil;
typedef pair<int, int> pii;
typedef vector<int> vi;
typedef vector<ll> vll;
typedef vector<vi> vvi;
constexpr static int dirs[4][2] = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};
constexpr static int inf = 0x3f3f3f3f, mod = 1e9 + 7;
const ll infl = 0x3f3f3f3f3f3f3f3fll;
template<class T> bool chmax(T &a, T b) {
    if (a >= b) return false;
    a = b; return true;
}
template<class T> bool chmin(T &a, T b) {
    if (a <= b) return false;
    a = b; return true;
}
template<class T> bool chsum(T &a, T b) {
    a = (a + b + mod) % mod;
    return 0;
}
class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        const int n = nums.size();
        int maxV = *maxe(all(nums));
        vector<pll> dp(maxV+2, {0, 0});
    
        ll total = 0;

        for(auto num : nums){
            ll new_count = 1;
            ll new_sum = num;

            if(num >=1){
                ll prev_count = dp[num-1].fi;
                ll prev_sum = dp[num-1].se;
                chsum(new_count , prev_count);
                chsum(new_sum , (prev_sum + prev_count * num));
            }

            if(num +1 <= 100000){
                ll prev_count = dp[num+1].fi;
                ll prev_sum = dp[num+1].se;
                chsum(new_count , prev_count);
                chsum(new_sum , (prev_sum + prev_count * num));
            }

            chsum(dp[num].fi , new_count);
            chsum(dp[num].se , new_sum);

            chsum(total, new_sum) ;
        }

        return total;
    }
};",1448203694
PooyaZ,pooyaz,130,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& arr, int k) {
        int n = arr.size();
        for(int i = 0; i + 2 * k <= n; i++){
            bool ok = true;
            for(int j = 0; j < k - 1; j++){
                if(arr[i + j] >= arr[i + j + 1]) ok = false;
                if(arr[i + k + j] >= arr[i + k + j + 1]) ok = false;
            }
            if(ok) return true;
        }
        return false;
    }
};",1448182825
PooyaZ,pooyaz,130,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& arr) {
        int n = arr.size();
        int fr[n], bc[n];
        fr[0] = 1;
        for(int i = 1; i < n; i++){
            if(arr[i] > arr[i - 1]){
                fr[i] = fr[i - 1] + 1;
            }
            else fr[i] = 1;
        }

        bc[n - 1] = 1;
        for(int i = n - 2; i >= 0; i--){
            if(arr[i] < arr[i + 1]){
                bc[i] = bc[i + 1] + 1;
            }
            else bc[i] = 1;
        }

        int res = 0;
        for(int i = 0; i + 1 < n; i++){
            res = max(res, min(fr[i], bc[i + 1]));
        }
        return res;
    }
};",1448191001
PooyaZ,pooyaz,130,3631,cpp,"#define Mod 1000000007

class Solution {
public:
    int n;
    string s;
    long long c[810][810];
    long long dp[810][810];
    long long comb(int k, int r){
        if(k > r) return 0;
        if(k == 0 || k == r) return 1;
        if(c[k][r] != -1) return c[k][r];
        return c[k][r] = (comb(k, r - 1) + comb(k - 1, r - 1)) % Mod;
    }

    long long mem(int idx, int rem){
        if(idx == n){
            return 0;
        }
        if(rem == 0){
            
        }
        if(dp[idx][rem] != -1) return dp[idx][rem];

        long long& ref = dp[idx][rem];
        if(s[idx] == '0'){
            ref = mem(idx + 1, rem);
        }
        else if(rem == 0){
            ref = 1;
        }
        else{
            ref = (comb(rem, n - idx - 1) + mem(idx + 1, rem - 1)) % Mod;;
        }
        return ref;
    }

    int countKReducibleNumbers(string ss, int k) {
        s = ss;
        n = s.length();
        memset(dp, -1, sizeof dp);
        memset(c, -1, sizeof c);
        int red[810];
        red[1] = 0;
        for(int i = 2; i < 810; i++){
            int cnt = 0, x = i;
            while(x){
                cnt += x & 1;
                x /= 2;
            }
            red[i] = red[cnt] + 1;
        }

        long long res = 0;
        for(int i = 1; i <= n; i++){
            if(red[i] + 1 <= k){
                long long cnt = mem(0, i);
                res = (res + cnt) % Mod;
            }
        }
        return res;
    }
};",1448250541
PooyaZ,pooyaz,130,3646,cpp,"#define Mod 1000000007

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& arr) {
        int n = arr.size();
        long long fr[n], bc[n];
        long long num[100010];
        
        memset(num, 0, sizeof num);
        for(int i = 0; i < n; i++){
            fr[i] = 1 + num[arr[i] + 1];
            if(arr[i] > 0) fr[i] += num[arr[i] - 1];
            fr[i] %= Mod;
            num[arr[i]] += fr[i];
            // cout << fr[i] << ' ';
        }
        // cout << endl;

        memset(num, 0, sizeof num);
        for(int i = n - 1; i >= 0; i--){
            bc[i] = 1 + num[arr[i] + 1];
            if(arr[i] > 0) bc[i] += num[arr[i] - 1];
            bc[i] %= Mod;
            num[arr[i]] += bc[i];
            // cout << bc[i] << ' ';
        }
        // cout << endl;

        long long res = 0;
        for(int i = 0; i < n; i++){
            res = (res + (fr[i] * bc[i]) % Mod * arr[i]) % Mod;
        }
        return res;
    }
};",1448209589
Remineva,Remineva,131,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        for i in range(k, n - k + 1):
            for j in range(i - k, i - 1):
                if nums[j] >= nums[j+1]:
                    break
            else:
                for j in range(i, i + k - 1):
                    if nums[j] >= nums[j+1]:
                        break
                else:
                    return True
        return False",1448183338
Remineva,Remineva,131,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        ls = [1] * n

        for i in range(n - 2, -1, -1):
            if nums[i] < nums[i + 1]:
                ls[i] = ls[i + 1] + 1
            else:
                ls[i] = 1

        def check(l):
            for i in range(n - l):
                if ls[i] >= l and ls[i+l] >= l:
                    return True
            return False
        
        l = 1
        r = n // 2
        while l < r:
            m = (l + r + 1) // 2
            if check(m):
                l = m
            else:
                r = m - 1
        return r",1448199064
Remineva,Remineva,131,3631,python3,"M = 10 ** 9 + 7
class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        if s == '1':
            return 0
        
        @cache
        def f(x):
            if x == 1:
                return 1
            return 1 + f(x.bit_count())

        n = len(s)
        flag = [False] * (n + 1)
        for cnt in range(1, n + 1):
            if f(cnt) <= k:
                flag[cnt] = True




        @cache
        def dp(i, cnt, b, is_flag):
            if i == n:
                if is_flag:
                    return 1 if flag[cnt] else 0
                else:
                    return 0
            limit = int(s[i]) if b else 1
            res = 0
            for digit in range(0, limit + 1):
                new_b = b and (digit == limit)
                new_is_flag = is_flag or (digit != 0)
                new_cnt = cnt + digit if new_is_flag else cnt
                res += dp(i + 1, new_cnt, new_b, new_is_flag)
                res %= M
            return res
        
        if flag[s.count('1')]:
            return dp(0, 0, True, False) - 1
        else:
            return dp(0, 0, True, False)",1448258102
Remineva,Remineva,131,3646,python3,"M = 10 ** 9 + 7
class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        res = 0
        n = len(nums)
        d = defaultdict(int)
        cnt = defaultdict(int)
        for i, num in enumerate(nums):
            curr = (d[num - 1] + d[num + 1]) % M
            cc = (cnt[num - 1] + cnt[num + 1] + 1) % M
            curr += cc * num % M
            curr %= M
            d[num] += curr
            d[num] %= M
            cnt[num] += cc
            cnt[num] %= M
            res += curr
            res %= M
        return res",1448212998
Agnibha Chakraborty,zanj0,136,3612,cpp,"/*
	JAI JAGANNATH!
*/
//@Author : zanj0

#include<bits/stdc++.h>
using namespace std;

#define ff              first
#define ss              second
#define pb              push_back
#define MOD             1000000007
#define inf             1e18

typedef long long int lli;


class Solution {
public:
	bool IsIncreasing(vector<int>& nums, int start, int end) {
		for (int i = start + 1; i <= end; i++) {
			if (nums[i] <= nums[i - 1]) return false;
		}
		return true;
	}
	bool hasIncreasingSubarrays(vector<int>& nums, int k) {
		int n = nums.size();
		for (int i = 0; i < n; i++) {
			int start1 = i;
			int end1 = i + k - 1;
			int start2 = end1 + 1;
			int end2 = start2 + k - 1;
			if (end2 >= nums.size()) return false;
			if (IsIncreasing(nums, start1, end1) && IsIncreasing(nums, start2, end2)) return true;
		}
		return false;
	}
};

#ifdef LOCAL
int main() {
	freopen(""output.txt"", ""w"", stdout);
	cout << ""Compiled!"" << endl;
}
#endif",1448182413
Agnibha Chakraborty,zanj0,136,3619,cpp,"/*
	JAI JAGANNATH!
*/
//@Author : zanj0

#include<bits/stdc++.h>
using namespace std;

#define ff              first
#define ss              second
#define pb              push_back
#define MOD             1000000007
#define inf             1e18

typedef long long int lli;


class Solution {
public:

	int maxIncreasingSubarrays(vector<int>& nums) {
		int n = nums.size();
		vector<int> pre(n, 1), suff(n, 1);
		for (int i = 1; i < n; i++) {
			if (nums[i] > nums[i - 1])pre[i] = 1 + pre[i - 1];
		}
		int ret = 0;
		for (int i = n - 2 ; i >= 0; i--) {
			if (nums[i] < nums[i + 1]) {
				suff[i] = 1 + suff[i + 1];
			}
		}
		for (int i = 1; i < n; i++) {
			ret = max(ret, min(pre[i - 1], suff[i]));
		}
		return ret;
	}
};

#ifdef LOCAL
int main() {
	freopen(""output.txt"", ""w"", stdout);
	cout << ""Compiled!"" << endl;
}
#endif",1448187174
Agnibha Chakraborty,zanj0,136,3631,cpp,"/*
	JAI JAGANNATH!
*/
//@Author : zanj0

#include<bits/stdc++.h>
using namespace std;

#define ff              first
#define ss              second
#define pb              push_back
#define MOD             1000000007
#define inf             1e18

typedef long long int lli;

lli Add(lli a, lli b) {
	return ((a % MOD)  + (b % MOD)) % MOD;
}
lli Mul(lli a, lli b) {
	return ((a % MOD)  * (b % MOD)) % MOD;
}
map<lli, lli> moves;
lli GetMoves(lli x) {
	if (moves.count(x)) return moves[x];
	lli ret = 1;
	lli org = x;
	while (x > 1) {
		ret++;
		x = __builtin_popcountll(x);
	}
	return moves[org] = ret;
}
class Solution {
public:
	lli Dfs(lli idx, lli tight, lli set_bits, string& s, lli k, vector<vector<vector<lli>>>& dp) {
		if (idx >= s.size()) {
            // cout << set_bits << "" "" << GetMoves(set_bits) << endl;
			bool ok= !tight && set_bits && (GetMoves(set_bits) <= k);
            // cout << ok << endl;
            return ok;
		}
		if (dp[idx][tight][set_bits] != -1) return dp[idx][tight][set_bits];
		lli ret = 0;
		for (auto it : {'1', '0'}) {
            if(tight && it> s[idx]) continue;
			lli n_tight = s[idx] == it && tight;
			ret = Add(ret, Dfs(idx + 1, n_tight, set_bits + (it - '0'), s, k, dp));
		}
		return dp[idx][tight][set_bits] = ret;
	}
	int countKReducibleNumbers(string s, int k) {
		int n = s.size();
		vector<vector<vector<lli>>> dp(n + 2, vector<vector<lli>>(2, vector<lli>(n + 2, -1)));
		return Dfs(0, 1, 0, s, k, dp);
	}
};

#ifdef LOCAL
int main() {
	freopen(""output.txt"", ""w"", stdout);
	cout << ""Compiled!"" << endl;
}
#endif",1448251236
Agnibha Chakraborty,zanj0,136,3646,cpp,"/*
	JAI JAGANNATH!
*/
//@Author : zanj0

#include<bits/stdc++.h>
using namespace std;

#define ff              first
#define ss              second
#define pb              push_back
#define MOD             1000000007
#define inf             1e18

typedef long long int lli;

lli Add(lli a, lli b) {
	return ((a % MOD)  + (b % MOD)) % MOD;
}
lli Mul(lli a, lli b) {
	return ((a % MOD)  * (b % MOD)) % MOD;
}
class Solution {
public:
	int sumOfGoodSubsequences(vector<int>& nums) {
		lli ret = 0;
		map<lli, lli> dp;
		map<lli, lli> sum;
		for (auto& it : nums) {
			lli small = dp[it - 1];
			lli big = dp[it + 1];
			dp[it] = Add(dp[it], Add(1, Add(small, big)));
			sum[it] = Add(sum[it], Mul(Add(1, Add(small, big)), it));
			sum[it] = Add(sum[it], sum[it - 1]);
			sum[it] = Add(sum[it], sum[it + 1]);
            // cout << small << "" "" << big << "" "" << sum[it + 1] << "" -> "" << sum[it - 1] << endl;
            // cout << it << "" -- "" << dp[it] << ""  "" << sum[it] << endl;
		}
		for (auto& it : sum) {
            ret = Add(ret, it.ss);
            // cout << it.ff << "" "" << it.ss << endl;
        }
		return ret;
	}
};

#ifdef LOCAL
int main() {
	freopen(""output.txt"", ""w"", stdout);
	cout << ""Compiled!"" << endl;
}
#endif",1448213679
urverymean,urverymean,138,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        def inc(arr):
            for i in range(1,len(arr)):
                if arr[i]<=arr[i-1]:
                    return False
            return True
        for i in range(len(nums) - 2*k + 1):
            if inc(nums[i:i+k]) and inc(nums[i+k:i+k+k]):
                return True
        return False",1448181756
urverymean,urverymean,138,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        pref = [0]*len(nums)
        pref[0] = 1
        for i in range(1,len(nums)):
            pref[i]+=pref[i-1]
            if nums[i] > nums[i-1]:
                pref[i] += 1
        lp = 2
        rp = len(nums)//2
        while lp<=rp:
            mid = (lp+rp)>>1
            p = 0
            good = False
            while p + 2*mid - 1 < len(nums):
                arr1 = pref[p + mid - 1]
                arr1-=pref[p]
                arr2 = pref[p+2*mid - 1]
                arr2-=pref[p+mid]
                if arr2>=mid-1 and arr1>=mid-1:
                    good = True
                    break
                p+=1
            if good:
                lp = mid +  1
            else:
                rp = mid - 1
        return rp",1448220605
urverymean,urverymean,138,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        st = set()
        for i in range(len(s)):
            curr = i
            for j in range(k-1):
                curr = curr.bit_count()
            if curr==1:
                st.add(i)
        MOD = 10**9+7
        @cache
        def dfs(i, bits, tight):
            if i==len(s):
                return int(not tight and bits in st)
            res = dfs(i + 1, bits, tight and s[i]=='0')
            if (not tight or s[i]=='1'):
                res+=dfs(i+1,bits+1, tight and s[i]=='1')
            return res%MOD
        res = dfs(0,0,True)
        dfs.cache_clear()
        return res",1448251442
urverymean,urverymean,138,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        MOD = 10**9+7
        ct = defaultdict(int)
        cl = [0]*len(nums)
        cr = [0]*len(nums)
        res = 0
        for i in range(len(nums)):
            curr = 1
            if nums[i]-1 in ct:
                curr+=ct[nums[i]-1]
            if nums[i]+1 in ct:
                curr+=ct[nums[i]+1]
            curr%=MOD
            cl[i] = curr
            ct[nums[i]] += curr
        ct1 = defaultdict(int)
        for i in range(len(nums)-1,-1,-1):
            curr = 1
            if nums[i]-1 in ct1:
                curr+=ct1[nums[i]-1]
            if nums[i]+1 in ct1:
                curr+=ct1[nums[i]+1]
            curr%=MOD
            cr[i] = curr
            ct1[nums[i]] += curr
        for i in range(len(nums)):
            res+=(nums[i]*cl[i]*cr[i])%MOD
            res%=MOD
        return res
        
            ",1448208973
Abhishek Kumar Jain,abhidot,139,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        vector<int> on;
        int n=nums.size();
        on.push_back(0);
        for(int i=1;i<n;i++){
            if(nums[i]<=nums[i-1]) on.push_back(i);
        }
        
        on.push_back(n);
        int ok=(k==1);
        for(int i=1;i<on.size()-1;i++){
            if(on[i]-on[i-1]>=k&&on[i+1]-on[i]>=k) ok=1;
            if(on[i]-on[i-1]>=2*k) ok=1;
            if(on[i+1]-on[i]>=2*k) ok=1;
        }
        
        if(on.size()==2){
            if(on[1]-on[0]>=2*k) ok=1;
        }
        
        return ok;
        
    }
};",1448190797
Abhishek Kumar Jain,abhidot,139,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        vector<int> on;
        int n=nums.size();
        on.push_back(0);
        for(int i=1;i<n;i++){
            if(nums[i]<=nums[i-1]) on.push_back(i);
        }
        
        on.push_back(n);
        int k=1;
        for(int i=1;i<on.size()-1;i++){
            k = max(k, min(on[i]-on[i-1], on[i+1]-on[i]));
            k = max(k, (on[i]-on[i-1])/2);
            k = max(k, (on[i+1]-on[i])/2);
        }
        
        if(on.size()==2){
            k = max(k, (on[1]-on[0])/2);
        }
        
        return k;
    }
};",1448195411
Abhishek Kumar Jain,abhidot,139,3631,cpp,"#define setbits(x) __builtin_popcountll(x)
const int N = 805;
class Solution {
public:
    bool get_bit(int a, int i)
    {
    	return a & (1ll << i);
    }
    const long long MOD=1e9+7;
    long long power(long long x, unsigned long long y)  
    {  
        long long res = 1;
        x = x % MOD;
        if (x == 0) return 0;
      
        while (y > 0)  
        { 
            if (y & 1)  
                res = (res*x) % MOD;
            y = y>>1;
            x = (x*x) % MOD;  
        }  
        return res;  
    }
    long long modInv(long long a){return power(a,MOD-2);}
    long long fact[N],inv[N];
    void factorial(long long n){
    	fact[0]=1;
    	for(int i=1;i<n;i++){
    		fact[i]=fact[i-1]*i;
    		if(fact[i]>=MOD)
    			fact[i]%=MOD;
    	}
    }
    void InvFactorial(long long n){
    	inv[0]=1;
    	for(int i=1;i<n;i++)
    		inv[i]=modInv(fact[i]);
    }
    long long ncr(int n,int r){
    	if(n<r||n<0||r<0)
    		return 0;
    	long long b=inv[n-r];
    	long long c=inv[r];
    	long long  a=fact[n]*b;
    	if(a>=MOD)
    		a%=MOD;
    	a*=c;
    	if(a>=MOD)
    		a%=MOD;
    	return a;
    }
    int countKReducibleNumbers(string s, int k) {
        int n=s.size();
        int f[n+5];
        factorial(n+5);
        InvFactorial(n+5);
        f[0]=0;
        f[1]=0;
        f[2]=1;
        for(int j=3; j<n+5; j++){
        	f[j]=f[setbits(j)]+1;
        } 

        vector<int> g(n+5, 0);
        for(int i=1;i<n+5;i++){
            g[i]=(f[i]<k);
        }

    	int ans=0,bits=0;
    	for(int j=0; j<n; j++){
    		if(s[j]=='1'){
    			
    			for(int k=0; k<=n-1-j; k++){
    				ans+=ncr(n-1-j,k)*(g[k+bits]);
    				ans%=MOD;
    			}
    			bits++;
    		}
    	}
    	
        return ans;
    }
};",1448251628
Abhishek Kumar Jain,abhidot,139,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        unordered_map<int,int> idx, idx2;
        int n = nums.size();
        vector<long long> dp(n), dp2(n);
        long long ans=0;
        long long mod = 1e9+7;
        for(int i=0;i<n;i++){
            dp2[i]=1;
            if(idx2.find(nums[i]+1)!=idx2.end()){
                dp2[i] = (dp2[i]+idx2[nums[i]+1])%mod;
            }

            if(idx2.find(nums[i]-1)!=idx2.end()){
                dp2[i] = (dp2[i]+idx2[nums[i]-1])%mod;
            }
            idx2[nums[i]] = (idx2[nums[i]]+dp2[i])%mod;

            // cout<<dp[i]<<"" "";

            // ans = (ans + dp[i]*nums[i]%mod)%mod;
        }
        for(int i=n-1;i>=0;i--){
            dp[i]=1;
            if(idx.find(nums[i]+1)!=idx.end()){
                dp[i] = (dp[i]+idx[nums[i]+1])%mod;
            }

            if(idx.find(nums[i]-1)!=idx.end()){
                dp[i] = (dp[i]+idx[nums[i]-1])%mod;
            }
            idx[nums[i]] = (idx[nums[i]]+dp[i])%mod;

            // cout<<dp[i]*dp2[i]<<"" "";

            ans = (ans + dp[i]*dp2[i]%mod*nums[i]%mod)%mod;
        }

        return ans;
    }
};",1448225995
cc4414,lu-chen-chen,141,3612,java,"class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        int n = nums.size();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = nums.get(i);
        }
        for (int i = 0; i <= n - 2 * k; i++) {
            boolean b = true;
            for (int j = 1; j < k; j++) {
                if (arr[i + j] <= arr[i + j - 1]) {
                    b = false;
                    break;
                }
            }
            for (int j = 1; j < k; j++) {
                if (arr[i + j + k] <= arr[i + j - 1 + k]) {
                    b = false;
                    break;
                }
            }
            if (b) {
                return true;
            }
        }
        return false;
    }
}",1448184518
cc4414,lu-chen-chen,141,3619,java,"class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        int n = nums.size();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = nums.get(i);
        }
        int l = 0;
        int r = n;
        while (l < r) {
            int mid = (l + r + 1) >> 1;
            if (hasIncreasingSubarrays(arr, mid)) {
                l = mid;
            } else {
                r = mid - 1;
            }
        }
        return l;
    }

    public boolean hasIncreasingSubarrays(int[] arr, int k) {
        int n = arr.length;
        int[] cnt = new int[n];
        cnt[n - 1] = 1;
        for (int i = n - 2; i >= 0; i--) {
            if (arr[i] < arr[i + 1]) {
                cnt[i] = cnt[i + 1] + 1;
            } else {
                cnt[i] = 1;
            }
        }
        for (int i = 0; i <= n - 2 * k; i++) {
            if (cnt[i] < k) {
                continue;
            }
            if (cnt[i + k] >= k) {
                return true;
            }
        }
        return false;
    }
}",1448196476
cc4414,lu-chen-chen,141,3631,java,"class Solution {
    long mod = (long) (1e9 + 7);
    char[] chars;
    long[][] dp;
    int[] r;
    int k;
    boolean[][] vis;

    public int countKReducibleNumbers(String s, int k) {
        this.k = k;
        chars = s.toCharArray();
        int n = chars.length;
        r = new int[n + 5];
        for (int i = 2; i < r.length; i++) {
            r[i] = r[Integer.bitCount(i)] + 1;
        }
        dp = new long[n][n + 1];
        vis = new boolean[n][n + 1];
        int sum = 0;
        for (int i = 0; i < n; i++) {
            sum += chars[i] - '0';
        }
        long ans = f(0, 0, true, false) - (r[sum] < k ? 1 : 0);
        return (int) ((ans % mod + mod) % mod);
    }

    long f(int i, int cnt, boolean isLimit, boolean isNum) {
        if (i == chars.length) {
            // （修改点）满足条件则返回1
            return isNum && r[cnt] < k && cnt > 0 ? 1 : 0;
        }
        if (!isLimit && isNum && vis[i][cnt]) {
            return dp[i][cnt];
        }
        long res = 0;
        if (!isNum) {
            // 可以跳过当前数位
            res = f(i + 1, cnt, false, false);
        }
        // 枚举要填入的数字 d
        for (int d = isNum ? 0 : 1, up = isLimit ? chars[i] - '0' : 1; d <= up; d++) {
            res += f(i + 1, cnt + d, isLimit && d == up, true);
        }
        if (!isLimit && isNum) {
            dp[i][cnt] = res % mod;
            vis[i][cnt] = true;
        }
        return res;
    }
}",1448259404
cc4414,lu-chen-chen,141,3646,java,"class Solution {
    public int sumOfGoodSubsequences(int[] nums) {
        long mod = (long) (1e9 + 7);
        int n = nums.length;
        long sum = 0;
        Map<Integer, Long> mapCnt = new HashMap<>();
        Map<Integer, Long> mapSum = new HashMap<>();
        for (int i = 0; i < n; i++) {
            int v = nums[i];
            long t1 = mapCnt.getOrDefault(v + 1, 0L);
            long t2 = mapCnt.getOrDefault(v - 1, 0L);
            long t = t1 + t2;
            long s1 = mapSum.getOrDefault(v + 1, 0L);
            long s2 = mapSum.getOrDefault(v - 1, 0L);
            long s = (s1 + s2 + t * v + v) % mod;
            mapCnt.put(v, (mapCnt.getOrDefault(v, 0L) + t + 1) % mod);
            mapSum.put(v, (mapSum.getOrDefault(v, 0L) + s) % mod);
            sum += s;
            sum %= mod;
        }
        return (int) ((sum % mod + mod) % mod);
    }
}",1448221505
gabriel88766,gabriel88766,142,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        for(int i=0;i<nums.size();i++){
            if(i + 2*k > nums.size()) break;
            bool ok = true;
            for(int j=i+1;j<i+k;j++){
                if(nums[j] <= nums[j-1]) ok = false;
            }
            for(int j=i+k+1;j<i+2*k;j++){
                if(nums[j] <= nums[j-1]) ok = false;
            }
            if(ok) return true;
        }
        return false;
    }
};",1448184841
gabriel88766,gabriel88766,142,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        vector<int> pr(nums.size()), su(nums.size());
        int ln = -1'000'000'001;
        int cs = 0;
        for(int j=0;j<nums.size();j++){
            if(nums[j] > ln) cs++;
            else{
                cs = 1;
            }
            ln = nums[j];
            pr[j] = cs;
        }
        ln = -1'000'000'001;
        cs = 0;
        for(int j=nums.size()-1;j>=0;j--){
            if(nums[j] < ln) cs++;
            else{
                cs = 1;
            }
            ln = nums[j];
            su[j] = cs;
        }
        int ans = 0;
        for(int j=0;j<nums.size()-1;j++){
            ans = max(ans, min(pr[j], su[j+1]));
        }
        return ans;
    }
};",1448198577
gabriel88766,gabriel88766,142,3631,cpp,"class Solution {
public:
    const long long MOD = 1'000'000'007;
    int countKReducibleNumbers(string s, int k) {
        int n = s.size();
        vector<int> red(n+1, 0);
        for(int i=1;i<=n;i++){
            int aux = i;
            int cnt = 0;
            while(aux != 1){
                aux = __builtin_popcount(aux);
                cnt++;
            }
            red[i] = cnt;
        }
        int dp[n+2][n+2][2];
        memset(dp, 0, sizeof(dp));
        dp[n][0][0] = dp[n][0][1] = 1;
        for(int i=n-1;i>=0;i--){
            for(int j=0;j<=n;j++){
                dp[i][j][0] += dp[i+1][j][0];
                dp[i][j+1][0] += dp[i+1][j][0];
                dp[i][j][0] %= MOD;
                dp[i][j+1][0] %= MOD;
            }
            if(s[i] == '1'){
                for(int j=0;j<=n;j++){
                    dp[i][j][1] += dp[i+1][j][0];
                    dp[i][j+1][1] += dp[i+1][j][1];   
                    dp[i][j][1] %= MOD;
                    dp[i][j+1][1] %= MOD;
                }
            }else{
                for(int j=0;j<=n;j++){
                    dp[i][j][1] += dp[i+1][j][1];
                    dp[i][j][1] %= MOD;
                }
            }
        }
        long long ans = 0;
        for(int i=1;i<=n;i++){
            if(red[i] + 1 <= k){
                ans += dp[0][i][1];
                ans %= MOD;
            }
        }
        int c1 = 0;
        for(auto c : s) if(c == '1') c1++;
        if(red[c1] + 1 <= k){
            if(ans != 0) ans--;
            else ans = MOD - 1;
        }
        return ans;
    }
};",1448259687
gabriel88766,gabriel88766,142,3646,cpp,"class Solution {
public:
    const long long MOD = 1'000'000'007;
    int sumOfGoodSubsequences(vector<int>& nums) {
        int n = nums.size();
        vector<long long> pr(n);
        vector<long long> su(n);
        map<long long,long long> dp;
        for(int i=0;i<nums.size();i++){
            long long cur = 1;
            if(dp.count(nums[i] - 1)) cur += dp[nums[i] - 1];
            if(dp.count(nums[i] + 1)) cur += dp[nums[i] + 1];
            cur %= MOD;
            pr[i] = cur;
            dp[nums[i]] = (dp[nums[i]] + cur) % MOD;
        }
        dp.clear();
        for(int i=nums.size()-1;i>=0;i--){
            long long cur = 1;
            if(dp.count(nums[i] - 1)) cur += dp[nums[i] - 1];
            if(dp.count(nums[i] + 1)) cur += dp[nums[i] + 1];
            cur %= MOD;
            su[i] = cur;
            dp[nums[i]] = (dp[nums[i]] + cur) % MOD;
        }
        long long ans = 0;
        for(int i=0;i<nums.size();i++){
            ans = (ans + nums[i] * ((pr[i] * su[i])%MOD)) % MOD;
        }
        return ans;
    }
};",1448227122
trchen,trchen,143,3612,cpp,"class Solution {
 public:
  bool Ok(const vector<int>& lengths, int k) {
    int n = lengths.size();
    for (int i = 0; i <= n - 2 * k; ++i) {
      if (lengths[i] >= k && lengths[i + k] >= k) {
        return true;
      }
    }
    return false;
  }

  bool hasIncreasingSubarrays(vector<int>& nums, int k) {
    int n = nums.size();
    vector<int> lengths(n);
    lengths.back() = 1;
    for (int i = n - 2; i >= 0; --i) {
      if (nums[i] < nums[i + 1]) {
        lengths[i] = lengths[i + 1] + 1;
      } else {
        lengths[i] = 1;
      }
    }
    return Ok(lengths, k);
  }
};",1448199522
trchen,trchen,143,3619,cpp,"class Solution {
 public:
  bool Ok(const vector<int>& lengths, int k) {
    int n = lengths.size();
    for (int i = 0; i <= n - 2 * k; ++i) {
      if (lengths[i] >= k && lengths[i + k] >= k) {
        return true;
      }
    }
    return false;
  }

  int maxIncreasingSubarrays(vector<int>& nums) {
    int n = nums.size();
    vector<int> lengths(n);
    lengths.back() = 1;
    for (int i = n - 2; i >= 0; --i) {
      if (nums[i] < nums[i + 1]) {
        lengths[i] = lengths[i + 1] + 1;
      } else {
        lengths[i] = 1;
      }
    }
    // for (auto c : lengths) {
    //   cout << c << ' ';
    // }
    // cout << endl;
    int low = 1;
    int high = n / 2;
    while (low + 3 < high) {
      int mid = (low + high) / 2;
      if (Ok(lengths, mid)) {
        low = mid;
      } else {
        high = mid - 1;
      }
    }
    for (int i = high; i >= low; --i) {
      if (Ok(lengths, i)) {
        return i;
      }
    }
    return 1;
  }
};",1448195783
trchen,trchen,143,3631,cpp,"using ll = long long;

class Solution {
 public:
  Solution() {
    reducible_counts.resize(801);
    for (int i = 1; i <= 800; ++i) {
      reducible_counts[i] = ReducibleCount(i);
    }
    int X = 800;
    factorials.resize(X + 1);
    inverse_factorials.resize(X + 1);
    factorials[0] = 1;
    for (ll i = 1; i <= X; ++i) {
      factorials[i] = (factorials[i - 1] * i) % MOD;
    }
    inverse_factorials.resize(X + 1);
    for (int i = 0; i <= X; ++i) {
      inverse_factorials[i] = Inverse(factorials[i]);
    }
  }

  ll Power(ll a, int power) {
    if (a == 0) {
      return 0;
    }
    ll ret = 1;
    while (power > 0) {
      if (power % 2 == 1) {
        ret = (ret * a) % MOD;
      }
      a = (a * a) % MOD;
      power /= 2;
    }
    return ret;
  }

  ll Inverse(int a) {
    return Power(a, MOD - 2);
  }

  int ReducibleCount(int n) {
    int ret = 0;
    while (n > 1) {
      ++ret;
      int new_n = 0;
      while (n > 0) {
        if (n % 2 == 1) {
          ++new_n;
        }
        n /= 2;
      }
      n = new_n;
    }
    return ret;
  }

  ll Choose(int n, int k) {
    ll ret = ((factorials[n] * inverse_factorials[k]) % MOD) * inverse_factorials[n - k] % MOD;
    return ret;
  }

  int countKReducibleNumbers(string s, int k) {
    int n = s.size();
    int count1 = 0;
    ll ret = 0;
    for (int i = 0; i < n; ++i) {
      if (s[i] == '0') {
        continue;
      }
      for (int j = 0; j <= n - (i + 1); ++j) {
        if (j + count1 > 0 && reducible_counts[j + count1] <= k - 1) {
          ret = (ret + Choose(n - (i + 1), j)) % MOD; 
        }
      }
      count1++;
    }
    return ret;
  }

  static constexpr ll MOD = 1000000007;
  vector<int> reducible_counts;
  vector<ll> factorials;
  vector<ll> inverse_factorials;
};",1448252265
trchen,trchen,143,3646,cpp,"
using ll = long long;

class Solution {
 public:
  int sumOfGoodSubsequences(vector<int>& nums) {
    unordered_map<int, pair<ll, ll>> prevs;
    int n = nums.size();
    ll ret = 0;
    for (auto c : nums) {
      pair<ll, ll> additional{ 1, c };
      if (prevs.find(c - 1) != prevs.end()) {
        auto p = prevs[c - 1];
        additional.first += p.first;
        additional.second += p.first * c + p.second;
      }
      additional.first %= MOD;
      additional.second %= MOD;
      if (prevs.find(c + 1) != prevs.end()) {
        auto p = prevs[c + 1];
        additional.first += p.first;
        additional.second += p.first * c + p.second;
      }
      additional.first %= MOD;
      additional.second %= MOD;
      ret = (ret + additional.second) % MOD;
      prevs[c].first = (prevs[c].first + additional.first) % MOD;
      prevs[c].second = (prevs[c].second + additional.second) % MOD;
    }
    return ret;
  }

  static inline constexpr ll MOD = 1000000007;
};",1448217099
Akash,Akash_0P,144,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();

        auto f = [&](int id) -> int {
            if(id + k - 1 >= n) return 0;
            for(int i = id + 1; i < id + k; i++) if(nums[i - 1] >= nums[i]) return 0;

            return 1;
        };

        for(int i = 0; i < n; i++) {
            if(f(i) && f(i + k)) return 1;
        }

        return 0;
    }
};",1448183269
Akash,Akash_0P,144,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp(n);

        for(int i = n - 1; i >= 0; i--) {
            dp[i] = 1;
            if(i + 1 < n && nums[i] < nums[i + 1]) dp[i] += dp[i + 1];
        }

        auto check = [&](int i, int k) {
            return i + k - 1 < n;
        };

        auto f = [&](int k) -> int {
            for(int i = 0; i < n; i++) if(check(i, k) && check(i + k, k)) {
                if(dp[i] >= k && dp[i + k] >= k) return 1;
            }

            return 0;
        };

        int l = 1, r = n, ans = 0;
        while(l <= r) {
            int m = (l + r) / 2;
            if(f(m)) ans = m, l = m + 1;
            else r = m - 1;
        }

        return ans;
    }
};",1448191554
Akash,Akash_0P,144,3631,cpp,"using ll = long long;

class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        int n = s.size(), M = 1e9 + 7;

        auto ok = [&](int total) {
            int cnt = 1;
            while(total > 1) {
                total = __builtin_popcount(total);
                cnt++;
            }

            return cnt;
        };

        vector<vector<vector<int>>> dp(2, vector<vector<int>> (n + 10, vector<int> (n + 10, -1)));

        auto f = [&](int i, int tight, int sum, auto && f) -> ll {
            if(i == n) {
                if(tight) return 0;
                return (sum > 0 && ok(sum) <= k);
            };

            if(dp[tight][i][sum] != -1) return dp[tight][i][sum];

            ll ans = 0;
    
            if(tight) {
                if(s[i] == '0') ans = f(i + 1, 1, sum, f);
                else {
                    ans = f(i + 1, 0, sum, f);
                    ans = (ans + f(i + 1, 1, sum + 1, f)) % M;
                }
            }else {
                ans = f(i + 1, 0, sum, f);
                ans = (ans + f(i + 1, 0, sum + 1, f)) % M;
            }

            return dp[tight][i][sum] = ans;

        };

        return f(0, 1, 0, f);
    }
};",1448259766
Akash,Akash_0P,144,3646,cpp,"using ll = long long;

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int n = nums.size(), M = 1e9 + 7;
        map<int, ll>mpp, cnt;

        ll ans = 0;

        auto add = [&](ll a, ll b) {
            return (a + b) % M;
        };

        auto mul = [&](ll a, ll b) {
            return (a * b) % M;
        };

        for(int i = n - 1; i >= 0; i--) {
            ll value = nums[i], sum = nums[i];

            if(mpp.count(value + 1)) {
                sum = add(sum, add(mul(value, cnt[value + 1]), mpp[value + 1]));
                cnt[value] = add(cnt[value], cnt[value + 1]);
            }

            if(mpp.count(value - 1)) {
                sum = add(sum, add(mul(value, cnt[value - 1]), mpp[value - 1]));
                cnt[value] = add(cnt[value], cnt[value - 1]);
            }

            ans = add(ans, sum);
            mpp[nums[i]] = add(mpp[nums[i]], sum);
            cnt[nums[i]] = add(cnt[nums[i]], 1);
        }

        return ans;
    }
};",1448215672
a_k,a0518,145,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        
        for i in range(n):
            if i+k >= n: continue
            ok = True
            for j in range(i+1, i+k):
                if nums[j]<=nums[j-1]:
                    ok = False
                    break
            # if i == 0: print(ok)
            if ok:
                ok = True
                idx = i+k
                if idx+k-1 <= n-1: 
                    for j in range(idx+1, idx+k):
                        if nums[j]<=nums[j-1]:
                            ok = False
                            break
                    if ok: return True
        return False",1448182914
a_k,a0518,145,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        prefix = [0 for _ in range(n)]
        suffix = [0 for _ in range(n)]
        i = 0
        while i < n:
            prv = -float(""inf"")
            l = 0
            while i < n and nums[i] > prv:
                l+=1
                prefix[i] = l
                prv = nums[i]
                i+=1
        
        i = n-1
        while i >= 0:
            prv = float(""inf"")
            l = 0
            while i >= 0 and nums[i] < prv:
                l+=1
                prv = nums[i]
                suffix[i] = l
                i-=1
        
        # print(prefix)
        # print(suffix)
        res = 0
        for i in range(n-1):
            res = max(res, min(prefix[i], suffix[i+1]))
        return res",1448187460
a_k,a0518,145,3631,python3,"
class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        mod = 10**9 + 7
        n = len(s)
        
        def good(x):
            cur = x
            for i in range(k - 1):
                cur = bin(cur)[2:].count('1')
            return cur == 1 
        
        dp = [[[0] * 2 for _ in range(n + 1)] for _ in range(n + 1)]
        
        dp[0][0][0] = 1
        
        for i in range(n):
            for cnt in range(n + 1):
                for ok in range(2):
                    dp[i + 1][cnt][ok or (s[i] == '1')] += dp[i][cnt][ok]
                    dp[i + 1][cnt][ok or (s[i] == '1')] %= mod
                    
                    if cnt > 0 and (ok or s[i] == '1'):
                        dp[i + 1][cnt][ok] += dp[i][cnt - 1][ok]
                        dp[i + 1][cnt][ok] %= mod
        

        res = 0
        for i in range(1, n + 1):
            if good(i):
                res = (res + dp[n][i][1]) % mod
                
        return res
",1448237211
a_k,a0518,145,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        mod = 10**9+7
        n = len(nums)
        mp = defaultdict(int)
        count = defaultdict(int)
        
        res = 0
        for i in range(n):
            cur = nums[i]
            count[nums[i]]+=1
            if nums[i]-1 in mp:
                count[nums[i]] = (count[nums[i]] + count[nums[i]-1]) % mod
                cur = (cur + mp[nums[i]-1] + (nums[i] * count[nums[i]-1]) % mod) % mod
            if nums[i]+1 in mp:
                count[nums[i]] = (count[nums[i]] + count[nums[i]+1]) % mod
                cur = (cur + mp[nums[i]+1] + (nums[i] * count[nums[i]+1]) % mod) % mod
            # if i == 1: print(mp)
            mp[nums[i]] = (mp[nums[i]] + cur) % mod
            res = (res + cur) % mod
        return res
        
                ",1448201308
lccfatc,lccfatc,146,3612,cpp,"#ifdef sigma-yyf
#include ""/Users/yangyf/Desktop/cpcode/leetcode/lc_help.hpp""
#endif
using namespace std;

using ll = long long;
#define ar(x) array<int,x> 
#define all(c) (c).begin(), (c).end()
#define rall(x) (x).rbegin(), (x).rend() 
#define sz(x) (int)(x).size()
#define f0(e) for(int i = 0; i < (e); ++i)
#define f1(e) for(int i = 1; i <= (e); ++i)
#define f2(i,e) for(int i = 0; i < (e); ++i)
#define f3(i,a,b) for (int i=(a);i<(b);i++)
#define r3(i,b,a) for (int i=(b)-1;i>=(a);i--)
#define Sm(a) accumulate((a).begin(), (a).end() , 0ll)
#define Mn(a) (*min_element((a).begin(), (a).end()))
#define Mx(a) (*max_element((a).begin(), (a).end()))
#define rev(a) reverse((a).begin(), (a).end())
#define each(x,a) for(auto& x : a)
mt19937 mrand(random_device{}()); 
int rng(int x) { return mrand() % x;}
int pct(long long x) {return __builtin_popcountll(x);} 
int lg(int x) {return x == 0 ? -1 : 31 - __builtin_clz(x);}
int clg(int x) {return x <= 1 ? 0 : 32 - __builtin_clz(x - 1);}
template<class t,class u> bool cmx(t &a, const u &b){return a < b ? a = b, 1 : 0;}
template<class t,class u> bool cmn(t &a, const u &b){return b < a ? a = b, 1 : 0;}
template <class T> T f_div(const T x, const T y) { T q = x / y, r = x % y; return q - ((x ^ y) < 0 and (r != 0));}
template <class T> T c_div(const T x, const T y) { T q = x / y, r = x % y; return q + ((x ^ y) > 0 and (r != 0));}
template <class T> int lb(const vector<T> &v, const T &x) { return distance(begin(v), lower_bound(begin(v), end(v), x));}
template <class T> int rb(const vector<T> &v, const T &x) { return distance(begin(v), upper_bound(begin(v), end(v), x));}
template<class T,class A> void psum(vector<T>& s, const vector<A>&a){
    int n=a.size();s.resize(n+1);s[0]=0;for(int i=0;i<n;++i)s[i+1]=s[i]+a[i];  
};
template<typename T, typename F> T b_search(T l, T r, bool fst, F &&f) {
    T c = fst ? r : l;
    while(l<=r){T md=(l+r)/2;if(f(md)){c=md; fst?(r=md-1):(l=md+1);} else fst?(l=md+1):(r=md-1);}
    return c;
}
template <typename T, typename U> // pair
ostream& operator<<(ostream& out, const pair<T, U>& a) {return out << a.first << ' ' << a.second;}
template <typename T>  // vector
ostream& operator<<(ostream& out, const vector<T>& a) {for(int i=0,n=a.size(); i<n; ++i) out<<a[i]<<"" \n""[i==n-1]; return out;}
template <typename T, size_t N> // array
ostream& operator<<(ostream& out, const array<T, N>& a) {for(int i=0;i<N;++i)cout<<a[i]<<"" \n""[i==N-1];return out;}
template <typename T, typename U> // pair
istream& operator>>(istream& in, pair<T, U>& a) {return in >> a.first >> a.second;}
template <typename T> // vector
istream& operator>>(istream& in, vector<T>& a) {for (auto &x: a) in >> x; return in;}
template <typename T, size_t N> // array
istream& operator>>(istream& in, array<T, N>& a) {for (int i=0;i<N;++i) in >> a[i]; return in;}
template<class T> void rd(T& x) {cin >> x;}
template<class H, class... T> void rd(H& h, T&... t) {rd(h); rd(t...);}
template<class A> void wt(A x) { cout << x;}
template<class H, class... T> void wt(const H& h, const T&... t) { wt(h); wt(t...);}
bool is_vo(char c){return c=='a' || c=='e' || c=='i' || c=='o' || c=='u';}
int s2t(string &s){return s[0]*600 + s[1]*60 + s[3]*10 + s[4] - 32208;} //s: ""HH:MM"" 
#ifdef sigma-yyf
#define dbg(...) debug_impl(#__VA_ARGS__, __VA_ARGS__)
template <class H, class... Ts> void debug_impl(const char* s, const H& h, const Ts&... t) {
    cerr << s << "": "" << h, ((cerr << "", "" << t), ..., (cerr << ""\n""));
}
#else
#define dbg(...) void(0)
#endif
template<class Fun> class Y_comb {
    Fun _f;
public:
    template<class T> explicit Y_comb(T &&fun): _f(forward<T>(fun)) {}
    template<class ...Args> decltype(auto) operator()(Args &&...As) {return _f(ref(*this), forward<Args>(As)...);}
};
template<class Fun> decltype(auto) y_comb(Fun &&fun) { return Y_comb<decay_t<Fun>>(forward<Fun>(fun));}
struct fast_ios { 
    fast_ios(){ cin.tie(nullptr), ios::sync_with_stdio(false), cout << fixed << setprecision(10);};
} fast_ios_;
constexpr char nl = '\n';
constexpr int inf = 1'061'109'567;
constexpr ll infll = 2'000'000'000'000'000'000;
constexpr int N = 2e5 + 5;
int n, m, k;

class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& a, int k) {
        n=sz(a);
       vector<int> f(n);
        f[n-1]=1;
        for(int i=n-2;i>=0;--i){
        	if(a[i]<a[i+1])f[i]=f[i+1]+1;
        	else f[i]=1;
        }
        // auto chk=[&](int pct,int k){
        // 	for(int i=p;i<p+k-1;++i)if(a[i]>=a[i+1])return 0;
        // 	return 1;
        // };
        if(n<2*k)return 0;
        for(int i=0;i<=n-2*k;++i){
        	if(f[i]>=k&&f[i+k]>=k)return 1;
        }
        return 0;
    }
};

#ifdef sigma-yyf
int main(){
    vector<int> v,a,b;
    string s,t;
    vector<string> sv;
    vector<vector<int>> vv;
    // ListNode* head = nullptr, *l1,*l2;
    // TreeNode* root = nullptr,*p,*q;
    // Solution so;
    // rd(a,k);
    // auto ans = so.;
    // wt(ans);
    cout<<'\n';
    return 0;
}
#endif
",1448260076
lccfatc,lccfatc,146,3619,cpp,"#ifdef sigma-yyf
#include ""/Users/yangyf/Desktop/cpcode/leetcode/lc_help.hpp""
#endif
using namespace std;

using ll = long long;
#define ar(x) array<int,x> 
#define all(c) (c).begin(), (c).end()
#define rall(x) (x).rbegin(), (x).rend() 
#define sz(x) (int)(x).size()
#define f0(e) for(int i = 0; i < (e); ++i)
#define f1(e) for(int i = 1; i <= (e); ++i)
#define f2(i,e) for(int i = 0; i < (e); ++i)
#define f3(i,a,b) for (int i=(a);i<(b);i++)
#define r3(i,b,a) for (int i=(b)-1;i>=(a);i--)
#define Sm(a) accumulate((a).begin(), (a).end() , 0ll)
#define Mn(a) (*min_element((a).begin(), (a).end()))
#define Mx(a) (*max_element((a).begin(), (a).end()))
#define rev(a) reverse((a).begin(), (a).end())
#define each(x,a) for(auto& x : a)
mt19937 mrand(random_device{}()); 
int rng(int x) { return mrand() % x;}
int pct(long long x) {return __builtin_popcountll(x);} 
int lg(int x) {return x == 0 ? -1 : 31 - __builtin_clz(x);}
int clg(int x) {return x <= 1 ? 0 : 32 - __builtin_clz(x - 1);}
template<class t,class u> bool cmx(t &a, const u &b){return a < b ? a = b, 1 : 0;}
template<class t,class u> bool cmn(t &a, const u &b){return b < a ? a = b, 1 : 0;}
template <class T> T f_div(const T x, const T y) { T q = x / y, r = x % y; return q - ((x ^ y) < 0 and (r != 0));}
template <class T> T c_div(const T x, const T y) { T q = x / y, r = x % y; return q + ((x ^ y) > 0 and (r != 0));}
template <class T> int lb(const vector<T> &v, const T &x) { return distance(begin(v), lower_bound(begin(v), end(v), x));}
template <class T> int rb(const vector<T> &v, const T &x) { return distance(begin(v), upper_bound(begin(v), end(v), x));}
template<class T,class A> void psum(vector<T>& s, const vector<A>&a){
    int n=a.size();s.resize(n+1);s[0]=0;for(int i=0;i<n;++i)s[i+1]=s[i]+a[i];  
};
template<typename T, typename F> T b_search(T l, T r, bool fst, F &&f) {
    T c = fst ? r : l;
    while(l<=r){T md=(l+r)/2;if(f(md)){c=md; fst?(r=md-1):(l=md+1);} else fst?(l=md+1):(r=md-1);}
    return c;
}
template <typename T, typename U> // pair
ostream& operator<<(ostream& out, const pair<T, U>& a) {return out << a.first << ' ' << a.second;}
template <typename T>  // vector
ostream& operator<<(ostream& out, const vector<T>& a) {for(int i=0,n=a.size(); i<n; ++i) out<<a[i]<<"" \n""[i==n-1]; return out;}
template <typename T, size_t N> // array
ostream& operator<<(ostream& out, const array<T, N>& a) {for(int i=0;i<N;++i)cout<<a[i]<<"" \n""[i==N-1];return out;}
template <typename T, typename U> // pair
istream& operator>>(istream& in, pair<T, U>& a) {return in >> a.first >> a.second;}
template <typename T> // vector
istream& operator>>(istream& in, vector<T>& a) {for (auto &x: a) in >> x; return in;}
template <typename T, size_t N> // array
istream& operator>>(istream& in, array<T, N>& a) {for (int i=0;i<N;++i) in >> a[i]; return in;}
template<class T> void rd(T& x) {cin >> x;}
template<class H, class... T> void rd(H& h, T&... t) {rd(h); rd(t...);}
template<class A> void wt(A x) { cout << x;}
template<class H, class... T> void wt(const H& h, const T&... t) { wt(h); wt(t...);}
bool is_vo(char c){return c=='a' || c=='e' || c=='i' || c=='o' || c=='u';}
int s2t(string &s){return s[0]*600 + s[1]*60 + s[3]*10 + s[4] - 32208;} //s: ""HH:MM"" 
#ifdef sigma-yyf
#define dbg(...) debug_impl(#__VA_ARGS__, __VA_ARGS__)
template <class H, class... Ts> void debug_impl(const char* s, const H& h, const Ts&... t) {
    cerr << s << "": "" << h, ((cerr << "", "" << t), ..., (cerr << ""\n""));
}
#else
#define dbg(...) void(0)
#endif
template<class Fun> class Y_comb {
    Fun _f;
public:
    template<class T> explicit Y_comb(T &&fun): _f(forward<T>(fun)) {}
    template<class ...Args> decltype(auto) operator()(Args &&...As) {return _f(ref(*this), forward<Args>(As)...);}
};
template<class Fun> decltype(auto) y_comb(Fun &&fun) { return Y_comb<decay_t<Fun>>(forward<Fun>(fun));}
struct fast_ios { 
    fast_ios(){ cin.tie(nullptr), ios::sync_with_stdio(false), cout << fixed << setprecision(10);};
} fast_ios_;
constexpr char nl = '\n';
constexpr int inf = 1'061'109'567;
constexpr ll infll = 2'000'000'000'000'000'000;
constexpr int N = 2e5 + 5;
int n, m, k;

class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& a) {
        n=sz(a);
        vector<int> f(n);
        f[n-1]=1;
        for(int i=n-2;i>=0;--i){
        	if(a[i]<a[i+1])f[i]=f[i+1]+1;
        	else f[i]=1;
        }
        int c=0,l=1,r=n/2;
        while(l<=r){
        	int x=(l+r)/2;
        	bool o=0;
        	for(int i=0;i<=n-2*x;++i){
            	if(f[i]>=x&&f[i+x]>=x){
                    o=1;break;
                }
            }
            if(o){
            	c=x;l=x+1;
            }else r=x-1;
        }

        return c;
    }
};

#ifdef sigma-yyf
int main(){
    vector<int> v,a,b;
    string s,t;
    vector<string> sv;
    vector<vector<int>> vv;
    // ListNode* head = nullptr, *l1,*l2;
    // TreeNode* root = nullptr,*p,*q;
    // Solution so;
    // rd(a,k);
    // auto ans = so.;
    // wt(ans);
    cout<<'\n';
    return 0;
}
#endif
",1448259811
lccfatc,lccfatc,146,3631,cpp,"#ifdef sigma-yyf
#include ""/Users/yangyf/Desktop/cpcode/leetcode/lc_help.hpp""
#endif
using namespace std;

using ll = long long;
#define ar(x) array<int,x> 
#define all(c) (c).begin(), (c).end()
#define rall(x) (x).rbegin(), (x).rend() 
#define sz(x) (int)(x).size()
#define f0(e) for(int i = 0; i < (e); ++i)
#define f1(e) for(int i = 1; i <= (e); ++i)
#define f2(i,e) for(int i = 0; i < (e); ++i)
#define f3(i,a,b) for (int i=(a);i<(b);i++)
#define r3(i,b,a) for (int i=(b)-1;i>=(a);i--)
#define Sm(a) accumulate((a).begin(), (a).end() , 0ll)
#define Mn(a) (*min_element((a).begin(), (a).end()))
#define Mx(a) (*max_element((a).begin(), (a).end()))
#define rev(a) reverse((a).begin(), (a).end())
#define each(x,a) for(auto& x : a)
mt19937 mrand(random_device{}()); 
int rng(int x) { return mrand() % x;}
int pct(long long x) {return __builtin_popcountll(x);} 
int lg(int x) {return x == 0 ? -1 : 31 - __builtin_clz(x);}
int clg(int x) {return x <= 1 ? 0 : 32 - __builtin_clz(x - 1);}
template<class t,class u> bool cmx(t &a, const u &b){return a < b ? a = b, 1 : 0;}
template<class t,class u> bool cmn(t &a, const u &b){return b < a ? a = b, 1 : 0;}
template <class T> T f_div(const T x, const T y) { T q = x / y, r = x % y; return q - ((x ^ y) < 0 and (r != 0));}
template <class T> T c_div(const T x, const T y) { T q = x / y, r = x % y; return q + ((x ^ y) > 0 and (r != 0));}
template <class T> int lb(const vector<T> &v, const T &x) { return distance(begin(v), lower_bound(begin(v), end(v), x));}
template <class T> int rb(const vector<T> &v, const T &x) { return distance(begin(v), upper_bound(begin(v), end(v), x));}
template<class T,class A> void psum(vector<T>& s, const vector<A>&a){
    int n=a.size();s.resize(n+1);s[0]=0;for(int i=0;i<n;++i)s[i+1]=s[i]+a[i];  
};
template<typename T, typename F> T b_search(T l, T r, bool fst, F &&f) {
    T c = fst ? r : l;
    while(l<=r){T md=(l+r)/2;if(f(md)){c=md; fst?(r=md-1):(l=md+1);} else fst?(l=md+1):(r=md-1);}
    return c;
}
template <typename T, typename U> // pair
ostream& operator<<(ostream& out, const pair<T, U>& a) {return out << a.first << ' ' << a.second;}
template <typename T>  // vector
ostream& operator<<(ostream& out, const vector<T>& a) {for(int i=0,n=a.size(); i<n; ++i) out<<a[i]<<"" \n""[i==n-1]; return out;}
template <typename T, size_t N> // array
ostream& operator<<(ostream& out, const array<T, N>& a) {for(int i=0;i<N;++i)cout<<a[i]<<"" \n""[i==N-1];return out;}
template <typename T, typename U> // pair
istream& operator>>(istream& in, pair<T, U>& a) {return in >> a.first >> a.second;}
template <typename T> // vector
istream& operator>>(istream& in, vector<T>& a) {for (auto &x: a) in >> x; return in;}
template <typename T, size_t N> // array
istream& operator>>(istream& in, array<T, N>& a) {for (int i=0;i<N;++i) in >> a[i]; return in;}
template<class T> void rd(T& x) {cin >> x;}
template<class H, class... T> void rd(H& h, T&... t) {rd(h); rd(t...);}
template<class A> void wt(A x) { cout << x;}
template<class H, class... T> void wt(const H& h, const T&... t) { wt(h); wt(t...);}
bool is_vo(char c){return c=='a' || c=='e' || c=='i' || c=='o' || c=='u';}
int s2t(string &s){return s[0]*600 + s[1]*60 + s[3]*10 + s[4] - 32208;} //s: ""HH:MM"" 
#ifdef sigma-yyf
#define dbg(...) debug_impl(#__VA_ARGS__, __VA_ARGS__)
template <class H, class... Ts> void debug_impl(const char* s, const H& h, const Ts&... t) {
    cerr << s << "": "" << h, ((cerr << "", "" << t), ..., (cerr << ""\n""));
}
#else
#define dbg(...) void(0)
#endif
template<class Fun> class Y_comb {
    Fun _f;
public:
    template<class T> explicit Y_comb(T &&fun): _f(forward<T>(fun)) {}
    template<class ...Args> decltype(auto) operator()(Args &&...As) {return _f(ref(*this), forward<Args>(As)...);}
};
template<class Fun> decltype(auto) y_comb(Fun &&fun) { return Y_comb<decay_t<Fun>>(forward<Fun>(fun));}
struct fast_ios { 
    fast_ios(){ cin.tie(nullptr), ios::sync_with_stdio(false), cout << fixed << setprecision(10);};
} fast_ios_;
constexpr char nl = '\n';
constexpr int inf = 1'061'109'567;
constexpr ll infll = 2'000'000'000'000'000'000;
constexpr int N = 2e5 + 5;
int n, m, k;

ll inverse(ll a, ll m) { 
    a %= m; if (a == 0) return 0; if (a < 0) a += m;
    ll u = 0, v = 1;
    while (a) { ll t = m / a;  m -= t * a; swap(a, m); u -= t * v; swap(u, v); }
    return u;
}
template <int m, bool is_prime = true>
struct static_mod {
    using mint = static_mod;
    static constexpr int mod() { return m; }
    static_mod() : _v(0) {}
    template <class T> static_mod(T v) {ll x = (ll)(v % (ll)(umod())); if (x < 0) x += umod(); _v = (unsigned int)(x);}
    static_mod(unsigned int v) { _v = (unsigned int)(v % umod());}
    unsigned int val() const { return _v; }
    mint& operator++() { _v++; if (_v == umod()) _v = 0; return *this;}
    mint& operator--() { if (_v == 0) _v = umod(); _v--; return *this;}
    mint operator++(int) { mint result = *this; ++*this; return result;}
    mint operator--(int) { mint result = *this; --*this; return result;}
    mint& operator+=(const mint& rhs) { _v += rhs._v; if (_v >= umod()) _v -= umod();return *this;}
    mint& operator-=(const mint& rhs) { _v -= rhs._v; if (_v >= umod()) _v += umod();return *this;}
    mint& operator*=(const mint& rhs) { unsigned long long z = _v; z *= rhs._v; _v = (unsigned int)(z % umod()); return *this;}
    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }
    mint operator+() const { return *this; }
    mint operator-() const { return mint() - *this; }
    mint pow(ll n) const {mint x = *this, r = 1; while (n) { if (n & 1) r *= x; x *= x;n >>= 1;} return r;}
    mint inv() const { if(is_prime) {assert(_v);return pow(umod() - 2);} return inverse(_v, m);}
    friend mint operator+(const mint& lhs, const mint& rhs) { return mint(lhs) += rhs;}
    friend mint operator-(const mint& lhs, const mint& rhs) { return mint(lhs) -= rhs;}
    friend mint operator*(const mint& lhs, const mint& rhs) { return mint(lhs) *= rhs;}
    friend mint operator/(const mint& lhs, const mint& rhs) { return mint(lhs) /= rhs;}
    friend bool operator==(const mint& lhs, const mint& rhs) { return lhs._v == rhs._v;}
    friend bool operator!=(const mint& lhs, const mint& rhs) { return lhs._v != rhs._v;}
    friend ostream& operator << (ostream& out, const mint& n) { return out << n.val(); }
    friend istream& operator >> (istream& in, mint& n) { ll x; in >> x; n = mint(x); return in; }
private:
    unsigned int _v;
    static constexpr unsigned int umod() { return m; }
};
using mint = static_mod<1000000007>; // 1000000007

struct Comb {
    vector<mint> fac, inv;
    vector<vector<mint>> s1, s2;
    Comb() : fac(1, 1), inv(1, 1){}
    void reserve(int a){
        if(fac.size() >= a) return;
        if(a < fac.size() * 2) a = fac.size() * 2;
        while(fac.size() < a) fac.push_back(fac.back() * mint(fac.size()));
        inv.resize(fac.size());
        inv.back() = fac.back().inv();
        for(int i = inv.size() - 1; inv[i - 1] == 0; i--) inv[i - 1] = inv[i] * i;
    }
    mint fact(int n){ if(n < 0) return 0; reserve(n + 1); return fac[n]; }
    mint invfac(int n) {if(n < 0) return 0; reserve(n + 1); return inv[n]; }
    mint P(int n, int r){ // 排列数
        if(r < 0 || n < r) return 0;
        if(n >> 24){ mint ans = 1; for(int i = 0; i < r; i++) ans *= n--; return ans; }
        reserve(n + 1); return fac[n] * inv[n - r];
    }
    mint Q(int n) {reserve(n); return fac[n - 1];} // n个元素的圆排列数
    mint C(int n, int m) { // 组合数
        if (n < m || m < 0) return 0;
        reserve(n + 1);
        return fac[n] * inv[m] * inv[n - m];
    }
    mint MC(int n, int m) { // r个相同物品放到n个篮子方案数
        return C(n + m - 1, n - 1);
    }
    mint catalan(int n) {
        reserve(n * 2 + 1); return fac[n * 2] * inv[n] * inv[n + 1];
    }
    mint CQ(int n, int m) {  // n个元素中选m个元素围成一圈的圆排列数。
        return C(n, m) * Q(m);
    }
    mint D(int n) { // 1-n的排列p的错位排列数  D[n]=(n-1)*(D[n-1]+D[n-2])
        if (n <= 3) return mint(n - 1);
        mint x = 1, y = 2, ans;
        for (int i = 4; i <= n; ++i) {
            ans = (i - 1) * (x + y);
            x = y, y = ans;
        }
        return ans;
    }
    mint stl1(int n, int m) { //n个不同元素，划分为m个非空圆排列的方案数(第一类斯特林数)
        if (s1.size() == 0) {
            int N = 10, M = 5;  // 根据题目数据范围调整
            s1.assign(N, vector<mint>(M));
            s1[0][0] = 1;
            for (int i = 1; i < N; ++i) for (int j = 1; j < M; ++j) {
                s1[i][j] = s1[i - 1][j - 1] + (i - 1) * s1[i - 1][j];
            }
        }
        return s1[n][m];
    }
    mint stl2(int n, int m) {// n个不同元素，划分为m个非空子集的方案数(第二类斯特林数)
        if (s2.size() == 0) {
            int N = 10, M = 5;  // 根据题目数据范围调整
            s2.assign(N, vector<mint>(M));
            s2[0][0] = 1;
            for (int i = 1; i < N; ++i) for (int j = 1; j < M; ++j) {
                s2[i][j] = s2[i - 1][j - 1] + j * s2[i - 1][j];
            }
        }
        return s2[n][m];
    }
} comb;

void sub(string &s){
	int n=sz(s);
	for(int j=n-1;j>=0;--j){
		if(s[j]=='1'){
			s[j]='0';
			for(int i=j+1;i<n;++i){
				s[i]='1';
			}
			break;
		}
	}
	rev(s);
	while(s.back()=='0')s.pop_back();
	rev(s);
}

class Solution {
public:
    int countKReducibleNumbers(string s, int K) {
    	if(s==""1"") return 0;
    	sub(s);
    	n=sz(s);
    	int c1=count(all(s),'1');
    	vector<mint> f(n+1);
        f[1]=0;
        for(int i=2;i<=n;++i){
        	f[i]=f[pct(i)]+1;
        }
        auto calk = [&](int k){
	        mint c=0;
	        int e=0;
	        f0(n){
	        	if(s[i]=='0')continue;
	        	int l=max(e,1);
	        	for(int j=l;j<=n;++j){
	        		if(f[j]==k-1){
	        			c+=comb.C(n-i-1,j-e);
	        			if(i==0&&k==1)c--;
	        		}
	        	}
	        	e++;
	        }
	        if(f[c1]==k-1)c++;
	        return c;
        };
        mint c=1;
        for(int k=1;k<=K;++k)
        	c+=calk(k);
        return c.val();
    }
};

#ifdef sigma-yyf
int main(){
    vector<int> v,a,b;
    string s,t;
    vector<string> sv;
    vector<vector<int>> vv;
    // ListNode* head = nullptr, *l1,*l2;
    // TreeNode* root = nullptr,*p,*q;
    // Solution so;
    // rd(a,k);
    // auto ans = so.;
    // wt(ans);
    cout<<'\n';
    return 0;
}
#endif
",1448259271
lccfatc,lccfatc,146,3646,cpp,"#ifdef sigma-yyf
#include ""/Users/yangyf/Desktop/cpcode/leetcode/lc_help.hpp""
#endif
using namespace std;

using ll = long long;
#define ar(x) array<int,x> 
#define all(c) (c).begin(), (c).end()
#define rall(x) (x).rbegin(), (x).rend() 
#define sz(x) (int)(x).size()
#define f0(e) for(int i = 0; i < (e); ++i)
#define f1(e) for(int i = 1; i <= (e); ++i)
#define f2(i,e) for(int i = 0; i < (e); ++i)
#define f3(i,a,b) for (int i=(a);i<(b);i++)
#define r3(i,b,a) for (int i=(b)-1;i>=(a);i--)
#define Sm(a) accumulate((a).begin(), (a).end() , 0ll)
#define Mn(a) (*min_element((a).begin(), (a).end()))
#define Mx(a) (*max_element((a).begin(), (a).end()))
#define rev(a) reverse((a).begin(), (a).end())
#define each(x,a) for(auto& x : a)
mt19937 mrand(random_device{}()); 
int rng(int x) { return mrand() % x;}
int pct(long long x) {return __builtin_popcountll(x);} 
int lg(int x) {return x == 0 ? -1 : 31 - __builtin_clz(x);}
int clg(int x) {return x <= 1 ? 0 : 32 - __builtin_clz(x - 1);}
template<class t,class u> bool cmx(t &a, const u &b){return a < b ? a = b, 1 : 0;}
template<class t,class u> bool cmn(t &a, const u &b){return b < a ? a = b, 1 : 0;}
template <class T> T f_div(const T x, const T y) { T q = x / y, r = x % y; return q - ((x ^ y) < 0 and (r != 0));}
template <class T> T c_div(const T x, const T y) { T q = x / y, r = x % y; return q + ((x ^ y) > 0 and (r != 0));}
template <class T> int lb(const vector<T> &v, const T &x) { return distance(begin(v), lower_bound(begin(v), end(v), x));}
template <class T> int rb(const vector<T> &v, const T &x) { return distance(begin(v), upper_bound(begin(v), end(v), x));}
template<class T,class A> void psum(vector<T>& s, const vector<A>&a){
    int n=a.size();s.resize(n+1);s[0]=0;for(int i=0;i<n;++i)s[i+1]=s[i]+a[i];  
};
template<typename T, typename F> T b_search(T l, T r, bool fst, F &&f) {
    T c = fst ? r : l;
    while(l<=r){T md=(l+r)/2;if(f(md)){c=md; fst?(r=md-1):(l=md+1);} else fst?(l=md+1):(r=md-1);}
    return c;
}
template <typename T, typename U> // pair
ostream& operator<<(ostream& out, const pair<T, U>& a) {return out << a.first << ' ' << a.second;}
template <typename T>  // vector
ostream& operator<<(ostream& out, const vector<T>& a) {for(int i=0,n=a.size(); i<n; ++i) out<<a[i]<<"" \n""[i==n-1]; return out;}
template <typename T, size_t N> // array
ostream& operator<<(ostream& out, const array<T, N>& a) {for(int i=0;i<N;++i)cout<<a[i]<<"" \n""[i==N-1];return out;}
template <typename T, typename U> // pair
istream& operator>>(istream& in, pair<T, U>& a) {return in >> a.first >> a.second;}
template <typename T> // vector
istream& operator>>(istream& in, vector<T>& a) {for (auto &x: a) in >> x; return in;}
template <typename T, size_t N> // array
istream& operator>>(istream& in, array<T, N>& a) {for (int i=0;i<N;++i) in >> a[i]; return in;}
template<class T> void rd(T& x) {cin >> x;}
template<class H, class... T> void rd(H& h, T&... t) {rd(h); rd(t...);}
template<class A> void wt(A x) { cout << x;}
template<class H, class... T> void wt(const H& h, const T&... t) { wt(h); wt(t...);}
bool is_vo(char c){return c=='a' || c=='e' || c=='i' || c=='o' || c=='u';}
int s2t(string &s){return s[0]*600 + s[1]*60 + s[3]*10 + s[4] - 32208;} //s: ""HH:MM"" 
#ifdef sigma-yyf
#define dbg(...) debug_impl(#__VA_ARGS__, __VA_ARGS__)
template <class H, class... Ts> void debug_impl(const char* s, const H& h, const Ts&... t) {
    cerr << s << "": "" << h, ((cerr << "", "" << t), ..., (cerr << ""\n""));
}
#else
#define dbg(...) void(0)
#endif
template<class Fun> class Y_comb {
    Fun _f;
public:
    template<class T> explicit Y_comb(T &&fun): _f(forward<T>(fun)) {}
    template<class ...Args> decltype(auto) operator()(Args &&...As) {return _f(ref(*this), forward<Args>(As)...);}
};
template<class Fun> decltype(auto) y_comb(Fun &&fun) { return Y_comb<decay_t<Fun>>(forward<Fun>(fun));}
struct fast_ios { 
    fast_ios(){ cin.tie(nullptr), ios::sync_with_stdio(false), cout << fixed << setprecision(10);};
} fast_ios_;
constexpr char nl = '\n';
constexpr int inf = 1'061'109'567;
constexpr ll infll = 2'000'000'000'000'000'000;
constexpr int N = 2e5 + 5;
int n, m, k;

ll inverse(ll a, ll m) { 
    a %= m; if (a == 0) return 0; if (a < 0) a += m;
    ll u = 0, v = 1;
    while (a) { ll t = m / a;  m -= t * a; swap(a, m); u -= t * v; swap(u, v); }
    return u;
}
template <int m, bool is_prime = true>
struct static_mod {
    using mint = static_mod;
    static constexpr int mod() { return m; }
    static_mod() : _v(0) {}
    template <class T> static_mod(T v) {ll x = (ll)(v % (ll)(umod())); if (x < 0) x += umod(); _v = (unsigned int)(x);}
    static_mod(unsigned int v) { _v = (unsigned int)(v % umod());}
    unsigned int val() const { return _v; }
    mint& operator++() { _v++; if (_v == umod()) _v = 0; return *this;}
    mint& operator--() { if (_v == 0) _v = umod(); _v--; return *this;}
    mint operator++(int) { mint result = *this; ++*this; return result;}
    mint operator--(int) { mint result = *this; --*this; return result;}
    mint& operator+=(const mint& rhs) { _v += rhs._v; if (_v >= umod()) _v -= umod();return *this;}
    mint& operator-=(const mint& rhs) { _v -= rhs._v; if (_v >= umod()) _v += umod();return *this;}
    mint& operator*=(const mint& rhs) { unsigned long long z = _v; z *= rhs._v; _v = (unsigned int)(z % umod()); return *this;}
    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }
    mint operator+() const { return *this; }
    mint operator-() const { return mint() - *this; }
    mint pow(ll n) const {mint x = *this, r = 1; while (n) { if (n & 1) r *= x; x *= x;n >>= 1;} return r;}
    mint inv() const { if(is_prime) {assert(_v);return pow(umod() - 2);} return inverse(_v, m);}
    friend mint operator+(const mint& lhs, const mint& rhs) { return mint(lhs) += rhs;}
    friend mint operator-(const mint& lhs, const mint& rhs) { return mint(lhs) -= rhs;}
    friend mint operator*(const mint& lhs, const mint& rhs) { return mint(lhs) *= rhs;}
    friend mint operator/(const mint& lhs, const mint& rhs) { return mint(lhs) /= rhs;}
    friend bool operator==(const mint& lhs, const mint& rhs) { return lhs._v == rhs._v;}
    friend bool operator!=(const mint& lhs, const mint& rhs) { return lhs._v != rhs._v;}
    friend ostream& operator << (ostream& out, const mint& n) { return out << n.val(); }
    friend istream& operator >> (istream& in, mint& n) { ll x; in >> x; n = mint(x); return in; }
private:
    unsigned int _v;
    static constexpr unsigned int umod() { return m; }
};
using mint = static_mod<1000000007>; // 1000000007


class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& a) {
        n=sz(a);
        vector<mint> f(n);
        f[0]=1;
        vector<mint> g(n);
        map<int,mint> mp;
        mp[a[0]]=1;
        g[0]=a[0];
        map<int,mint> m1;
        m1[a[0]]=a[0];
        for(int i=1;i<n;++i){
        	mint c=1,s=a[i];
        	if(mp.count(a[i]-1)){
        		c+=mp[a[i]-1];
        		s+=mp[a[i]-1]*a[i]+m1[a[i]-1];
        	}
        	if(mp.count(a[i]+1)){
        		c+=mp[a[i]+1];
        		s+=mp[a[i]+1]*a[i]+m1[a[i]+1];
        	}
        	f[i]=c;
        	g[i]=s;
        	mp[a[i]]+=c;
        	m1[a[i]]+=s;
        }
        mint c=0;
        f0(n)c+=g[i];
        return c.val();
    }
};

#ifdef sigma-yyf
int main(){
    vector<int> v,a,b;
    string s,t;
    vector<string> sv;
    vector<vector<int>> vv;
    // ListNode* head = nullptr, *l1,*l2;
    // TreeNode* root = nullptr,*p,*q;
    // Solution so;
    // rd(a,k);
    // auto ans = so.;
    // wt(ans);
    cout<<'\n';
    return 0;
}
#endif
",1448259521
Huzaifa Khilawala,RedHeadphone,147,3612,python3,"
class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)

        incre = [0] * n
        for i in range(1,n):
            if nums[i] > nums[i-1]:
                incre[i] = 1
        
        incre_preffix = list(itertools.accumulate(incre))

        def incresi(l,r):
            return incre_preffix[r-1] - incre_preffix[l] == (r-l-1)

        def check(k):  
            for i in range(n-2*k+1):
                if incresi(i,i+k) and incresi(i+k,i+2*k):
                    return True
            return False

        return check(k)",1448199406
Huzaifa Khilawala,RedHeadphone,147,3619,python3,"
def binary_search(left, right, check, start_from_left):
    if start_from_left:
        ans = left
    else:
        ans = right
    while left <= right:
        mid = (left + right) // 2
        if start_from_left:
            if check(mid):
                ans, left = mid, mid + 1
            else:
                right = mid - 1
        else:
            if check(mid):
                ans, right = mid, mid - 1
            else:
                left = mid + 1
    return ans

class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)

        incre = [0] * n
        for i in range(1,n):
            if nums[i] > nums[i-1]:
                incre[i] = 1
        
        incre_preffix = list(itertools.accumulate(incre))

        def incresi(l,r):
            return incre_preffix[r-1] - incre_preffix[l] == (r-l-1)

        def check(k):  
            for i in range(n-2*k+1):
                if incresi(i,i+k) and incresi(i+k,i+2*k):
                    return True
            return False


        ans = binary_search(1,n//2,check,True)
        return ans",1448198259
Huzaifa Khilawala,RedHeadphone,147,3631,python3,"
MOD = 10**9 + 7

class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        n = len(s)

        precom = [0]*(n+1)
        precom[0] = -1
        for i in range(2,n+1):
            set_c = bin(i).count(""1"")
            precom[i] = 1+precom[set_c]
            

        @cache
        def dp(i,set_c,touching):
            if i == n:
                if touching==1:
                    return 0
                else:
                    return 1 if (precom[set_c]<k and set_c!=0) else 0

            if touching==1:
                if s[i]=='1':
                    return (dp(i+1,set_c+1,1)+dp(i+1,set_c,0))%MOD
                else:
                    return dp(i+1,set_c,1)%MOD
            else:
                return (dp(i+1,set_c,0)+dp(i+1,set_c+1,0))%MOD

        ans = dp(0,0,1)

        return ans",1448260387
Huzaifa Khilawala,RedHeadphone,147,3646,python3,"
MOD = 10**9 + 7

class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        n = len(nums)
        mapp = {}
        ans = 0
        for i in range(n-1,-1,-1):
            temps = 0
            tempc = 1
            if nums[i]+1 in mapp:
                temps += mapp[nums[i]+1][0]
                tempc += mapp[nums[i]+1][1]
            if nums[i]-1 in mapp:
                temps += mapp[nums[i]-1][0]
                tempc += mapp[nums[i]-1][1]
            
            tempc %= MOD
            temps += tempc*nums[i]
            temps %= MOD

            ans+=temps
            ans%=MOD

            if nums[i] not in mapp:
                mapp[nums[i]] = [temps,tempc]
            else:
                mapp[nums[i]][0]+=temps
                mapp[nums[i]][0] %= MOD
                mapp[nums[i]][1]+=tempc
                mapp[nums[i]][1] %= MOD
            
        return ans

",1448216920
Muhammad Hasan,mhasan01,148,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& a, int k) {
        int n = (int) a.size();
        for (int i = 0; i < n; i++) {
            int x = i + k - 1;
            int y = i + 2 * k - 1;
            if (y >= n) {
                break;
            }
            bool ok = true;
            for (int j = i + 1; j <= x; j++) {
                if (a[j - 1] >= a[j]) {
                    ok = false;
                    break;
                }
            }
            for (int j = x + 2; j <= y; j++) {
                if (a[j - 1] >= a[j]) {
                    ok = false;
                    break;
                }
            }
            if (ok) {
                return ok;
            }
        }
        return false;
    }
};",1448257333
Muhammad Hasan,mhasan01,148,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& a) {
        int n = (int) a.size();
        vector<int> pre(n - 1);
        for (int i = 0; i + 1 < n; i++) {
            pre[i] = (a[i] >= a[i + 1]);
            if (i > 0) {
                pre[i] += pre[i - 1];
            }
        }
        
        auto can = [&](int k) {
            for (int i = 0; i < n; i++) {
                int x = i + k - 1;
                int y = i + 2 * k - 1;
                if (y >= n) {
                    break;
                }
                if (pre[x - 1] - (i > 0 ? pre[i - 1] : 0) > 0) {
                    continue;
                }
                if (pre[y - 1] - pre[x] > 0) {
                    continue;
                }
                return true;
            }
            return false;
        };
        
        int l = 2, r = n, ans = 1;
        while (l <= r) {
            int mid = (l + r) >> 1;
            if (can(mid)) {
                l = mid + 1;
                ans = mid;
            } else {
                r = mid - 1;
            }
        }
        return ans;
    }
};",1448260771
Muhammad Hasan,mhasan01,148,3631,cpp,"struct mint {
    const int MOD = 1e9 + 7;
    int x;

    mint(int _x) : x((_x % MOD + MOD) % MOD) {}
    mint(long long _x) : x((_x % MOD + MOD) % MOD) {}

    mint() : x(0) {}

    mint &operator=(const mint &rhs) {
        x = rhs.x;
        return *this;
    }

    mint pow(long long n) const {
        assert(0 <= n);
        mint x = *this, r = mint(1);
        while (n)
        {
            if (n & 1)
                r *= x;
            x *= x;
            n >>= 1;
        }
        return r;
    }

    mint inv() const {
        return pow(MOD - 2);
    }

    mint &operator+=(const mint &rhs) {
        x += rhs.x;
        if (x >= MOD)
            x -= MOD;
        return *this;
    }

    mint &operator-=(const mint &rhs) {
        x -= rhs.x;
        if (x < 0)
            x += MOD;
        return *this;
    }

    mint &operator*=(const mint &rhs) {
        unsigned long long z = x;
        z *= rhs.x;
        x = (unsigned int)(z % MOD);
        return *this;
    }

    mint &operator/=(const mint &rhs) {
        return *this = *this * rhs.inv();
    }

    friend mint operator+(const mint &lhs, const mint &rhs) {
        return mint(lhs) += rhs;
    }

    friend mint operator-(const mint &lhs, const mint &rhs) {
        return mint(lhs) -= rhs;
    }

    friend mint operator*(const mint &lhs, const mint &rhs) {
        return mint(lhs) *= rhs;
    }

    friend mint operator/(const mint &lhs, const mint &rhs) {
        return mint(lhs) /= rhs;
    }

    friend ostream& operator<<(ostream &os, const mint &m) {
        return os << m.x;
    }
};

const int N = 805;
const int K = 5;

vector<int> cnts[K + 5];
bool done = false;
mint dp[2][2][N];

class Solution {
public:
    int get(int x) {
        int cnt = 0;
        for (int i = 15; i >= 0; i--) {
            if (x & (1 << i)) {
                cnt++;
            }
        }
        x = cnt;
        return x;
    }
    
    int countKReducibleNumbers(string s, int kk) {
        if (!done) {
            for (int i = 1; i < N; i++) {
                int x = i;
                for (int j = 1; j <= K; j++) {
                    if (x == 1) {
                        cnts[j].emplace_back(i);
                    }
                    x = get(x);
                }
            }
            done = true;
        }
        int n = (int) s.length();
        for (int i = 0; i < 2; i++) {
            for (int j = 0; j < 2; j++) {
                for (int k = 0; k < N; k++) {
                    dp[i][j][k] = 0;
                }
            }
        }
        dp[0][0][1] = 1;
        dp[0][1][0] = 1;
        for (int i = 1; i < n; i++) {
            int cur = (i & 1);
            int bef = 1 - cur;
            for (int j = 0; j < 2; j++) {
                for (int k = 0; k < N; k++) {
                    dp[cur][j][k] = 0;
                }
            }
            for (int k = 0; k < N; k++) {
                if (s[i] == '1') {
                    dp[cur][1][k] += dp[bef][0][k];
                    if (k + 1 < N) {
                        dp[cur][0][k + 1] += dp[bef][0][k];
                    }
                } else {
                    dp[cur][0][k] += dp[bef][0][k];
                }
                dp[cur][1][k] += dp[bef][1][k];
                if (k + 1 < N) {
                    dp[cur][1][k + 1] += dp[bef][1][k];
                }
            }
        }
        int cur = (n - 1) & 1;
        mint ans = 0;
        for (int x : cnts[kk]) {
            ans += dp[cur][1][x];
        }
        return ans.x;
    }
};",1448255575
Muhammad Hasan,mhasan01,148,3646,cpp,"struct mint {
    const int MOD = 1e9 + 7;
    int x;

    mint(int _x) : x((_x % MOD + MOD) % MOD) {}
    mint(long long _x) : x((_x % MOD + MOD) % MOD) {}

    mint() : x(0) {}

    mint &operator=(const mint &rhs) {
        x = rhs.x;
        return *this;
    }

    mint pow(long long n) const {
        assert(0 <= n);
        mint x = *this, r = mint(1);
        while (n)
        {
            if (n & 1)
                r *= x;
            x *= x;
            n >>= 1;
        }
        return r;
    }

    mint inv() const {
        return pow(MOD - 2);
    }

    mint &operator+=(const mint &rhs) {
        x += rhs.x;
        if (x >= MOD)
            x -= MOD;
        return *this;
    }

    mint &operator-=(const mint &rhs) {
        x -= rhs.x;
        if (x < 0)
            x += MOD;
        return *this;
    }

    mint &operator*=(const mint &rhs) {
        unsigned long long z = x;
        z *= rhs.x;
        x = (unsigned int)(z % MOD);
        return *this;
    }

    mint &operator/=(const mint &rhs) {
        return *this = *this * rhs.inv();
    }

    friend mint operator+(const mint &lhs, const mint &rhs) {
        return mint(lhs) += rhs;
    }

    friend mint operator-(const mint &lhs, const mint &rhs) {
        return mint(lhs) -= rhs;
    }

    friend mint operator*(const mint &lhs, const mint &rhs) {
        return mint(lhs) *= rhs;
    }

    friend mint operator/(const mint &lhs, const mint &rhs) {
        return mint(lhs) /= rhs;
    }

    friend ostream& operator<<(ostream &os, const mint &m) {
        return os << m.x;
    }
};

const int N = 1e5 + 5;

mint dp[N];
mint ways[N];

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& a) {
        mint ans = 0;
        for (int x : a) {
            mint cur = 1;
            mint sum = 0;
            for (int y : {x - 1, x + 1}) {
                if (y < 0) {
                    continue;
                }
                cur += ways[y];
                sum += dp[y];
            }
            sum += cur * x;
            dp[x] += sum;
            ways[x] += cur;
            ans += sum;
        }
        for (int x : a) {
            dp[x] = 0;
            ways[x] = 0;
        }
        return ans.x;
    }
};",1448256381
haohao,cchao,150,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& a, int k) {
        const int n = a.size();
        vector<bool> b(n - k + 1);
        for (int i = 0; i < n - k + 1; ++i) {
            b[i] = true;
            for (int j = 0; j < k - 1; ++j) {
                if (a[i + j] >= a[i + j + 1]) {
                    b[i] = false;
                    break;
                }
            }
            if (b[i] && i >= k && b[i - k]) return true;
        }
        return false;
    }
};",1448186868
haohao,cchao,150,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        const int n = nums.size();
        vector<int> to_left(n), to_right(n);
        for (int i = 0, tmp = 0; i < n; ++i) {
            if (i && nums[i] > nums[i - 1]) {
                ++tmp;
            } else {
                tmp = 1;
            }
            to_left[i] = tmp;
        }
        for (int i = n - 1, tmp = 0; i >= 0; --i) {
            if (i + 1 < n && nums[i] < nums[i + 1]) {
                ++tmp;
            } else {
                tmp = 1;
            }
            to_right[i] = tmp;
        }
        int ans = 0;
        for (int i = 0; i + 1 < n; ++i) {
            ans = max(ans, min(to_left[i], to_right[i + 1]));
        }
        return ans;
    }
};",1448196465
haohao,cchao,150,3631,cpp,"vector<int> d(1010);
int f[801][801][2];
void init() {
  if (d[0] > 0) return;
  d[0] = INT_MAX;
  for (uint32_t i = 2; i < d.size(); ++i) {
    d[i] = d[std::popcount(i)] + 1;
  }
}

constexpr int64_t mod = 1e9 + 7;
class Solution {
  string s;
  int k;
  int dfs(int x, int cnt, bool small) {
    if (x == s.size()) {
      return small && d[cnt] <= k;
    }
    if (f[x][cnt][small] >= 0) {
      return f[x][cnt][small];
    }
    int64_t ans = 0;
    const int digit = s[x] - '0';
    ans += dfs(x + 1, cnt, small || 0 < digit);
    if (small || digit == 1) ans += dfs(x + 1, cnt + 1, small);
    return f[x][cnt][small] = ans % mod;
  }

 public:
  int countKReducibleNumbers(string s, int k) {
    memset(f, -1, sizeof f);
    init();
    this->s = s;
    this->k = k - 1;
    return dfs(0, 0, 0);
  }
};
",1448253529
haohao,cchao,150,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        constexpr long long mod = 1e9 + 7;
        unordered_map<long long, long long> sum;
        unordered_map<long long, long long> cnt;

        for (int x : nums) {
            const vector<int> b = {x - 1, x + 1};
            cnt[x] += 1;
            sum[x] += x;
            for (int y : b) {
                if (!cnt.count(y)) continue;
                cnt[x] += cnt[y];
                sum[x] += sum[y] + cnt[y] * x;
                cnt[x] %= mod;
                sum[x] %= mod;
            }
        }
        long long ans = 0;
        for (auto it : sum) ans += it.second;
        return ans % mod;
    }
};",1448208972
Tin,tin_le,151,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& a, int k) {
        int n = a.size();
        vector<int> rightMost(n);
        iota(begin(rightMost), end(rightMost), 0);
        for(int i = n - 2; i >= 0; i--) {
            if(a[i] < a[i + 1]) rightMost[i] = rightMost[i + 1]; 
        }
        int res = 0;
        for(int i = 0; i < n; i++) {
            int r = rightMost[i];
            res = max(res, (r - i + 1) / 2);
            if(r + 1 < n) {
                int f = r - i + 1;
                int g = rightMost[r + 1] - r;
                if(g >= f) {
                    res = max(res, f);
                }
            }
        }
        return res >= k;
    }
};",1448192841
Tin,tin_le,151,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& a) {
        int n = a.size();
        vector<int> rightMost(n);
        iota(begin(rightMost), end(rightMost), 0);
        for(int i = n - 2; i >= 0; i--) {
            if(a[i] < a[i + 1]) rightMost[i] = rightMost[i + 1]; 
        }
        int res = 0;
        for(int i = 0; i < n; i++) {
            int r = rightMost[i];
            res = max(res, (r - i + 1) / 2);
            if(r + 1 < n) {
                int f = r - i + 1;
                int g = rightMost[r + 1] - r;
                if(g >= f) {
                    res = max(res, f);
                }
            }
        }
        return res;
        
    }
};",1448191366
Tin,tin_le,151,3631,cpp,"#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef vector<int> vi;

const int MOD = 1e9 + 7;

class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        int n = s.size();        
        vi cnt(n + 1, 0);
        for(int i = 2; i <= n; i++) {
            int p = __builtin_popcount(i);
            cnt[i] = cnt[p] + 1;
        }
        vector<vector<vector<ll>>> dp(n, vector<vector<ll>>(n + 1, vector<ll>(2, -1)));
        auto dfs = [&](auto& dfs_ref, int pos = 0, int count = 0, bool tight = true) -> ll {
            if(pos == n) {
                return !tight && count && cnt[count] <= k - 1;
            }
            int tight_val = tight ? 1 : 0;
            if(dp[pos][count][tight_val] != -1) return dp[pos][count][tight_val];

            ll res = 0;
            int max_bit = tight ? (s[pos] - '0') : 1;
            for(int b = 0; b <= max_bit; b++) {
                bool next_tight = tight && (b == max_bit);
                res = (res + dfs_ref(dfs_ref, pos + 1, count + b, tight && b == max_bit)) % MOD;
            }
            dp[pos][count][tight_val] = res;
            return res;
        };
        return dfs(dfs);
    }
};
",1448253580
Tin,tin_le,151,3646,cpp,"//████████╗██╗███╗░░██╗  ██╗░░░░░███████╗
//╚══██╔══╝██║████╗░██║  ██║░░░░░██╔════╝
//░░░██║░░░██║██╔██╗██║  ██║░░░░░█████╗░░
//░░░██║░░░██║██║╚████║  ██║░░░░░██╔══╝░░
//░░░██║░░░██║██║░╚███║  ███████╗███████╗
//░░░╚═╝░░░╚═╝╚═╝░░╚══╝  ╚══════╝╚══════╝
//   __________________
//  | ________________ |
//  ||          ____  ||
//  ||   /\    |      ||
//  ||  /__\   |      ||
//  || /    \  |____  ||
//  ||________________||
//  |__________________|
//  \###################\
//   \###################\
//    \        ____       \
//     \_______\___\_______\
// An AC a day keeps the doctor away.

#pragma GCC optimize(""Ofast"")
#pragma GCC optimize (""unroll-loops"")
#pragma GCC target(""popcnt"")
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;
using namespace std;
template<class T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
#define vt vector
#define all(x) begin(x), end(x)
#define allr(x) rbegin(x), rend(x)
#define ub upper_bound
#define lb lower_bound
#define db double
#define ld long db
#define ll long long
#define pll pair<ll, ll>    
#define vll vt<ll>  
#define vpll vt<pll>
#define vvpll vt<vpll>
#define vvvll vt<vvll>
#define vi vector<int>
#define pii pair<int, int>
#define vpii vector<pair<int, int>>
#define vs vector<string>
#define vb vector<bool>
#define vvpii vector<vpii>
#define vvi vector<vi>
#define vd vector<db>
#define ar(x) array<int, x>
#define var(x) vector<ar(x)>
#define pq priority_queue
#define mset(m, v) memset(m, v, sizeof(m))
#define pb push_back
#define ff first
#define ss second
#define sv string_view
#define MP make_pair
#define MT make_tuple
#define rsz resize
#define sum(x) accumulate(all(x), 0LL)
#define srt(x) sort(all(x))
#define srtR(x) sort(allr(x))
#define srtU(x) sort(all(x)), (x).erase(unique(all(x)), (x).end())
#define rev(x) reverse(all(x))
#define gcd(a, b) __gcd(a, b)
#define lcm(a, b) (a * b) / gcd(a, b)
#define MAX(a) *max_element(all(a)) 
#define MIN(a) *min_element(all(a))

//SGT DEFINE
#define lc i * 2 + 1
#define rc i * 2 + 2
#define lp lc, left, middle
#define rp rc, middle + 1, right
#define entireTree 0, 0, n - 1
#define midPoint left + (right - left) / 2
#define pushDown push(i, left, right)
#define iterator int i, int left, int right

#define IOS ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0)

struct custom {
    static const uint64_t C = 0x9e3779b97f4a7c15; const uint32_t RANDOM = std::chrono::steady_clock::now().time_since_epoch().count();
    size_t operator()(uint64_t x) const { return __builtin_bswap64((x ^ RANDOM) * C); }
    size_t operator()(const std::string& s) const { size_t hash = std::hash<std::string>{}(s); return hash ^ RANDOM; } };
template <class K, class V> using umap = std::unordered_map<K, V, custom>; template <class K> using uset = std::unordered_set<K, custom>;
    
 
template<typename T> vt<T> uniqued(vt<T> arr) {  srtU(arr); return arr; }

#ifdef LOCAL
#define debug(x...) debug_out(#x, x)
void debug_out(const char* names) { std::cerr << std::endl; }
template <typename T, typename... Args>
void debug_out(const char* names, T value, Args... args) {
    const char* comma = strchr(names, ',');
    std::cerr << ""["" << (comma ? std::string(names, comma) : names) << "" = "" << value << ""]"";
    if (sizeof...(args)) { std::cerr << "", ""; debug_out(comma + 1, args...); }   
    else { std::cerr << std::endl; }
}
#define startClock clock_t tStart = clock();
#define endClock std::cout << std::fixed << std::setprecision(10) << ""\nTime Taken: "" << (double)(clock() - tStart) / CLOCKS_PER_SEC << "" seconds"" << std::endl;
#else
#define debug(...)
#define startClock
#define endClock

#endif
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());

#define eps 1e-9
#define M_PI 3.14159265358979323846
const static ll INF = 1LL << 60;
const static int MK = 20;
const static int MX = 2e6 + 5;
const static int MOD = 1e9 + 7;
int pct(ll x) { return __builtin_popcountll(x); }
const vvi dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}, {1, 1}, {-1, -1}, {1, -1}, {-1, 1}}; // UP, DOWN, LEFT, RIGHT

const vpii dirs_3_3 = { 
        {0,1}, {0,3},
        {1,0}, {1,2}, {1,4},
        {2,1}, {2,5},
        {3,0}, {3,4}, {3,6},
        {4,1}, {4,3}, {4,5}, {4,7},
        {5,2}, {5,4}, {5,8},
        {6,3}, {6,7},
        {7,4}, {7,6}, {7,8},
        {8,5}, {8,7}
};

int modExpo(ll base, ll exp, ll mod) { ll res = 1; base %= mod; while(exp) { if(exp & 1) res = (res * base) % mod; base = (base * base) % mod; exp >>= 1; } return res; }
void multiply(int f[2][2], int m[2][2]) {   
    int res[2][2] = {}; 
    for(int i = 0; i < 2; i++)  {   for(int j = 0; j < 2; j++)  {   for(int k = 0; k < 2; k++)  {   res[i][j] = (res[i][j] + f[i][k] * m[k][j]) % MOD; }   }   }   
    for(int i = 0; i < 2; i++)  {   for(int j = 0; j < 2; j++) f[i][j] = res[i][j]; }   }
int fib(int n)  {       if(n == 0) return 0;        if(n == 1) return 1;    
    int f[2][2] = {{1, 1}, {1, 0}}; int res[2][2] = {{1, 0}, {0, 1}};       
    while(n)    {   if(n & 1) multiply(res, f); multiply(f, f); n >>= 1;    }   return res[0][1] % MOD; }   
vi primes, first_divisor(MX);  
bitset<MX> primeBits;
void generatePrime() {  primeBits.set(2);   
    for(int i = 3; i < MX; i += 2) primeBits.set(i);
    for(int i = 2; i * i < MX; i += (i == 2 ? 1 : 2)) {    
        if(primeBits[i]) {  
            for(int j = i; j * i < MX; j += 2) {    primeBits.reset(i * j); }
        }
    }
    for(int i = 2; i < MX; i++) {    
        if(primeBits[i]) {  
            for(int j = i; j < MX; j += i) {    if(first_divisor[j] == 0) first_divisor[j] = i; }
        }
    }
    for(int i = 0; i < MX; i++ ) {  if(primeBits[i]) {  primes.pb(i); } }   
}
class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& a) {
        int M = MAX(a);
        vll count(M + 1), sm(M + 1);
        ll res = 0;
        for(auto& x : a) {
            ll c1 = 0, s1 = 0, c2 = 0, s2 = 0;
            if(x) {
                c1 = count[x - 1];
                s1 = (sm[x - 1] + c1 * x) % MOD;
            }
            if(x + 1 <= M) {
                c2 = count[x + 1];
                s2 = (sm[x + 1] + c2 * x) % MOD;
            }
            ll c3 = (1 + c1 + c2) % MOD;
            ll s3 = ((ll)x + s1 + s2) % MOD;
            count[x] = (count[x] + c3) % MOD;
            sm[x] = (sm[x] + s3) % MOD;
            res = (res + s3) % MOD;
        }
        return res;
    }
};
",1448209199
Milind Gupta,milind0110,152,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        for(int i = 0; i + 2 * k <= n; i++){
            bool ok = true;
            for(int j = i + 1; j < i + k; j++){
                ok &= (nums[j] > nums[j - 1]);
            }
            for(int j = i + k + 1; j < i + 2 * k; j++){
                ok &= (nums[j] > nums[j - 1]);
            }
            if(ok) return true;
        }
        return false;
    }
};",1448215877
Milind Gupta,milind0110,152,3619,cpp,"
class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& a) {
        int n = a.size();
        vector<int> ans(n);
        for(int i = n - 2; i >= 0; i--){
            if(a[i] < a[i + 1]){
                ans[i] += ans[i + 1] + 1;
            }
        }
        int mx = 1;
        for(int i = 0; i < n; i++){
            mx = max(mx,(ans[i] + 1) / 2);
            if(i + ans[i] + 1 < n){
                mx = max(mx,min(ans[i],ans[i + ans[i] + 1]) + 1);
            }
        }
        return mx;
    }
};",1448254015
Milind Gupta,milind0110,152,3631,cpp,"const int N = 1000;
const int mod = 1e9 + 7;
using uint = unsigned int;
using ll = long long;
using ull = unsigned long long;
constexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }
template <class T> using V = vector<T>;
template <class T> using VV = V<V<T>>;

template <uint MD> struct ModInt {
    using M = ModInt;
    const static M G;
    uint v;
    ModInt(ll _v = 0) { set_v(_v % MD + MD); }
    M& set_v(uint _v) {
        v = (_v < MD) ? _v : _v - MD;
        return *this;
    }
    explicit operator bool() const { return v != 0; }
    M operator-() const { return M() - *this; }
    M operator+(const M& r) const { return M().set_v(v + r.v); }
    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }
    M operator*(const M& r) const { return M().set_v(ull(v) * r.v % MD); }
    M operator/(const M& r) const { return *this * r.inv(); }
    M& operator+=(const M& r) { return *this = *this + r; }
    M& operator-=(const M& r) { return *this = *this - r; }
    M& operator*=(const M& r) { return *this = *this * r; }
    M& operator/=(const M& r) { return *this = *this / r; }
    bool operator==(const M& r) const { return v == r.v; }
    M pow(ll n) const {
        M x = *this, r = 1;
        while (n) {
            if (n & 1) r *= x;
            x *= x;
            n >>= 1;
        }
        return r;
    }
    M inv() const { return pow(MD - 2); }
    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }
};
using Mint = ModInt<mod>;
template<> const Mint Mint::G = Mint(3);

// template <class Mint> void nft(bool type, V<Mint>& a) {
//     int n = int(a.size()), s = 0;
//     while ((1 << s) < n) s++;
//     assert(1 << s == n);

//     static V<Mint> ep, iep;
//     while (int(ep.size()) <= s) {
//         ep.push_back(Mint::G.pow(Mint(-1).v / (1 << ep.size())));
//         iep.push_back(ep.back().inv());
//     }
//     V<Mint> b(n);
//     for (int i = 1; i <= s; i++) {
//         int w = 1 << (s - i);
//         Mint base = type ? iep[i] : ep[i], now = 1;
//         for (int y = 0; y < n / 2; y += w) {
//             for (int x = 0; x < w; x++) {
//                 auto l = a[y << 1 | x];
//                 auto r = now * a[y << 1 | x | w];
//                 b[y | x] = l + r;
//                 b[y | x | n >> 1] = l - r;
//             }
//             now *= base;
//         }
//         swap(a, b);
//     }
// }

// template <class Mint> V<Mint> multiply(const V<Mint>& a, const V<Mint>& b) {
//     assert(false);
//     incase of cross-correlation reverse b and the answer will be at length of reversed array - the index for answer
//     int n = int(a.size()), m = int(b.size());
//     if (!n || !m) return {};
//     int lg = 0;
//     while ((1 << lg) < n + m - 1) lg++;
//     int z = 1 << lg;
//     auto a2 = a, b2 = b;
//     a2.resize(z);
//     b2.resize(z);
//     nft(false, a2);
//     nft(false, b2);
//     for (int i = 0; i < z; i++) a2[i] *= b2[i];
//     nft(true, a2);
//     a2.resize(n + m - 1);
//     Mint iz = Mint(z).inv();
//     for (int i = 0; i < n + m - 1; i++) a2[i] *= iz;
//     return a2;
// }

Mint fact[N];
Mint inv[N];
void precalc(){
    fact[0] = 1;
    for(int i = 1; i < N; i++){
        fact[i] = fact[i - 1];
        fact[i] *= i;
    }
    for(int i = 0; i < N; i++){
        inv[i] = 1;
        inv[i] /= fact[i];
    }
}
Mint ncrmodp(int n,int r){
    if(n < 0 || n < r)
        return 0;
    return fact[n]*inv[n-r]*inv[r];
}
class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        precalc();
        const int mx = 805;
        vector<int> val(mx);
        for(int i = 2; i < mx; i++){
            val[i] += val[__builtin_popcount(i)] + 1;
        }
        int n = s.length();
        Mint ans = 0;
        int cnt = 0;
        for(int i = 0; i < n; i++){
            if(s[i] == '0') continue;
            int len = n - i - 1;
            for(int j = 0; j <= len; j++){
                if((j + cnt) && val[j + cnt] < k){
                    ans += ncrmodp(len,j);
                }
            }
            cnt++;
        }
        return ans.v;
    }
};",1448238734
Milind Gupta,milind0110,152,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        map<int,int> dp;
        int n = nums.size();
        const int mod = 1e9 + 7;
        vector<int> ways(n),oways(n);
        long long ans = 0;
        for(int i = 0; i < n; i++){
            dp[nums[i]] += 1;
            ways[i]++;
            for(auto x : {-1,1}){
                int j = nums[i] + x;
                if(dp.count(j)){
                    dp[nums[i]] += dp[j];
                    ways[i] += dp[j];
                    if(ways[i] >= mod) ways[i] -= mod;
                    if(dp[nums[i]] >= mod) dp[nums[i]] -= mod;
                }
            }
        }
        dp.clear();
        for(int i = n - 1; i >= 0; i--){
            dp[nums[i]] += 1;
            oways[i]++;
            for(auto x : {-1,1}){
                int j = nums[i] + x;
                if(dp.count(j)){
                    dp[nums[i]] += dp[j];
                    oways[i] += dp[j];
                    if(oways[i] >= mod) oways[i] -= mod;
                    if(dp[nums[i]] >= mod) dp[nums[i]] -= mod;
                }
            }
        }
        for(int i = 0; i < n; i++){
            ans += (((1LL * ways[i] * oways[i]) % mod) * nums[i]) % mod;
            if(ans >= mod) ans -= mod;
        }
        return ans;
    }
};",1448205886
LeeetCode,user3517H,153,3612,python3,"class Solution:
  def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
    n = len(nums)
    l = [None] * n
    r = [None] * n
    l[0] = r[-1] = 1
    for i in range(1, n):
      l[i] = 1 if nums[i] <= nums[i - 1] else l[i - 1] + 1
    for i in reversed(range(n - 1)):
      r[i] = 1 if nums[i] >= nums[i + 1] else r[i + 1] + 1
    return any(min(l[i], r[i + 1]) >= k for i in range(n - 1))
        ",1448185382
LeeetCode,user3517H,153,3619,python3,"class Solution:
  def maxIncreasingSubarrays(self, nums: List[int]) -> int:
    n = len(nums)
    l = [None] * n
    r = [None] * n
    l[0] = r[-1] = 1
    for i in range(1, n):
      l[i] = 1 if nums[i] <= nums[i - 1] else l[i - 1] + 1
    for i in reversed(range(n - 1)):
      r[i] = 1 if nums[i] >= nums[i + 1] else r[i + 1] + 1
    return max(min(l[i], r[i + 1]) for i in range(n - 1))
",1448184656
LeeetCode,user3517H,153,3631,python3,"class Solution:
  def countKReducibleNumbers(self, s: str, k: int) -> int:
    def count(i):
      cnt = 0
      while i > 0:
        i &= i - 1
        cnt += 1
      return cnt
    
    @cache
    def f(i):
      if i == 1:
        return 0
      c = f(count(i))
      return c + 1 if c < k else inf

    @cache
    def comb(n, k):
      if k < 0 or k > n:
        return 0
      k = min(k, n - k)
      if k == 0:
        return 1
      return (comb(n - 1, k) + comb(n - 1, k - 1)) % mod

    @cache
    def dfs(i, c):
      r = n - i
      if c > r:
        return 0
      if c == 0:
        return 1
      if i >= n:
        return 0
      if s[i] == ""0"":
        return dfs(i + 1, c)
      return (comb(r - 1, c) + dfs(i + 1, c - 1)) % mod

    mod = 10 ** 9 + 7
    n = len(s)
    k -= 1
    res = 0
    for i in range(1, n + 1):
      if f(i) < inf:
        res = (res + dfs(0, i)) % mod
    res -= 1 if f(sum(1 for i in s if i == ""1"")) < inf else 0
    return res
",1448261580
LeeetCode,user3517H,153,3646,python3,"class Solution:
  def sumOfGoodSubsequences(self, nums: List[int]) -> int:
    mod = 10 ** 9 + 7
    cnt = Counter()
    tot = Counter()
    res = 0
    for i in nums:
      c = (1 + cnt[i - 1] + cnt[i + 1]) % mod
      t = (c * i + tot[i - 1] + tot[i + 1]) % mod
      cnt[i] = (cnt[i] + c) % mod
      tot[i] = (tot[i] + t) % mod
      res = (res + t) % mod
    return res
",1448195102
JeffreyLC,JeffreyLC,155,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        const int n = nums.size();
        for (int a = 0; a + 2 * k <= n; ++a) {
            bool ok = true;
            for (int i = a + 1; i < a + k; ++i) {
                if (nums[i - 1] >= nums[i]) {
                    ok = false;
                }
            }
            int b = a + k;
            for (int i = b + 1; i < b + k; ++i) {
                if (nums[i - 1] >= nums[i]) {
                    ok = false;
                }
            }
            if (ok) return true;
        }
        return false;
    }
};",1448183004
JeffreyLC,JeffreyLC,155,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        const int n = nums.size();
        vector<int> v(n);
        v[0] = 1;
        int ans = 1;
        for (int i = 1; i < n; ++i) {
            if (nums[i - 1] < nums[i]) {
                v[i] = v[i - 1] + 1;
                ans = max(ans, v[i] / 2);
            } else {
                int prev = i - 1 - v[i - 1];
                if (prev >= 0) {
                    ans = max(ans, min(v[prev], v[i - 1]));
                }
                v[i] = 1;
            }
        }
        int prev = n - 1 - v[n - 1];
        if (prev >= 0) {
            ans = max(ans, min(v[prev], v[n - 1]));
        }
        return ans;
    }
};",1448190367
JeffreyLC,JeffreyLC,155,3631,cpp,"class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        constexpr int MOD = 1e9 + 7;
        const int n = s.length();
        vector<int> num_bits(n + 1);
        vector<vector<int>> adj(n + 1);
        for (int i = 1; i <= n; ++i) {
            num_bits[i] = num_bits[i ^ (i & (-i))] + 1;
            if (i == num_bits[i]) continue;
            adj[num_bits[i]].push_back(i);
        }
        vector<bool> check(n + 1);
        queue<pair<int, int>> q;
        check[1] = true;
        q.push({1, 0});
        while (!q.empty()) {
            auto [num, op] = q.front();
            q.pop();
            if (op + 1 == k) break;
            for (int num2 : adj[num]) {
                if (check[num2]) continue;
                check[num2] = true;
                q.push({num2, op + 1});
            }
        }
        vector<int> checks;
        for (int i = 1; i <= n; ++i) {
            if (check[i]) {
                checks.push_back(i);
            }
        }
        tri = PascalTriangle(800, MOD);
        
        int ans = 0, bitcnt = 0;
        for (int i = 0; i < n; ++i) {
            if (s[i] == '1') {
                for (int c : checks) {
                    ans += nCr(n - 1 - i, c - bitcnt);
                    ans %= MOD;
                }
                ++bitcnt;
            }
        }
        return ans;
    }
private:
    vector<vector<int>> tri;
    
    vector<vector<int>> PascalTriangle(int n, int mod) {
        vector<vector<int>> pascal_triangle;
        vector<int> row;
        for (int i = 0; i <= n; ++i) {
            row.push_back(1 % mod);
            for (int j = i - 1; j > 0; --j) {
                row[j] = (row[j - 1] + row[j]) % mod;
            }
            pascal_triangle.push_back(row);
        }
        return pascal_triangle;
    }
    
    int nCr(int n, int r) {
        if (r < 0 || n < r) return 0;
        return tri[n][r];
    }
};",1448239612
JeffreyLC,JeffreyLC,155,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        constexpr int MOD = 1e9 + 7;
        const int n = nums.size();
        unordered_map<int, pair<long long, long long>> m(100001);
        for (int num : nums) {
            auto& p = m[num];
            ++p.first;
            p.first %= MOD;
            p.second += num;
            p.second %= MOD;
            
            auto it = m.find(num - 1);
            if (it != m.end()) {
                p.first += it->second.first;
                p.first %= MOD;
                p.second += it->second.second + it->second.first * num;
                p.second %= MOD;
            }
            it = m.find(num + 1);
            if (it != m.end()) {
                p.first += it->second.first;
                p.first %= MOD;
                p.second += it->second.second + it->second.first * num;
                p.second %= MOD;
            }
        }
        int ans = 0;
        for (auto [key, val] : m) {
            ans += val.second;
            ans %= MOD;
        }
        return ans;
    }
};",1448203145
skyinde2,skyinde2,156,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        last = 0
        ret = 0
        cur = 1

        nums.append(-10000000000)

        for i in range(1, len(nums)):
            if nums[i] > nums[i - 1]:
                cur += 1
            else:
                ret = max(ret, min(last, cur))
                ret = max(ret, cur // 2)
                last = cur
                cur = 1
        
        return ret >= k

        

        ",1448190946
skyinde2,skyinde2,156,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: list[int]) -> int:
        last = 0
        ret = 0
        cur = 1

        nums.append(-10000000000)

        for i in range(1, len(nums)):
            if nums[i] > nums[i - 1]:
                cur += 1
            else:
                ret = max(ret, min(last, cur))
                ret = max(ret, cur // 2)
                last = cur
                cur = 1
        
        return ret
",1448188948
skyinde2,skyinde2,156,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        MOD = 1_000_000_007
        n = len(s)
        r = [False] * (n + 1)

        for i in range(1, n + 1):
            j = i
            for _ in range(k - 1):
                j = int.bit_count(j)
            if j == 1:
                r[i] = True

        c = [[1] * (n + 1) for _ in range(n + 1)]
        for i in range(2, n + 1):
            for j in range(1, i):
                c[i][j] = (c[i-1][j-1] + c[i-1][j]) % MOD

        pos = []
        for i in range(n):
            if s[i] == '1':
                pos.append(n - i)

        ret = -1 if r[len(pos)] else 0
        while len(pos):
            if r[len(pos)]:
                ret += 1
            
            i = pos.pop()
            for j in range(1, i):
                if r[len(pos) + j]:
                    ret = (ret + c[i-1][j]) % MOD
        
        return ret % MOD

s = Solution()
s.countKReducibleNumbers('1000', 4)



",1448247530
skyinde2,skyinde2,156,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: list[int]) -> int:
        MOD = 1_000_000_007

        dp = [0] * 100002
        cnt = [0] * 100002
        ret = 0

        for num in nums:
            a = (cnt[num - 1] + cnt[num + 1] + 1) % MOD
            b = (dp[num - 1] + dp[num + 1] + a * num) % MOD
            ret = (ret + b) % MOD
            cnt[num] = (cnt[num] + a) % MOD
            dp[num] = (dp[num] + b) % MOD
        
        return ret",1448207079
chengxia you,cy171,157,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        curr = [1]
        for i in range(1, len(nums)):
            if nums[i] > nums[i-1]:
                curr[-1] += 1
            else:
                curr.append(1)
        ans = max(curr)//2
        for i in range(1, len(curr)):
            ans = max(ans, min(curr[i], curr[i-1]))
        
        return ans >= k",1448187881
chengxia you,cy171,157,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        curr = [1]
        for i in range(1, len(nums)):
            if nums[i] > nums[i-1]:
                curr[-1] += 1
            else:
                curr.append(1)
        ans = max(curr)//2
        for i in range(1, len(curr)):
            ans = max(ans, min(curr[i], curr[i-1]))
        return ans",1448187233
chengxia you,cy171,157,3631,python3,"dic = {}
for n in range(1, 801):
    i = 0
    save = n
    while n != 1:
        i += 1
        n = bin(n)[2:].count(""1"")
    dic[save] = i
# print(dic)
mod = 10**9 + 7
class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        n = len(s)
        # top = [0, 1] + [0]*(n-1)
        curr = 1
        dp = [1] + [0]*(n)
        for i in range(1, n):
            for j in range(n,0,-1):
                dp[j] += dp[j-1]
                dp[j] %= mod
            if s[i] == ""1"":
                dp[curr] += 1
                curr += 1
            # print(dp)
        ans = 0
        for c, val in enumerate(dp[1:], 1):
            if dic[c] < k:
                ans += val
                ans %= mod
        # print(dp)
        return ans
                ",1448262458
chengxia you,cy171,157,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        total = defaultdict(int)
        count = defaultdict(int)
        for num in nums:
            count[num] += count[num-1] + count[num+1]
            total[num] += total[num+1] + total[num-1] + num * count[num-1] + num * count[num+1]
            count[num] += 1
            total[num] += num
            count[num] %= (10**9 + 7)
            total[num] %= (10**9 + 7)

        return sum(total.values())% (10**9 + 7)",1448199011
funsquared,funsquared,158,3612,python3,"def is_sorted(a):
    return all(x < y for x, y in pairwise(a))

class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        for i in range(len(nums) + 1 - 2 * k):
            if is_sorted(nums[i:i+k]) and is_sorted(nums[i+k:i+2*k]):
                return True
        return False",1448214044
funsquared,funsquared,158,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        diff = [x < y for x, y in pairwise(nums)]
        gs = [(t, len(list(g))) for t, g in groupby(diff)]
        res = 1
        for i in range(len(gs)):
            if gs[i][0]:
                res = max(res, (gs[i][1] + 1) // 2)
                if i + 2 < len(gs) and gs[i + 1][1] == 1:
                    res = max(res, min(gs[i][1], gs[i + 2][1]) + 1)
        return res
            ",1448213885
funsquared,funsquared,158,3631,python3,"MOD = 10 ** 9 + 7

class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        def good(o):
            for _ in range(k - 1):
                if o == 1:
                    return True
                o = o.bit_count()
            return o == 1
        s = int(s, 2)
        @cache
        def count(s, o=0):
            if s < 0:
                return 0
            if s == 0:
                return 1 if good(o) else 0
            return (count((s - 1) // 2, o + 1) + count(s // 2, o)) % MOD
        res = count(s - 1)
        count.cache_clear()
        return res
                ",1448247877
funsquared,funsquared,158,3646,python3,"MOD = 10 ** 9 + 7

class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        mx = max(nums)
        ct = [0] * (mx + 2)
        sm = [0] * (mx + 2)
        for x in nums:
            ct[x] = (ct[x] + ct[x - 1] + ct[x + 1] + 1)
            sm[x] = (sm[x] + x * (ct[x - 1] + ct[x + 1] + 1) + sm[x - 1] + sm[x + 1])
        return sum(sm) % MOD
        ",1448213737
Jie Chen,JustJie,159,3612,cpp,"/********************************************
 * author : Jie Chen (3rd Year CS)
 * school : Rochester Institute of Technology
 * created: 11.09.2024 21:46:00
*********************************************/
#include <bits/stdc++.h>

using namespace std;

#ifdef BROKEN_CODE
#include <bits/LC_parser.h>
#include <bits/debug.h>
#else
#define dbg(...) 10082002
#define dbp(...) ""Need Internship""
#endif

using i64 = long long;

class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& a, int k) {
        int n = a.size();
        vector<int> f(n, 1);
        int first = -1, last = -1;
        vector<bool> good(n);
        for (int i = 0; i < n; i++) {
            if (i > 0 && a[i] > a[i - 1]) {
                f[i] += f[i - 1];
            }
            if (f[i] >= k) {
                good[i] = true;
            }
        }
        for (int i = k; i < n; i++) {
            if (good[i] && good[i - k]) {
                return true;
            }
        }
        return false;
    }
};

#ifdef BROKEN_CODE
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    exec(&Solution::LoveJenney); // CHANGE FOR PROBLEM
}
#endif

// ~ JustJie",1448247925
Jie Chen,JustJie,159,3619,cpp,"/********************************************
 * author : Jie Chen (3rd Year CS)
 * school : Rochester Institute of Technology
 * created: 11.09.2024 21:48:05
*********************************************/
#include <bits/stdc++.h>

using namespace std;

#ifdef BROKEN_CODE
#include <bits/LC_parser.h>
#include <bits/debug.h>
#else
#define dbg(...) 10082002
#define dbp(...) ""Need Internship""
#endif

using i64 = long long;

class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& a) {

        auto good = [&](int k) {
            int n = a.size();
            vector<int> f(n, 1);
            int first = -1, last = -1;
            vector<bool> good(n);
            for (int i = 1; i < n; i++) {
                if (a[i] > a[i - 1]) {
                    f[i] += f[i - 1];
                }
                if (f[i] >= k) {
                    good[i] = true;
                }
            }
            for (int i = k; i < n; i++) {
                if (good[i] && good[i - k]) {
                    return true;
                }
            }
            return false;
        };

        int lo = 1, hi = a.size();
        while (lo < hi) {
            int mid = (lo + hi + 1) / 2;
            if (good(mid)) {
                lo = mid;
            } else {
                hi = mid - 1;
            }
        }
        return lo;
    }
};

#ifdef BROKEN_CODE
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    exec(&Solution::LoveJenney); // CHANGE FOR PROBLEM
}
#endif

// ~ JustJie",1448245824
Jie Chen,JustJie,159,3631,cpp,"/********************************************
 * author : Jie Chen (3rd Year CS)
 * school : Rochester Institute of Technology
 * created: 11.09.2024 21:57:54
*********************************************/
#include <bits/stdc++.h>

using namespace std;

#ifdef BROKEN_CODE
#include <bits/LC_parser.h>
#include <bits/debug.h>
#else
#define dbg(...) 10082002
#define dbp(...) ""Need Internship""
#endif

using i64 = long long;


// Credit: Jiangly
template<class T>
constexpr T power(T a, i64 b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}

constexpr i64 mul(i64 a, i64 b, i64 p) {
    i64 res = a * b - i64(1.L * a * b / p) * p;
    res %= p;
    if (res < 0) {
        res += p;
    }
    return res;
}
template<int P>
struct MInt {
    int x;
    constexpr MInt() : x{} {}
    constexpr MInt(i64 x) : x{norm(x % getMod())} {}
    
    static int Mod;
    constexpr static int getMod() {
        if (P > 0) {
            return P;
        } else {
            return Mod;
        }
    }
    constexpr static void setMod(int Mod_) {
        Mod = Mod_;
    }
    constexpr int norm(int x) const {
        if (x < 0) {
            x += getMod();
        }
        if (x >= getMod()) {
            x -= getMod();
        }
        return x;
    }
    constexpr int val() const {
        return x;
    }
    explicit constexpr operator int() const {
        return x;
    }
    constexpr MInt operator-() const {
        MInt res;
        res.x = norm(getMod() - x);
        return res;
    }
    constexpr MInt inv() const {
        assert(x != 0);
        return power(*this, getMod() - 2);
    }
    constexpr MInt &operator*=(MInt rhs) & {
        x = 1LL * x * rhs.x % getMod();
        return *this;
    }
    constexpr MInt &operator+=(MInt rhs) & {
        x = norm(x + rhs.x);
        return *this;
    }
    constexpr MInt &operator-=(MInt rhs) & {
        x = norm(x - rhs.x);
        return *this;
    }
    constexpr MInt &operator/=(MInt rhs) & {
        return *this *= rhs.inv();
    }
    friend constexpr MInt operator*(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res *= rhs;
        return res;
    }
    friend constexpr MInt operator+(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res += rhs;
        return res;
    }
    friend constexpr MInt operator-(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res -= rhs;
        return res;
    }
    friend constexpr MInt operator/(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res /= rhs;
        return res;
    }
    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {
        i64 v;
        is >> v;
        a = MInt(v);
        return is;
    }
    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {
        return os << a.val();
    }
    friend constexpr bool operator==(MInt lhs, MInt rhs) {
        return lhs.val() == rhs.val();
    }
    friend constexpr bool operator!=(MInt lhs, MInt rhs) {
        return lhs.val() != rhs.val();
    }
};
 
template<>
int MInt<0>::Mod = 998'244'353;
 
template<int V, int P>
constexpr MInt<P> CInv = MInt<P>(V).inv();
 
constexpr int P = 1'000'000'007; // 998'244'353;
using Z = MInt<P>;

// Credit: Jiangly
struct Comb {
    int n;
    vector<Z> _fac, _invfac, _inv, _pw2;
    
    Comb() : n{0}, _fac{1}, _invfac{1}, _inv{0}, _pw2{1} {}
    Comb(int n) : Comb() {
        init(n);
    }
    
    void init(int m) {
        if (m <= n) return;
        _fac.resize(m + 1);
        _invfac.resize(m + 1);
        _inv.resize(m + 1);
        _pw2.resize(m + 1);
        
        for (int i = n + 1; i <= m; i++) {
            _fac[i] = _fac[i - 1] * i;
            _pw2[i] = _pw2[i - 1] * 2;
        }
        _invfac[m] = _fac[m].inv();
        for (int i = m; i > n; i--) {
            _invfac[i - 1] = _invfac[i] * i;
            _inv[i] = _invfac[i] * _fac[i - 1];
        }
        n = m;
    }
    
    Z pw2(int m) {
        if (m > n) init(2 * m);
        return _pw2[m];
    }
    Z fac(int m) {
        if (m > n) init(2 * m);
        return _fac[m];
    }
    Z invfac(int m) {
        if (m > n) init(2 * m);
        return _invfac[m];
    }
    Z inv(int m) {
        if (m > n) init(2 * m);
        return _inv[m];
    }
    Z binom(int n, int m) {
        if (n < m || m < 0) return 0;
        return fac(n) * invfac(m) * invfac(n - m);
    }
} comb;

constexpr int N = 801;

class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        int n = s.size();
        vector<Z> f(N);
        auto rec = [&](auto&& self, int i, int cnt) {
            if (i == n) {
                return;
            }
            if (s[i] == '1') {
                self(self, i + 1, cnt + 1);
                int m = n - i - 1;
                for (int i = 0; i <= m; i++) {
                    f[i + cnt] += comb.binom(m, i);
                }
            } else {
                self(self, i + 1, cnt);
            }
        };
        rec(rec, 0, 0);
        k -= 1;

        auto count = [&](int x) {
            int ans = 0;
            for (int i = 0; x; i++) {
                if (x >> i & 1) {
                    ans++;
                    x -= (1 << i);
                }
            }
            return ans;
        };

        while (k--) {
            vector<Z> nf(N);
            for (int i = 1; i < N; i++) {
                if (f[i] == Z(0)) {
                    continue;
                }
                nf[count(i)] += f[i];
            }
            swap(f, nf);
        }
        return f[1].val();
    }
};

#ifdef BROKEN_CODE
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    exec(&Solution::LoveJenney); // CHANGE FOR PROBLEM
}
#endif

// ~ JustJie",1448244686
Jie Chen,JustJie,159,3646,cpp,"/********************************************
 * author : Jie Chen (3rd Year CS)
 * school : Rochester Institute of Technology
 * created: 11.09.2024 21:50:45
*********************************************/
#include <bits/stdc++.h>

using namespace std;

#ifdef BROKEN_CODE
#include <bits/LC_parser.h>
#include <bits/debug.h>
#else
#define dbg(...) 10082002
#define dbp(...) ""Need Internship""
#endif

using i64 = long long;

// Credit: Jiangly
template<class T>
constexpr T power(T a, i64 b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}

constexpr i64 mul(i64 a, i64 b, i64 p) {
    i64 res = a * b - i64(1.L * a * b / p) * p;
    res %= p;
    if (res < 0) {
        res += p;
    }
    return res;
}
template<int P>
struct MInt {
    int x;
    constexpr MInt() : x{} {}
    constexpr MInt(i64 x) : x{norm(x % getMod())} {}
    
    static int Mod;
    constexpr static int getMod() {
        if (P > 0) {
            return P;
        } else {
            return Mod;
        }
    }
    constexpr static void setMod(int Mod_) {
        Mod = Mod_;
    }
    constexpr int norm(int x) const {
        if (x < 0) {
            x += getMod();
        }
        if (x >= getMod()) {
            x -= getMod();
        }
        return x;
    }
    constexpr int val() const {
        return x;
    }
    explicit constexpr operator int() const {
        return x;
    }
    constexpr MInt operator-() const {
        MInt res;
        res.x = norm(getMod() - x);
        return res;
    }
    constexpr MInt inv() const {
        assert(x != 0);
        return power(*this, getMod() - 2);
    }
    constexpr MInt &operator*=(MInt rhs) & {
        x = 1LL * x * rhs.x % getMod();
        return *this;
    }
    constexpr MInt &operator+=(MInt rhs) & {
        x = norm(x + rhs.x);
        return *this;
    }
    constexpr MInt &operator-=(MInt rhs) & {
        x = norm(x - rhs.x);
        return *this;
    }
    constexpr MInt &operator/=(MInt rhs) & {
        return *this *= rhs.inv();
    }
    friend constexpr MInt operator*(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res *= rhs;
        return res;
    }
    friend constexpr MInt operator+(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res += rhs;
        return res;
    }
    friend constexpr MInt operator-(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res -= rhs;
        return res;
    }
    friend constexpr MInt operator/(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res /= rhs;
        return res;
    }
    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {
        i64 v;
        is >> v;
        a = MInt(v);
        return is;
    }
    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {
        return os << a.val();
    }
    friend constexpr bool operator==(MInt lhs, MInt rhs) {
        return lhs.val() == rhs.val();
    }
    friend constexpr bool operator!=(MInt lhs, MInt rhs) {
        return lhs.val() != rhs.val();
    }
};
 
template<>
int MInt<0>::Mod = 998'244'353;
 
template<int V, int P>
constexpr MInt<P> CInv = MInt<P>(V).inv();
 
constexpr int P = 1'000'000'007; // 998'244'353;
using Z = MInt<P>;

constexpr int N = int(1e5) + 5;

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& a) {
        Z ans = 0;
        Z f[N] {};
        Z f2[N] {};
        for (int x : a) {
            ans += x;
            f[x] += 1;
            f2[x] += x;
            for (int d : {-1, +1}) {
                if (x + d >= 0) {
                    ans += f2[x + d];
                    ans += f[x + d] * x;
                    f[x] += f[x + d];
                    f2[x] += f2[x + d] + f[x + d] * x;
                }
            }
        }
        return ans.val();
    }
};

#ifdef BROKEN_CODE
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    exec(&Solution::LoveJenney); // CHANGE FOR PROBLEM
}
#endif

// ~ JustJie",1448244776
pr3pony,pr3pony,161,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        pr = [1 for i in range(n)]
        po = [1 for i in range(n)]
        for i in range(1, n):
            if nums[i - 1] < nums[i]:
                pr[i] = pr[i - 1] + 1
            else:
                pr[i] = 1
        for i in range(n-2,-1,-1):
            if nums[i] < nums[i + 1]:
                po[i] = po[i + 1] + 1
            else:
                po[i] = 1
        ans = 1
        for i in range(n - 1):
            ans = max(ans, min(pr[i], po[i+1]))
        return ans >= k
",1448189822
pr3pony,pr3pony,161,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        pr = [1 for i in range(n)]
        po = [1 for i in range(n)]
        for i in range(1, n):
            if nums[i - 1] < nums[i]:
                pr[i] = pr[i - 1] + 1
            else:
                pr[i] = 1
        for i in range(n-2,-1,-1):
            if nums[i] < nums[i + 1]:
                po[i] = po[i + 1] + 1
            else:
                po[i] = 1
        ans = 1
        for i in range(n - 1):
            ans = max(ans, min(pr[i], po[i+1]))
        return ans
            ",1448188146
pr3pony,pr3pony,161,3631,cpp,"class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        const int C = 805;
        const int MOD = 1000000007;
        std::vector<std::vector<int>> ways(C, std::vector<int>(C, 0));
        for (int i = 0; i < C; ++i) {
            ways[i][i] = 1;
            ways[i][0] = 1;
            if (i <= 1) continue;
            for (int j = 1; j < i; ++j) {
                ways[i][j] = (ways[i-1][j] + ways[i-1][j-1]) % MOD;
            }
        }
        std::vector<int> r(C, 0);
        for (int i = 2; i < C; ++i) {
            r[i] = 1 + r[__builtin_popcount(i)];
        }
        int ans = 0;
        int lt = 0;
        for (int i = 0; i < s.length(); ++i) {
            if (s[i] == '0') continue;
            int rt = s.length() - 1 - i;
            for (int j = 0; j <= rt; ++j) {
                if (r[lt + j] >= k) continue;
                ans = (ans + ways[rt][j]) % MOD;
            }
            lt += 1;
        }
        ans = (ans - 1 + MOD) % MOD;
        return ans;
    }
};",1448255779
pr3pony,pr3pony,161,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        n = len(nums)
        a = [nums[i] + 1 for i in range(n)]
        pr = [0 for i in range(n)]
        C = 100005
        w = [0 for i in range(C)]
        MOD = 10**9+7
        for i in range(n):
            pr[i] = (1 + w[a[i] + 1] + w[a[i] - 1]) % MOD
            w[a[i]] = (w[a[i]] + pr[i]) % MOD
        w = [0 for i in range(C)]
        po = [0 for i in range(n)]
        for i in range(n-1, -1, -1):
            po[i] = (1 + w[a[i] + 1] + w[a[i] - 1]) % MOD
            w[a[i]] = (w[a[i]] + po[i]) % MOD
        ans = 0
        for i in range(n):
            ans = (ans + pr[i] * po[i] * nums[i]) % MOD
        return ans
            ",1448205793
enereltd7,enereltd7,162,3612,cpp,"class Solution {
public:

    int le[100];

    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        le[0] = 1;
        for(int i = 1; i < n; i++) {
            if(nums[i] > nums[i - 1])
                le[i] = le[i - 1] + 1;
            else
                le[i] = 1;
        }
        for(int i = k; i < n; i++)
            if(le[i] >= k && le[i - k] >= k)
                return true;
        return false;
    }
};",1448182522
enereltd7,enereltd7,162,3619,cpp,"class Solution {
public:

    int le[200005], n;

    bool check(int k) {
        for(int i = k; i < n; i++)
            if(le[i] >= k && le[i - k] >= k)
                return true;
        return false;
    }

    int find(int l, int r) {
        if(l == r) 
            return l;
        int mid = (l + r) / 2;
        if(check(mid + 1))
            return find(mid + 1, r);
        else
            return find(l, mid);
    }

    int maxIncreasingSubarrays(vector<int>& nums) {
        n = nums.size();
        le[0] = 1;
        for(int i = 1; i < n; i++) {
            if(nums[i] > nums[i - 1])
                le[i] = le[i - 1] + 1;
            else
                le[i] = 1;
        }
        return find(1, n);
    }
};",1448188183
enereltd7,enereltd7,162,3631,cpp,"class Solution {
public:

    bool is(int n, int k) {
        if(n == 1)
            return 1;
        if(!k)
            return 0;
        return is(__builtin_popcount(n), k - 1);
    }

    bool pos[801];
    long long dp[801][801], fac[801], invfac[801], mod = 1e9 + 7;
    string st;

    long long find(int ind, int num) {
        if(dp[ind][num] != -1)
            return dp[ind][num];
        if(ind == st.size())
            return dp[ind][num] = 0;
        if(st[ind] == '0')
            return dp[ind][num] = find(ind + 1, num);
        long long ans = 0;
        int k = st.size() - ind - 1;
        for(int i = 0; i <= k; i++)
            if(pos[num + i])
                ans += fac[k] * invfac[i] % mod * invfac[k - i] % mod;
        return dp[ind][num] = (ans + find(ind + 1, num + 1)) % mod;
    }

    long long deg(long long x, int d) {
        if(!d)
            return 1;
        long long ans = deg(x, d / 2);
        if(d % 2)
            return ans * ans % mod * x % mod;
        else
            return ans * ans % mod;
    }

    void pre() {
        fac[0] = 1;
        invfac[0] = 1;
        for(int i = 1; i <= 800; i++) {
            fac[i] = fac[i - 1] * i % mod;
            invfac[i] = deg(fac[i], mod - 2);
        }
    }

    int countKReducibleNumbers(string s, int k) {
        pre();
        memset(dp, -1, sizeof(dp));
        for(int i = 1; i <= 800; i++)
            pos[i] = is(i, k - 1);
        st = s;
        return find(0, 0);
    }
};",1448255810
enereltd7,enereltd7,162,3646,cpp,"class Solution {
public:

    int mod = 1e9 + 7;
    long long sum[100005], num[100005];

    int sumOfGoodSubsequences(vector<int>& nums) {
        for(auto x: nums) {
            num[x + 1]++;
            num[x + 1] += num[x];
            num[x + 1] += num[x + 2];
            num[x + 1] %= mod;
            sum[x + 1] += x;
            sum[x + 1] += sum[x] + num[x] * x;
            sum[x + 1] %= mod;
            sum[x + 1] += sum[x + 2] + num[x + 2] * x;
            sum[x + 1] %= mod;
        }
        long long ans = 0;
        for(int i = 1; i <= 100001; i++)
            ans += sum[i];
        ans %= mod;
        return ans;
    }
};",1448206511
YuningCong,YuningCong,163,3612,cpp,"class Solution {
public:
    bool check(int l, vector<int>& nums, vector<int>& dp){
        if(l*2 > nums.size()) return false;
        for(int i=l;i<nums.size();i++){
            if(dp[i]>=l&&dp[i-l]>=l) return true;
        }
        return false;
    }
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        int l = 1, r = n/2+1;
        vector<int>dp(n,1);
        for(int i=1;i<n;i++){
            if(nums[i]>nums[i-1]) dp[i] = dp[i-1]+1;
        }
        while(l<r-1){
            int mid = (l+r+1)>>1;
            if(!check(mid, nums, dp)){
                r = mid;
            }else{
                l = mid;
            }
        }
        return l;
    }
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        int l = 1, r = n/2+1;
        vector<int>dp(n,1);
        for(int i=1;i<n;i++){
            if(nums[i]>nums[i-1]) dp[i] = dp[i-1]+1;
        }
        return check(k, nums, dp);
    }
};",1448195196
YuningCong,YuningCong,163,3619,cpp,"class Solution {
public:
    bool check(int l, vector<int>& nums, vector<int>& dp){
        if(l*2 > nums.size()) return false;
        for(int i=l;i<nums.size();i++){
            if(dp[i]>=l&&dp[i-l]>=l) return true;
        }
        return false;
    }
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        int l = 1, r = n/2+1;
        vector<int>dp(n,1);
        for(int i=1;i<n;i++){
            if(nums[i]>nums[i-1]) dp[i] = dp[i-1]+1;
        }
        while(l<r-1){
            int mid = (l+r+1)>>1;
            if(!check(mid, nums, dp)){
                r = mid;
            }else{
                l = mid;
            }
        }
        return l;
    }
};",1448193329
YuningCong,YuningCong,163,3631,cpp,"class Solution {
public:
    long long dp[806];
    const int mod = 1e9+7;
    int dfs(int i, int k){
        for(int j=0;j<k;j++){
            i = __builtin_popcount(i);
        }
        return i==1;
    }
    long long chose[805][805];
    int countKReducibleNumbers(string s, int k) {
        int n = s.size();
        memset(dp,0,sizeof(dp));
        for(int i=1;i<=n;i++){
            dp[i] = dfs(i, k-1);
        }
        long long ans = 0;
        memset(chose, 0, sizeof(chose));
        chose[0][0] = 1;
        for(int i=1;i<=n;i++){
            for(int j=0;j<=i;j++){
                if(j)
                chose[i][j] = (chose[i][j]+chose[i-1][j-1])%mod;
                chose[i][j] = (chose[i][j]+chose[i-1][j])%mod;
            }
        }
        long long tot = 0;
        for(int i=0;i<n;i++){
            if(s[i]=='0') continue;
            for(int j=0;j<=n-i-1;j++){
                if(dp[j+tot]){
                    ans = (ans + chose[n-i-1][j])%mod;
                }
            }
            tot++;
        }
        return ans;
    }
};",1448255978
YuningCong,YuningCong,163,3646,cpp,"class Solution {
public:
    const long long mod = 1e9+7;
    int sumOfGoodSubsequences(vector<int>& nums) {
        unordered_map<long long, long long>m;
        unordered_map<long long, long long>counter;
        for(auto i: nums){
            long long base = 0;
            long long count = 1;
            if(m.find(i-1)!=m.end()) {
                count = (count + counter[i-1])%mod;
                base = (base + m[i-1])%mod;
            }
            if(m.find(i+1)!=m.end()) {
                count = (count + counter[i+1])%mod;
                base = (base + m[i+1])%mod;
            }
            m[i] = (m[i]+base)%mod;
            long long tmp = (long long)i;
            m[i] = (m[i] + ((count%mod)*(tmp%mod))%mod)%mod;
            counter[i] = (counter[i]+count)%mod;
        }
        long long f = 0;
        for(auto i: m){
            f = (f+i.second)%mod;
        }
        return f;
    }
};",1448216332
Jose Coves,jcoves,168,3612,cpp,"
#ifdef LOCAL_RUN
#include ""debug_leet.h""
    #else
    #define trace(...) ;
    #define dbg(...) ;
    #define dbgc(...) ;
    #define debug(x) ;
    #define debuga(a, n) ;
    #define debug2(x, y) ;
    #define debug3(x, y, z) ;
    #define debug4(x, y, z, w) ;
    #define debug5(a,b,c,d,e) ;
    #define lassert(x) ;
    #define dassert(x, ...) ;
    int recur_depth = 0; bool rec_indent = true;
    const bool isLocal = false;
    template <typename Arg, typename... Args>
    void display(TreeNode* root) {}
    #endif

    #define pb push_back
    #define eb emplace_back
    #define popb pop_back
    #define all(v) begin(v), end(v)
    #define rall(v) (v).rbegin(),(v).rend()
    #define make_unique(v) (v).erase(unique(all(v)), (v).end())
    #define sz(c) ((int) c.size())
    #define forn(i,n) for(auto i=(n)-(n);i<(n);i++)
    #define fornn(i,s,n) for(auto i=(n)-(n)+(s);i<(n);i++)
    #define forb(i,n) for(auto i=(n)-1;i>=0;i--)
    #define forbn(i,s,n) for(auto i=(n)-1;i>=(s);i--)
    #define forit(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)
    #define mem(a,b) memset(a,b,sizeof(a))
    #define abs(x) (((x) < 0) ? -(x) : (x))
    #define sqr(x) ((x) * (x))
    #define sqrt(x) sqrt(abs(x))
    #define has(c,x) (c.find(x) != c.end())
    #define pw(x) (1LL << (x))
    #define ibit(x,i) (((x) >> (i)) & 1)
    #define data(v) v.data(), sz(v) // vi -> vai
    #define gtime() ((double(clock()) - 0)/CLOCKS_PER_SEC)

    typedef stringstream sstr;
    typedef long long ll;
    typedef long double ld;
    typedef pair<int, int> pii;
    typedef pair<ll,ll> pll;
    typedef pair<ld,ld> pdd;
    typedef vector<int> vi;
    typedef vector<ll> vll;
    typedef vector<pii> vpii;
    typedef vector<vi> vvi;
    typedef vector<vll> vvll;
    typedef valarray<int> vai;
    template <class T>
    using min_pq = priority_queue<T, vector<T>, greater<T>>;
    template <class T>
    using vc = vector<T>;
    template <class T>
    using vvc = vector<vc<T>>;
    template <class T>
    using vvvc = vector<vvc<T>>;
    template <class T>
    using vvvvc = vector<vvvc<T>>;
    template <class T>
    using vvvvvc = vector<vvvvc<T>>;

    template<class F>
    struct y_comb{
        F f;
        template<class T> explicit y_comb(T &&f_in): f(forward<T>(f_in)){ }
        template<class ...Args> decltype(auto) operator()(Args &&...args){ return f(ref(*this), forward<Args>(args)...); }
    };
    template<class F>
    decltype(auto) yf(F &&f){
        return y_comb<decay_t<F>>(forward<F>(f));
    }

    inline int ni(){ int x; cin >> x;   return x; }
    inline ll  nl() { ll  x; cin >> x; return x; }

    template <class T> void mmin(T& a, const T& b) {
        a = (a) < (b) ? (a) : (b);
    }
    template <class T> void mmax(T& a, const T& b) {
        a = (a) > (b) ? (a) : (b);
    }
    template <class T> int LB(vc<T> &a, T x){
        return int(lower_bound(all(a), x) - a.begin());
    }
    template <class T> int UB(vc<T> &a, T x){
        return int(upper_bound(all(a), x) - a.begin());
    }
    template <class T> T MAX(vc<T> &a, int l=0, int r=-1){
        if(r < 0) r = sz(a);
        return *max_element(a.begin()+l, a.begin()+r);
    }
    template <class T> T MIN(vc<T> &a, int l=0, int r=-1){
        if(r < 0) r = sz(a);
        return *min_element(a.begin()+l, a.begin()+r);
    }
    template <class T> auto vv(int d1, T x){
        return vc<T>(d1, x);
    }
    template <class T> auto vv(int d1, int d2, T x){
        return vc<vc<T>>(d1, vc<T>(d2, x));
    }
    template <class T> auto vv(int d1, int d2, int d3, T x){
        return vc<vc<vc<T>>>(d1, vv(d2, d3, x));
    }
    template <class T> auto vv(int d1, int d2, int d3, int d4, T x){
        return vc<vc<vc<vc<T>>>>(d1, vv(d2, d3, d4, x));
    }
    void outv(auto &v){
        for(auto &x: v) {cout<< x <<"" "";} cout<<endl;
    }
    void rvec(int &n, auto &v){
        cin >> n; v.resize(n); for(auto &x: v) cin >> (x);
    }
    template <typename Arg, typename... Args>
    void read(Arg&& arg, Args&&... args){
        cin >> std::forward<Arg>(arg); using expander = int[];
        (void)expander{0, (void(cin >> std::forward<Args>(args)),0)...};
    }
    template <typename Arg, typename... Args>
    void out(Arg&& arg, Args&&... args){
        cout << std::forward<Arg>(arg); using expander = int[];
        (void)expander{0, (void(cout << "" "" << std::forward<Args>(args)),0)...};
        cout << endl;
    }
    template <class Integer, class F>
    Integer find_first_false(Integer l, Integer r, F&& f) {
        --l; // ++r;
        while (r - l > 1) {
            Integer m = midpoint(l, r);
            if (f(m)) l = m;
            else r = m;
        }
        return r;
    }
    template <class Integer, class F>
    Integer find_last_true(Integer l, Integer r, F &&f) {
        return find_first_false(l, r, [&f](Integer i) { return f(i); }) - 1;
    }
    template <class Integer, class F>
    Integer find_first_true(Integer l, Integer r, F &&f) {
        return find_first_false(l, r, [&f](Integer i) { return !f(i); });
    }
    auto init = []() {
        ios::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL); return 'c';
    }();

    ll pwr(ll base, ll p, ll mod){
        ll ans=1; while(p) {if(p&1) ans=(ans*base)%mod;
            base=(base*base)%mod; p/=2;}
        return ans;
    }
    ll gcd(ll a, ll b) {  return b == 0 ? a : gcd(b,a%b); }
    ll lcm(ll a, ll b) {  return a*(b/gcd(a,b)); }

    const long double PI = (long double)(3.1415926535897932384626433832795);
    const ll  mx_ll   = numeric_limits<ll> :: max();
    const int mx_int  = numeric_limits<int> :: max();

    const int oo = 0x3f3f3f3f;
    const ll  OO = 0x3f3f3f3f3f3f3f3fll;
    const double eps = 1e-9;
    const int DX[8]={0,1, 0,-1,-1,1,-1, 1};
    const int DY[8]={1,0,-1, 0,-1,1, 1,-1};

const int maxn = 1e5 + 3;
const int mod = 1e9+7;
class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& a, int k) {
        if(k==1) return true;
        int n = sz(a);
        vi p(n-1);
        forn(i, n-1) p[i] = a[i] < a[i+1];
        forn(i, n-2) if(p[i+1]) p[i+1] += p[i];
        debug(p);
        fornn(i, k, n-1) {
            if(p[i-k] >= k-1 and p[i] >= k-1) return true;
        }
        return false;
    }
};

#ifdef LOCAL_RUN
void _solve(){
    Solution sol;
    vi a; int k; cin >> a >> k;
    cout << sol.hasIncreasingSubarrays(a, k) << endl;
}


/*************************************************************************/
int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    //cout.precision(15);
    // return 0;
    while(cin.peek() == 32 or cin.peek() == 10) cin.get();
    while(cin.peek() != EOF){
        _solve();
        while(cin.peek() == 32 or cin.peek() == 10) cin.get();
    }
}
#endif
",1448186881
Jose Coves,jcoves,168,3619,cpp,"
#ifdef LOCAL_RUN
#include ""debug_leet.h""
    #else
    #define trace(...) ;
    #define dbg(...) ;
    #define dbgc(...) ;
    #define debug(x) ;
    #define debuga(a, n) ;
    #define debug2(x, y) ;
    #define debug3(x, y, z) ;
    #define debug4(x, y, z, w) ;
    #define debug5(a,b,c,d,e) ;
    #define lassert(x) ;
    #define dassert(x, ...) ;
    int recur_depth = 0; bool rec_indent = true;
    const bool isLocal = false;
    template <typename Arg, typename... Args>
    void display(TreeNode* root) {}
    #endif

    #define pb push_back
    #define eb emplace_back
    #define popb pop_back
    #define all(v) begin(v), end(v)
    #define rall(v) (v).rbegin(),(v).rend()
    #define make_unique(v) (v).erase(unique(all(v)), (v).end())
    #define sz(c) ((int) c.size())
    #define forn(i,n) for(auto i=(n)-(n);i<(n);i++)
    #define fornn(i,s,n) for(auto i=(n)-(n)+(s);i<(n);i++)
    #define forb(i,n) for(auto i=(n)-1;i>=0;i--)
    #define forbn(i,s,n) for(auto i=(n)-1;i>=(s);i--)
    #define forit(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)
    #define mem(a,b) memset(a,b,sizeof(a))
    #define abs(x) (((x) < 0) ? -(x) : (x))
    #define sqr(x) ((x) * (x))
    #define sqrt(x) sqrt(abs(x))
    #define has(c,x) (c.find(x) != c.end())
    #define pw(x) (1LL << (x))
    #define ibit(x,i) (((x) >> (i)) & 1)
    #define data(v) v.data(), sz(v) // vi -> vai
    #define gtime() ((double(clock()) - 0)/CLOCKS_PER_SEC)

    typedef stringstream sstr;
    typedef long long ll;
    typedef long double ld;
    typedef pair<int, int> pii;
    typedef pair<ll,ll> pll;
    typedef pair<ld,ld> pdd;
    typedef vector<int> vi;
    typedef vector<ll> vll;
    typedef vector<pii> vpii;
    typedef vector<vi> vvi;
    typedef vector<vll> vvll;
    typedef valarray<int> vai;
    template <class T>
    using min_pq = priority_queue<T, vector<T>, greater<T>>;
    template <class T>
    using vc = vector<T>;
    template <class T>
    using vvc = vector<vc<T>>;
    template <class T>
    using vvvc = vector<vvc<T>>;
    template <class T>
    using vvvvc = vector<vvvc<T>>;
    template <class T>
    using vvvvvc = vector<vvvvc<T>>;

    template<class F>
    struct y_comb{
        F f;
        template<class T> explicit y_comb(T &&f_in): f(forward<T>(f_in)){ }
        template<class ...Args> decltype(auto) operator()(Args &&...args){ return f(ref(*this), forward<Args>(args)...); }
    };
    template<class F>
    decltype(auto) yf(F &&f){
        return y_comb<decay_t<F>>(forward<F>(f));
    }

    inline int ni(){ int x; cin >> x;   return x; }
    inline ll  nl() { ll  x; cin >> x; return x; }

    template <class T> void mmin(T& a, const T& b) {
        a = (a) < (b) ? (a) : (b);
    }
    template <class T> void mmax(T& a, const T& b) {
        a = (a) > (b) ? (a) : (b);
    }
    template <class T> int LB(vc<T> &a, T x){
        return int(lower_bound(all(a), x) - a.begin());
    }
    template <class T> int UB(vc<T> &a, T x){
        return int(upper_bound(all(a), x) - a.begin());
    }
    template <class T> T MAX(vc<T> &a, int l=0, int r=-1){
        if(r < 0) r = sz(a);
        return *max_element(a.begin()+l, a.begin()+r);
    }
    template <class T> T MIN(vc<T> &a, int l=0, int r=-1){
        if(r < 0) r = sz(a);
        return *min_element(a.begin()+l, a.begin()+r);
    }
    template <class T> auto vv(int d1, T x){
        return vc<T>(d1, x);
    }
    template <class T> auto vv(int d1, int d2, T x){
        return vc<vc<T>>(d1, vc<T>(d2, x));
    }
    template <class T> auto vv(int d1, int d2, int d3, T x){
        return vc<vc<vc<T>>>(d1, vv(d2, d3, x));
    }
    template <class T> auto vv(int d1, int d2, int d3, int d4, T x){
        return vc<vc<vc<vc<T>>>>(d1, vv(d2, d3, d4, x));
    }
    void outv(auto &v){
        for(auto &x: v) {cout<< x <<"" "";} cout<<endl;
    }
    void rvec(int &n, auto &v){
        cin >> n; v.resize(n); for(auto &x: v) cin >> (x);
    }
    template <typename Arg, typename... Args>
    void read(Arg&& arg, Args&&... args){
        cin >> std::forward<Arg>(arg); using expander = int[];
        (void)expander{0, (void(cin >> std::forward<Args>(args)),0)...};
    }
    template <typename Arg, typename... Args>
    void out(Arg&& arg, Args&&... args){
        cout << std::forward<Arg>(arg); using expander = int[];
        (void)expander{0, (void(cout << "" "" << std::forward<Args>(args)),0)...};
        cout << endl;
    }
    template <class Integer, class F>
    Integer find_first_false(Integer l, Integer r, F&& f) {
        --l; // ++r;
        while (r - l > 1) {
            Integer m = midpoint(l, r);
            if (f(m)) l = m;
            else r = m;
        }
        return r;
    }
    template <class Integer, class F>
    Integer find_last_true(Integer l, Integer r, F &&f) {
        return find_first_false(l, r, [&f](Integer i) { return f(i); }) - 1;
    }
    template <class Integer, class F>
    Integer find_first_true(Integer l, Integer r, F &&f) {
        return find_first_false(l, r, [&f](Integer i) { return !f(i); });
    }
    auto init = []() {
        ios::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL); return 'c';
    }();

    ll pwr(ll base, ll p, ll mod){
        ll ans=1; while(p) {if(p&1) ans=(ans*base)%mod;
            base=(base*base)%mod; p/=2;}
        return ans;
    }
    ll gcd(ll a, ll b) {  return b == 0 ? a : gcd(b,a%b); }
    ll lcm(ll a, ll b) {  return a*(b/gcd(a,b)); }

    const long double PI = (long double)(3.1415926535897932384626433832795);
    const ll  mx_ll   = numeric_limits<ll> :: max();
    const int mx_int  = numeric_limits<int> :: max();

    const int oo = 0x3f3f3f3f;
    const ll  OO = 0x3f3f3f3f3f3f3f3fll;
    const double eps = 1e-9;
    const int DX[8]={0,1, 0,-1,-1,1,-1, 1};
    const int DY[8]={1,0,-1, 0,-1,1, 1,-1};

const int maxn = 1e5 + 3;
const int mod = 1e9+7;
template <class T, class F>
    T last_true(T lo, T hi, F&& f) { 
        lo--; // if all are false, return lo-1
        while(lo < hi){
            T mid = lo + (hi - lo + 1) / 2;
            if(f(mid)) lo = mid; 
            else hi = mid - 1;
        }
        return lo;
    }
class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& a, int k) {
        if(k==1) return true;
        int n = sz(a);
        vi p(n-1);
        forn(i, n-1) p[i] = a[i] < a[i+1];
        forn(i, n-2) if(p[i+1]) p[i+1] += p[i];
        debug(p);
        fornn(i, k, n-1) {
            if(p[i-k] >= k-1 and p[i] >= k-1) return true;
        }
        return false;
    }
    int maxIncreasingSubarrays(vector<int>& a) {
        int n = sz(a);
        return last_true(1, n/2, [&](int k){
            return hasIncreasingSubarrays(a, k);
        });
        // vi p(n-1);
        // forn(i, n-1) p[i] = a[i] < a[i+1];
        // forn(i, n-2) if(p[i+1]) p[i+1] += p[i];
        // debug(p);
        // fornn(i, k, n-1) {
        //     if(p[i-k] >= k-1 and p[i] >= k-1) return true;
        // }
    }
};

#ifdef LOCAL_RUN
void _solve(){
    Solution sol;
    vi a; cin >> a;
    out(sol.maxIncreasingSubarrays(a));
}


/*************************************************************************/
int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    //cout.precision(15);
    // return 0;
    while(cin.peek() == 32 or cin.peek() == 10) cin.get();
    while(cin.peek() != EOF){
        _solve();
        while(cin.peek() == 32 or cin.peek() == 10) cin.get();
    }
}
#endif
",1448191166
Jose Coves,jcoves,168,3631,cpp,"
#ifdef LOCAL_RUN
#include ""debug_leet.h""
    #else
    #define trace(...) ;
    #define dbg(...) ;
    #define dbgc(...) ;
    #define debug(x) ;
    #define debuga(a, n) ;
    #define debug2(x, y) ;
    #define debug3(x, y, z) ;
    #define debug4(x, y, z, w) ;
    #define debug5(a,b,c,d,e) ;
    #define lassert(x) ;
    #define dassert(x, ...) ;
    int recur_depth = 0; bool rec_indent = true;
    const bool isLocal = false;
    template <typename Arg, typename... Args>
    void display(TreeNode* root) {}
    #endif

    #define pb push_back
    #define eb emplace_back
    #define popb pop_back
    #define all(v) begin(v), end(v)
    #define rall(v) (v).rbegin(),(v).rend()
    #define make_unique(v) (v).erase(unique(all(v)), (v).end())
    #define sz(c) ((int) c.size())
    #define forn(i,n) for(auto i=(n)-(n);i<(n);i++)
    #define fornn(i,s,n) for(auto i=(n)-(n)+(s);i<(n);i++)
    #define forb(i,n) for(auto i=(n)-1;i>=0;i--)
    #define forbn(i,s,n) for(auto i=(n)-1;i>=(s);i--)
    #define forit(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)
    #define mem(a,b) memset(a,b,sizeof(a))
    #define abs(x) (((x) < 0) ? -(x) : (x))
    #define sqr(x) ((x) * (x))
    #define sqrt(x) sqrt(abs(x))
    #define has(c,x) (c.find(x) != c.end())
    #define pw(x) (1LL << (x))
    #define ibit(x,i) (((x) >> (i)) & 1)
    #define data(v) v.data(), sz(v) // vi -> vai
    #define gtime() ((double(clock()) - 0)/CLOCKS_PER_SEC)

    typedef stringstream sstr;
    typedef long long ll;
    typedef long double ld;
    typedef pair<int, int> pii;
    typedef pair<ll,ll> pll;
    typedef pair<ld,ld> pdd;
    typedef vector<int> vi;
    typedef vector<ll> vll;
    typedef vector<pii> vpii;
    typedef vector<vi> vvi;
    typedef vector<vll> vvll;
    typedef valarray<int> vai;
    template <class T>
    using min_pq = priority_queue<T, vector<T>, greater<T>>;
    template <class T>
    using vc = vector<T>;
    template <class T>
    using vvc = vector<vc<T>>;
    template <class T>
    using vvvc = vector<vvc<T>>;
    template <class T>
    using vvvvc = vector<vvvc<T>>;
    template <class T>
    using vvvvvc = vector<vvvvc<T>>;

    template<class F>
    struct y_comb{
        F f;
        template<class T> explicit y_comb(T &&f_in): f(forward<T>(f_in)){ }
        template<class ...Args> decltype(auto) operator()(Args &&...args){ return f(ref(*this), forward<Args>(args)...); }
    };
    template<class F>
    decltype(auto) yf(F &&f){
        return y_comb<decay_t<F>>(forward<F>(f));
    }

    inline int ni(){ int x; cin >> x;   return x; }
    inline ll  nl() { ll  x; cin >> x; return x; }

    template <class T> void mmin(T& a, const T& b) {
        a = (a) < (b) ? (a) : (b);
    }
    template <class T> void mmax(T& a, const T& b) {
        a = (a) > (b) ? (a) : (b);
    }
    template <class T> int LB(vc<T> &a, T x){
        return int(lower_bound(all(a), x) - a.begin());
    }
    template <class T> int UB(vc<T> &a, T x){
        return int(upper_bound(all(a), x) - a.begin());
    }
    template <class T> T MAX(vc<T> &a, int l=0, int r=-1){
        if(r < 0) r = sz(a);
        return *max_element(a.begin()+l, a.begin()+r);
    }
    template <class T> T MIN(vc<T> &a, int l=0, int r=-1){
        if(r < 0) r = sz(a);
        return *min_element(a.begin()+l, a.begin()+r);
    }
    template <class T> auto vv(int d1, T x){
        return vc<T>(d1, x);
    }
    template <class T> auto vv(int d1, int d2, T x){
        return vc<vc<T>>(d1, vc<T>(d2, x));
    }
    template <class T> auto vv(int d1, int d2, int d3, T x){
        return vc<vc<vc<T>>>(d1, vv(d2, d3, x));
    }
    template <class T> auto vv(int d1, int d2, int d3, int d4, T x){
        return vc<vc<vc<vc<T>>>>(d1, vv(d2, d3, d4, x));
    }
    void outv(auto &v){
        for(auto &x: v) {cout<< x <<"" "";} cout<<endl;
    }
    void rvec(int &n, auto &v){
        cin >> n; v.resize(n); for(auto &x: v) cin >> (x);
    }
    template <typename Arg, typename... Args>
    void read(Arg&& arg, Args&&... args){
        cin >> std::forward<Arg>(arg); using expander = int[];
        (void)expander{0, (void(cin >> std::forward<Args>(args)),0)...};
    }
    template <typename Arg, typename... Args>
    void out(Arg&& arg, Args&&... args){
        cout << std::forward<Arg>(arg); using expander = int[];
        (void)expander{0, (void(cout << "" "" << std::forward<Args>(args)),0)...};
        cout << endl;
    }
    template <class Integer, class F>
    Integer find_first_false(Integer l, Integer r, F&& f) {
        --l; // ++r;
        while (r - l > 1) {
            Integer m = midpoint(l, r);
            if (f(m)) l = m;
            else r = m;
        }
        return r;
    }
    template <class Integer, class F>
    Integer find_last_true(Integer l, Integer r, F &&f) {
        return find_first_false(l, r, [&f](Integer i) { return f(i); }) - 1;
    }
    template <class Integer, class F>
    Integer find_first_true(Integer l, Integer r, F &&f) {
        return find_first_false(l, r, [&f](Integer i) { return !f(i); });
    }
    auto init = []() {
        ios::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL); return 'c';
    }();

    ll pwr(ll base, ll p, ll mod){
        ll ans=1; while(p) {if(p&1) ans=(ans*base)%mod;
            base=(base*base)%mod; p/=2;}
        return ans;
    }
    ll gcd(ll a, ll b) {  return b == 0 ? a : gcd(b,a%b); }
    ll lcm(ll a, ll b) {  return a*(b/gcd(a,b)); }

    const long double PI = (long double)(3.1415926535897932384626433832795);
    const ll  mx_ll   = numeric_limits<ll> :: max();
    const int mx_int  = numeric_limits<int> :: max();

    const int oo = 0x3f3f3f3f;
    const ll  OO = 0x3f3f3f3f3f3f3f3fll;
    const double eps = 1e-9;
    const int DX[8]={0,1, 0,-1,-1,1,-1, 1};
    const int DY[8]={1,0,-1, 0,-1,1, 1,-1};

const int maxn = 1e5 + 3;
const int mod = 1e9+7;
namespace mod_util {
    using i64 = long long;
    template<class T>
    constexpr T power(T a, i64 b) {
        T res = 1;
        for (; b; b /= 2, a *= a) {
            if (b % 2) {
                res *= a;
            }
        }
        return res;
    }

    template<int P>
    struct MInt {
        i64 x;
        constexpr MInt() : x{} {}
        constexpr MInt(i64 x_input) : x{norm(x_input % getMod())} {}

        static int Mod;
        static MInt power(MInt a, i64 b) {
            return mod_util::power(a, b);
        }
        constexpr static int getMod() {
            if (P > 0) {
                return P;
            } else {
                return Mod;
            }
        }
        constexpr static void setMod(int Mod_) {
            Mod = Mod_;
        }
        constexpr i64 norm(i64 val) const {
            if (val < 0) {
                val += getMod();
            }
            if (val >= getMod()) {
                val -= getMod();
            }
            return val;
        }
        constexpr i64 val() const {
            return x;
        }
        explicit constexpr operator ll() const {
            return x;
        }
        constexpr MInt operator-() const {
            MInt res;
            res.x = norm(getMod() - x);
            return res;
        }
        constexpr MInt inv() const {
            assert(x != 0);
            return power(*this, getMod() - 2);
        }
        constexpr MInt &operator*=(MInt rhs) & {
            x = 1LL * x * rhs.x % getMod();
            return *this;
        }
        constexpr MInt &operator+=(MInt rhs) & {
            x = norm(x + rhs.x);
            return *this;
        }
        constexpr MInt &operator-=(MInt rhs) & {
            x = norm(x - rhs.x);
            return *this;
        }
        constexpr MInt &operator/=(MInt rhs) & {
            return *this *= rhs.inv();
        }
        constexpr MInt &operator^=(MInt rhs) & {
            return *this = power(*this, rhs.x);
        }
        constexpr MInt pow(ll rhs) {
            return *this = power(*this, rhs);
        }
        friend constexpr MInt operator*(MInt lhs, MInt rhs) {
            MInt res = lhs;
            res *= rhs;
            return res;
        }
        friend constexpr MInt operator+(MInt lhs, MInt rhs) {
            MInt res = lhs;
            res += rhs;
            return res;
        }
        friend constexpr MInt operator-(MInt lhs, MInt rhs) {
            MInt res = lhs;
            res -= rhs;
            return res;
        }
        friend constexpr MInt operator/(MInt lhs, MInt rhs) {
            MInt res = lhs;
            res /= rhs;
            return res;
        }
        friend constexpr MInt operator^(MInt lhs, MInt rhs) {
            MInt res = lhs;
            res ^= rhs;
            return res;
        }
        friend constexpr istream &operator>>(istream &is, MInt &a) {
            i64 v;
            is >> v;
            a = MInt(v);
            return is;
        }
        friend constexpr ostream &operator<<(ostream &os, const MInt &a) {
            return os << a.val();
        }
        friend constexpr bool operator==(MInt lhs, MInt rhs) {
            return lhs.val() == rhs.val();
        }
        friend constexpr bool operator!=(MInt lhs, MInt rhs) {
            return lhs.val() != rhs.val();
        }
    };

    template<>
    int MInt<0>::Mod = mod;

    template<int V, int P>
    constexpr MInt<P> CInv = MInt<P>(V).inv();

    constexpr int P = mod;
    using Z = MInt<P>;

    struct Comb {
        int N;
        vector<Z> _fac;
        vector<Z> _invfac;
        vector<Z> _inv;

        Comb() : N{0}, _fac{1}, _invfac{1}, _inv{0} {}
        Comb(int n) : Comb() {
            init(n);
        }

        void init(int m) {
            m = min(m, Z::getMod() - 1);
            if (m <= N) return;
            _fac.resize(m + 1);
            _invfac.resize(m + 1);
            _inv.resize(m + 1);

            for (int i = N + 1; i <= m; i++) {
                _fac[i] = _fac[i - 1] * i;
            }
            _invfac[m] = _fac[m].inv();
            for (int i = m; i > N; i--) {
                _invfac[i - 1] = _invfac[i] * i;
                _inv[i] = _invfac[i] * _fac[i - 1];
            }
            N = m;
        }
        void check_init(int m){
            if (m > N) init(2 * m);
        }
        Z fac(int m) {
            check_init(m);
            return _fac[m];
        }
        Z invfac(int m) {
            check_init(m);
            return _invfac[m];
        }
        Z inv(int m) {
            check_init(m);
            return _inv[m];
        }
        Z binom(int n, int k) { // choose k out of n
            if (n < k || k < 0) return 0;
            return fac(n) * invfac(k) * invfac(n - k);
        }
        Z choose(int k, int n) { // choose k out of n
            return binom(n, k);
        }
    } comb;
}
using Z = mod_util::MInt<mod>;
auto &comb = mod_util::comb;
void build(){
    int n = 801;
    vi dp(n); dp[0]=dp[1]=0;
    fornn(i,2,n) dp[i] = 1 + dp[__builtin_popcount(i)];
    forn(i, n){
        int to = __builtin_popcount(i);
        debug3(i, to, dp[i]);
    }
}
class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        int n = sz(s);
        vi cost(n+1); cost[1]=0;
        debug2(n, s);
        fornn(i,2,n+1) cost[i] = 1 + cost[__builtin_popcount(i)];
        auto dp = vv(n+1, 2, n+1, Z(0));
        auto vis = vv(n+1, 2, n+1, 0);
        auto go = yf([&](auto f, int rem, int eq, int i) -> Z {
            if(rem < 0) return 0;
            if(i == n) {
                if(rem > 0) return 0;
                if(eq == 1) return 0;
                return 1;
            }
            auto &ans = dp[rem][eq][i]; if(vis[rem][eq][i]++) return ans;
            if(eq){
                if(s[i] == '1'){
                    ans += f(rem-1, eq, i+1); // 1
                    ans += f(rem-0, 0, i+1); // 0
                } else { // = 0
                    // cant be higher; ans += f(rem-1, eq, i+1); // 1; 
                    ans += f(rem-0, eq, i+1); // 0
                }
            } else {
                ans += f(rem-1, eq, i+1); // 1
                ans += f(rem-0, eq, i+1); // 0
                // if(s[i] == '1'){
                //     ans += f(rem-1, eq, i+1); // 1
                //     ans += f(rem-0, eq, i+1); // 0
                // } else { // = 0
                //     ans += f(rem-1, eq, i+1); // 1; 
                //     ans += f(rem-0, eq, i+1); // 0
                // }
            }
            return ans;
        });
        Z ans = 0;
        fornn(on, 1, n+1) if(cost[on] < k) {
            auto val = go(on, 1, 0);
            debug3(on, cost[on], val);
            ans += val;
        }
        return int(ans.val());
    }
};

#ifdef LOCAL_RUN
void _solve(){
    Solution sol;
    string s; int k; cin >> s >> k;
    out(sol.countKReducibleNumbers(s, k));
}


/*************************************************************************/
int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    //cout.precision(15);
    // return 0;
    build();
    while(cin.peek() == 32 or cin.peek() == 10) cin.get();
    while(cin.peek() != EOF){
        _solve();
        while(cin.peek() == 32 or cin.peek() == 10) cin.get();
    }
}
#endif
",1448257295
Jose Coves,jcoves,168,3646,cpp,"
#ifdef LOCAL_RUN
#include ""debug_leet.h""
    #else
    #define trace(...) ;
    #define dbg(...) ;
    #define dbgc(...) ;
    #define debug(x) ;
    #define debuga(a, n) ;
    #define debug2(x, y) ;
    #define debug3(x, y, z) ;
    #define debug4(x, y, z, w) ;
    #define debug5(a,b,c,d,e) ;
    #define lassert(x) ;
    #define dassert(x, ...) ;
    int recur_depth = 0; bool rec_indent = true;
    const bool isLocal = false;
    template <typename Arg, typename... Args>
    void display(TreeNode* root) {}
    #endif

    #define pb push_back
    #define eb emplace_back
    #define popb pop_back
    #define all(v) begin(v), end(v)
    #define rall(v) (v).rbegin(),(v).rend()
    #define make_unique(v) (v).erase(unique(all(v)), (v).end())
    #define sz(c) ((int) c.size())
    #define forn(i,n) for(auto i=(n)-(n);i<(n);i++)
    #define fornn(i,s,n) for(auto i=(n)-(n)+(s);i<(n);i++)
    #define forb(i,n) for(auto i=(n)-1;i>=0;i--)
    #define forbn(i,s,n) for(auto i=(n)-1;i>=(s);i--)
    #define forit(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)
    #define mem(a,b) memset(a,b,sizeof(a))
    #define abs(x) (((x) < 0) ? -(x) : (x))
    #define sqr(x) ((x) * (x))
    #define sqrt(x) sqrt(abs(x))
    #define has(c,x) (c.find(x) != c.end())
    #define pw(x) (1LL << (x))
    #define ibit(x,i) (((x) >> (i)) & 1)
    #define data(v) v.data(), sz(v) // vi -> vai
    #define gtime() ((double(clock()) - 0)/CLOCKS_PER_SEC)

    typedef stringstream sstr;
    typedef long long ll;
    typedef long double ld;
    typedef pair<int, int> pii;
    typedef pair<ll,ll> pll;
    typedef pair<ld,ld> pdd;
    typedef vector<int> vi;
    typedef vector<ll> vll;
    typedef vector<pii> vpii;
    typedef vector<vi> vvi;
    typedef vector<vll> vvll;
    typedef valarray<int> vai;
    template <class T>
    using min_pq = priority_queue<T, vector<T>, greater<T>>;
    template <class T>
    using vc = vector<T>;
    template <class T>
    using vvc = vector<vc<T>>;
    template <class T>
    using vvvc = vector<vvc<T>>;
    template <class T>
    using vvvvc = vector<vvvc<T>>;
    template <class T>
    using vvvvvc = vector<vvvvc<T>>;

    template<class F>
    struct y_comb{
        F f;
        template<class T> explicit y_comb(T &&f_in): f(forward<T>(f_in)){ }
        template<class ...Args> decltype(auto) operator()(Args &&...args){ return f(ref(*this), forward<Args>(args)...); }
    };
    template<class F>
    decltype(auto) yf(F &&f){
        return y_comb<decay_t<F>>(forward<F>(f));
    }

    inline int ni(){ int x; cin >> x;   return x; }
    inline ll  nl() { ll  x; cin >> x; return x; }

    template <class T> void mmin(T& a, const T& b) {
        a = (a) < (b) ? (a) : (b);
    }
    template <class T> void mmax(T& a, const T& b) {
        a = (a) > (b) ? (a) : (b);
    }
    template <class T> int LB(vc<T> &a, T x){
        return int(lower_bound(all(a), x) - a.begin());
    }
    template <class T> int UB(vc<T> &a, T x){
        return int(upper_bound(all(a), x) - a.begin());
    }
    template <class T> T MAX(vc<T> &a, int l=0, int r=-1){
        if(r < 0) r = sz(a);
        return *max_element(a.begin()+l, a.begin()+r);
    }
    template <class T> T MIN(vc<T> &a, int l=0, int r=-1){
        if(r < 0) r = sz(a);
        return *min_element(a.begin()+l, a.begin()+r);
    }
    template <class T> auto vv(int d1, T x){
        return vc<T>(d1, x);
    }
    template <class T> auto vv(int d1, int d2, T x){
        return vc<vc<T>>(d1, vc<T>(d2, x));
    }
    template <class T> auto vv(int d1, int d2, int d3, T x){
        return vc<vc<vc<T>>>(d1, vv(d2, d3, x));
    }
    template <class T> auto vv(int d1, int d2, int d3, int d4, T x){
        return vc<vc<vc<vc<T>>>>(d1, vv(d2, d3, d4, x));
    }
    void outv(auto &v){
        for(auto &x: v) {cout<< x <<"" "";} cout<<endl;
    }
    void rvec(int &n, auto &v){
        cin >> n; v.resize(n); for(auto &x: v) cin >> (x);
    }
    template <typename Arg, typename... Args>
    void read(Arg&& arg, Args&&... args){
        cin >> std::forward<Arg>(arg); using expander = int[];
        (void)expander{0, (void(cin >> std::forward<Args>(args)),0)...};
    }
    template <typename Arg, typename... Args>
    void out(Arg&& arg, Args&&... args){
        cout << std::forward<Arg>(arg); using expander = int[];
        (void)expander{0, (void(cout << "" "" << std::forward<Args>(args)),0)...};
        cout << endl;
    }
    template <class Integer, class F>
    Integer find_first_false(Integer l, Integer r, F&& f) {
        --l; // ++r;
        while (r - l > 1) {
            Integer m = midpoint(l, r);
            if (f(m)) l = m;
            else r = m;
        }
        return r;
    }
    template <class Integer, class F>
    Integer find_last_true(Integer l, Integer r, F &&f) {
        return find_first_false(l, r, [&f](Integer i) { return f(i); }) - 1;
    }
    template <class Integer, class F>
    Integer find_first_true(Integer l, Integer r, F &&f) {
        return find_first_false(l, r, [&f](Integer i) { return !f(i); });
    }
    auto init = []() {
        ios::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL); return 'c';
    }();

    ll pwr(ll base, ll p, ll mod){
        ll ans=1; while(p) {if(p&1) ans=(ans*base)%mod;
            base=(base*base)%mod; p/=2;}
        return ans;
    }
    ll gcd(ll a, ll b) {  return b == 0 ? a : gcd(b,a%b); }
    ll lcm(ll a, ll b) {  return a*(b/gcd(a,b)); }

    const long double PI = (long double)(3.1415926535897932384626433832795);
    const ll  mx_ll   = numeric_limits<ll> :: max();
    const int mx_int  = numeric_limits<int> :: max();

    const int oo = 0x3f3f3f3f;
    const ll  OO = 0x3f3f3f3f3f3f3f3fll;
    const double eps = 1e-9;
    const int DX[8]={0,1, 0,-1,-1,1,-1, 1};
    const int DY[8]={1,0,-1, 0,-1,1, 1,-1};

const int maxn = 1e5 + 3;
const int mod = 1e9+7;
namespace mod_util {
    using i64 = long long;
    template<class T>
    constexpr T power(T a, i64 b) {
        T res = 1;
        for (; b; b /= 2, a *= a) {
            if (b % 2) {
                res *= a;
            }
        }
        return res;
    }

    template<int P>
    struct MInt {
        i64 x;
        constexpr MInt() : x{} {}
        constexpr MInt(i64 x_input) : x{norm(x_input % getMod())} {}

        static int Mod;
        static MInt power(MInt a, i64 b) {
            return mod_util::power(a, b);
        }
        constexpr static int getMod() {
            if (P > 0) {
                return P;
            } else {
                return Mod;
            }
        }
        constexpr static void setMod(int Mod_) {
            Mod = Mod_;
        }
        constexpr i64 norm(i64 val) const {
            if (val < 0) {
                val += getMod();
            }
            if (val >= getMod()) {
                val -= getMod();
            }
            return val;
        }
        constexpr i64 val() const {
            return x;
        }
        explicit constexpr operator ll() const {
            return x;
        }
        constexpr MInt operator-() const {
            MInt res;
            res.x = norm(getMod() - x);
            return res;
        }
        constexpr MInt inv() const {
            assert(x != 0);
            return power(*this, getMod() - 2);
        }
        constexpr MInt &operator*=(MInt rhs) & {
            x = 1LL * x * rhs.x % getMod();
            return *this;
        }
        constexpr MInt &operator+=(MInt rhs) & {
            x = norm(x + rhs.x);
            return *this;
        }
        constexpr MInt &operator-=(MInt rhs) & {
            x = norm(x - rhs.x);
            return *this;
        }
        constexpr MInt &operator/=(MInt rhs) & {
            return *this *= rhs.inv();
        }
        constexpr MInt &operator^=(MInt rhs) & {
            return *this = power(*this, rhs.x);
        }
        constexpr MInt pow(ll rhs) {
            return *this = power(*this, rhs);
        }
        friend constexpr MInt operator*(MInt lhs, MInt rhs) {
            MInt res = lhs;
            res *= rhs;
            return res;
        }
        friend constexpr MInt operator+(MInt lhs, MInt rhs) {
            MInt res = lhs;
            res += rhs;
            return res;
        }
        friend constexpr MInt operator-(MInt lhs, MInt rhs) {
            MInt res = lhs;
            res -= rhs;
            return res;
        }
        friend constexpr MInt operator/(MInt lhs, MInt rhs) {
            MInt res = lhs;
            res /= rhs;
            return res;
        }
        friend constexpr MInt operator^(MInt lhs, MInt rhs) {
            MInt res = lhs;
            res ^= rhs;
            return res;
        }
        friend constexpr istream &operator>>(istream &is, MInt &a) {
            i64 v;
            is >> v;
            a = MInt(v);
            return is;
        }
        friend constexpr ostream &operator<<(ostream &os, const MInt &a) {
            return os << a.val();
        }
        friend constexpr bool operator==(MInt lhs, MInt rhs) {
            return lhs.val() == rhs.val();
        }
        friend constexpr bool operator!=(MInt lhs, MInt rhs) {
            return lhs.val() != rhs.val();
        }
    };

    template<>
    int MInt<0>::Mod = mod;

    template<int V, int P>
    constexpr MInt<P> CInv = MInt<P>(V).inv();

    constexpr int P = mod;
    using Z = MInt<P>;

    struct Comb {
        int N;
        vector<Z> _fac;
        vector<Z> _invfac;
        vector<Z> _inv;

        Comb() : N{0}, _fac{1}, _invfac{1}, _inv{0} {}
        Comb(int n) : Comb() {
            init(n);
        }

        void init(int m) {
            m = min(m, Z::getMod() - 1);
            if (m <= N) return;
            _fac.resize(m + 1);
            _invfac.resize(m + 1);
            _inv.resize(m + 1);

            for (int i = N + 1; i <= m; i++) {
                _fac[i] = _fac[i - 1] * i;
            }
            _invfac[m] = _fac[m].inv();
            for (int i = m; i > N; i--) {
                _invfac[i - 1] = _invfac[i] * i;
                _inv[i] = _invfac[i] * _fac[i - 1];
            }
            N = m;
        }
        void check_init(int m){
            if (m > N) init(2 * m);
        }
        Z fac(int m) {
            check_init(m);
            return _fac[m];
        }
        Z invfac(int m) {
            check_init(m);
            return _invfac[m];
        }
        Z inv(int m) {
            check_init(m);
            return _inv[m];
        }
        Z binom(int n, int k) { // choose k out of n
            if (n < k || k < 0) return 0;
            return fac(n) * invfac(k) * invfac(n - k);
        }
        Z choose(int k, int n) { // choose k out of n
            return binom(n, k);
        }
    } comb;
}
using Z = mod_util::MInt<mod>;
auto &comb = mod_util::comb;
class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& a) {
        int n = sz(a);
        int hi = MAX(a) + 1;
        debug3(n, hi, a);
        // vc<Z> dp(hi);
        vc<Z> cnt(hi), sum(hi);
        for(int x: a){
            cnt[x] += 1;
            sum[x] += x;
            if(x > 0 ){
                cnt[x] += cnt[x-1];
                sum[x] += cnt[x-1] * x + sum[x-1];
            }
            if(x+1 < hi ){
                cnt[x] += cnt[x+1];
                sum[x] += cnt[x+1] * x + sum[x+1];
            }
            debug3(x, cnt[x], sum[x]);
        }
        Z ans = 0;
        forn(i, hi) ans += sum[i];
        return int(ans.val());
    }
};

#ifdef LOCAL_RUN
void _solve(){
    Solution sol;
    vi a; cin >> a;
    out(sol.sumOfGoodSubsequences(a));
}


/*************************************************************************/
int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    //cout.precision(15);
    // return 0;
    while(cin.peek() == 32 or cin.peek() == 10) cin.get();
    while(cin.peek() != EOF){
        _solve();
        while(cin.peek() == 32 or cin.peek() == 10) cin.get();
    }
}
#endif
",1448217249
IphoneX,hahahiehie,169,3612,java,"import java.util.*;

class Utils {
    public static int log2(long n) {
        return 63 - Long.numberOfLeadingZeros(n);
    }

    // nums = ""aaabaaaba"" odd d[1] return [1, 2, 1, 4, 1, 2, 2]
    // d[0] for even, d[1] for odd
    public static int[][] manacher(String s) {
        int n = s.length();
        int[] d1 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; ++i) {
            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s.charAt(i - k) == s.charAt(i + k)) k++;
            d1[i] = k;
            if (i + k - 1 > r) {
                l = i - k + 1;
                r = i + k - 1;
            }
        }

        int[] d0 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : Math.min(d0[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s.charAt(i - k - 1) == s.charAt(i + k)) {
                k++;
            }
            d0[i] = k;
            if (i + k - 1 > r) {
                l = i - k;
                r = i + k - 1;
            }
        }
        return new int[][]{d0, d1};
    }

    // generate primes that is <= n
    public static int[] genPrimes(int n) {
        if (n <= 1) return new int[0];
        boolean[] isComp = new boolean[n + 1];
        int len = 0;
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                len++;
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                }
            }
        }
        int[] ans = new int[len];
        for (int i = 2, j = 0; i <= n; i++) {
            if (!isComp[i]) {
                ans[j++] = i;
            }
        }
        return ans;
    }

    // int[0] = primeFactor, int[1] = count of that primeFactor
    // NOTE: factors[0] and factors[1] are empty list.
    public static List<int[]>[] genPrimeFactors(int n) {
        List<int[]>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            factors[i] = new ArrayList<>();
        }
        boolean[] isComp = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                factors[i].add(new int[]{i, 1});
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                    int t = j, count = 0;
                    while (t % i == 0) {
                        count++;
                        t /= i;
                    }
                    factors[j].add(new int[]{i, count});
                }
            }
        }
        return factors;
    }

    // generate factors (not prime factors), factors[0] is empty list.
    public static List<Integer>[] genFactors(int n) {
        List<Integer>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) factors[i] = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j += i) {
                factors[j].add(i);
            }
        }
        return factors;
    }

    public static int lowerBound(int[] a, int target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(int[] a, int target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(long[] a, long target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(long[] a, long target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static long or(int x, int y) {
        return ((long) x << 32) | ((long) y << 32 >>> 32);
    }

    // k = 0...nums.length - 1
    // After calling this function, nums[k] is the k-th number.
    public static int kthNumber(int[] nums, int k) {
        return kthNumberHelper(nums, k, 0, nums.length - 1);
    }

    // end is inclusive (0 to nums.length - 1)
    private static int kthNumberHelper(int[] nums, int K, int start, int end) {
        if (start == end) return nums[start];
        int i = partition(nums, start, end);
        return K <= i ? kthNumberHelper(nums, K, start, i) : kthNumberHelper(nums, K, i + 1, end);
    }

    // end is inclusive (0 to nums.length - 1)
    public static int partition(int[] nums, int start, int end) {
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && nums[i] < pivot) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && pivot < nums[j]) j--;
            if (i < j) nums[i++] = nums[j];
        }

        // pos is the final position for pivot.
        nums[i] = pivot;
        return i;
    }

    public static void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    // partition nums into 3 parts [smaller than pivot, equal to pivot, larger than pivot]
    public static void partition3(int[] nums, int pivot) {
        int n = nums.length;
        int l = 0, r = n - 1;
        for (int i = 0; i <= r; i++) {
            if (nums[i] < pivot) {
                swap(nums, l++, i);
            } else if (nums[i] > pivot) {
                swap(nums, r--, i--);
            }
        }
    }

    // end is inclusive
    public static void reverse(int[] nums, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    }

    // Return false if next permutation is not available. (nums is not changed for this case)
    public static boolean nextPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] >= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] > nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // Return false if previous permutation is not available. (nums is not changed for this case)
    public static boolean prevPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] <= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] < nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }


    // a, b could be negative
    // remainder >= 0
    // return [a / b, a % b]
    public static int[] divMod(int a, int b) {
        int r = a % b;
        int c = a / b;
        if (r < 0) {
            r += Math.abs(b);
            c++;
        }
        return new int[]{c, r};
    }

    public static List<Integer> negativeBase(int n, int base) {
        List<Integer> digits = new ArrayList<>();
        if (n == 0) {
            digits.add(0);
            return digits;
        }
        while (n != 0) {
            // t[0] = n / base
            // t[1] = n % base;
            int[] t = divMod(n, base);
            digits.add(t[1]);
            n = t[0];
        }
        Collections.reverse(digits);
        return digits;
    }

    // (a ^ b) % MOD
    public static long powMod(long a, long b, long MOD) {
        long res = 1L;
        a %= MOD; // In case a * a is overflow
        while (b > 0) {
            if ((b & 1) != 0) res = (res * a) % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    public static long[][] genCombination(int n) {
        long[][] C = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        return C;
    }

    public static long[][] genPermutation(int n) {
        long[][] P = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
        return P;
    }

    public static long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }

    public static int[] preprocessLog2(int n) { // from log2(0) .... log2(n) inclusive
        int[] lg = new int[n + 1];
        for (int k = 0, i = 1; i <= n; lg[i++] = k - 1) {
            while ((1 << k) <= i) {
                k++;
            }
        }
        return lg;
    }

    public static long max(long[] nums) {
        long ret = Long.MIN_VALUE;
        for (long v : nums) ret = Math.max(ret, v);
        return ret;
    }

    public static int max(int[] nums) {
        int ret = Integer.MIN_VALUE;
        for (int v : nums) ret = Math.max(ret, v);
        return ret;
    }
}

// Tested by leetcode 1163
class SuffixArray {
    int[] s;
    int[] SA; // SA[i] => index of the i-th ranked suffix
    int[] rank; // rank[i] => the rank of i-th suffix, SA[rank[i]] == i
    int[] height; // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).

    private int[][] d;
    private int n;
    private int[] lg;

    private int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    private static int[] stringToIntArray(String str) {
        int[] nums = new int[str.length()];
        for (int i = 0; i < str.length(); i++) nums[i] = str.charAt(i);
        return nums;
    }

    public SuffixArray(String str) {
        this(str, true);
    }

    public SuffixArray(String str, boolean toBuildRMQ) {
        this(stringToIntArray(str), toBuildRMQ);
    }

    public SuffixArray(int[] nums) {
        this(nums, true);
    }

    public SuffixArray(int[] nums, boolean toBuildRMQ) {
        this.s = nums;
        this.n = nums.length;
        this.SA = new int[n];
        this.rank = new int[n];
        suffixSort(s);
        if (toBuildRMQ) {
            this.height = new int[n];
            this.d = new int[log2(n) + 1][n];
            this.lg = new int[n + 1];
            buildHeight();
            buildRMQ();
        }
    }

    // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).
    // ?? s[n] = 0 or s[n] = -INF.
    private void buildHeight() {
        int i, j, h;
        height[0] = 0;
        for (i = 0; i < n; i++)
            rank[SA[i]] = i;
        for (h = i = 0; i < n; i++)
            if (rank[i] > 0) {
                j = SA[rank[i] - 1];
                while (i + h < n && j + h < n && s[i + h] == s[j + h]) ++h;
                height[rank[i]] = h;
                if (h > 0) --h;
            }
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    private void buildRMQ() {
        int i, j, k;
        for (i = 0; i < n; i++)
            d[0][i] = height[i];
        for (j = 1; (1 << j) <= n; j++)
            for (i = 0; i + (1 << j) <= n; i++)
                d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
        for (lg[0] = k = 0, i = 1; i <= n; lg[i++] = k - 1)
            while ((1 << k) <= i) k++;
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    public int LCP(int i, int j) {
        if (i == j) return n - SA[i];
        if (i > j) {
            int t = i;
            i = j;
            j = t;
        }
        int k = lg[j - (++i) + 1];
        return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }

    // LCPIndex(i, j) = LCP(s[i], s[j])
    public int LCPIndex(int i, int j) {
        return LCP(rank[i], rank[j]);
    }

    private void sortIndex(int[] nums, int start, int end) {
        if (start >= end) return;
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && s[nums[i]] < s[pivot]) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && s[pivot] < s[nums[j]]) j--;
            if (i < j) nums[i++] = nums[j];
        }
        nums[i] = pivot; // index i is the final position for pivot.
        sortIndex(nums, start, i - 1);
        sortIndex(nums, i + 1, end);
    }

    private void suffixSort(int[] s) {
        int[] count = new int[n], t;
        int[] nSA = new int[n];
        int[] nRank = new int[n];
//        Integer[] tempArray = new Integer[n];
//        for (int x = 0; x < n; x++) tempArray[x] = x;
//        Arrays.sort(tempArray, (a, b) -> Integer.compare(s[a], s[b]));
//        for (int x = 0; x < n; x++) SA[x] = tempArray[x];
        int i, k;
        int minV = s[0], maxV = s[0];
        for (i = 1; i < n; i++) {
            minV = Math.min(minV, s[i]);
            maxV = Math.max(maxV, s[i]);
        }
        if ((long) maxV - minV + 1 <= (long) n) { // radix sort if alphabet size is small
            for (i = 0; i < n; i++) count[s[i] - minV]++;
            for (i = minV + 1; i <= maxV; i++) count[i - minV] += count[i - minV - 1];
            for (i = n - 1; i >= 0; i--) SA[--count[s[i] - minV]] = i;
        } else {
            for (i = 0; i < n; i++) SA[i] = i;
            sortIndex(SA, 0, n - 1);
        }
        for (rank[SA[0]] = 0, i = 1; i < n; i++) {
            rank[SA[i]] = (s[SA[i]] != s[SA[i - 1]]) ? rank[SA[i - 1]] + 1 : rank[SA[i - 1]];
        }
        for (k = 1; k < n && rank[SA[n - 1]] < n - 1; k <<= 1) {
            for (i = 0; i < n; i++) count[rank[SA[i]]] = i + 1;
            for (i = n - 1; i >= 0; i--) if (SA[i] >= k) nSA[--count[rank[SA[i] - k]]] = SA[i] - k;
            for (i = n - k; i < n; i++) nSA[--count[rank[i]]] = i;
            t = SA;
            SA = nSA;
            nSA = t;
            for (nRank[SA[0]] = 0, i = 1; i < n; i++) {
                nRank[SA[i]] = (SA[i] + k >= n || SA[i - 1] + k >= n || rank[SA[i]] != rank[SA[i - 1]] || rank[SA[i] + k] != rank[SA[i - 1] + k]) ? nRank[SA[i - 1]] + 1 : nRank[SA[i - 1]];
            }
            t = rank;
            rank = nRank;
            nRank = t;
        }
    }
}

class Combination {
    long[] factorial;
    long[] inverseFactorial;
    long MOD;

    // O(maxSize) for preprocessing
    // MOD must be prime
    public Combination(int maxSize, long MOD) {
        factorial = new long[maxSize + 1];
        inverseFactorial = new long[maxSize + 1];
        factorial[0] = 1;
        inverseFactorial[0] = 1;
        this.MOD = MOD;
        for (int i = 1; i <= maxSize; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
            inverseFactorial[i] = inverse(factorial[i]);
        }
    }

    // x, y are long[1]
    // ax + by = gcd(a, b)
    private long extGcd(long a, long b, long[] x, long[] y) {
        if (b == 0) {
            x[0] = 1;
            y[0] = 0;
            return a;
        } else {
            long r = extGcd(b, a % b, y, x);
            y[0] -= x[0] * (a / b);
            return r;
        }
    }

    // (a * x) % MOD = 1
    // x is the inverse element
    public long inverse(long a) {
        long[] x = new long[1], y = new long[1];
        extGcd(a, MOD, x, y);
        return (x[0] % MOD + MOD) % MOD;
    }

    // m >= n
    // O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        else if (m == n) return factorial[m];
            //return factorial[m] * inverse(factorial[m - n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD;
    }

    // m >= n
    // O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
            //return factorial[m] * inverse(factorial[m - n]) % MOD * inverse(factorial[n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD * inverseFactorial[n] % MOD;
    }
}

class CombinationNoMod {

    long[][] C;
    long[][] P;

    public CombinationNoMod(int maxSize) {
        C = new long[maxSize + 1][maxSize + 1];
        P = new long[maxSize + 1][maxSize + 1];
        int m = C.length;
        int n = C[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
    }

    // m >= n. O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        return P[m][n];
    }

    // m >= n. O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
        return C[m][n];
    }
}

class Fraction {
    long n, d; // n / d (d != 0)

    public Fraction(long n, long d) {
        if (d == 0) {
            this.n = Long.MAX_VALUE;
            this.d = 1;
            return;
        }
        long g = gcd(Math.abs(n), Math.abs(d));
        this.n = n / g;
        this.d = d / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    public void add(Fraction other) {
        long numerator = this.n * other.d + this.d * other.n;
        long denominator = this.d * other.d;
        long g = gcd(Math.abs(numerator), Math.abs(denominator));
        this.n = numerator / g;
        this.d = denominator / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    @Override
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof Fraction) {
            Fraction anotherObject = (Fraction) anObject;
            return n == anotherObject.n && d == anotherObject.d;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return (int) (n * 31 + d);
    }

    private long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }
}

class UnionFind {
    int[] parent;
    int[] sz;

    // from 0 ... n - 1
    public UnionFind(int n) {
        parent = new int[n];
        sz = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public void clear() {
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public int find(int x) {
        //return parent[x] == x ? x : (parent[x] = find(parent[x]));
        if (parent[x] == x) return x;
        int px = x;
        while (px != parent[px]) px = parent[px];
        while (x != px) {
            int next = parent[x];
            parent[x] = px;
            x = next;
        }
        return px;
    }

    // px is the final parent
    public boolean union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return false;
        parent[py] = px;
        sz[px] += sz[py];
        return true;
    }

    public int size(int x) {
        return sz[find(x)];
    }

    public UnionFind clone() {
        UnionFind cloned = new UnionFind(parent.length);
        for (int i = 0; i < parent.length; i++) {
            cloned.parent[i] = parent[i];
            cloned.sz[i] = sz[i];
        }
        return cloned;
    }
}

class Trie {
    static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        boolean isWord = false;
        long count = 0L;
    }

    TrieNode root = new TrieNode();

    public void add(String word) {
        add(word, 1L);
    }

    public void remove(String word) {
        add(word, -1L);
    }

    private void add(String word, long count) {
        TrieNode cur = root;
        cur.count += count;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) cur.next[c] = new TrieNode();
            cur = cur.next[c];
            cur.count += count;
        }
        cur.isWord = true;
    }

    public boolean contains(String word) {
        TrieNode cur = root;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null || cur.next[c].count <= 0L) return false;
            cur = cur.next[c];
            //if (cur.isWord) return true;
        }
        return cur.isWord;
    }
}

// Tested by Leetcode 1707 and Leetcode 1803
class TrieBinary {
    static class TrieNode {
        TrieNode[] next = new TrieNode[2];
        long count;
    }

    private TrieNode root;
    private int numOfBits;

    public TrieBinary(int numOfBits) { // normally 31 for int and 63 for long
        this.numOfBits = numOfBits;
        this.root = new TrieNode();
    }

    public void add(long v) {
        add(v, 1L);
    }

    public void remove(long v) { // Tested by Leetcode 1938
        add(v, -1L);
    }

    public void add(long v, long count) {
        TrieNode cur = root;
        root.count += count;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null) cur.next[b] = new TrieNode();
            cur = cur.next[b];
            cur.count += count;
        }
    }

    // Tested by Leetcode 1707
    public long xorMax(long v) {
        TrieNode cur = root;
        long key = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[1 - b] != null && cur.next[1 - b].count > 0) {
                cur = cur.next[1 - b];
                key |= (1L - b) << i;
            } else {
                cur = cur.next[b];
                key |= (long) b << i;
            }
        }
        return key ^ v;
    }

    public boolean contains(long v) {
        TrieNode cur = root;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null || cur.next[b].count <= 0) return false;
            cur = cur.next[b];
        }
        return true;
    }

    // Tested by Leetcode 1803
    // count(x ^ v <= limit)
    public long xorLessOrEqualCount(long v, long limit) {
        if (limit < 0) return 0;
        TrieNode cur = root;
        long ans = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int bitLimit = ((limit >>> i) & 1) == 0 ? 0 : 1;
            int bitV = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (bitLimit == 1) {
                ans += (cur.next[bitV] != null ? cur.next[bitV].count : 0);
            }
            cur = cur.next[bitV ^ bitLimit];
            if (cur == null) break;
            if (i == 0) ans += cur.count;
        }
        return ans;
    }
}

// Lazy execution example is in https://leetcode.com/submissions/detail/1034182539/
// Refer to AlgorithmCompilation.java

// [Template] Classic Segment Tree (Range Sum), used for Template
class ClassicSegmentTree { // For Range Sum
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final int L, R;

    public ClassicSegmentTree(int[] input) {
        L = 0;
        R = input.length - 1;
        root = new TreeNode();
        build(root, L, R, input);
    }

    private void build(TreeNode root, int l, int r, int[] input) {
        if (l == r) {
            root.sum = input[l];
            return;
        }
        int m = (l + r) >> 1;
        root.left = new TreeNode();
        root.right = new TreeNode();
        build(root.left, l, m, input);
        build(root.right, m + 1, r, input);
        root.sum = root.left.sum + root.right.sum;
    }

    public void set(int index, int value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, int L, int R, int index, int value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        int M = L + ((R - L) >> 1);
        if (index <= M) {
            set(root.left, L, M, index, value);
        } else {
            set(root.right, M + 1, R, index, value);
        }
        root.sum = root.left.sum + root.right.sum;
    }

    // Sum[queryL...queryR] inclusive
    public long query(int queryL, int queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, int L, int R, int queryL, int queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        int M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 307
class DynamicSegmentTreeRangeSum {
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeSum(long l, long r) {
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return sum(cur);
    }

    public void add(long index, long value) {
        set(index, get(index) + value);
    }

    private long sum(TreeNode node) {
        return node == null ? 0L : node.sum;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.sum = sum(root.left) + sum(root.right);
    }

    // Sum[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        long M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 239, 2926
class DynamicSegmentTreeRangeMax {
    class TreeNode {
        TreeNode left, right;
        long max = Long.MIN_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMax(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return max(cur);
    }

    private long max(TreeNode node) {
        return node == null ? Long.MIN_VALUE : node.max;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.max = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.max = Math.max(max(root.left), max(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MIN_VALUE;
        if (queryL <= L && R <= queryR) return root.max;
        long M = L + ((R - L) >> 1);
        return Math.max(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class DynamicSegmentTreeRangeMin {
    class TreeNode {
        TreeNode left, right;
        long min = Long.MAX_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMin(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return min(cur);
    }

    private long min(TreeNode node) {
        return node == null ? Long.MAX_VALUE : node.min;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.min = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.min = Math.min(min(root.left), min(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MAX_VALUE;
        if (queryL <= L && R <= queryR) return root.min;
        long M = L + ((R - L) >> 1);
        return Math.min(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class BinaryIndexTree {
    private long[] c;
    private int n;

    // NOTE: index is from 1 to n. (NOT 0 ... n - 1)
    public BinaryIndexTree(int n) {
        this.n = n;
        this.c = new long[n + 1];
    }

    // Add value to position k, k is from 1 to n.
    public void add(int k, long value) {
        while (k <= n) {
            c[k] += value;
            k += (k & (k ^ (k - 1)));
        }
    }

    // k is from 1 to n.
    public long getSum(int k) {
        long sum = 0;
        while (k > 0) {
            sum += c[k];
            k -= (k & (k ^ (k - 1)));
        }
        return sum;
    }
}

class RangeSum {
    BinaryIndexTree tree;
    int start;

    // [low, high] inclusive
    public RangeSum(int low, int high) {
        start = low;
        tree = new BinaryIndexTree(high - low + 1);
    }

    public void add(int index, long value) {
        tree.add(index - start + 1, value);
    }

    public long get(int index) {
        return tree.getSum(index - start + 1) - tree.getSum(index - start);
    }

    public void set(int index, long value) {
        tree.add(index - start + 1, value - get(index));
    }

    // [l, r] inclusive
    public long getSum(int l, int r) {
        return tree.getSum(r - start + 1) - tree.getSum(l - start);
    }
}

class RangeMax {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMax(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MIN_VALUE);
    }

    public RangeMax(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.max(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMax(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MIN_VALUE, resr = Long.MIN_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.max(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.max(t[--r], resr);
        }
        return Math.max(resl, resr);
    }
}

class RangeMin {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMin(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MAX_VALUE);
    }

    public RangeMin(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.min(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMin(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MAX_VALUE, resr = Long.MAX_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.min(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.min(t[--r], resr);
        }
        return Math.min(resl, resr);
    }
}

// Including topological sort.
class GraphIntegerFaster {
    public List<Integer>[] adj;

    public GraphIntegerFaster(int n) {
        adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    // directed edge x -> y
    public void link(int x, int y) {
        adj[x].add(y);
    }

    public List<Integer> getChildren(int x) {
        return adj[x];
    }

    private static final int TEMPORARY = 1;
    private static final int PERMANENT = 2;

    // x -> y means x should be processed before y
    // The input is a directed graph.
    // 1. return null, means there is a cycle inside the graph, or the input is
    // invalid.
    // 2. return List<Node> as the result.
    public List<Integer> topologicalSort() {
        //Map<E, Integer> vst = new HashMap<>();
        int n = adj.length;
        int[] vst = new int[n];
        List<Integer> result = new ArrayList<>();
        for (int x = 0; x < n; x++) {
            if (!topologicalSort(x, vst, result)) {
                return null;
            }
        }
        Collections.reverse(result);
        return result;
    }

    private boolean topologicalSort(int root, int[] vst, List<Integer> result) {
        if (vst[root] == PERMANENT) {
            return true;
        }
        if (vst[root] == TEMPORARY) { // found cycle
            return false;
        }

        vst[root] = TEMPORARY;
        for (int child : getChildren(root)) {
            if (!topologicalSort(child, vst, result)) {
                return false;
            }
        }
        result.add(root);
        vst[root] = PERMANENT;
        return true;
    }
}

class DijkstraLongFaster {
    public static class Edge {
        int to;
        long w;

        public Edge(int to, long w) {
            this.to = to;
            this.w = w;
        }
    }

    public static final long INF = Long.MAX_VALUE / 4;
    public List<Edge>[] adj;

    public DijkstraLongFaster(int n) {
        this.adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    public void link(int x, int y, long w) {
        adj[x].add(new Edge(y, w));
    }

    public long[] shortestPath(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
        q.add(new Edge(src, 0));
        dist[src] = 0;

        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (vst[cur.to]) continue;
            int u = cur.to;
            long w = cur.w;
            vst[u] = true;

            for (Edge e : adj[u]) {
                if (!vst[e.to] && dist[e.to] > w + e.w) {
                    dist[e.to] = w + e.w;
                    q.add(new Edge(e.to, dist[e.to]));
                }
            }
        }
        return dist;
    }

    // NOTE: w of each edge must be the same.
    public long[] bfs(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        Queue<Integer> q = new ArrayDeque<>();
        q.add(src);
        dist[src] = 0;
        vst[src] = true;

        while (!q.isEmpty()) {
            int u = q.poll();
            long w = dist[u];
            for (Edge e : adj[u]) {
                if (!vst[e.to]) {
                    dist[e.to] = w + e.w;
                    vst[e.to] = true;
                    q.add(e.to);
                }
            }
        }
        return dist;
    }
}

class TreapSet<E> {
    private class Node {
        E key;
        int priority, count, total;
        Node left, right, pnt;

        public Node(E key, int priority, Node pnt) {
            this.key = key;
            this.priority = priority;
            this.pnt = pnt;
            this.count = 1;
            this.total = 1;
        }
    }

    private static final Random RANDOM = new Random();
    private final Comparator<? super E> comparator;
    private Node root;

    public TreapSet(Comparator<? super E> comparator) {
        this.comparator = comparator;
    }

    public boolean isEmpty() {
        return root == null;
    }

    public void clear() {
        root = null;
    }

    public int size() {
        return root == null ? 0 : root.total;
    }

    private int leftRank(Node p) {
        return p.left != null ? p.left.total : 0;
    }

    private int rightRank(Node p) {
        return p.right != null ? p.right.total : 0;
    }

    private void rotateLeft(Node x) {
        Node y = x.right;
        if ((x.right = y.left) != null) y.left.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.left) x.pnt.left = y;
        else x.pnt.right = y;
        y.left = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    private void rotateRight(Node x) {
        Node y = x.left;
        if ((x.left = y.right) != null) y.right.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.right) x.pnt.right = y;
        else x.pnt.left = y;
        y.right = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    public void add(E key) {
        if (root == null) {
            root = new Node(key, RANDOM.nextInt(), null);
            return;
        }
        Node x = root, p = null;
        while (x != null) {
            ++((p = x).total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                ++(x.count);
                return;
            }
        }

        x = new Node(key, RANDOM.nextInt(), p);
        if (comparator.compare(key, p.key) < 0) p.left = x;
        else p.right = x;
        while ((p = x.pnt) != null && p.priority < x.priority) {
            if (p.left == x) rotateRight(p);
            else rotateLeft(p);
        }
    }

    public void remove(E key) {
        Node x = root, p = null;
        while (x != null) {
            --(x.total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                if (--(x.count) > 0) return;
                break;
            }
        }
        if (x == null) return;
        while (x.left != null || x.right != null) {
            if (x.left == null || (x.right != null && x.right.priority > x.left.priority)) {
                rotateLeft(x);
            } else {
                rotateRight(x);
            }
        }
        if ((p = x.pnt) != null) {
            if (p.left == x) p.left = null;
            else p.right = null;
        } else {
            root = null;
        }
        // delete x;
    }

    // number of elements smaller than key
    public int lowerCount(E key) {
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                sum += leftRank(x) + x.count;
                x = x.right;
            } else {
                sum += leftRank(x);
                break;
            }
        }
        return sum;
    }

    // number of elements larger than key
    public int higherCount(E key) {
        //return size() - lowerCount(key) - count(key);
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp > 0) x = x.right;
            else if (cmp < 0) {
                sum += rightRank(x) + x.count;
                x = x.left;
            } else {
                sum += rightRank(x);
                break;
            }
        }
        return sum;
    }

    public int index(E key) {
        return lowerCount(key);
    }

    public E get(int index) // index = 0 ... size - 1
    {
        Node p = root;
        ++index;
        while (true) {
            int t = leftRank(p);
            if (index <= t) p = p.left;
            else {
                if ((index -= t + p.count) <= 0) break;
                p = p.right;
            }
        }
        return p.key;
    }

    public int count(E key) {
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                x = x.right;
            } else {
                return x.count;
            }
        }
        return 0;
    }

    public E first() {
        if (root == null) return null;
        Node x = root;
        while (x.left != null) {
            x = x.left;
        }
        return x.key;
    }

    public E last() {
        if (root == null) return null;
        Node x = root;
        while (x.right != null) {
            x = x.right;
        }
        return x.key;
    }

    public boolean contains(E key) {
        return count(key) > 0;
    }

    public E ceiling(E key) {
        int id = lowerCount(key);
        return id >= size() ? null : get(id);
    }

    public E floor(E key) {
        int id = size() - higherCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E lower(E key) {
        int id = lowerCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E higher(E key) {
        int id = size() - higherCount(key);
        return id >= size() ? null : get(id);
    }

    // return the first index whose value >= target
    // if this value doesn't exist, return index = size()
    public int lowerBound(E target) {
        return lowerCount(target);
    }

    // return the first index whose value > target
    // if this value doesn't exist, return index = size()
    public int upperBound(E target) {
        return size() - higherCount(target);
    }

    public List<E> keys() {
        List<E> list = new ArrayList<>();
        inorder(root, list);
        return list;
    }

    private void inorder(Node x, List<E> list) {
        if (x == null) return;
        inorder(x.left, list);
        list.add(x.key);
        inorder(x.right, list);
    }
}

class ArraySum {
    long[] sum;
    int n;

    // nums index starts from 0 to nums.length - 1;
    public ArraySum(int[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    public ArraySum(long[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    // [l, r], index starts from 0
    public long getSum(int l, int r) {
        // error handling
        if (l > r || !(l >= 0 && l < n && r >= 0 && r < n)) return 0L;
        return sum[r + 1] - sum[l];
    }
}

class TwoDArraySum {
    int[][] sum;
    int m, n;

    // nums index starts from 0
    public TwoDArraySum(final int[][] nums) {
        m = nums.length;
        n = nums[0].length;
        sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + nums[i - 1][j - 1];
            }
        }
    }

    // [(x1, y1), (x2, y2)], index starts from 0
    // x1 <= x2 and y1 <= y2
    public int getSum(int x1, int y1, int x2, int y2) {
        if (!(x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && x2 >= 0 && x2 < m && y2 >= 0 && y2 < n) || x1 > x2 || y1 > y2)
            return 0;
        return sum[x2 + 1][y2 + 1] - sum[x2 + 1][y1] - sum[x1][y2 + 1] + sum[x1][y1];
    }
}

class ArrayUtils {
    static void fill(int[] array, int defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(int[][] array, int defaultValue) {
        for (int[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(int[][][] array, int defaultValue) {
        for (int[][] a2 : array) {
            for (int[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(int[][][][] array, int defaultValue) {
        for (int[][][] a3 : array) {
            for (int[][] a2 : a3) {
                for (int[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(int[][][][][] array, int defaultValue) {
        for (int[][][][] a4 : array) {
            for (int[][][] a3 : a4) {
                for (int[][] a2 : a3) {
                    for (int[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(int[][][][][][] array, int defaultValue) {
        for (int[][][][][] a5 : array) {
            for (int[][][][] a4 : a5) {
                for (int[][][] a3 : a4) {
                    for (int[][] a2 : a3) {
                        for (int[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }

    static void fill(long[] array, long defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(long[][] array, long defaultValue) {
        for (long[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(long[][][] array, long defaultValue) {
        for (long[][] a2 : array) {
            for (long[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(long[][][][] array, long defaultValue) {
        for (long[][][] a3 : array) {
            for (long[][] a2 : a3) {
                for (long[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(long[][][][][] array, long defaultValue) {
        for (long[][][][] a4 : array) {
            for (long[][][] a3 : a4) {
                for (long[][] a2 : a3) {
                    for (long[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(long[][][][][][] array, long defaultValue) {
        for (long[][][][][] a5 : array) {
            for (long[][][][] a4 : a5) {
                for (long[][][] a3 : a4) {
                    for (long[][] a2 : a3) {
                        for (long[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }
}

class CharacterUtils {
    static boolean[] vowel = new boolean[128];

    static {
        vowel['a'] = vowel['e'] = vowel['i'] = vowel['o'] = vowel['u'] = true;
        vowel['A'] = vowel['E'] = vowel['I'] = vowel['O'] = vowel['U'] = true;
    }

    static boolean isVowel(char ch) {
        return vowel[ch];
    }

    static boolean isLetter(char ch) {
        return ((ch - 'a') >= 0 && (ch - 'a') < 26) ||
                ((ch - 'A') >= 0 && (ch - 'A') < 26);
    }

    static boolean isLowerCase(char ch) {
        return (ch - 'a') >= 0 && (ch - 'a') < 26;
    }

    static boolean isUpperCase(char ch) {
        return (ch - 'A') >= 0 && (ch - 'A') < 26;
    }

    static boolean isDigit(char ch) {
        return (ch - '0') >= 0 && (ch - '0') <= 9;
    }
}

class DoubleUtils {
    private static final double EPS = 1e-8;

    public static int compare(double a, double b) {
        if (a - b > EPS) return 1;
        else if (a - b < -EPS) return -1;
        else return 0;
    }

    public static boolean isInteger(double a) {
        return compare(floor(a), a) == 0;
    }

    public static double floor(double a) {
        return Math.floor(a + EPS);
    }

    public static double ceil(double a) {
        return Math.ceil(a - EPS);
    }
}

class MatrixUtils {
    static final long MOD = 1_000_000_007L;

    // matrix[n][n], matrix[i][i] = 1
    static long[][] genIdentityMatrix(int n) {
        long[][] matrix = new long[n][n];
        for (int i = 0; i < n; i++) matrix[i][i] = 1;
        return matrix;
    }

    static long[][] multiply(long[][] a, long[][] b, long MOD) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]) % MOD;
                }
            }
        }
        return res;
    }

    static long[][] multiply(long[][] a, long[][] b) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]);
                }
            }
        }
        return res;
    }

    // a^b % MOD
    static long[][] powMod(long[][] a, long b, long MOD) {
        int n = a.length;
        long[][] res = genIdentityMatrix(n);
        while (b > 0) {
            if ((b & 1) != 0) res = multiply(res, a, MOD);
            a = multiply(a, a, MOD);
            b >>= 1;
        }
        return res;
    }

    static void print(long[][] matrix) {
        for (int i = 0; i < matrix.length; i++) {
            System.out.println(Arrays.toString(matrix[i]));
        }
    }
}

class IntegerUtils {
    static long[] power10 = new long[19]; // 10^i

    static {
        power10[0] = 1L;
        for (int i = 1; i < power10.length; i++) {
            power10[i] = power10[i - 1] * 10;
        }
    }

    // swap index i and j of integer (long) num. i == 0 means the lowest position.
    static long swapDigit(long num, int i, int j) {
        if (i == j) return num;
        long di = num / power10[i] % 10L;
        long dj = num / power10[j] % 10L;
        return num - di * power10[i] - dj * power10[j] + dj * power10[i] + di * power10[j];
    }
}

class StringUtils {
    // This function is deprecated, please hash(int l, int r) in class StableStringHash or StringHash
    // rolling hash of substrings of 's' with length == k
    // long[pos] = hash(s.substring(pos, pos + k))
    public static long[] rollingHash(String s, int k) {
        long[] ans = new long[s.length() - k + 1];
        int seed1 = 31;
        int seed2 = 131;
        int h1 = 0, h2 = 0, power1 = 1, power2 = 1;
        for (int i = 0; i < k; i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);

            power1 *= seed1;
            power2 *= seed2;
        }

        ans[0] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        for (int i = k; i < s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i) - power1 * s.charAt(i - k);
            h2 = h2 * seed2 + s.charAt(i) - power2 * s.charAt(i - k);
            ans[i - k + 1] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        }

        return ans;
    }

    public static int[] kmpNext(String s) {
        int n = s.length();
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s.charAt(i) != s.charAt(k)) k = next[k - 1];
            if (s.charAt(i) == s.charAt(k)) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(String s, String p) {
        int[] next = kmpNext(p);
        int n = s.length();
        int m = p.length();
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p.charAt(j) != s.charAt(i)) {
                j = next[j - 1];
            }
            if (p.charAt(j) == s.charAt(i)) j++;
            if (j == m) return true;
        }
        return false;
    }

    public static int[] kmpNext(int[] s) {
        int n = s.length;
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s[i] != s[k]) k = next[k - 1];
            if (s[i] == s[k]) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(int[] s, int[] p) {
        int[] next = kmpNext(p);
        int n = s.length;
        int m = p.length;
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p[j] != s[i]) {
                j = next[j - 1];
            }
            if (p[j] == s[i]) j++;
            if (j == m) return true;
        }
        return false;
    }

    // Z[i] = longest length of common prefix of str[0 ... n - 1] and str[i ... n - 1]
    // Tested by LC2223, LC459
    public static int[] zFunction(String str) {
        int n = str.length();
        int[] Z = new int[n];
        // [L,R] makes a window which matches with prefix of s
        int L = 0, R = 0;
        Z[0] = n;
        for (int i = 1; i < n; ++i) {
            if (i > R) {
                L = R = i;
                while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                Z[i] = R - L;
                R--;
            } else {
                int k = i - L;
                if (Z[k] < R - i + 1) {
                    Z[i] = Z[k];
                } else {
                    L = i;
                    while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                    Z[i] = R - L;
                    R--;
                }
            }
        }
        return Z;
    }
}

// Better to use this when length of string >= 2^11
class StringHash {
    static class SingleStringHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleStringHash(String s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length();
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s.charAt(i - 1)) % MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleStringHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L;

    public StringHash(String s) {
        hash1 = new SingleStringHash(s, SEED1, MOD);
        hash2 = new SingleStringHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(String s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length(); i++) {
            h1 = (h1 * SEED1 + s.charAt(i)) % MOD;
            h2 = (h2 * SEED2 + s.charAt(i)) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(char[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class IntegerArrayHash {
    static class SingleIntegerArrayHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleIntegerArrayHash(int[] s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length;
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s[i - 1]) % MOD;
                if (h[i] < 0) h[i] += MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleIntegerArrayHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L; // or 1_000_000_123L

    public IntegerArrayHash(int[] s) {
        hash1 = new SingleIntegerArrayHash(s, SEED1, MOD);
        hash2 = new SingleIntegerArrayHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(int[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(List<Integer> s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.size(); i++) {
            h1 = (h1 * SEED1 + s.get(i)) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s.get(i)) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class RMQ { // NOTE!!! query return index, not value
    // tested by LC 1438,239
    final long[] a; // input data array copy
    int[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQ(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQ(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new int[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = i;
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = a[d[j - 1][i]] >= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                } else {
                    d[j][i] = a[d[j - 1][i]] <= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                }
    }

    // i <= j, and index starts from 0.
    public int query(int i, int j) { // NOTE!!! return index, not value
        int k = log2[j - i + 1];
        if (useMax) return a[d[k][i]] >= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
        else return a[d[k][i]] <= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
    }
}

class RMQValue { // NOTE!!! query return value, not index
    final long[] a; // input data array copy
    long[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQValue(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQValue(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new long[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = a[i];
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = Math.max(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                } else {
                    d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                }
    }

    // i <= j, and index starts from 0.
    public long query(int i, int j) {
        int k = log2[j - i + 1];
        if (useMax) return Math.max(d[k][i], d[k][j - (1 << k) + 1]);
        else return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }
}

// Tested by 2827
// Similar: 1012, 2376, 902, 2719, 2801, 357, 1215, 1397
class DigitDP {
    static final boolean ENABLE_DEBUG_MODE = false; // TODO: set it to true if you want to print more debug info
    static final long UNSET = -1;
    // dp[isStart][hasLimit][pos] | [odd][even][r]
    // (isStart, hasLimit, pos) is generic, (odd, even, r) is use case specific
    long[][][][][][] dp;
    int K;

    public long digitDP(long num, int k) {
        String numString = String.valueOf(num); // TODO
        this.dp = new long[2][2][numString.length()][numString.length() + 1][numString.length() + 1][k];
        this.K = k;

        if (ENABLE_DEBUG_MODE) System.out.println(""num = "" + numString);
        ArrayUtils.fill(dp, UNSET);
        long ans = dfs(new StringBuilder(), numString, 1, 1, 0, 0, 0, 0);
        if (ENABLE_DEBUG_MODE) System.out.println(""---------------------\n"");
        return ans;
    }

    long dfs(StringBuilder curResult, String s, int isStart, int hasLimit, int pos, int odd, int even, int r) {
        if (pos == s.length()) {
            if (isStart == 1) return 0; // NOTE: special check for num == 0. TODO
            if (r == 0 && odd == even) { // TODO
                if (ENABLE_DEBUG_MODE) System.out.println(""result = "" + curResult);
                return 1;
            } else {
                return 0;
            }
        }
        if (dp[isStart][hasLimit][pos][odd][even][r] != UNSET) return dp[isStart][hasLimit][pos][odd][even][r];

        int start = 0;
        int end = (hasLimit == 1) ? s.charAt(pos) - '0' : 9; // TODO: check if it is binary string or not

        long ans = 0;
        for (int digit = start; digit <= end; digit++) {
            if (isStart == 1 && digit == 0) { // NOTE: handle leading zeros
                // [0, 999..9]
                // [0， 10^(len(s) - pos - 1) - 1]
                ans += dfs(new StringBuilder(), s, 1, 0, pos + 1, 0, 0, 0);
                continue;
            }
            int newHasLimit = (hasLimit == 1 && digit == s.charAt(pos) - '0') ? 1 : 0;

            int newOdd = odd + (digit % 2); // TODO
            int newEven = even + (digit % 2 == 0 ? 1 : 0); // TODO
            int newR = (isStart == 1 ? digit % this.K : (r * 10 + digit) % this.K); // TODO;

            if (ENABLE_DEBUG_MODE) curResult.append(digit);
            ans += dfs(curResult, s, 0, newHasLimit, pos + 1, newOdd, newEven, newR);
            if (ENABLE_DEBUG_MODE) curResult.deleteCharAt(curResult.length() - 1);

        }
        return dp[isStart][hasLimit][pos][odd][even][r] = ans;
    }
}

class Printer {
    static boolean ENABLE_LOCAL_PRINT = false;

    static void println(String x) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.println(x);
    }

    static void printf(String format, Object... args) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.printf(format, args);
    }
}


public class Solution {
    private static final int INF = 1_000_000_001;
    private static final long MOD = 1_000_000_007L;

    private static final int UNSET = -131;
    // 4 neighbors
    private static final int[] DX = {-1, 0, 1, 0}; // up, right, down, left
    private static final int[] DY = {0, 1, 0, -1};

    // 8 neighbors
    //    private static final int[] DX = {-1, -1, 0, 1, 1,  1, 0,  -1};
    //    private static final int[] DY = {0,   1, 1, 1, 0, -1, -1, -1};

    // knight
    //    private static final int[] DX = {-2, -2, -1, 1, 2, 2, 1, -1};
    //    private static final int[] DY = {-1, 1, 2, 2, 1, -1, -2, -2};

    boolean check(int[] next, int limit) {
        int n = next.length;
        for (int i = 0; i < n; i++) {
            int l1 = next[i] - i + 1;
            int l2 = (i + limit < n ? next[i + limit] - (i + limit) + 1 : -1);
            if (l1 >= limit && l2 >= limit) return true;
        }
        return false;
    }

    public int maxIncreasingSubarrays(List<Integer> nums) {
        int n = nums.size();
        int[] next = new int[n];

        for (int i = 0; i < n; ) {
            int j = i + 1;
            while (j < n && nums.get(j) > nums.get(j - 1)) j++;

            for (int k = i; k < j; k++) {
                next[k] = j - 1;
            }
            i = j;
        }

        int ans = 0;
        int low = 1;
        int high = n;
        while (low <= high) {
            int mid = (low + high) / 2;
            if (check(next, mid)) {
                ans = mid;
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        return ans;
    }

    public boolean hasIncreasingSubarrays(List<Integer> nums, int KK) {
        int n = nums.size();
        int[] next = new int[n];

        for (int i = 0; i < n; ) {
            int j = i + 1;
            while (j < n && nums.get(j) > nums.get(j - 1)) j++;

            for (int k = i; k < j; k++) {
                next[k] = j - 1;
            }
            i = j;
        }

        return check(next, KK);
    }


    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        Printer.ENABLE_LOCAL_PRINT = true;
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */





        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        System.out.println((System.currentTimeMillis() - startTime) + ""ms"");
    }
}",1448189174
IphoneX,hahahiehie,169,3619,java,"import java.util.*;

class Utils {
    public static int log2(long n) {
        return 63 - Long.numberOfLeadingZeros(n);
    }

    // nums = ""aaabaaaba"" odd d[1] return [1, 2, 1, 4, 1, 2, 2]
    // d[0] for even, d[1] for odd
    public static int[][] manacher(String s) {
        int n = s.length();
        int[] d1 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; ++i) {
            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s.charAt(i - k) == s.charAt(i + k)) k++;
            d1[i] = k;
            if (i + k - 1 > r) {
                l = i - k + 1;
                r = i + k - 1;
            }
        }

        int[] d0 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : Math.min(d0[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s.charAt(i - k - 1) == s.charAt(i + k)) {
                k++;
            }
            d0[i] = k;
            if (i + k - 1 > r) {
                l = i - k;
                r = i + k - 1;
            }
        }
        return new int[][]{d0, d1};
    }

    // generate primes that is <= n
    public static int[] genPrimes(int n) {
        if (n <= 1) return new int[0];
        boolean[] isComp = new boolean[n + 1];
        int len = 0;
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                len++;
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                }
            }
        }
        int[] ans = new int[len];
        for (int i = 2, j = 0; i <= n; i++) {
            if (!isComp[i]) {
                ans[j++] = i;
            }
        }
        return ans;
    }

    // int[0] = primeFactor, int[1] = count of that primeFactor
    // NOTE: factors[0] and factors[1] are empty list.
    public static List<int[]>[] genPrimeFactors(int n) {
        List<int[]>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            factors[i] = new ArrayList<>();
        }
        boolean[] isComp = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                factors[i].add(new int[]{i, 1});
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                    int t = j, count = 0;
                    while (t % i == 0) {
                        count++;
                        t /= i;
                    }
                    factors[j].add(new int[]{i, count});
                }
            }
        }
        return factors;
    }

    // generate factors (not prime factors), factors[0] is empty list.
    public static List<Integer>[] genFactors(int n) {
        List<Integer>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) factors[i] = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j += i) {
                factors[j].add(i);
            }
        }
        return factors;
    }

    public static int lowerBound(int[] a, int target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(int[] a, int target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(long[] a, long target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(long[] a, long target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static long or(int x, int y) {
        return ((long) x << 32) | ((long) y << 32 >>> 32);
    }

    // k = 0...nums.length - 1
    // After calling this function, nums[k] is the k-th number.
    public static int kthNumber(int[] nums, int k) {
        return kthNumberHelper(nums, k, 0, nums.length - 1);
    }

    // end is inclusive (0 to nums.length - 1)
    private static int kthNumberHelper(int[] nums, int K, int start, int end) {
        if (start == end) return nums[start];
        int i = partition(nums, start, end);
        return K <= i ? kthNumberHelper(nums, K, start, i) : kthNumberHelper(nums, K, i + 1, end);
    }

    // end is inclusive (0 to nums.length - 1)
    public static int partition(int[] nums, int start, int end) {
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && nums[i] < pivot) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && pivot < nums[j]) j--;
            if (i < j) nums[i++] = nums[j];
        }

        // pos is the final position for pivot.
        nums[i] = pivot;
        return i;
    }

    public static void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    // partition nums into 3 parts [smaller than pivot, equal to pivot, larger than pivot]
    public static void partition3(int[] nums, int pivot) {
        int n = nums.length;
        int l = 0, r = n - 1;
        for (int i = 0; i <= r; i++) {
            if (nums[i] < pivot) {
                swap(nums, l++, i);
            } else if (nums[i] > pivot) {
                swap(nums, r--, i--);
            }
        }
    }

    // end is inclusive
    public static void reverse(int[] nums, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    }

    // Return false if next permutation is not available. (nums is not changed for this case)
    public static boolean nextPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] >= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] > nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // Return false if previous permutation is not available. (nums is not changed for this case)
    public static boolean prevPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] <= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] < nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }


    // a, b could be negative
    // remainder >= 0
    // return [a / b, a % b]
    public static int[] divMod(int a, int b) {
        int r = a % b;
        int c = a / b;
        if (r < 0) {
            r += Math.abs(b);
            c++;
        }
        return new int[]{c, r};
    }

    public static List<Integer> negativeBase(int n, int base) {
        List<Integer> digits = new ArrayList<>();
        if (n == 0) {
            digits.add(0);
            return digits;
        }
        while (n != 0) {
            // t[0] = n / base
            // t[1] = n % base;
            int[] t = divMod(n, base);
            digits.add(t[1]);
            n = t[0];
        }
        Collections.reverse(digits);
        return digits;
    }

    // (a ^ b) % MOD
    public static long powMod(long a, long b, long MOD) {
        long res = 1L;
        a %= MOD; // In case a * a is overflow
        while (b > 0) {
            if ((b & 1) != 0) res = (res * a) % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    public static long[][] genCombination(int n) {
        long[][] C = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        return C;
    }

    public static long[][] genPermutation(int n) {
        long[][] P = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
        return P;
    }

    public static long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }

    public static int[] preprocessLog2(int n) { // from log2(0) .... log2(n) inclusive
        int[] lg = new int[n + 1];
        for (int k = 0, i = 1; i <= n; lg[i++] = k - 1) {
            while ((1 << k) <= i) {
                k++;
            }
        }
        return lg;
    }

    public static long max(long[] nums) {
        long ret = Long.MIN_VALUE;
        for (long v : nums) ret = Math.max(ret, v);
        return ret;
    }

    public static int max(int[] nums) {
        int ret = Integer.MIN_VALUE;
        for (int v : nums) ret = Math.max(ret, v);
        return ret;
    }
}

// Tested by leetcode 1163
class SuffixArray {
    int[] s;
    int[] SA; // SA[i] => index of the i-th ranked suffix
    int[] rank; // rank[i] => the rank of i-th suffix, SA[rank[i]] == i
    int[] height; // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).

    private int[][] d;
    private int n;
    private int[] lg;

    private int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    private static int[] stringToIntArray(String str) {
        int[] nums = new int[str.length()];
        for (int i = 0; i < str.length(); i++) nums[i] = str.charAt(i);
        return nums;
    }

    public SuffixArray(String str) {
        this(str, true);
    }

    public SuffixArray(String str, boolean toBuildRMQ) {
        this(stringToIntArray(str), toBuildRMQ);
    }

    public SuffixArray(int[] nums) {
        this(nums, true);
    }

    public SuffixArray(int[] nums, boolean toBuildRMQ) {
        this.s = nums;
        this.n = nums.length;
        this.SA = new int[n];
        this.rank = new int[n];
        suffixSort(s);
        if (toBuildRMQ) {
            this.height = new int[n];
            this.d = new int[log2(n) + 1][n];
            this.lg = new int[n + 1];
            buildHeight();
            buildRMQ();
        }
    }

    // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).
    // ?? s[n] = 0 or s[n] = -INF.
    private void buildHeight() {
        int i, j, h;
        height[0] = 0;
        for (i = 0; i < n; i++)
            rank[SA[i]] = i;
        for (h = i = 0; i < n; i++)
            if (rank[i] > 0) {
                j = SA[rank[i] - 1];
                while (i + h < n && j + h < n && s[i + h] == s[j + h]) ++h;
                height[rank[i]] = h;
                if (h > 0) --h;
            }
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    private void buildRMQ() {
        int i, j, k;
        for (i = 0; i < n; i++)
            d[0][i] = height[i];
        for (j = 1; (1 << j) <= n; j++)
            for (i = 0; i + (1 << j) <= n; i++)
                d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
        for (lg[0] = k = 0, i = 1; i <= n; lg[i++] = k - 1)
            while ((1 << k) <= i) k++;
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    public int LCP(int i, int j) {
        if (i == j) return n - SA[i];
        if (i > j) {
            int t = i;
            i = j;
            j = t;
        }
        int k = lg[j - (++i) + 1];
        return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }

    // LCPIndex(i, j) = LCP(s[i], s[j])
    public int LCPIndex(int i, int j) {
        return LCP(rank[i], rank[j]);
    }

    private void sortIndex(int[] nums, int start, int end) {
        if (start >= end) return;
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && s[nums[i]] < s[pivot]) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && s[pivot] < s[nums[j]]) j--;
            if (i < j) nums[i++] = nums[j];
        }
        nums[i] = pivot; // index i is the final position for pivot.
        sortIndex(nums, start, i - 1);
        sortIndex(nums, i + 1, end);
    }

    private void suffixSort(int[] s) {
        int[] count = new int[n], t;
        int[] nSA = new int[n];
        int[] nRank = new int[n];
//        Integer[] tempArray = new Integer[n];
//        for (int x = 0; x < n; x++) tempArray[x] = x;
//        Arrays.sort(tempArray, (a, b) -> Integer.compare(s[a], s[b]));
//        for (int x = 0; x < n; x++) SA[x] = tempArray[x];
        int i, k;
        int minV = s[0], maxV = s[0];
        for (i = 1; i < n; i++) {
            minV = Math.min(minV, s[i]);
            maxV = Math.max(maxV, s[i]);
        }
        if ((long) maxV - minV + 1 <= (long) n) { // radix sort if alphabet size is small
            for (i = 0; i < n; i++) count[s[i] - minV]++;
            for (i = minV + 1; i <= maxV; i++) count[i - minV] += count[i - minV - 1];
            for (i = n - 1; i >= 0; i--) SA[--count[s[i] - minV]] = i;
        } else {
            for (i = 0; i < n; i++) SA[i] = i;
            sortIndex(SA, 0, n - 1);
        }
        for (rank[SA[0]] = 0, i = 1; i < n; i++) {
            rank[SA[i]] = (s[SA[i]] != s[SA[i - 1]]) ? rank[SA[i - 1]] + 1 : rank[SA[i - 1]];
        }
        for (k = 1; k < n && rank[SA[n - 1]] < n - 1; k <<= 1) {
            for (i = 0; i < n; i++) count[rank[SA[i]]] = i + 1;
            for (i = n - 1; i >= 0; i--) if (SA[i] >= k) nSA[--count[rank[SA[i] - k]]] = SA[i] - k;
            for (i = n - k; i < n; i++) nSA[--count[rank[i]]] = i;
            t = SA;
            SA = nSA;
            nSA = t;
            for (nRank[SA[0]] = 0, i = 1; i < n; i++) {
                nRank[SA[i]] = (SA[i] + k >= n || SA[i - 1] + k >= n || rank[SA[i]] != rank[SA[i - 1]] || rank[SA[i] + k] != rank[SA[i - 1] + k]) ? nRank[SA[i - 1]] + 1 : nRank[SA[i - 1]];
            }
            t = rank;
            rank = nRank;
            nRank = t;
        }
    }
}

class Combination {
    long[] factorial;
    long[] inverseFactorial;
    long MOD;

    // O(maxSize) for preprocessing
    // MOD must be prime
    public Combination(int maxSize, long MOD) {
        factorial = new long[maxSize + 1];
        inverseFactorial = new long[maxSize + 1];
        factorial[0] = 1;
        inverseFactorial[0] = 1;
        this.MOD = MOD;
        for (int i = 1; i <= maxSize; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
            inverseFactorial[i] = inverse(factorial[i]);
        }
    }

    // x, y are long[1]
    // ax + by = gcd(a, b)
    private long extGcd(long a, long b, long[] x, long[] y) {
        if (b == 0) {
            x[0] = 1;
            y[0] = 0;
            return a;
        } else {
            long r = extGcd(b, a % b, y, x);
            y[0] -= x[0] * (a / b);
            return r;
        }
    }

    // (a * x) % MOD = 1
    // x is the inverse element
    public long inverse(long a) {
        long[] x = new long[1], y = new long[1];
        extGcd(a, MOD, x, y);
        return (x[0] % MOD + MOD) % MOD;
    }

    // m >= n
    // O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        else if (m == n) return factorial[m];
            //return factorial[m] * inverse(factorial[m - n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD;
    }

    // m >= n
    // O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
            //return factorial[m] * inverse(factorial[m - n]) % MOD * inverse(factorial[n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD * inverseFactorial[n] % MOD;
    }
}

class CombinationNoMod {

    long[][] C;
    long[][] P;

    public CombinationNoMod(int maxSize) {
        C = new long[maxSize + 1][maxSize + 1];
        P = new long[maxSize + 1][maxSize + 1];
        int m = C.length;
        int n = C[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
    }

    // m >= n. O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        return P[m][n];
    }

    // m >= n. O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
        return C[m][n];
    }
}

class Fraction {
    long n, d; // n / d (d != 0)

    public Fraction(long n, long d) {
        if (d == 0) {
            this.n = Long.MAX_VALUE;
            this.d = 1;
            return;
        }
        long g = gcd(Math.abs(n), Math.abs(d));
        this.n = n / g;
        this.d = d / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    public void add(Fraction other) {
        long numerator = this.n * other.d + this.d * other.n;
        long denominator = this.d * other.d;
        long g = gcd(Math.abs(numerator), Math.abs(denominator));
        this.n = numerator / g;
        this.d = denominator / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    @Override
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof Fraction) {
            Fraction anotherObject = (Fraction) anObject;
            return n == anotherObject.n && d == anotherObject.d;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return (int) (n * 31 + d);
    }

    private long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }
}

class UnionFind {
    int[] parent;
    int[] sz;

    // from 0 ... n - 1
    public UnionFind(int n) {
        parent = new int[n];
        sz = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public void clear() {
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public int find(int x) {
        //return parent[x] == x ? x : (parent[x] = find(parent[x]));
        if (parent[x] == x) return x;
        int px = x;
        while (px != parent[px]) px = parent[px];
        while (x != px) {
            int next = parent[x];
            parent[x] = px;
            x = next;
        }
        return px;
    }

    // px is the final parent
    public boolean union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return false;
        parent[py] = px;
        sz[px] += sz[py];
        return true;
    }

    public int size(int x) {
        return sz[find(x)];
    }

    public UnionFind clone() {
        UnionFind cloned = new UnionFind(parent.length);
        for (int i = 0; i < parent.length; i++) {
            cloned.parent[i] = parent[i];
            cloned.sz[i] = sz[i];
        }
        return cloned;
    }
}

class Trie {
    static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        boolean isWord = false;
        long count = 0L;
    }

    TrieNode root = new TrieNode();

    public void add(String word) {
        add(word, 1L);
    }

    public void remove(String word) {
        add(word, -1L);
    }

    private void add(String word, long count) {
        TrieNode cur = root;
        cur.count += count;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) cur.next[c] = new TrieNode();
            cur = cur.next[c];
            cur.count += count;
        }
        cur.isWord = true;
    }

    public boolean contains(String word) {
        TrieNode cur = root;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null || cur.next[c].count <= 0L) return false;
            cur = cur.next[c];
            //if (cur.isWord) return true;
        }
        return cur.isWord;
    }
}

// Tested by Leetcode 1707 and Leetcode 1803
class TrieBinary {
    static class TrieNode {
        TrieNode[] next = new TrieNode[2];
        long count;
    }

    private TrieNode root;
    private int numOfBits;

    public TrieBinary(int numOfBits) { // normally 31 for int and 63 for long
        this.numOfBits = numOfBits;
        this.root = new TrieNode();
    }

    public void add(long v) {
        add(v, 1L);
    }

    public void remove(long v) { // Tested by Leetcode 1938
        add(v, -1L);
    }

    public void add(long v, long count) {
        TrieNode cur = root;
        root.count += count;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null) cur.next[b] = new TrieNode();
            cur = cur.next[b];
            cur.count += count;
        }
    }

    // Tested by Leetcode 1707
    public long xorMax(long v) {
        TrieNode cur = root;
        long key = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[1 - b] != null && cur.next[1 - b].count > 0) {
                cur = cur.next[1 - b];
                key |= (1L - b) << i;
            } else {
                cur = cur.next[b];
                key |= (long) b << i;
            }
        }
        return key ^ v;
    }

    public boolean contains(long v) {
        TrieNode cur = root;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null || cur.next[b].count <= 0) return false;
            cur = cur.next[b];
        }
        return true;
    }

    // Tested by Leetcode 1803
    // count(x ^ v <= limit)
    public long xorLessOrEqualCount(long v, long limit) {
        if (limit < 0) return 0;
        TrieNode cur = root;
        long ans = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int bitLimit = ((limit >>> i) & 1) == 0 ? 0 : 1;
            int bitV = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (bitLimit == 1) {
                ans += (cur.next[bitV] != null ? cur.next[bitV].count : 0);
            }
            cur = cur.next[bitV ^ bitLimit];
            if (cur == null) break;
            if (i == 0) ans += cur.count;
        }
        return ans;
    }
}

// Lazy execution example is in https://leetcode.com/submissions/detail/1034182539/
// Refer to AlgorithmCompilation.java

// [Template] Classic Segment Tree (Range Sum), used for Template
class ClassicSegmentTree { // For Range Sum
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final int L, R;

    public ClassicSegmentTree(int[] input) {
        L = 0;
        R = input.length - 1;
        root = new TreeNode();
        build(root, L, R, input);
    }

    private void build(TreeNode root, int l, int r, int[] input) {
        if (l == r) {
            root.sum = input[l];
            return;
        }
        int m = (l + r) >> 1;
        root.left = new TreeNode();
        root.right = new TreeNode();
        build(root.left, l, m, input);
        build(root.right, m + 1, r, input);
        root.sum = root.left.sum + root.right.sum;
    }

    public void set(int index, int value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, int L, int R, int index, int value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        int M = L + ((R - L) >> 1);
        if (index <= M) {
            set(root.left, L, M, index, value);
        } else {
            set(root.right, M + 1, R, index, value);
        }
        root.sum = root.left.sum + root.right.sum;
    }

    // Sum[queryL...queryR] inclusive
    public long query(int queryL, int queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, int L, int R, int queryL, int queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        int M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 307
class DynamicSegmentTreeRangeSum {
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeSum(long l, long r) {
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return sum(cur);
    }

    public void add(long index, long value) {
        set(index, get(index) + value);
    }

    private long sum(TreeNode node) {
        return node == null ? 0L : node.sum;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.sum = sum(root.left) + sum(root.right);
    }

    // Sum[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        long M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 239, 2926
class DynamicSegmentTreeRangeMax {
    class TreeNode {
        TreeNode left, right;
        long max = Long.MIN_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMax(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return max(cur);
    }

    private long max(TreeNode node) {
        return node == null ? Long.MIN_VALUE : node.max;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.max = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.max = Math.max(max(root.left), max(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MIN_VALUE;
        if (queryL <= L && R <= queryR) return root.max;
        long M = L + ((R - L) >> 1);
        return Math.max(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class DynamicSegmentTreeRangeMin {
    class TreeNode {
        TreeNode left, right;
        long min = Long.MAX_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMin(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return min(cur);
    }

    private long min(TreeNode node) {
        return node == null ? Long.MAX_VALUE : node.min;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.min = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.min = Math.min(min(root.left), min(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MAX_VALUE;
        if (queryL <= L && R <= queryR) return root.min;
        long M = L + ((R - L) >> 1);
        return Math.min(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class BinaryIndexTree {
    private long[] c;
    private int n;

    // NOTE: index is from 1 to n. (NOT 0 ... n - 1)
    public BinaryIndexTree(int n) {
        this.n = n;
        this.c = new long[n + 1];
    }

    // Add value to position k, k is from 1 to n.
    public void add(int k, long value) {
        while (k <= n) {
            c[k] += value;
            k += (k & (k ^ (k - 1)));
        }
    }

    // k is from 1 to n.
    public long getSum(int k) {
        long sum = 0;
        while (k > 0) {
            sum += c[k];
            k -= (k & (k ^ (k - 1)));
        }
        return sum;
    }
}

class RangeSum {
    BinaryIndexTree tree;
    int start;

    // [low, high] inclusive
    public RangeSum(int low, int high) {
        start = low;
        tree = new BinaryIndexTree(high - low + 1);
    }

    public void add(int index, long value) {
        tree.add(index - start + 1, value);
    }

    public long get(int index) {
        return tree.getSum(index - start + 1) - tree.getSum(index - start);
    }

    public void set(int index, long value) {
        tree.add(index - start + 1, value - get(index));
    }

    // [l, r] inclusive
    public long getSum(int l, int r) {
        return tree.getSum(r - start + 1) - tree.getSum(l - start);
    }
}

class RangeMax {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMax(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MIN_VALUE);
    }

    public RangeMax(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.max(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMax(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MIN_VALUE, resr = Long.MIN_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.max(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.max(t[--r], resr);
        }
        return Math.max(resl, resr);
    }
}

class RangeMin {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMin(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MAX_VALUE);
    }

    public RangeMin(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.min(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMin(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MAX_VALUE, resr = Long.MAX_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.min(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.min(t[--r], resr);
        }
        return Math.min(resl, resr);
    }
}

// Including topological sort.
class GraphIntegerFaster {
    public List<Integer>[] adj;

    public GraphIntegerFaster(int n) {
        adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    // directed edge x -> y
    public void link(int x, int y) {
        adj[x].add(y);
    }

    public List<Integer> getChildren(int x) {
        return adj[x];
    }

    private static final int TEMPORARY = 1;
    private static final int PERMANENT = 2;

    // x -> y means x should be processed before y
    // The input is a directed graph.
    // 1. return null, means there is a cycle inside the graph, or the input is
    // invalid.
    // 2. return List<Node> as the result.
    public List<Integer> topologicalSort() {
        //Map<E, Integer> vst = new HashMap<>();
        int n = adj.length;
        int[] vst = new int[n];
        List<Integer> result = new ArrayList<>();
        for (int x = 0; x < n; x++) {
            if (!topologicalSort(x, vst, result)) {
                return null;
            }
        }
        Collections.reverse(result);
        return result;
    }

    private boolean topologicalSort(int root, int[] vst, List<Integer> result) {
        if (vst[root] == PERMANENT) {
            return true;
        }
        if (vst[root] == TEMPORARY) { // found cycle
            return false;
        }

        vst[root] = TEMPORARY;
        for (int child : getChildren(root)) {
            if (!topologicalSort(child, vst, result)) {
                return false;
            }
        }
        result.add(root);
        vst[root] = PERMANENT;
        return true;
    }
}

class DijkstraLongFaster {
    public static class Edge {
        int to;
        long w;

        public Edge(int to, long w) {
            this.to = to;
            this.w = w;
        }
    }

    public static final long INF = Long.MAX_VALUE / 4;
    public List<Edge>[] adj;

    public DijkstraLongFaster(int n) {
        this.adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    public void link(int x, int y, long w) {
        adj[x].add(new Edge(y, w));
    }

    public long[] shortestPath(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
        q.add(new Edge(src, 0));
        dist[src] = 0;

        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (vst[cur.to]) continue;
            int u = cur.to;
            long w = cur.w;
            vst[u] = true;

            for (Edge e : adj[u]) {
                if (!vst[e.to] && dist[e.to] > w + e.w) {
                    dist[e.to] = w + e.w;
                    q.add(new Edge(e.to, dist[e.to]));
                }
            }
        }
        return dist;
    }

    // NOTE: w of each edge must be the same.
    public long[] bfs(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        Queue<Integer> q = new ArrayDeque<>();
        q.add(src);
        dist[src] = 0;
        vst[src] = true;

        while (!q.isEmpty()) {
            int u = q.poll();
            long w = dist[u];
            for (Edge e : adj[u]) {
                if (!vst[e.to]) {
                    dist[e.to] = w + e.w;
                    vst[e.to] = true;
                    q.add(e.to);
                }
            }
        }
        return dist;
    }
}

class TreapSet<E> {
    private class Node {
        E key;
        int priority, count, total;
        Node left, right, pnt;

        public Node(E key, int priority, Node pnt) {
            this.key = key;
            this.priority = priority;
            this.pnt = pnt;
            this.count = 1;
            this.total = 1;
        }
    }

    private static final Random RANDOM = new Random();
    private final Comparator<? super E> comparator;
    private Node root;

    public TreapSet(Comparator<? super E> comparator) {
        this.comparator = comparator;
    }

    public boolean isEmpty() {
        return root == null;
    }

    public void clear() {
        root = null;
    }

    public int size() {
        return root == null ? 0 : root.total;
    }

    private int leftRank(Node p) {
        return p.left != null ? p.left.total : 0;
    }

    private int rightRank(Node p) {
        return p.right != null ? p.right.total : 0;
    }

    private void rotateLeft(Node x) {
        Node y = x.right;
        if ((x.right = y.left) != null) y.left.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.left) x.pnt.left = y;
        else x.pnt.right = y;
        y.left = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    private void rotateRight(Node x) {
        Node y = x.left;
        if ((x.left = y.right) != null) y.right.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.right) x.pnt.right = y;
        else x.pnt.left = y;
        y.right = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    public void add(E key) {
        if (root == null) {
            root = new Node(key, RANDOM.nextInt(), null);
            return;
        }
        Node x = root, p = null;
        while (x != null) {
            ++((p = x).total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                ++(x.count);
                return;
            }
        }

        x = new Node(key, RANDOM.nextInt(), p);
        if (comparator.compare(key, p.key) < 0) p.left = x;
        else p.right = x;
        while ((p = x.pnt) != null && p.priority < x.priority) {
            if (p.left == x) rotateRight(p);
            else rotateLeft(p);
        }
    }

    public void remove(E key) {
        Node x = root, p = null;
        while (x != null) {
            --(x.total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                if (--(x.count) > 0) return;
                break;
            }
        }
        if (x == null) return;
        while (x.left != null || x.right != null) {
            if (x.left == null || (x.right != null && x.right.priority > x.left.priority)) {
                rotateLeft(x);
            } else {
                rotateRight(x);
            }
        }
        if ((p = x.pnt) != null) {
            if (p.left == x) p.left = null;
            else p.right = null;
        } else {
            root = null;
        }
        // delete x;
    }

    // number of elements smaller than key
    public int lowerCount(E key) {
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                sum += leftRank(x) + x.count;
                x = x.right;
            } else {
                sum += leftRank(x);
                break;
            }
        }
        return sum;
    }

    // number of elements larger than key
    public int higherCount(E key) {
        //return size() - lowerCount(key) - count(key);
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp > 0) x = x.right;
            else if (cmp < 0) {
                sum += rightRank(x) + x.count;
                x = x.left;
            } else {
                sum += rightRank(x);
                break;
            }
        }
        return sum;
    }

    public int index(E key) {
        return lowerCount(key);
    }

    public E get(int index) // index = 0 ... size - 1
    {
        Node p = root;
        ++index;
        while (true) {
            int t = leftRank(p);
            if (index <= t) p = p.left;
            else {
                if ((index -= t + p.count) <= 0) break;
                p = p.right;
            }
        }
        return p.key;
    }

    public int count(E key) {
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                x = x.right;
            } else {
                return x.count;
            }
        }
        return 0;
    }

    public E first() {
        if (root == null) return null;
        Node x = root;
        while (x.left != null) {
            x = x.left;
        }
        return x.key;
    }

    public E last() {
        if (root == null) return null;
        Node x = root;
        while (x.right != null) {
            x = x.right;
        }
        return x.key;
    }

    public boolean contains(E key) {
        return count(key) > 0;
    }

    public E ceiling(E key) {
        int id = lowerCount(key);
        return id >= size() ? null : get(id);
    }

    public E floor(E key) {
        int id = size() - higherCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E lower(E key) {
        int id = lowerCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E higher(E key) {
        int id = size() - higherCount(key);
        return id >= size() ? null : get(id);
    }

    // return the first index whose value >= target
    // if this value doesn't exist, return index = size()
    public int lowerBound(E target) {
        return lowerCount(target);
    }

    // return the first index whose value > target
    // if this value doesn't exist, return index = size()
    public int upperBound(E target) {
        return size() - higherCount(target);
    }

    public List<E> keys() {
        List<E> list = new ArrayList<>();
        inorder(root, list);
        return list;
    }

    private void inorder(Node x, List<E> list) {
        if (x == null) return;
        inorder(x.left, list);
        list.add(x.key);
        inorder(x.right, list);
    }
}

class ArraySum {
    long[] sum;
    int n;

    // nums index starts from 0 to nums.length - 1;
    public ArraySum(int[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    public ArraySum(long[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    // [l, r], index starts from 0
    public long getSum(int l, int r) {
        // error handling
        if (l > r || !(l >= 0 && l < n && r >= 0 && r < n)) return 0L;
        return sum[r + 1] - sum[l];
    }
}

class TwoDArraySum {
    int[][] sum;
    int m, n;

    // nums index starts from 0
    public TwoDArraySum(final int[][] nums) {
        m = nums.length;
        n = nums[0].length;
        sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + nums[i - 1][j - 1];
            }
        }
    }

    // [(x1, y1), (x2, y2)], index starts from 0
    // x1 <= x2 and y1 <= y2
    public int getSum(int x1, int y1, int x2, int y2) {
        if (!(x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && x2 >= 0 && x2 < m && y2 >= 0 && y2 < n) || x1 > x2 || y1 > y2)
            return 0;
        return sum[x2 + 1][y2 + 1] - sum[x2 + 1][y1] - sum[x1][y2 + 1] + sum[x1][y1];
    }
}

class ArrayUtils {
    static void fill(int[] array, int defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(int[][] array, int defaultValue) {
        for (int[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(int[][][] array, int defaultValue) {
        for (int[][] a2 : array) {
            for (int[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(int[][][][] array, int defaultValue) {
        for (int[][][] a3 : array) {
            for (int[][] a2 : a3) {
                for (int[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(int[][][][][] array, int defaultValue) {
        for (int[][][][] a4 : array) {
            for (int[][][] a3 : a4) {
                for (int[][] a2 : a3) {
                    for (int[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(int[][][][][][] array, int defaultValue) {
        for (int[][][][][] a5 : array) {
            for (int[][][][] a4 : a5) {
                for (int[][][] a3 : a4) {
                    for (int[][] a2 : a3) {
                        for (int[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }

    static void fill(long[] array, long defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(long[][] array, long defaultValue) {
        for (long[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(long[][][] array, long defaultValue) {
        for (long[][] a2 : array) {
            for (long[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(long[][][][] array, long defaultValue) {
        for (long[][][] a3 : array) {
            for (long[][] a2 : a3) {
                for (long[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(long[][][][][] array, long defaultValue) {
        for (long[][][][] a4 : array) {
            for (long[][][] a3 : a4) {
                for (long[][] a2 : a3) {
                    for (long[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(long[][][][][][] array, long defaultValue) {
        for (long[][][][][] a5 : array) {
            for (long[][][][] a4 : a5) {
                for (long[][][] a3 : a4) {
                    for (long[][] a2 : a3) {
                        for (long[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }
}

class CharacterUtils {
    static boolean[] vowel = new boolean[128];

    static {
        vowel['a'] = vowel['e'] = vowel['i'] = vowel['o'] = vowel['u'] = true;
        vowel['A'] = vowel['E'] = vowel['I'] = vowel['O'] = vowel['U'] = true;
    }

    static boolean isVowel(char ch) {
        return vowel[ch];
    }

    static boolean isLetter(char ch) {
        return ((ch - 'a') >= 0 && (ch - 'a') < 26) ||
                ((ch - 'A') >= 0 && (ch - 'A') < 26);
    }

    static boolean isLowerCase(char ch) {
        return (ch - 'a') >= 0 && (ch - 'a') < 26;
    }

    static boolean isUpperCase(char ch) {
        return (ch - 'A') >= 0 && (ch - 'A') < 26;
    }

    static boolean isDigit(char ch) {
        return (ch - '0') >= 0 && (ch - '0') <= 9;
    }
}

class DoubleUtils {
    private static final double EPS = 1e-8;

    public static int compare(double a, double b) {
        if (a - b > EPS) return 1;
        else if (a - b < -EPS) return -1;
        else return 0;
    }

    public static boolean isInteger(double a) {
        return compare(floor(a), a) == 0;
    }

    public static double floor(double a) {
        return Math.floor(a + EPS);
    }

    public static double ceil(double a) {
        return Math.ceil(a - EPS);
    }
}

class MatrixUtils {
    static final long MOD = 1_000_000_007L;

    // matrix[n][n], matrix[i][i] = 1
    static long[][] genIdentityMatrix(int n) {
        long[][] matrix = new long[n][n];
        for (int i = 0; i < n; i++) matrix[i][i] = 1;
        return matrix;
    }

    static long[][] multiply(long[][] a, long[][] b, long MOD) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]) % MOD;
                }
            }
        }
        return res;
    }

    static long[][] multiply(long[][] a, long[][] b) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]);
                }
            }
        }
        return res;
    }

    // a^b % MOD
    static long[][] powMod(long[][] a, long b, long MOD) {
        int n = a.length;
        long[][] res = genIdentityMatrix(n);
        while (b > 0) {
            if ((b & 1) != 0) res = multiply(res, a, MOD);
            a = multiply(a, a, MOD);
            b >>= 1;
        }
        return res;
    }

    static void print(long[][] matrix) {
        for (int i = 0; i < matrix.length; i++) {
            System.out.println(Arrays.toString(matrix[i]));
        }
    }
}

class IntegerUtils {
    static long[] power10 = new long[19]; // 10^i

    static {
        power10[0] = 1L;
        for (int i = 1; i < power10.length; i++) {
            power10[i] = power10[i - 1] * 10;
        }
    }

    // swap index i and j of integer (long) num. i == 0 means the lowest position.
    static long swapDigit(long num, int i, int j) {
        if (i == j) return num;
        long di = num / power10[i] % 10L;
        long dj = num / power10[j] % 10L;
        return num - di * power10[i] - dj * power10[j] + dj * power10[i] + di * power10[j];
    }
}

class StringUtils {
    // This function is deprecated, please hash(int l, int r) in class StableStringHash or StringHash
    // rolling hash of substrings of 's' with length == k
    // long[pos] = hash(s.substring(pos, pos + k))
    public static long[] rollingHash(String s, int k) {
        long[] ans = new long[s.length() - k + 1];
        int seed1 = 31;
        int seed2 = 131;
        int h1 = 0, h2 = 0, power1 = 1, power2 = 1;
        for (int i = 0; i < k; i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);

            power1 *= seed1;
            power2 *= seed2;
        }

        ans[0] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        for (int i = k; i < s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i) - power1 * s.charAt(i - k);
            h2 = h2 * seed2 + s.charAt(i) - power2 * s.charAt(i - k);
            ans[i - k + 1] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        }

        return ans;
    }

    public static int[] kmpNext(String s) {
        int n = s.length();
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s.charAt(i) != s.charAt(k)) k = next[k - 1];
            if (s.charAt(i) == s.charAt(k)) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(String s, String p) {
        int[] next = kmpNext(p);
        int n = s.length();
        int m = p.length();
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p.charAt(j) != s.charAt(i)) {
                j = next[j - 1];
            }
            if (p.charAt(j) == s.charAt(i)) j++;
            if (j == m) return true;
        }
        return false;
    }

    public static int[] kmpNext(int[] s) {
        int n = s.length;
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s[i] != s[k]) k = next[k - 1];
            if (s[i] == s[k]) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(int[] s, int[] p) {
        int[] next = kmpNext(p);
        int n = s.length;
        int m = p.length;
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p[j] != s[i]) {
                j = next[j - 1];
            }
            if (p[j] == s[i]) j++;
            if (j == m) return true;
        }
        return false;
    }

    // Z[i] = longest length of common prefix of str[0 ... n - 1] and str[i ... n - 1]
    // Tested by LC2223, LC459
    public static int[] zFunction(String str) {
        int n = str.length();
        int[] Z = new int[n];
        // [L,R] makes a window which matches with prefix of s
        int L = 0, R = 0;
        Z[0] = n;
        for (int i = 1; i < n; ++i) {
            if (i > R) {
                L = R = i;
                while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                Z[i] = R - L;
                R--;
            } else {
                int k = i - L;
                if (Z[k] < R - i + 1) {
                    Z[i] = Z[k];
                } else {
                    L = i;
                    while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                    Z[i] = R - L;
                    R--;
                }
            }
        }
        return Z;
    }
}

// Better to use this when length of string >= 2^11
class StringHash {
    static class SingleStringHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleStringHash(String s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length();
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s.charAt(i - 1)) % MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleStringHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L;

    public StringHash(String s) {
        hash1 = new SingleStringHash(s, SEED1, MOD);
        hash2 = new SingleStringHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(String s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length(); i++) {
            h1 = (h1 * SEED1 + s.charAt(i)) % MOD;
            h2 = (h2 * SEED2 + s.charAt(i)) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(char[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class IntegerArrayHash {
    static class SingleIntegerArrayHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleIntegerArrayHash(int[] s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length;
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s[i - 1]) % MOD;
                if (h[i] < 0) h[i] += MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleIntegerArrayHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L; // or 1_000_000_123L

    public IntegerArrayHash(int[] s) {
        hash1 = new SingleIntegerArrayHash(s, SEED1, MOD);
        hash2 = new SingleIntegerArrayHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(int[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(List<Integer> s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.size(); i++) {
            h1 = (h1 * SEED1 + s.get(i)) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s.get(i)) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class RMQ { // NOTE!!! query return index, not value
    // tested by LC 1438,239
    final long[] a; // input data array copy
    int[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQ(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQ(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new int[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = i;
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = a[d[j - 1][i]] >= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                } else {
                    d[j][i] = a[d[j - 1][i]] <= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                }
    }

    // i <= j, and index starts from 0.
    public int query(int i, int j) { // NOTE!!! return index, not value
        int k = log2[j - i + 1];
        if (useMax) return a[d[k][i]] >= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
        else return a[d[k][i]] <= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
    }
}

class RMQValue { // NOTE!!! query return value, not index
    final long[] a; // input data array copy
    long[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQValue(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQValue(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new long[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = a[i];
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = Math.max(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                } else {
                    d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                }
    }

    // i <= j, and index starts from 0.
    public long query(int i, int j) {
        int k = log2[j - i + 1];
        if (useMax) return Math.max(d[k][i], d[k][j - (1 << k) + 1]);
        else return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }
}

// Tested by 2827
// Similar: 1012, 2376, 902, 2719, 2801, 357, 1215, 1397
class DigitDP {
    static final boolean ENABLE_DEBUG_MODE = false; // TODO: set it to true if you want to print more debug info
    static final long UNSET = -1;
    // dp[isStart][hasLimit][pos] | [odd][even][r]
    // (isStart, hasLimit, pos) is generic, (odd, even, r) is use case specific
    long[][][][][][] dp;
    int K;

    public long digitDP(long num, int k) {
        String numString = String.valueOf(num); // TODO
        this.dp = new long[2][2][numString.length()][numString.length() + 1][numString.length() + 1][k];
        this.K = k;

        if (ENABLE_DEBUG_MODE) System.out.println(""num = "" + numString);
        ArrayUtils.fill(dp, UNSET);
        long ans = dfs(new StringBuilder(), numString, 1, 1, 0, 0, 0, 0);
        if (ENABLE_DEBUG_MODE) System.out.println(""---------------------\n"");
        return ans;
    }

    long dfs(StringBuilder curResult, String s, int isStart, int hasLimit, int pos, int odd, int even, int r) {
        if (pos == s.length()) {
            if (isStart == 1) return 0; // NOTE: special check for num == 0. TODO
            if (r == 0 && odd == even) { // TODO
                if (ENABLE_DEBUG_MODE) System.out.println(""result = "" + curResult);
                return 1;
            } else {
                return 0;
            }
        }
        if (dp[isStart][hasLimit][pos][odd][even][r] != UNSET) return dp[isStart][hasLimit][pos][odd][even][r];

        int start = 0;
        int end = (hasLimit == 1) ? s.charAt(pos) - '0' : 9; // TODO: check if it is binary string or not

        long ans = 0;
        for (int digit = start; digit <= end; digit++) {
            if (isStart == 1 && digit == 0) { // NOTE: handle leading zeros
                // [0, 999..9]
                // [0， 10^(len(s) - pos - 1) - 1]
                ans += dfs(new StringBuilder(), s, 1, 0, pos + 1, 0, 0, 0);
                continue;
            }
            int newHasLimit = (hasLimit == 1 && digit == s.charAt(pos) - '0') ? 1 : 0;

            int newOdd = odd + (digit % 2); // TODO
            int newEven = even + (digit % 2 == 0 ? 1 : 0); // TODO
            int newR = (isStart == 1 ? digit % this.K : (r * 10 + digit) % this.K); // TODO;

            if (ENABLE_DEBUG_MODE) curResult.append(digit);
            ans += dfs(curResult, s, 0, newHasLimit, pos + 1, newOdd, newEven, newR);
            if (ENABLE_DEBUG_MODE) curResult.deleteCharAt(curResult.length() - 1);

        }
        return dp[isStart][hasLimit][pos][odd][even][r] = ans;
    }
}

class Printer {
    static boolean ENABLE_LOCAL_PRINT = false;

    static void println(String x) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.println(x);
    }

    static void printf(String format, Object... args) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.printf(format, args);
    }
}


public class Solution {
    private static final int INF = 1_000_000_001;
    private static final long MOD = 1_000_000_007L;

    private static final int UNSET = -131;
    // 4 neighbors
    private static final int[] DX = {-1, 0, 1, 0}; // up, right, down, left
    private static final int[] DY = {0, 1, 0, -1};

    // 8 neighbors
    //    private static final int[] DX = {-1, -1, 0, 1, 1,  1, 0,  -1};
    //    private static final int[] DY = {0,   1, 1, 1, 0, -1, -1, -1};

    // knight
    //    private static final int[] DX = {-2, -2, -1, 1, 2, 2, 1, -1};
    //    private static final int[] DY = {-1, 1, 2, 2, 1, -1, -2, -2};

    boolean check(int[] next, int limit) {
        int n = next.length;
        for (int i = 0; i < n; i++) {
            int l1 = next[i] - i + 1;
            int l2 = (i + limit < n ? next[i + limit] - (i + limit) + 1 : -1);
            if (l1 >= limit && l2 >= limit) return true;
        }
        return false;
    }

    public int maxIncreasingSubarrays(List<Integer> nums) {
        int n = nums.size();
        int[] next = new int[n];

        for (int i = 0; i < n; ) {
            int j = i + 1;
            while (j < n && nums.get(j) > nums.get(j - 1)) j++;

            for (int k = i; k < j; k++) {
                next[k] = j - 1;
            }
            i = j;
        }

        int ans = 0;
        int low = 1;
        int high = n;
        while (low <= high) {
            int mid = (low + high) / 2;
            if (check(next, mid)) {
                ans = mid;
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        return ans;
    }


    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        Printer.ENABLE_LOCAL_PRINT = true;
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */





        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        System.out.println((System.currentTimeMillis() - startTime) + ""ms"");
    }
}",1448187575
IphoneX,hahahiehie,169,3631,java,"import java.util.*;

class Utils {
    public static int log2(long n) {
        return 63 - Long.numberOfLeadingZeros(n);
    }

    // nums = ""aaabaaaba"" odd d[1] return [1, 2, 1, 4, 1, 2, 2]
    // d[0] for even, d[1] for odd
    public static int[][] manacher(String s) {
        int n = s.length();
        int[] d1 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; ++i) {
            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s.charAt(i - k) == s.charAt(i + k)) k++;
            d1[i] = k;
            if (i + k - 1 > r) {
                l = i - k + 1;
                r = i + k - 1;
            }
        }

        int[] d0 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : Math.min(d0[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s.charAt(i - k - 1) == s.charAt(i + k)) {
                k++;
            }
            d0[i] = k;
            if (i + k - 1 > r) {
                l = i - k;
                r = i + k - 1;
            }
        }
        return new int[][]{d0, d1};
    }

    // generate primes that is <= n
    public static int[] genPrimes(int n) {
        if (n <= 1) return new int[0];
        boolean[] isComp = new boolean[n + 1];
        int len = 0;
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                len++;
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                }
            }
        }
        int[] ans = new int[len];
        for (int i = 2, j = 0; i <= n; i++) {
            if (!isComp[i]) {
                ans[j++] = i;
            }
        }
        return ans;
    }

    // int[0] = primeFactor, int[1] = count of that primeFactor
    // NOTE: factors[0] and factors[1] are empty list.
    public static List<int[]>[] genPrimeFactors(int n) {
        List<int[]>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            factors[i] = new ArrayList<>();
        }
        boolean[] isComp = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                factors[i].add(new int[]{i, 1});
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                    int t = j, count = 0;
                    while (t % i == 0) {
                        count++;
                        t /= i;
                    }
                    factors[j].add(new int[]{i, count});
                }
            }
        }
        return factors;
    }

    // generate factors (not prime factors), factors[0] is empty list.
    public static List<Integer>[] genFactors(int n) {
        List<Integer>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) factors[i] = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j += i) {
                factors[j].add(i);
            }
        }
        return factors;
    }

    public static int lowerBound(int[] a, int target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(int[] a, int target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(long[] a, long target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(long[] a, long target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static long or(int x, int y) {
        return ((long) x << 32) | ((long) y << 32 >>> 32);
    }

    // k = 0...nums.length - 1
    // After calling this function, nums[k] is the k-th number.
    public static int kthNumber(int[] nums, int k) {
        return kthNumberHelper(nums, k, 0, nums.length - 1);
    }

    // end is inclusive (0 to nums.length - 1)
    private static int kthNumberHelper(int[] nums, int K, int start, int end) {
        if (start == end) return nums[start];
        int i = partition(nums, start, end);
        return K <= i ? kthNumberHelper(nums, K, start, i) : kthNumberHelper(nums, K, i + 1, end);
    }

    // end is inclusive (0 to nums.length - 1)
    public static int partition(int[] nums, int start, int end) {
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && nums[i] < pivot) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && pivot < nums[j]) j--;
            if (i < j) nums[i++] = nums[j];
        }

        // pos is the final position for pivot.
        nums[i] = pivot;
        return i;
    }

    public static void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    // partition nums into 3 parts [smaller than pivot, equal to pivot, larger than pivot]
    public static void partition3(int[] nums, int pivot) {
        int n = nums.length;
        int l = 0, r = n - 1;
        for (int i = 0; i <= r; i++) {
            if (nums[i] < pivot) {
                swap(nums, l++, i);
            } else if (nums[i] > pivot) {
                swap(nums, r--, i--);
            }
        }
    }

    // end is inclusive
    public static void reverse(int[] nums, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    }

    // Return false if next permutation is not available. (nums is not changed for this case)
    public static boolean nextPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] >= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] > nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // Return false if previous permutation is not available. (nums is not changed for this case)
    public static boolean prevPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] <= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] < nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }


    // a, b could be negative
    // remainder >= 0
    // return [a / b, a % b]
    public static int[] divMod(int a, int b) {
        int r = a % b;
        int c = a / b;
        if (r < 0) {
            r += Math.abs(b);
            c++;
        }
        return new int[]{c, r};
    }

    public static List<Integer> negativeBase(int n, int base) {
        List<Integer> digits = new ArrayList<>();
        if (n == 0) {
            digits.add(0);
            return digits;
        }
        while (n != 0) {
            // t[0] = n / base
            // t[1] = n % base;
            int[] t = divMod(n, base);
            digits.add(t[1]);
            n = t[0];
        }
        Collections.reverse(digits);
        return digits;
    }

    // (a ^ b) % MOD
    public static long powMod(long a, long b, long MOD) {
        long res = 1L;
        a %= MOD; // In case a * a is overflow
        while (b > 0) {
            if ((b & 1) != 0) res = (res * a) % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    public static long[][] genCombination(int n) {
        long[][] C = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        return C;
    }

    public static long[][] genPermutation(int n) {
        long[][] P = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
        return P;
    }

    public static long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }

    public static int[] preprocessLog2(int n) { // from log2(0) .... log2(n) inclusive
        int[] lg = new int[n + 1];
        for (int k = 0, i = 1; i <= n; lg[i++] = k - 1) {
            while ((1 << k) <= i) {
                k++;
            }
        }
        return lg;
    }

    public static long max(long[] nums) {
        long ret = Long.MIN_VALUE;
        for (long v : nums) ret = Math.max(ret, v);
        return ret;
    }

    public static int max(int[] nums) {
        int ret = Integer.MIN_VALUE;
        for (int v : nums) ret = Math.max(ret, v);
        return ret;
    }
}

// Tested by leetcode 1163
class SuffixArray {
    int[] s;
    int[] SA; // SA[i] => index of the i-th ranked suffix
    int[] rank; // rank[i] => the rank of i-th suffix, SA[rank[i]] == i
    int[] height; // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).

    private int[][] d;
    private int n;
    private int[] lg;

    private int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    private static int[] stringToIntArray(String str) {
        int[] nums = new int[str.length()];
        for (int i = 0; i < str.length(); i++) nums[i] = str.charAt(i);
        return nums;
    }

    public SuffixArray(String str) {
        this(str, true);
    }

    public SuffixArray(String str, boolean toBuildRMQ) {
        this(stringToIntArray(str), toBuildRMQ);
    }

    public SuffixArray(int[] nums) {
        this(nums, true);
    }

    public SuffixArray(int[] nums, boolean toBuildRMQ) {
        this.s = nums;
        this.n = nums.length;
        this.SA = new int[n];
        this.rank = new int[n];
        suffixSort(s);
        if (toBuildRMQ) {
            this.height = new int[n];
            this.d = new int[log2(n) + 1][n];
            this.lg = new int[n + 1];
            buildHeight();
            buildRMQ();
        }
    }

    // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).
    // ?? s[n] = 0 or s[n] = -INF.
    private void buildHeight() {
        int i, j, h;
        height[0] = 0;
        for (i = 0; i < n; i++)
            rank[SA[i]] = i;
        for (h = i = 0; i < n; i++)
            if (rank[i] > 0) {
                j = SA[rank[i] - 1];
                while (i + h < n && j + h < n && s[i + h] == s[j + h]) ++h;
                height[rank[i]] = h;
                if (h > 0) --h;
            }
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    private void buildRMQ() {
        int i, j, k;
        for (i = 0; i < n; i++)
            d[0][i] = height[i];
        for (j = 1; (1 << j) <= n; j++)
            for (i = 0; i + (1 << j) <= n; i++)
                d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
        for (lg[0] = k = 0, i = 1; i <= n; lg[i++] = k - 1)
            while ((1 << k) <= i) k++;
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    public int LCP(int i, int j) {
        if (i == j) return n - SA[i];
        if (i > j) {
            int t = i;
            i = j;
            j = t;
        }
        int k = lg[j - (++i) + 1];
        return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }

    // LCPIndex(i, j) = LCP(s[i], s[j])
    public int LCPIndex(int i, int j) {
        return LCP(rank[i], rank[j]);
    }

    private void sortIndex(int[] nums, int start, int end) {
        if (start >= end) return;
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && s[nums[i]] < s[pivot]) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && s[pivot] < s[nums[j]]) j--;
            if (i < j) nums[i++] = nums[j];
        }
        nums[i] = pivot; // index i is the final position for pivot.
        sortIndex(nums, start, i - 1);
        sortIndex(nums, i + 1, end);
    }

    private void suffixSort(int[] s) {
        int[] count = new int[n], t;
        int[] nSA = new int[n];
        int[] nRank = new int[n];
//        Integer[] tempArray = new Integer[n];
//        for (int x = 0; x < n; x++) tempArray[x] = x;
//        Arrays.sort(tempArray, (a, b) -> Integer.compare(s[a], s[b]));
//        for (int x = 0; x < n; x++) SA[x] = tempArray[x];
        int i, k;
        int minV = s[0], maxV = s[0];
        for (i = 1; i < n; i++) {
            minV = Math.min(minV, s[i]);
            maxV = Math.max(maxV, s[i]);
        }
        if ((long) maxV - minV + 1 <= (long) n) { // radix sort if alphabet size is small
            for (i = 0; i < n; i++) count[s[i] - minV]++;
            for (i = minV + 1; i <= maxV; i++) count[i - minV] += count[i - minV - 1];
            for (i = n - 1; i >= 0; i--) SA[--count[s[i] - minV]] = i;
        } else {
            for (i = 0; i < n; i++) SA[i] = i;
            sortIndex(SA, 0, n - 1);
        }
        for (rank[SA[0]] = 0, i = 1; i < n; i++) {
            rank[SA[i]] = (s[SA[i]] != s[SA[i - 1]]) ? rank[SA[i - 1]] + 1 : rank[SA[i - 1]];
        }
        for (k = 1; k < n && rank[SA[n - 1]] < n - 1; k <<= 1) {
            for (i = 0; i < n; i++) count[rank[SA[i]]] = i + 1;
            for (i = n - 1; i >= 0; i--) if (SA[i] >= k) nSA[--count[rank[SA[i] - k]]] = SA[i] - k;
            for (i = n - k; i < n; i++) nSA[--count[rank[i]]] = i;
            t = SA;
            SA = nSA;
            nSA = t;
            for (nRank[SA[0]] = 0, i = 1; i < n; i++) {
                nRank[SA[i]] = (SA[i] + k >= n || SA[i - 1] + k >= n || rank[SA[i]] != rank[SA[i - 1]] || rank[SA[i] + k] != rank[SA[i - 1] + k]) ? nRank[SA[i - 1]] + 1 : nRank[SA[i - 1]];
            }
            t = rank;
            rank = nRank;
            nRank = t;
        }
    }
}

class Combination {
    long[] factorial;
    long[] inverseFactorial;
    long MOD;

    // O(maxSize) for preprocessing
    // MOD must be prime
    public Combination(int maxSize, long MOD) {
        factorial = new long[maxSize + 1];
        inverseFactorial = new long[maxSize + 1];
        factorial[0] = 1;
        inverseFactorial[0] = 1;
        this.MOD = MOD;
        for (int i = 1; i <= maxSize; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
            inverseFactorial[i] = inverse(factorial[i]);
        }
    }

    // x, y are long[1]
    // ax + by = gcd(a, b)
    private long extGcd(long a, long b, long[] x, long[] y) {
        if (b == 0) {
            x[0] = 1;
            y[0] = 0;
            return a;
        } else {
            long r = extGcd(b, a % b, y, x);
            y[0] -= x[0] * (a / b);
            return r;
        }
    }

    // (a * x) % MOD = 1
    // x is the inverse element
    public long inverse(long a) {
        long[] x = new long[1], y = new long[1];
        extGcd(a, MOD, x, y);
        return (x[0] % MOD + MOD) % MOD;
    }

    // m >= n
    // O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        else if (m == n) return factorial[m];
            //return factorial[m] * inverse(factorial[m - n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD;
    }

    // m >= n
    // O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
            //return factorial[m] * inverse(factorial[m - n]) % MOD * inverse(factorial[n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD * inverseFactorial[n] % MOD;
    }
}

class CombinationNoMod {

    long[][] C;
    long[][] P;

    public CombinationNoMod(int maxSize) {
        C = new long[maxSize + 1][maxSize + 1];
        P = new long[maxSize + 1][maxSize + 1];
        int m = C.length;
        int n = C[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
    }

    // m >= n. O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        return P[m][n];
    }

    // m >= n. O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
        return C[m][n];
    }
}

class Fraction {
    long n, d; // n / d (d != 0)

    public Fraction(long n, long d) {
        if (d == 0) {
            this.n = Long.MAX_VALUE;
            this.d = 1;
            return;
        }
        long g = gcd(Math.abs(n), Math.abs(d));
        this.n = n / g;
        this.d = d / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    public void add(Fraction other) {
        long numerator = this.n * other.d + this.d * other.n;
        long denominator = this.d * other.d;
        long g = gcd(Math.abs(numerator), Math.abs(denominator));
        this.n = numerator / g;
        this.d = denominator / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    @Override
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof Fraction) {
            Fraction anotherObject = (Fraction) anObject;
            return n == anotherObject.n && d == anotherObject.d;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return (int) (n * 31 + d);
    }

    private long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }
}

class UnionFind {
    int[] parent;
    int[] sz;

    // from 0 ... n - 1
    public UnionFind(int n) {
        parent = new int[n];
        sz = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public void clear() {
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public int find(int x) {
        //return parent[x] == x ? x : (parent[x] = find(parent[x]));
        if (parent[x] == x) return x;
        int px = x;
        while (px != parent[px]) px = parent[px];
        while (x != px) {
            int next = parent[x];
            parent[x] = px;
            x = next;
        }
        return px;
    }

    // px is the final parent
    public boolean union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return false;
        parent[py] = px;
        sz[px] += sz[py];
        return true;
    }

    public int size(int x) {
        return sz[find(x)];
    }

    public UnionFind clone() {
        UnionFind cloned = new UnionFind(parent.length);
        for (int i = 0; i < parent.length; i++) {
            cloned.parent[i] = parent[i];
            cloned.sz[i] = sz[i];
        }
        return cloned;
    }
}

class Trie {
    static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        boolean isWord = false;
        long count = 0L;
    }

    TrieNode root = new TrieNode();

    public void add(String word) {
        add(word, 1L);
    }

    public void remove(String word) {
        add(word, -1L);
    }

    private void add(String word, long count) {
        TrieNode cur = root;
        cur.count += count;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) cur.next[c] = new TrieNode();
            cur = cur.next[c];
            cur.count += count;
        }
        cur.isWord = true;
    }

    public boolean contains(String word) {
        TrieNode cur = root;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null || cur.next[c].count <= 0L) return false;
            cur = cur.next[c];
            //if (cur.isWord) return true;
        }
        return cur.isWord;
    }
}

// Tested by Leetcode 1707 and Leetcode 1803
class TrieBinary {
    static class TrieNode {
        TrieNode[] next = new TrieNode[2];
        long count;
    }

    private TrieNode root;
    private int numOfBits;

    public TrieBinary(int numOfBits) { // normally 31 for int and 63 for long
        this.numOfBits = numOfBits;
        this.root = new TrieNode();
    }

    public void add(long v) {
        add(v, 1L);
    }

    public void remove(long v) { // Tested by Leetcode 1938
        add(v, -1L);
    }

    public void add(long v, long count) {
        TrieNode cur = root;
        root.count += count;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null) cur.next[b] = new TrieNode();
            cur = cur.next[b];
            cur.count += count;
        }
    }

    // Tested by Leetcode 1707
    public long xorMax(long v) {
        TrieNode cur = root;
        long key = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[1 - b] != null && cur.next[1 - b].count > 0) {
                cur = cur.next[1 - b];
                key |= (1L - b) << i;
            } else {
                cur = cur.next[b];
                key |= (long) b << i;
            }
        }
        return key ^ v;
    }

    public boolean contains(long v) {
        TrieNode cur = root;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null || cur.next[b].count <= 0) return false;
            cur = cur.next[b];
        }
        return true;
    }

    // Tested by Leetcode 1803
    // count(x ^ v <= limit)
    public long xorLessOrEqualCount(long v, long limit) {
        if (limit < 0) return 0;
        TrieNode cur = root;
        long ans = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int bitLimit = ((limit >>> i) & 1) == 0 ? 0 : 1;
            int bitV = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (bitLimit == 1) {
                ans += (cur.next[bitV] != null ? cur.next[bitV].count : 0);
            }
            cur = cur.next[bitV ^ bitLimit];
            if (cur == null) break;
            if (i == 0) ans += cur.count;
        }
        return ans;
    }
}

// Lazy execution example is in https://leetcode.com/submissions/detail/1034182539/
// Refer to AlgorithmCompilation.java

// [Template] Classic Segment Tree (Range Sum), used for Template
class ClassicSegmentTree { // For Range Sum
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final int L, R;

    public ClassicSegmentTree(int[] input) {
        L = 0;
        R = input.length - 1;
        root = new TreeNode();
        build(root, L, R, input);
    }

    private void build(TreeNode root, int l, int r, int[] input) {
        if (l == r) {
            root.sum = input[l];
            return;
        }
        int m = (l + r) >> 1;
        root.left = new TreeNode();
        root.right = new TreeNode();
        build(root.left, l, m, input);
        build(root.right, m + 1, r, input);
        root.sum = root.left.sum + root.right.sum;
    }

    public void set(int index, int value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, int L, int R, int index, int value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        int M = L + ((R - L) >> 1);
        if (index <= M) {
            set(root.left, L, M, index, value);
        } else {
            set(root.right, M + 1, R, index, value);
        }
        root.sum = root.left.sum + root.right.sum;
    }

    // Sum[queryL...queryR] inclusive
    public long query(int queryL, int queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, int L, int R, int queryL, int queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        int M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 307
class DynamicSegmentTreeRangeSum {
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeSum(long l, long r) {
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return sum(cur);
    }

    public void add(long index, long value) {
        set(index, get(index) + value);
    }

    private long sum(TreeNode node) {
        return node == null ? 0L : node.sum;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.sum = sum(root.left) + sum(root.right);
    }

    // Sum[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        long M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 239, 2926
class DynamicSegmentTreeRangeMax {
    class TreeNode {
        TreeNode left, right;
        long max = Long.MIN_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMax(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return max(cur);
    }

    private long max(TreeNode node) {
        return node == null ? Long.MIN_VALUE : node.max;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.max = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.max = Math.max(max(root.left), max(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MIN_VALUE;
        if (queryL <= L && R <= queryR) return root.max;
        long M = L + ((R - L) >> 1);
        return Math.max(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class DynamicSegmentTreeRangeMin {
    class TreeNode {
        TreeNode left, right;
        long min = Long.MAX_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMin(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return min(cur);
    }

    private long min(TreeNode node) {
        return node == null ? Long.MAX_VALUE : node.min;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.min = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.min = Math.min(min(root.left), min(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MAX_VALUE;
        if (queryL <= L && R <= queryR) return root.min;
        long M = L + ((R - L) >> 1);
        return Math.min(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class BinaryIndexTree {
    private long[] c;
    private int n;

    // NOTE: index is from 1 to n. (NOT 0 ... n - 1)
    public BinaryIndexTree(int n) {
        this.n = n;
        this.c = new long[n + 1];
    }

    // Add value to position k, k is from 1 to n.
    public void add(int k, long value) {
        while (k <= n) {
            c[k] += value;
            k += (k & (k ^ (k - 1)));
        }
    }

    // k is from 1 to n.
    public long getSum(int k) {
        long sum = 0;
        while (k > 0) {
            sum += c[k];
            k -= (k & (k ^ (k - 1)));
        }
        return sum;
    }
}

class RangeSum {
    BinaryIndexTree tree;
    int start;

    // [low, high] inclusive
    public RangeSum(int low, int high) {
        start = low;
        tree = new BinaryIndexTree(high - low + 1);
    }

    public void add(int index, long value) {
        tree.add(index - start + 1, value);
    }

    public long get(int index) {
        return tree.getSum(index - start + 1) - tree.getSum(index - start);
    }

    public void set(int index, long value) {
        tree.add(index - start + 1, value - get(index));
    }

    // [l, r] inclusive
    public long getSum(int l, int r) {
        return tree.getSum(r - start + 1) - tree.getSum(l - start);
    }
}

class RangeMax {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMax(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MIN_VALUE);
    }

    public RangeMax(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.max(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMax(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MIN_VALUE, resr = Long.MIN_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.max(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.max(t[--r], resr);
        }
        return Math.max(resl, resr);
    }
}

class RangeMin {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMin(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MAX_VALUE);
    }

    public RangeMin(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.min(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMin(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MAX_VALUE, resr = Long.MAX_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.min(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.min(t[--r], resr);
        }
        return Math.min(resl, resr);
    }
}

// Including topological sort.
class GraphIntegerFaster {
    public List<Integer>[] adj;

    public GraphIntegerFaster(int n) {
        adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    // directed edge x -> y
    public void link(int x, int y) {
        adj[x].add(y);
    }

    public List<Integer> getChildren(int x) {
        return adj[x];
    }

    private static final int TEMPORARY = 1;
    private static final int PERMANENT = 2;

    // x -> y means x should be processed before y
    // The input is a directed graph.
    // 1. return null, means there is a cycle inside the graph, or the input is
    // invalid.
    // 2. return List<Node> as the result.
    public List<Integer> topologicalSort() {
        //Map<E, Integer> vst = new HashMap<>();
        int n = adj.length;
        int[] vst = new int[n];
        List<Integer> result = new ArrayList<>();
        for (int x = 0; x < n; x++) {
            if (!topologicalSort(x, vst, result)) {
                return null;
            }
        }
        Collections.reverse(result);
        return result;
    }

    private boolean topologicalSort(int root, int[] vst, List<Integer> result) {
        if (vst[root] == PERMANENT) {
            return true;
        }
        if (vst[root] == TEMPORARY) { // found cycle
            return false;
        }

        vst[root] = TEMPORARY;
        for (int child : getChildren(root)) {
            if (!topologicalSort(child, vst, result)) {
                return false;
            }
        }
        result.add(root);
        vst[root] = PERMANENT;
        return true;
    }
}

class DijkstraLongFaster {
    public static class Edge {
        int to;
        long w;

        public Edge(int to, long w) {
            this.to = to;
            this.w = w;
        }
    }

    public static final long INF = Long.MAX_VALUE / 4;
    public List<Edge>[] adj;

    public DijkstraLongFaster(int n) {
        this.adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    public void link(int x, int y, long w) {
        adj[x].add(new Edge(y, w));
    }

    public long[] shortestPath(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
        q.add(new Edge(src, 0));
        dist[src] = 0;

        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (vst[cur.to]) continue;
            int u = cur.to;
            long w = cur.w;
            vst[u] = true;

            for (Edge e : adj[u]) {
                if (!vst[e.to] && dist[e.to] > w + e.w) {
                    dist[e.to] = w + e.w;
                    q.add(new Edge(e.to, dist[e.to]));
                }
            }
        }
        return dist;
    }

    // NOTE: w of each edge must be the same.
    public long[] bfs(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        Queue<Integer> q = new ArrayDeque<>();
        q.add(src);
        dist[src] = 0;
        vst[src] = true;

        while (!q.isEmpty()) {
            int u = q.poll();
            long w = dist[u];
            for (Edge e : adj[u]) {
                if (!vst[e.to]) {
                    dist[e.to] = w + e.w;
                    vst[e.to] = true;
                    q.add(e.to);
                }
            }
        }
        return dist;
    }
}

class TreapSet<E> {
    private class Node {
        E key;
        int priority, count, total;
        Node left, right, pnt;

        public Node(E key, int priority, Node pnt) {
            this.key = key;
            this.priority = priority;
            this.pnt = pnt;
            this.count = 1;
            this.total = 1;
        }
    }

    private static final Random RANDOM = new Random();
    private final Comparator<? super E> comparator;
    private Node root;

    public TreapSet(Comparator<? super E> comparator) {
        this.comparator = comparator;
    }

    public boolean isEmpty() {
        return root == null;
    }

    public void clear() {
        root = null;
    }

    public int size() {
        return root == null ? 0 : root.total;
    }

    private int leftRank(Node p) {
        return p.left != null ? p.left.total : 0;
    }

    private int rightRank(Node p) {
        return p.right != null ? p.right.total : 0;
    }

    private void rotateLeft(Node x) {
        Node y = x.right;
        if ((x.right = y.left) != null) y.left.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.left) x.pnt.left = y;
        else x.pnt.right = y;
        y.left = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    private void rotateRight(Node x) {
        Node y = x.left;
        if ((x.left = y.right) != null) y.right.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.right) x.pnt.right = y;
        else x.pnt.left = y;
        y.right = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    public void add(E key) {
        if (root == null) {
            root = new Node(key, RANDOM.nextInt(), null);
            return;
        }
        Node x = root, p = null;
        while (x != null) {
            ++((p = x).total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                ++(x.count);
                return;
            }
        }

        x = new Node(key, RANDOM.nextInt(), p);
        if (comparator.compare(key, p.key) < 0) p.left = x;
        else p.right = x;
        while ((p = x.pnt) != null && p.priority < x.priority) {
            if (p.left == x) rotateRight(p);
            else rotateLeft(p);
        }
    }

    public void remove(E key) {
        Node x = root, p = null;
        while (x != null) {
            --(x.total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                if (--(x.count) > 0) return;
                break;
            }
        }
        if (x == null) return;
        while (x.left != null || x.right != null) {
            if (x.left == null || (x.right != null && x.right.priority > x.left.priority)) {
                rotateLeft(x);
            } else {
                rotateRight(x);
            }
        }
        if ((p = x.pnt) != null) {
            if (p.left == x) p.left = null;
            else p.right = null;
        } else {
            root = null;
        }
        // delete x;
    }

    // number of elements smaller than key
    public int lowerCount(E key) {
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                sum += leftRank(x) + x.count;
                x = x.right;
            } else {
                sum += leftRank(x);
                break;
            }
        }
        return sum;
    }

    // number of elements larger than key
    public int higherCount(E key) {
        //return size() - lowerCount(key) - count(key);
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp > 0) x = x.right;
            else if (cmp < 0) {
                sum += rightRank(x) + x.count;
                x = x.left;
            } else {
                sum += rightRank(x);
                break;
            }
        }
        return sum;
    }

    public int index(E key) {
        return lowerCount(key);
    }

    public E get(int index) // index = 0 ... size - 1
    {
        Node p = root;
        ++index;
        while (true) {
            int t = leftRank(p);
            if (index <= t) p = p.left;
            else {
                if ((index -= t + p.count) <= 0) break;
                p = p.right;
            }
        }
        return p.key;
    }

    public int count(E key) {
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                x = x.right;
            } else {
                return x.count;
            }
        }
        return 0;
    }

    public E first() {
        if (root == null) return null;
        Node x = root;
        while (x.left != null) {
            x = x.left;
        }
        return x.key;
    }

    public E last() {
        if (root == null) return null;
        Node x = root;
        while (x.right != null) {
            x = x.right;
        }
        return x.key;
    }

    public boolean contains(E key) {
        return count(key) > 0;
    }

    public E ceiling(E key) {
        int id = lowerCount(key);
        return id >= size() ? null : get(id);
    }

    public E floor(E key) {
        int id = size() - higherCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E lower(E key) {
        int id = lowerCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E higher(E key) {
        int id = size() - higherCount(key);
        return id >= size() ? null : get(id);
    }

    // return the first index whose value >= target
    // if this value doesn't exist, return index = size()
    public int lowerBound(E target) {
        return lowerCount(target);
    }

    // return the first index whose value > target
    // if this value doesn't exist, return index = size()
    public int upperBound(E target) {
        return size() - higherCount(target);
    }

    public List<E> keys() {
        List<E> list = new ArrayList<>();
        inorder(root, list);
        return list;
    }

    private void inorder(Node x, List<E> list) {
        if (x == null) return;
        inorder(x.left, list);
        list.add(x.key);
        inorder(x.right, list);
    }
}

class ArraySum {
    long[] sum;
    int n;

    // nums index starts from 0 to nums.length - 1;
    public ArraySum(int[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    public ArraySum(long[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    // [l, r], index starts from 0
    public long getSum(int l, int r) {
        // error handling
        if (l > r || !(l >= 0 && l < n && r >= 0 && r < n)) return 0L;
        return sum[r + 1] - sum[l];
    }
}

class TwoDArraySum {
    int[][] sum;
    int m, n;

    // nums index starts from 0
    public TwoDArraySum(final int[][] nums) {
        m = nums.length;
        n = nums[0].length;
        sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + nums[i - 1][j - 1];
            }
        }
    }

    // [(x1, y1), (x2, y2)], index starts from 0
    // x1 <= x2 and y1 <= y2
    public int getSum(int x1, int y1, int x2, int y2) {
        if (!(x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && x2 >= 0 && x2 < m && y2 >= 0 && y2 < n) || x1 > x2 || y1 > y2)
            return 0;
        return sum[x2 + 1][y2 + 1] - sum[x2 + 1][y1] - sum[x1][y2 + 1] + sum[x1][y1];
    }
}

class ArrayUtils {
    static void fill(int[] array, int defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(int[][] array, int defaultValue) {
        for (int[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(int[][][] array, int defaultValue) {
        for (int[][] a2 : array) {
            for (int[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(int[][][][] array, int defaultValue) {
        for (int[][][] a3 : array) {
            for (int[][] a2 : a3) {
                for (int[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(int[][][][][] array, int defaultValue) {
        for (int[][][][] a4 : array) {
            for (int[][][] a3 : a4) {
                for (int[][] a2 : a3) {
                    for (int[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(int[][][][][][] array, int defaultValue) {
        for (int[][][][][] a5 : array) {
            for (int[][][][] a4 : a5) {
                for (int[][][] a3 : a4) {
                    for (int[][] a2 : a3) {
                        for (int[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }

    static void fill(long[] array, long defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(long[][] array, long defaultValue) {
        for (long[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(long[][][] array, long defaultValue) {
        for (long[][] a2 : array) {
            for (long[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(long[][][][] array, long defaultValue) {
        for (long[][][] a3 : array) {
            for (long[][] a2 : a3) {
                for (long[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(long[][][][][] array, long defaultValue) {
        for (long[][][][] a4 : array) {
            for (long[][][] a3 : a4) {
                for (long[][] a2 : a3) {
                    for (long[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(long[][][][][][] array, long defaultValue) {
        for (long[][][][][] a5 : array) {
            for (long[][][][] a4 : a5) {
                for (long[][][] a3 : a4) {
                    for (long[][] a2 : a3) {
                        for (long[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }
}

class CharacterUtils {
    static boolean[] vowel = new boolean[128];

    static {
        vowel['a'] = vowel['e'] = vowel['i'] = vowel['o'] = vowel['u'] = true;
        vowel['A'] = vowel['E'] = vowel['I'] = vowel['O'] = vowel['U'] = true;
    }

    static boolean isVowel(char ch) {
        return vowel[ch];
    }

    static boolean isLetter(char ch) {
        return ((ch - 'a') >= 0 && (ch - 'a') < 26) ||
                ((ch - 'A') >= 0 && (ch - 'A') < 26);
    }

    static boolean isLowerCase(char ch) {
        return (ch - 'a') >= 0 && (ch - 'a') < 26;
    }

    static boolean isUpperCase(char ch) {
        return (ch - 'A') >= 0 && (ch - 'A') < 26;
    }

    static boolean isDigit(char ch) {
        return (ch - '0') >= 0 && (ch - '0') <= 9;
    }
}

class DoubleUtils {
    private static final double EPS = 1e-8;

    public static int compare(double a, double b) {
        if (a - b > EPS) return 1;
        else if (a - b < -EPS) return -1;
        else return 0;
    }

    public static boolean isInteger(double a) {
        return compare(floor(a), a) == 0;
    }

    public static double floor(double a) {
        return Math.floor(a + EPS);
    }

    public static double ceil(double a) {
        return Math.ceil(a - EPS);
    }
}

class MatrixUtils {
    static final long MOD = 1_000_000_007L;

    // matrix[n][n], matrix[i][i] = 1
    static long[][] genIdentityMatrix(int n) {
        long[][] matrix = new long[n][n];
        for (int i = 0; i < n; i++) matrix[i][i] = 1;
        return matrix;
    }

    static long[][] multiply(long[][] a, long[][] b, long MOD) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]) % MOD;
                }
            }
        }
        return res;
    }

    static long[][] multiply(long[][] a, long[][] b) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]);
                }
            }
        }
        return res;
    }

    // a^b % MOD
    static long[][] powMod(long[][] a, long b, long MOD) {
        int n = a.length;
        long[][] res = genIdentityMatrix(n);
        while (b > 0) {
            if ((b & 1) != 0) res = multiply(res, a, MOD);
            a = multiply(a, a, MOD);
            b >>= 1;
        }
        return res;
    }

    static void print(long[][] matrix) {
        for (int i = 0; i < matrix.length; i++) {
            System.out.println(Arrays.toString(matrix[i]));
        }
    }
}

class IntegerUtils {
    static long[] power10 = new long[19]; // 10^i

    static {
        power10[0] = 1L;
        for (int i = 1; i < power10.length; i++) {
            power10[i] = power10[i - 1] * 10;
        }
    }

    // swap index i and j of integer (long) num. i == 0 means the lowest position.
    static long swapDigit(long num, int i, int j) {
        if (i == j) return num;
        long di = num / power10[i] % 10L;
        long dj = num / power10[j] % 10L;
        return num - di * power10[i] - dj * power10[j] + dj * power10[i] + di * power10[j];
    }
}

class StringUtils {
    // This function is deprecated, please hash(int l, int r) in class StableStringHash or StringHash
    // rolling hash of substrings of 's' with length == k
    // long[pos] = hash(s.substring(pos, pos + k))
    public static long[] rollingHash(String s, int k) {
        long[] ans = new long[s.length() - k + 1];
        int seed1 = 31;
        int seed2 = 131;
        int h1 = 0, h2 = 0, power1 = 1, power2 = 1;
        for (int i = 0; i < k; i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);

            power1 *= seed1;
            power2 *= seed2;
        }

        ans[0] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        for (int i = k; i < s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i) - power1 * s.charAt(i - k);
            h2 = h2 * seed2 + s.charAt(i) - power2 * s.charAt(i - k);
            ans[i - k + 1] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        }

        return ans;
    }

    public static int[] kmpNext(String s) {
        int n = s.length();
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s.charAt(i) != s.charAt(k)) k = next[k - 1];
            if (s.charAt(i) == s.charAt(k)) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(String s, String p) {
        int[] next = kmpNext(p);
        int n = s.length();
        int m = p.length();
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p.charAt(j) != s.charAt(i)) {
                j = next[j - 1];
            }
            if (p.charAt(j) == s.charAt(i)) j++;
            if (j == m) return true;
        }
        return false;
    }

    public static int[] kmpNext(int[] s) {
        int n = s.length;
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s[i] != s[k]) k = next[k - 1];
            if (s[i] == s[k]) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(int[] s, int[] p) {
        int[] next = kmpNext(p);
        int n = s.length;
        int m = p.length;
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p[j] != s[i]) {
                j = next[j - 1];
            }
            if (p[j] == s[i]) j++;
            if (j == m) return true;
        }
        return false;
    }

    // Z[i] = longest length of common prefix of str[0 ... n - 1] and str[i ... n - 1]
    // Tested by LC2223, LC459
    public static int[] zFunction(String str) {
        int n = str.length();
        int[] Z = new int[n];
        // [L,R] makes a window which matches with prefix of s
        int L = 0, R = 0;
        Z[0] = n;
        for (int i = 1; i < n; ++i) {
            if (i > R) {
                L = R = i;
                while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                Z[i] = R - L;
                R--;
            } else {
                int k = i - L;
                if (Z[k] < R - i + 1) {
                    Z[i] = Z[k];
                } else {
                    L = i;
                    while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                    Z[i] = R - L;
                    R--;
                }
            }
        }
        return Z;
    }
}

// Better to use this when length of string >= 2^11
class StringHash {
    static class SingleStringHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleStringHash(String s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length();
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s.charAt(i - 1)) % MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleStringHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L;

    public StringHash(String s) {
        hash1 = new SingleStringHash(s, SEED1, MOD);
        hash2 = new SingleStringHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(String s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length(); i++) {
            h1 = (h1 * SEED1 + s.charAt(i)) % MOD;
            h2 = (h2 * SEED2 + s.charAt(i)) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(char[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class IntegerArrayHash {
    static class SingleIntegerArrayHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleIntegerArrayHash(int[] s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length;
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s[i - 1]) % MOD;
                if (h[i] < 0) h[i] += MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleIntegerArrayHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L; // or 1_000_000_123L

    public IntegerArrayHash(int[] s) {
        hash1 = new SingleIntegerArrayHash(s, SEED1, MOD);
        hash2 = new SingleIntegerArrayHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(int[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(List<Integer> s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.size(); i++) {
            h1 = (h1 * SEED1 + s.get(i)) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s.get(i)) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class RMQ { // NOTE!!! query return index, not value
    // tested by LC 1438,239
    final long[] a; // input data array copy
    int[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQ(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQ(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new int[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = i;
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = a[d[j - 1][i]] >= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                } else {
                    d[j][i] = a[d[j - 1][i]] <= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                }
    }

    // i <= j, and index starts from 0.
    public int query(int i, int j) { // NOTE!!! return index, not value
        int k = log2[j - i + 1];
        if (useMax) return a[d[k][i]] >= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
        else return a[d[k][i]] <= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
    }
}

class RMQValue { // NOTE!!! query return value, not index
    final long[] a; // input data array copy
    long[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQValue(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQValue(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new long[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = a[i];
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = Math.max(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                } else {
                    d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                }
    }

    // i <= j, and index starts from 0.
    public long query(int i, int j) {
        int k = log2[j - i + 1];
        if (useMax) return Math.max(d[k][i], d[k][j - (1 << k) + 1]);
        else return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }
}

// Tested by 2827
// Similar: 1012, 2376, 902, 2719, 2801, 357, 1215, 1397
class DigitDP {
    static final boolean ENABLE_DEBUG_MODE = false; // TODO: set it to true if you want to print more debug info
    static final long UNSET = -1;
    // dp[isStart][hasLimit][pos] | [odd][even][r]
    // (isStart, hasLimit, pos) is generic, (odd, even, r) is use case specific
    long[][][][][][] dp;
    int K;

    public long digitDP(long num, int k) {
        String numString = String.valueOf(num); // TODO
        this.dp = new long[2][2][numString.length()][numString.length() + 1][numString.length() + 1][k];
        this.K = k;

        if (ENABLE_DEBUG_MODE) System.out.println(""num = "" + numString);
        ArrayUtils.fill(dp, UNSET);
        long ans = dfs(new StringBuilder(), numString, 1, 1, 0, 0, 0, 0);
        if (ENABLE_DEBUG_MODE) System.out.println(""---------------------\n"");
        return ans;
    }

    long dfs(StringBuilder curResult, String s, int isStart, int hasLimit, int pos, int odd, int even, int r) {
        if (pos == s.length()) {
            if (isStart == 1) return 0; // NOTE: special check for num == 0. TODO
            if (r == 0 && odd == even) { // TODO
                if (ENABLE_DEBUG_MODE) System.out.println(""result = "" + curResult);
                return 1;
            } else {
                return 0;
            }
        }
        if (dp[isStart][hasLimit][pos][odd][even][r] != UNSET) return dp[isStart][hasLimit][pos][odd][even][r];

        int start = 0;
        int end = (hasLimit == 1) ? s.charAt(pos) - '0' : 9; // TODO: check if it is binary string or not

        long ans = 0;
        for (int digit = start; digit <= end; digit++) {
            if (isStart == 1 && digit == 0) { // NOTE: handle leading zeros
                // [0, 999..9]
                // [0， 10^(len(s) - pos - 1) - 1]
                ans += dfs(new StringBuilder(), s, 1, 0, pos + 1, 0, 0, 0);
                continue;
            }
            int newHasLimit = (hasLimit == 1 && digit == s.charAt(pos) - '0') ? 1 : 0;

            int newOdd = odd + (digit % 2); // TODO
            int newEven = even + (digit % 2 == 0 ? 1 : 0); // TODO
            int newR = (isStart == 1 ? digit % this.K : (r * 10 + digit) % this.K); // TODO;

            if (ENABLE_DEBUG_MODE) curResult.append(digit);
            ans += dfs(curResult, s, 0, newHasLimit, pos + 1, newOdd, newEven, newR);
            if (ENABLE_DEBUG_MODE) curResult.deleteCharAt(curResult.length() - 1);

        }
        return dp[isStart][hasLimit][pos][odd][even][r] = ans;
    }
}

class Printer {
    static boolean ENABLE_LOCAL_PRINT = false;

    static void println(String x) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.println(x);
    }

    static void printf(String format, Object... args) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.printf(format, args);
    }
}


public class Solution {
    private static final int INF = 1_000_000_001;
    private static final long MOD = 1_000_000_007L;

    private static final int UNSET = -131;
    // 4 neighbors
    private static final int[] DX = {-1, 0, 1, 0}; // up, right, down, left
    private static final int[] DY = {0, 1, 0, -1};

    // 8 neighbors
    //    private static final int[] DX = {-1, -1, 0, 1, 1,  1, 0,  -1};
    //    private static final int[] DY = {0,   1, 1, 1, 0, -1, -1, -1};

    // knight
    //    private static final int[] DX = {-2, -2, -1, 1, 2, 2, 1, -1};
    //    private static final int[] DY = {-1, 1, 2, 2, 1, -1, -2, -2};

    static final int L = 1000;
    static int[] steps = new int[L];

    static {
        steps[1] = 0;
        for (int i = 2; i < L; i++) {
            int bitCount = Integer.bitCount(i);
            //if (bitCount > 1) {
            steps[i] = steps[bitCount] + 1;
            //}
        }
    }

    static Combination comb = new Combination(L, MOD);

    public int countKReducibleNumbers(String s, int k) {

        int n = s.length();

        long ans = 0;
        int curCount = 0;
        for (int i = 0; i < n; i++) {
            if (s.charAt(i) == '0') {
                continue;
            }
            int remainCount = n - i - 1;
            for (int j = 0; j <= remainCount; j++) {
                if (curCount + j == 0) continue;
                if (curCount + j == 1) {
                    ans = (ans + comb.C(remainCount, j)) % MOD;
                } else if (steps[curCount + j] + 1 <= k) {
                    ans = (ans + comb.C(remainCount, j)) % MOD;
                }
            }
            curCount++;
        }
        return (int) ans;
    }


    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        Printer.ENABLE_LOCAL_PRINT = true;
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */

//
//        System.out.println(new Solution().countKReducibleNumbers(""111100100100100100011111010000"", 5));
//
//// 16219592

        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        System.out.println((System.currentTimeMillis() - startTime) + ""ms"");
    }
}",1448257627
IphoneX,hahahiehie,169,3646,java,"import java.util.*;

class Utils {
    public static int log2(long n) {
        return 63 - Long.numberOfLeadingZeros(n);
    }

    // nums = ""aaabaaaba"" odd d[1] return [1, 2, 1, 4, 1, 2, 2]
    // d[0] for even, d[1] for odd
    public static int[][] manacher(String s) {
        int n = s.length();
        int[] d1 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; ++i) {
            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s.charAt(i - k) == s.charAt(i + k)) k++;
            d1[i] = k;
            if (i + k - 1 > r) {
                l = i - k + 1;
                r = i + k - 1;
            }
        }

        int[] d0 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : Math.min(d0[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s.charAt(i - k - 1) == s.charAt(i + k)) {
                k++;
            }
            d0[i] = k;
            if (i + k - 1 > r) {
                l = i - k;
                r = i + k - 1;
            }
        }
        return new int[][]{d0, d1};
    }

    // generate primes that is <= n
    public static int[] genPrimes(int n) {
        if (n <= 1) return new int[0];
        boolean[] isComp = new boolean[n + 1];
        int len = 0;
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                len++;
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                }
            }
        }
        int[] ans = new int[len];
        for (int i = 2, j = 0; i <= n; i++) {
            if (!isComp[i]) {
                ans[j++] = i;
            }
        }
        return ans;
    }

    // int[0] = primeFactor, int[1] = count of that primeFactor
    // NOTE: factors[0] and factors[1] are empty list.
    public static List<int[]>[] genPrimeFactors(int n) {
        List<int[]>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            factors[i] = new ArrayList<>();
        }
        boolean[] isComp = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                factors[i].add(new int[]{i, 1});
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                    int t = j, count = 0;
                    while (t % i == 0) {
                        count++;
                        t /= i;
                    }
                    factors[j].add(new int[]{i, count});
                }
            }
        }
        return factors;
    }

    // generate factors (not prime factors), factors[0] is empty list.
    public static List<Integer>[] genFactors(int n) {
        List<Integer>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) factors[i] = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j += i) {
                factors[j].add(i);
            }
        }
        return factors;
    }

    public static int lowerBound(int[] a, int target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(int[] a, int target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(long[] a, long target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(long[] a, long target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static long or(int x, int y) {
        return ((long) x << 32) | ((long) y << 32 >>> 32);
    }

    // k = 0...nums.length - 1
    // After calling this function, nums[k] is the k-th number.
    public static int kthNumber(int[] nums, int k) {
        return kthNumberHelper(nums, k, 0, nums.length - 1);
    }

    // end is inclusive (0 to nums.length - 1)
    private static int kthNumberHelper(int[] nums, int K, int start, int end) {
        if (start == end) return nums[start];
        int i = partition(nums, start, end);
        return K <= i ? kthNumberHelper(nums, K, start, i) : kthNumberHelper(nums, K, i + 1, end);
    }

    // end is inclusive (0 to nums.length - 1)
    public static int partition(int[] nums, int start, int end) {
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && nums[i] < pivot) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && pivot < nums[j]) j--;
            if (i < j) nums[i++] = nums[j];
        }

        // pos is the final position for pivot.
        nums[i] = pivot;
        return i;
    }

    public static void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    // partition nums into 3 parts [smaller than pivot, equal to pivot, larger than pivot]
    public static void partition3(int[] nums, int pivot) {
        int n = nums.length;
        int l = 0, r = n - 1;
        for (int i = 0; i <= r; i++) {
            if (nums[i] < pivot) {
                swap(nums, l++, i);
            } else if (nums[i] > pivot) {
                swap(nums, r--, i--);
            }
        }
    }

    // end is inclusive
    public static void reverse(int[] nums, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    }

    // Return false if next permutation is not available. (nums is not changed for this case)
    public static boolean nextPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] >= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] > nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // Return false if previous permutation is not available. (nums is not changed for this case)
    public static boolean prevPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] <= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] < nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }


    // a, b could be negative
    // remainder >= 0
    // return [a / b, a % b]
    public static int[] divMod(int a, int b) {
        int r = a % b;
        int c = a / b;
        if (r < 0) {
            r += Math.abs(b);
            c++;
        }
        return new int[]{c, r};
    }

    public static List<Integer> negativeBase(int n, int base) {
        List<Integer> digits = new ArrayList<>();
        if (n == 0) {
            digits.add(0);
            return digits;
        }
        while (n != 0) {
            // t[0] = n / base
            // t[1] = n % base;
            int[] t = divMod(n, base);
            digits.add(t[1]);
            n = t[0];
        }
        Collections.reverse(digits);
        return digits;
    }

    // (a ^ b) % MOD
    public static long powMod(long a, long b, long MOD) {
        long res = 1L;
        a %= MOD; // In case a * a is overflow
        while (b > 0) {
            if ((b & 1) != 0) res = (res * a) % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    public static long[][] genCombination(int n) {
        long[][] C = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        return C;
    }

    public static long[][] genPermutation(int n) {
        long[][] P = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
        return P;
    }

    public static long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }

    public static int[] preprocessLog2(int n) { // from log2(0) .... log2(n) inclusive
        int[] lg = new int[n + 1];
        for (int k = 0, i = 1; i <= n; lg[i++] = k - 1) {
            while ((1 << k) <= i) {
                k++;
            }
        }
        return lg;
    }

    public static long max(long[] nums) {
        long ret = Long.MIN_VALUE;
        for (long v : nums) ret = Math.max(ret, v);
        return ret;
    }

    public static int max(int[] nums) {
        int ret = Integer.MIN_VALUE;
        for (int v : nums) ret = Math.max(ret, v);
        return ret;
    }
}

// Tested by leetcode 1163
class SuffixArray {
    int[] s;
    int[] SA; // SA[i] => index of the i-th ranked suffix
    int[] rank; // rank[i] => the rank of i-th suffix, SA[rank[i]] == i
    int[] height; // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).

    private int[][] d;
    private int n;
    private int[] lg;

    private int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    private static int[] stringToIntArray(String str) {
        int[] nums = new int[str.length()];
        for (int i = 0; i < str.length(); i++) nums[i] = str.charAt(i);
        return nums;
    }

    public SuffixArray(String str) {
        this(str, true);
    }

    public SuffixArray(String str, boolean toBuildRMQ) {
        this(stringToIntArray(str), toBuildRMQ);
    }

    public SuffixArray(int[] nums) {
        this(nums, true);
    }

    public SuffixArray(int[] nums, boolean toBuildRMQ) {
        this.s = nums;
        this.n = nums.length;
        this.SA = new int[n];
        this.rank = new int[n];
        suffixSort(s);
        if (toBuildRMQ) {
            this.height = new int[n];
            this.d = new int[log2(n) + 1][n];
            this.lg = new int[n + 1];
            buildHeight();
            buildRMQ();
        }
    }

    // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).
    // ?? s[n] = 0 or s[n] = -INF.
    private void buildHeight() {
        int i, j, h;
        height[0] = 0;
        for (i = 0; i < n; i++)
            rank[SA[i]] = i;
        for (h = i = 0; i < n; i++)
            if (rank[i] > 0) {
                j = SA[rank[i] - 1];
                while (i + h < n && j + h < n && s[i + h] == s[j + h]) ++h;
                height[rank[i]] = h;
                if (h > 0) --h;
            }
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    private void buildRMQ() {
        int i, j, k;
        for (i = 0; i < n; i++)
            d[0][i] = height[i];
        for (j = 1; (1 << j) <= n; j++)
            for (i = 0; i + (1 << j) <= n; i++)
                d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
        for (lg[0] = k = 0, i = 1; i <= n; lg[i++] = k - 1)
            while ((1 << k) <= i) k++;
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    public int LCP(int i, int j) {
        if (i == j) return n - SA[i];
        if (i > j) {
            int t = i;
            i = j;
            j = t;
        }
        int k = lg[j - (++i) + 1];
        return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }

    // LCPIndex(i, j) = LCP(s[i], s[j])
    public int LCPIndex(int i, int j) {
        return LCP(rank[i], rank[j]);
    }

    private void sortIndex(int[] nums, int start, int end) {
        if (start >= end) return;
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && s[nums[i]] < s[pivot]) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && s[pivot] < s[nums[j]]) j--;
            if (i < j) nums[i++] = nums[j];
        }
        nums[i] = pivot; // index i is the final position for pivot.
        sortIndex(nums, start, i - 1);
        sortIndex(nums, i + 1, end);
    }

    private void suffixSort(int[] s) {
        int[] count = new int[n], t;
        int[] nSA = new int[n];
        int[] nRank = new int[n];
//        Integer[] tempArray = new Integer[n];
//        for (int x = 0; x < n; x++) tempArray[x] = x;
//        Arrays.sort(tempArray, (a, b) -> Integer.compare(s[a], s[b]));
//        for (int x = 0; x < n; x++) SA[x] = tempArray[x];
        int i, k;
        int minV = s[0], maxV = s[0];
        for (i = 1; i < n; i++) {
            minV = Math.min(minV, s[i]);
            maxV = Math.max(maxV, s[i]);
        }
        if ((long) maxV - minV + 1 <= (long) n) { // radix sort if alphabet size is small
            for (i = 0; i < n; i++) count[s[i] - minV]++;
            for (i = minV + 1; i <= maxV; i++) count[i - minV] += count[i - minV - 1];
            for (i = n - 1; i >= 0; i--) SA[--count[s[i] - minV]] = i;
        } else {
            for (i = 0; i < n; i++) SA[i] = i;
            sortIndex(SA, 0, n - 1);
        }
        for (rank[SA[0]] = 0, i = 1; i < n; i++) {
            rank[SA[i]] = (s[SA[i]] != s[SA[i - 1]]) ? rank[SA[i - 1]] + 1 : rank[SA[i - 1]];
        }
        for (k = 1; k < n && rank[SA[n - 1]] < n - 1; k <<= 1) {
            for (i = 0; i < n; i++) count[rank[SA[i]]] = i + 1;
            for (i = n - 1; i >= 0; i--) if (SA[i] >= k) nSA[--count[rank[SA[i] - k]]] = SA[i] - k;
            for (i = n - k; i < n; i++) nSA[--count[rank[i]]] = i;
            t = SA;
            SA = nSA;
            nSA = t;
            for (nRank[SA[0]] = 0, i = 1; i < n; i++) {
                nRank[SA[i]] = (SA[i] + k >= n || SA[i - 1] + k >= n || rank[SA[i]] != rank[SA[i - 1]] || rank[SA[i] + k] != rank[SA[i - 1] + k]) ? nRank[SA[i - 1]] + 1 : nRank[SA[i - 1]];
            }
            t = rank;
            rank = nRank;
            nRank = t;
        }
    }
}

class Combination {
    long[] factorial;
    long[] inverseFactorial;
    long MOD;

    // O(maxSize) for preprocessing
    // MOD must be prime
    public Combination(int maxSize, long MOD) {
        factorial = new long[maxSize + 1];
        inverseFactorial = new long[maxSize + 1];
        factorial[0] = 1;
        inverseFactorial[0] = 1;
        this.MOD = MOD;
        for (int i = 1; i <= maxSize; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
            inverseFactorial[i] = inverse(factorial[i]);
        }
    }

    // x, y are long[1]
    // ax + by = gcd(a, b)
    private long extGcd(long a, long b, long[] x, long[] y) {
        if (b == 0) {
            x[0] = 1;
            y[0] = 0;
            return a;
        } else {
            long r = extGcd(b, a % b, y, x);
            y[0] -= x[0] * (a / b);
            return r;
        }
    }

    // (a * x) % MOD = 1
    // x is the inverse element
    public long inverse(long a) {
        long[] x = new long[1], y = new long[1];
        extGcd(a, MOD, x, y);
        return (x[0] % MOD + MOD) % MOD;
    }

    // m >= n
    // O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        else if (m == n) return factorial[m];
            //return factorial[m] * inverse(factorial[m - n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD;
    }

    // m >= n
    // O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
            //return factorial[m] * inverse(factorial[m - n]) % MOD * inverse(factorial[n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD * inverseFactorial[n] % MOD;
    }
}

class CombinationNoMod {

    long[][] C;
    long[][] P;

    public CombinationNoMod(int maxSize) {
        C = new long[maxSize + 1][maxSize + 1];
        P = new long[maxSize + 1][maxSize + 1];
        int m = C.length;
        int n = C[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
    }

    // m >= n. O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        return P[m][n];
    }

    // m >= n. O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
        return C[m][n];
    }
}

class Fraction {
    long n, d; // n / d (d != 0)

    public Fraction(long n, long d) {
        if (d == 0) {
            this.n = Long.MAX_VALUE;
            this.d = 1;
            return;
        }
        long g = gcd(Math.abs(n), Math.abs(d));
        this.n = n / g;
        this.d = d / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    public void add(Fraction other) {
        long numerator = this.n * other.d + this.d * other.n;
        long denominator = this.d * other.d;
        long g = gcd(Math.abs(numerator), Math.abs(denominator));
        this.n = numerator / g;
        this.d = denominator / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    @Override
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof Fraction) {
            Fraction anotherObject = (Fraction) anObject;
            return n == anotherObject.n && d == anotherObject.d;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return (int) (n * 31 + d);
    }

    private long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }
}

class UnionFind {
    int[] parent;
    int[] sz;

    // from 0 ... n - 1
    public UnionFind(int n) {
        parent = new int[n];
        sz = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public void clear() {
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public int find(int x) {
        //return parent[x] == x ? x : (parent[x] = find(parent[x]));
        if (parent[x] == x) return x;
        int px = x;
        while (px != parent[px]) px = parent[px];
        while (x != px) {
            int next = parent[x];
            parent[x] = px;
            x = next;
        }
        return px;
    }

    // px is the final parent
    public boolean union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return false;
        parent[py] = px;
        sz[px] += sz[py];
        return true;
    }

    public int size(int x) {
        return sz[find(x)];
    }

    public UnionFind clone() {
        UnionFind cloned = new UnionFind(parent.length);
        for (int i = 0; i < parent.length; i++) {
            cloned.parent[i] = parent[i];
            cloned.sz[i] = sz[i];
        }
        return cloned;
    }
}

class Trie {
    static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        boolean isWord = false;
        long count = 0L;
    }

    TrieNode root = new TrieNode();

    public void add(String word) {
        add(word, 1L);
    }

    public void remove(String word) {
        add(word, -1L);
    }

    private void add(String word, long count) {
        TrieNode cur = root;
        cur.count += count;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) cur.next[c] = new TrieNode();
            cur = cur.next[c];
            cur.count += count;
        }
        cur.isWord = true;
    }

    public boolean contains(String word) {
        TrieNode cur = root;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null || cur.next[c].count <= 0L) return false;
            cur = cur.next[c];
            //if (cur.isWord) return true;
        }
        return cur.isWord;
    }
}

// Tested by Leetcode 1707 and Leetcode 1803
class TrieBinary {
    static class TrieNode {
        TrieNode[] next = new TrieNode[2];
        long count;
    }

    private TrieNode root;
    private int numOfBits;

    public TrieBinary(int numOfBits) { // normally 31 for int and 63 for long
        this.numOfBits = numOfBits;
        this.root = new TrieNode();
    }

    public void add(long v) {
        add(v, 1L);
    }

    public void remove(long v) { // Tested by Leetcode 1938
        add(v, -1L);
    }

    public void add(long v, long count) {
        TrieNode cur = root;
        root.count += count;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null) cur.next[b] = new TrieNode();
            cur = cur.next[b];
            cur.count += count;
        }
    }

    // Tested by Leetcode 1707
    public long xorMax(long v) {
        TrieNode cur = root;
        long key = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[1 - b] != null && cur.next[1 - b].count > 0) {
                cur = cur.next[1 - b];
                key |= (1L - b) << i;
            } else {
                cur = cur.next[b];
                key |= (long) b << i;
            }
        }
        return key ^ v;
    }

    public boolean contains(long v) {
        TrieNode cur = root;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null || cur.next[b].count <= 0) return false;
            cur = cur.next[b];
        }
        return true;
    }

    // Tested by Leetcode 1803
    // count(x ^ v <= limit)
    public long xorLessOrEqualCount(long v, long limit) {
        if (limit < 0) return 0;
        TrieNode cur = root;
        long ans = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int bitLimit = ((limit >>> i) & 1) == 0 ? 0 : 1;
            int bitV = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (bitLimit == 1) {
                ans += (cur.next[bitV] != null ? cur.next[bitV].count : 0);
            }
            cur = cur.next[bitV ^ bitLimit];
            if (cur == null) break;
            if (i == 0) ans += cur.count;
        }
        return ans;
    }
}

// Lazy execution example is in https://leetcode.com/submissions/detail/1034182539/
// Refer to AlgorithmCompilation.java

// [Template] Classic Segment Tree (Range Sum), used for Template
class ClassicSegmentTree { // For Range Sum
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final int L, R;

    public ClassicSegmentTree(int[] input) {
        L = 0;
        R = input.length - 1;
        root = new TreeNode();
        build(root, L, R, input);
    }

    private void build(TreeNode root, int l, int r, int[] input) {
        if (l == r) {
            root.sum = input[l];
            return;
        }
        int m = (l + r) >> 1;
        root.left = new TreeNode();
        root.right = new TreeNode();
        build(root.left, l, m, input);
        build(root.right, m + 1, r, input);
        root.sum = root.left.sum + root.right.sum;
    }

    public void set(int index, int value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, int L, int R, int index, int value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        int M = L + ((R - L) >> 1);
        if (index <= M) {
            set(root.left, L, M, index, value);
        } else {
            set(root.right, M + 1, R, index, value);
        }
        root.sum = root.left.sum + root.right.sum;
    }

    // Sum[queryL...queryR] inclusive
    public long query(int queryL, int queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, int L, int R, int queryL, int queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        int M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 307
class DynamicSegmentTreeRangeSum {
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeSum(long l, long r) {
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return sum(cur);
    }

    public void add(long index, long value) {
        set(index, get(index) + value);
    }

    private long sum(TreeNode node) {
        return node == null ? 0L : node.sum;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.sum = sum(root.left) + sum(root.right);
    }

    // Sum[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        long M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 239, 2926
class DynamicSegmentTreeRangeMax {
    class TreeNode {
        TreeNode left, right;
        long max = Long.MIN_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMax(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return max(cur);
    }

    private long max(TreeNode node) {
        return node == null ? Long.MIN_VALUE : node.max;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.max = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.max = Math.max(max(root.left), max(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MIN_VALUE;
        if (queryL <= L && R <= queryR) return root.max;
        long M = L + ((R - L) >> 1);
        return Math.max(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class DynamicSegmentTreeRangeMin {
    class TreeNode {
        TreeNode left, right;
        long min = Long.MAX_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMin(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return min(cur);
    }

    private long min(TreeNode node) {
        return node == null ? Long.MAX_VALUE : node.min;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.min = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.min = Math.min(min(root.left), min(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MAX_VALUE;
        if (queryL <= L && R <= queryR) return root.min;
        long M = L + ((R - L) >> 1);
        return Math.min(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class BinaryIndexTree {
    private long[] c;
    private int n;

    // NOTE: index is from 1 to n. (NOT 0 ... n - 1)
    public BinaryIndexTree(int n) {
        this.n = n;
        this.c = new long[n + 1];
    }

    // Add value to position k, k is from 1 to n.
    public void add(int k, long value) {
        while (k <= n) {
            c[k] += value;
            k += (k & (k ^ (k - 1)));
        }
    }

    // k is from 1 to n.
    public long getSum(int k) {
        long sum = 0;
        while (k > 0) {
            sum += c[k];
            k -= (k & (k ^ (k - 1)));
        }
        return sum;
    }
}

class RangeSum {
    BinaryIndexTree tree;
    int start;

    // [low, high] inclusive
    public RangeSum(int low, int high) {
        start = low;
        tree = new BinaryIndexTree(high - low + 1);
    }

    public void add(int index, long value) {
        tree.add(index - start + 1, value);
    }

    public long get(int index) {
        return tree.getSum(index - start + 1) - tree.getSum(index - start);
    }

    public void set(int index, long value) {
        tree.add(index - start + 1, value - get(index));
    }

    // [l, r] inclusive
    public long getSum(int l, int r) {
        return tree.getSum(r - start + 1) - tree.getSum(l - start);
    }
}

class RangeMax {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMax(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MIN_VALUE);
    }

    public RangeMax(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.max(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMax(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MIN_VALUE, resr = Long.MIN_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.max(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.max(t[--r], resr);
        }
        return Math.max(resl, resr);
    }
}

class RangeMin {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMin(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MAX_VALUE);
    }

    public RangeMin(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.min(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMin(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MAX_VALUE, resr = Long.MAX_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.min(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.min(t[--r], resr);
        }
        return Math.min(resl, resr);
    }
}

// Including topological sort.
class GraphIntegerFaster {
    public List<Integer>[] adj;

    public GraphIntegerFaster(int n) {
        adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    // directed edge x -> y
    public void link(int x, int y) {
        adj[x].add(y);
    }

    public List<Integer> getChildren(int x) {
        return adj[x];
    }

    private static final int TEMPORARY = 1;
    private static final int PERMANENT = 2;

    // x -> y means x should be processed before y
    // The input is a directed graph.
    // 1. return null, means there is a cycle inside the graph, or the input is
    // invalid.
    // 2. return List<Node> as the result.
    public List<Integer> topologicalSort() {
        //Map<E, Integer> vst = new HashMap<>();
        int n = adj.length;
        int[] vst = new int[n];
        List<Integer> result = new ArrayList<>();
        for (int x = 0; x < n; x++) {
            if (!topologicalSort(x, vst, result)) {
                return null;
            }
        }
        Collections.reverse(result);
        return result;
    }

    private boolean topologicalSort(int root, int[] vst, List<Integer> result) {
        if (vst[root] == PERMANENT) {
            return true;
        }
        if (vst[root] == TEMPORARY) { // found cycle
            return false;
        }

        vst[root] = TEMPORARY;
        for (int child : getChildren(root)) {
            if (!topologicalSort(child, vst, result)) {
                return false;
            }
        }
        result.add(root);
        vst[root] = PERMANENT;
        return true;
    }
}

class DijkstraLongFaster {
    public static class Edge {
        int to;
        long w;

        public Edge(int to, long w) {
            this.to = to;
            this.w = w;
        }
    }

    public static final long INF = Long.MAX_VALUE / 4;
    public List<Edge>[] adj;

    public DijkstraLongFaster(int n) {
        this.adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    public void link(int x, int y, long w) {
        adj[x].add(new Edge(y, w));
    }

    public long[] shortestPath(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
        q.add(new Edge(src, 0));
        dist[src] = 0;

        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (vst[cur.to]) continue;
            int u = cur.to;
            long w = cur.w;
            vst[u] = true;

            for (Edge e : adj[u]) {
                if (!vst[e.to] && dist[e.to] > w + e.w) {
                    dist[e.to] = w + e.w;
                    q.add(new Edge(e.to, dist[e.to]));
                }
            }
        }
        return dist;
    }

    // NOTE: w of each edge must be the same.
    public long[] bfs(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        Queue<Integer> q = new ArrayDeque<>();
        q.add(src);
        dist[src] = 0;
        vst[src] = true;

        while (!q.isEmpty()) {
            int u = q.poll();
            long w = dist[u];
            for (Edge e : adj[u]) {
                if (!vst[e.to]) {
                    dist[e.to] = w + e.w;
                    vst[e.to] = true;
                    q.add(e.to);
                }
            }
        }
        return dist;
    }
}

class TreapSet<E> {
    private class Node {
        E key;
        int priority, count, total;
        Node left, right, pnt;

        public Node(E key, int priority, Node pnt) {
            this.key = key;
            this.priority = priority;
            this.pnt = pnt;
            this.count = 1;
            this.total = 1;
        }
    }

    private static final Random RANDOM = new Random();
    private final Comparator<? super E> comparator;
    private Node root;

    public TreapSet(Comparator<? super E> comparator) {
        this.comparator = comparator;
    }

    public boolean isEmpty() {
        return root == null;
    }

    public void clear() {
        root = null;
    }

    public int size() {
        return root == null ? 0 : root.total;
    }

    private int leftRank(Node p) {
        return p.left != null ? p.left.total : 0;
    }

    private int rightRank(Node p) {
        return p.right != null ? p.right.total : 0;
    }

    private void rotateLeft(Node x) {
        Node y = x.right;
        if ((x.right = y.left) != null) y.left.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.left) x.pnt.left = y;
        else x.pnt.right = y;
        y.left = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    private void rotateRight(Node x) {
        Node y = x.left;
        if ((x.left = y.right) != null) y.right.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.right) x.pnt.right = y;
        else x.pnt.left = y;
        y.right = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    public void add(E key) {
        if (root == null) {
            root = new Node(key, RANDOM.nextInt(), null);
            return;
        }
        Node x = root, p = null;
        while (x != null) {
            ++((p = x).total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                ++(x.count);
                return;
            }
        }

        x = new Node(key, RANDOM.nextInt(), p);
        if (comparator.compare(key, p.key) < 0) p.left = x;
        else p.right = x;
        while ((p = x.pnt) != null && p.priority < x.priority) {
            if (p.left == x) rotateRight(p);
            else rotateLeft(p);
        }
    }

    public void remove(E key) {
        Node x = root, p = null;
        while (x != null) {
            --(x.total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                if (--(x.count) > 0) return;
                break;
            }
        }
        if (x == null) return;
        while (x.left != null || x.right != null) {
            if (x.left == null || (x.right != null && x.right.priority > x.left.priority)) {
                rotateLeft(x);
            } else {
                rotateRight(x);
            }
        }
        if ((p = x.pnt) != null) {
            if (p.left == x) p.left = null;
            else p.right = null;
        } else {
            root = null;
        }
        // delete x;
    }

    // number of elements smaller than key
    public int lowerCount(E key) {
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                sum += leftRank(x) + x.count;
                x = x.right;
            } else {
                sum += leftRank(x);
                break;
            }
        }
        return sum;
    }

    // number of elements larger than key
    public int higherCount(E key) {
        //return size() - lowerCount(key) - count(key);
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp > 0) x = x.right;
            else if (cmp < 0) {
                sum += rightRank(x) + x.count;
                x = x.left;
            } else {
                sum += rightRank(x);
                break;
            }
        }
        return sum;
    }

    public int index(E key) {
        return lowerCount(key);
    }

    public E get(int index) // index = 0 ... size - 1
    {
        Node p = root;
        ++index;
        while (true) {
            int t = leftRank(p);
            if (index <= t) p = p.left;
            else {
                if ((index -= t + p.count) <= 0) break;
                p = p.right;
            }
        }
        return p.key;
    }

    public int count(E key) {
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                x = x.right;
            } else {
                return x.count;
            }
        }
        return 0;
    }

    public E first() {
        if (root == null) return null;
        Node x = root;
        while (x.left != null) {
            x = x.left;
        }
        return x.key;
    }

    public E last() {
        if (root == null) return null;
        Node x = root;
        while (x.right != null) {
            x = x.right;
        }
        return x.key;
    }

    public boolean contains(E key) {
        return count(key) > 0;
    }

    public E ceiling(E key) {
        int id = lowerCount(key);
        return id >= size() ? null : get(id);
    }

    public E floor(E key) {
        int id = size() - higherCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E lower(E key) {
        int id = lowerCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E higher(E key) {
        int id = size() - higherCount(key);
        return id >= size() ? null : get(id);
    }

    // return the first index whose value >= target
    // if this value doesn't exist, return index = size()
    public int lowerBound(E target) {
        return lowerCount(target);
    }

    // return the first index whose value > target
    // if this value doesn't exist, return index = size()
    public int upperBound(E target) {
        return size() - higherCount(target);
    }

    public List<E> keys() {
        List<E> list = new ArrayList<>();
        inorder(root, list);
        return list;
    }

    private void inorder(Node x, List<E> list) {
        if (x == null) return;
        inorder(x.left, list);
        list.add(x.key);
        inorder(x.right, list);
    }
}

class ArraySum {
    long[] sum;
    int n;

    // nums index starts from 0 to nums.length - 1;
    public ArraySum(int[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    public ArraySum(long[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    // [l, r], index starts from 0
    public long getSum(int l, int r) {
        // error handling
        if (l > r || !(l >= 0 && l < n && r >= 0 && r < n)) return 0L;
        return sum[r + 1] - sum[l];
    }
}

class TwoDArraySum {
    int[][] sum;
    int m, n;

    // nums index starts from 0
    public TwoDArraySum(final int[][] nums) {
        m = nums.length;
        n = nums[0].length;
        sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + nums[i - 1][j - 1];
            }
        }
    }

    // [(x1, y1), (x2, y2)], index starts from 0
    // x1 <= x2 and y1 <= y2
    public int getSum(int x1, int y1, int x2, int y2) {
        if (!(x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && x2 >= 0 && x2 < m && y2 >= 0 && y2 < n) || x1 > x2 || y1 > y2)
            return 0;
        return sum[x2 + 1][y2 + 1] - sum[x2 + 1][y1] - sum[x1][y2 + 1] + sum[x1][y1];
    }
}

class ArrayUtils {
    static void fill(int[] array, int defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(int[][] array, int defaultValue) {
        for (int[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(int[][][] array, int defaultValue) {
        for (int[][] a2 : array) {
            for (int[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(int[][][][] array, int defaultValue) {
        for (int[][][] a3 : array) {
            for (int[][] a2 : a3) {
                for (int[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(int[][][][][] array, int defaultValue) {
        for (int[][][][] a4 : array) {
            for (int[][][] a3 : a4) {
                for (int[][] a2 : a3) {
                    for (int[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(int[][][][][][] array, int defaultValue) {
        for (int[][][][][] a5 : array) {
            for (int[][][][] a4 : a5) {
                for (int[][][] a3 : a4) {
                    for (int[][] a2 : a3) {
                        for (int[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }

    static void fill(long[] array, long defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(long[][] array, long defaultValue) {
        for (long[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(long[][][] array, long defaultValue) {
        for (long[][] a2 : array) {
            for (long[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(long[][][][] array, long defaultValue) {
        for (long[][][] a3 : array) {
            for (long[][] a2 : a3) {
                for (long[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(long[][][][][] array, long defaultValue) {
        for (long[][][][] a4 : array) {
            for (long[][][] a3 : a4) {
                for (long[][] a2 : a3) {
                    for (long[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(long[][][][][][] array, long defaultValue) {
        for (long[][][][][] a5 : array) {
            for (long[][][][] a4 : a5) {
                for (long[][][] a3 : a4) {
                    for (long[][] a2 : a3) {
                        for (long[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }
}

class CharacterUtils {
    static boolean[] vowel = new boolean[128];

    static {
        vowel['a'] = vowel['e'] = vowel['i'] = vowel['o'] = vowel['u'] = true;
        vowel['A'] = vowel['E'] = vowel['I'] = vowel['O'] = vowel['U'] = true;
    }

    static boolean isVowel(char ch) {
        return vowel[ch];
    }

    static boolean isLetter(char ch) {
        return ((ch - 'a') >= 0 && (ch - 'a') < 26) ||
                ((ch - 'A') >= 0 && (ch - 'A') < 26);
    }

    static boolean isLowerCase(char ch) {
        return (ch - 'a') >= 0 && (ch - 'a') < 26;
    }

    static boolean isUpperCase(char ch) {
        return (ch - 'A') >= 0 && (ch - 'A') < 26;
    }

    static boolean isDigit(char ch) {
        return (ch - '0') >= 0 && (ch - '0') <= 9;
    }
}

class DoubleUtils {
    private static final double EPS = 1e-8;

    public static int compare(double a, double b) {
        if (a - b > EPS) return 1;
        else if (a - b < -EPS) return -1;
        else return 0;
    }

    public static boolean isInteger(double a) {
        return compare(floor(a), a) == 0;
    }

    public static double floor(double a) {
        return Math.floor(a + EPS);
    }

    public static double ceil(double a) {
        return Math.ceil(a - EPS);
    }
}

class MatrixUtils {
    static final long MOD = 1_000_000_007L;

    // matrix[n][n], matrix[i][i] = 1
    static long[][] genIdentityMatrix(int n) {
        long[][] matrix = new long[n][n];
        for (int i = 0; i < n; i++) matrix[i][i] = 1;
        return matrix;
    }

    static long[][] multiply(long[][] a, long[][] b, long MOD) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]) % MOD;
                }
            }
        }
        return res;
    }

    static long[][] multiply(long[][] a, long[][] b) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]);
                }
            }
        }
        return res;
    }

    // a^b % MOD
    static long[][] powMod(long[][] a, long b, long MOD) {
        int n = a.length;
        long[][] res = genIdentityMatrix(n);
        while (b > 0) {
            if ((b & 1) != 0) res = multiply(res, a, MOD);
            a = multiply(a, a, MOD);
            b >>= 1;
        }
        return res;
    }

    static void print(long[][] matrix) {
        for (int i = 0; i < matrix.length; i++) {
            System.out.println(Arrays.toString(matrix[i]));
        }
    }
}

class IntegerUtils {
    static long[] power10 = new long[19]; // 10^i

    static {
        power10[0] = 1L;
        for (int i = 1; i < power10.length; i++) {
            power10[i] = power10[i - 1] * 10;
        }
    }

    // swap index i and j of integer (long) num. i == 0 means the lowest position.
    static long swapDigit(long num, int i, int j) {
        if (i == j) return num;
        long di = num / power10[i] % 10L;
        long dj = num / power10[j] % 10L;
        return num - di * power10[i] - dj * power10[j] + dj * power10[i] + di * power10[j];
    }
}

class StringUtils {
    // This function is deprecated, please hash(int l, int r) in class StableStringHash or StringHash
    // rolling hash of substrings of 's' with length == k
    // long[pos] = hash(s.substring(pos, pos + k))
    public static long[] rollingHash(String s, int k) {
        long[] ans = new long[s.length() - k + 1];
        int seed1 = 31;
        int seed2 = 131;
        int h1 = 0, h2 = 0, power1 = 1, power2 = 1;
        for (int i = 0; i < k; i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);

            power1 *= seed1;
            power2 *= seed2;
        }

        ans[0] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        for (int i = k; i < s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i) - power1 * s.charAt(i - k);
            h2 = h2 * seed2 + s.charAt(i) - power2 * s.charAt(i - k);
            ans[i - k + 1] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        }

        return ans;
    }

    public static int[] kmpNext(String s) {
        int n = s.length();
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s.charAt(i) != s.charAt(k)) k = next[k - 1];
            if (s.charAt(i) == s.charAt(k)) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(String s, String p) {
        int[] next = kmpNext(p);
        int n = s.length();
        int m = p.length();
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p.charAt(j) != s.charAt(i)) {
                j = next[j - 1];
            }
            if (p.charAt(j) == s.charAt(i)) j++;
            if (j == m) return true;
        }
        return false;
    }

    public static int[] kmpNext(int[] s) {
        int n = s.length;
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s[i] != s[k]) k = next[k - 1];
            if (s[i] == s[k]) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(int[] s, int[] p) {
        int[] next = kmpNext(p);
        int n = s.length;
        int m = p.length;
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p[j] != s[i]) {
                j = next[j - 1];
            }
            if (p[j] == s[i]) j++;
            if (j == m) return true;
        }
        return false;
    }

    // Z[i] = longest length of common prefix of str[0 ... n - 1] and str[i ... n - 1]
    // Tested by LC2223, LC459
    public static int[] zFunction(String str) {
        int n = str.length();
        int[] Z = new int[n];
        // [L,R] makes a window which matches with prefix of s
        int L = 0, R = 0;
        Z[0] = n;
        for (int i = 1; i < n; ++i) {
            if (i > R) {
                L = R = i;
                while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                Z[i] = R - L;
                R--;
            } else {
                int k = i - L;
                if (Z[k] < R - i + 1) {
                    Z[i] = Z[k];
                } else {
                    L = i;
                    while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                    Z[i] = R - L;
                    R--;
                }
            }
        }
        return Z;
    }
}

// Better to use this when length of string >= 2^11
class StringHash {
    static class SingleStringHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleStringHash(String s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length();
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s.charAt(i - 1)) % MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleStringHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L;

    public StringHash(String s) {
        hash1 = new SingleStringHash(s, SEED1, MOD);
        hash2 = new SingleStringHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(String s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length(); i++) {
            h1 = (h1 * SEED1 + s.charAt(i)) % MOD;
            h2 = (h2 * SEED2 + s.charAt(i)) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(char[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class IntegerArrayHash {
    static class SingleIntegerArrayHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleIntegerArrayHash(int[] s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length;
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s[i - 1]) % MOD;
                if (h[i] < 0) h[i] += MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleIntegerArrayHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L; // or 1_000_000_123L

    public IntegerArrayHash(int[] s) {
        hash1 = new SingleIntegerArrayHash(s, SEED1, MOD);
        hash2 = new SingleIntegerArrayHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(int[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(List<Integer> s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.size(); i++) {
            h1 = (h1 * SEED1 + s.get(i)) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s.get(i)) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class RMQ { // NOTE!!! query return index, not value
    // tested by LC 1438,239
    final long[] a; // input data array copy
    int[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQ(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQ(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new int[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = i;
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = a[d[j - 1][i]] >= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                } else {
                    d[j][i] = a[d[j - 1][i]] <= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                }
    }

    // i <= j, and index starts from 0.
    public int query(int i, int j) { // NOTE!!! return index, not value
        int k = log2[j - i + 1];
        if (useMax) return a[d[k][i]] >= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
        else return a[d[k][i]] <= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
    }
}

class RMQValue { // NOTE!!! query return value, not index
    final long[] a; // input data array copy
    long[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQValue(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQValue(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new long[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = a[i];
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = Math.max(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                } else {
                    d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                }
    }

    // i <= j, and index starts from 0.
    public long query(int i, int j) {
        int k = log2[j - i + 1];
        if (useMax) return Math.max(d[k][i], d[k][j - (1 << k) + 1]);
        else return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }
}

// Tested by 2827
// Similar: 1012, 2376, 902, 2719, 2801, 357, 1215, 1397
class DigitDP {
    static final boolean ENABLE_DEBUG_MODE = false; // TODO: set it to true if you want to print more debug info
    static final long UNSET = -1;
    // dp[isStart][hasLimit][pos] | [odd][even][r]
    // (isStart, hasLimit, pos) is generic, (odd, even, r) is use case specific
    long[][][][][][] dp;
    int K;

    public long digitDP(long num, int k) {
        String numString = String.valueOf(num); // TODO
        this.dp = new long[2][2][numString.length()][numString.length() + 1][numString.length() + 1][k];
        this.K = k;

        if (ENABLE_DEBUG_MODE) System.out.println(""num = "" + numString);
        ArrayUtils.fill(dp, UNSET);
        long ans = dfs(new StringBuilder(), numString, 1, 1, 0, 0, 0, 0);
        if (ENABLE_DEBUG_MODE) System.out.println(""---------------------\n"");
        return ans;
    }

    long dfs(StringBuilder curResult, String s, int isStart, int hasLimit, int pos, int odd, int even, int r) {
        if (pos == s.length()) {
            if (isStart == 1) return 0; // NOTE: special check for num == 0. TODO
            if (r == 0 && odd == even) { // TODO
                if (ENABLE_DEBUG_MODE) System.out.println(""result = "" + curResult);
                return 1;
            } else {
                return 0;
            }
        }
        if (dp[isStart][hasLimit][pos][odd][even][r] != UNSET) return dp[isStart][hasLimit][pos][odd][even][r];

        int start = 0;
        int end = (hasLimit == 1) ? s.charAt(pos) - '0' : 9; // TODO: check if it is binary string or not

        long ans = 0;
        for (int digit = start; digit <= end; digit++) {
            if (isStart == 1 && digit == 0) { // NOTE: handle leading zeros
                // [0, 999..9]
                // [0， 10^(len(s) - pos - 1) - 1]
                ans += dfs(new StringBuilder(), s, 1, 0, pos + 1, 0, 0, 0);
                continue;
            }
            int newHasLimit = (hasLimit == 1 && digit == s.charAt(pos) - '0') ? 1 : 0;

            int newOdd = odd + (digit % 2); // TODO
            int newEven = even + (digit % 2 == 0 ? 1 : 0); // TODO
            int newR = (isStart == 1 ? digit % this.K : (r * 10 + digit) % this.K); // TODO;

            if (ENABLE_DEBUG_MODE) curResult.append(digit);
            ans += dfs(curResult, s, 0, newHasLimit, pos + 1, newOdd, newEven, newR);
            if (ENABLE_DEBUG_MODE) curResult.deleteCharAt(curResult.length() - 1);

        }
        return dp[isStart][hasLimit][pos][odd][even][r] = ans;
    }
}

class Printer {
    static boolean ENABLE_LOCAL_PRINT = false;

    static void println(String x) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.println(x);
    }

    static void printf(String format, Object... args) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.printf(format, args);
    }
}


public class Solution {
    private static final int INF = 1_000_000_001;
    private static final long MOD = 1_000_000_007L;

    private static final int UNSET = -131;
    // 4 neighbors
    private static final int[] DX = {-1, 0, 1, 0}; // up, right, down, left
    private static final int[] DY = {0, 1, 0, -1};

    // 8 neighbors
    //    private static final int[] DX = {-1, -1, 0, 1, 1,  1, 0,  -1};
    //    private static final int[] DY = {0,   1, 1, 1, 0, -1, -1, -1};

    // knight
    //    private static final int[] DX = {-2, -2, -1, 1, 2, 2, 1, -1};
    //    private static final int[] DY = {-1, 1, 2, 2, 1, -1, -2, -2};

    public int sumOfGoodSubsequences(int[] nums) {
        final int L = Utils.max(nums);
        int n = nums.length;
        long[] count = new long[L + 1];
        long[] sum = new long[L + 1];

        long ans = 0;
        for (int i = 0; i < n; i++) {
            int v = nums[i];
            long prevSum = 0;
            long prevCount = 0;
            if (v - 1 >= 0) {

                //prevSum = (prevSum + sum[v - 1] + count[v - 1] * v) % MOD;
                //prevCount = (prevCount + count[v - 1]);
                ans = (ans + sum[v - 1] + count[v - 1] * v) % MOD;
                sum[v] = (sum[v] + sum[v - 1] + count[v - 1] * v) % MOD;
                count[v] = (count[v] + count[v - 1]);

            }
            if (v + 1 <= L) {
                ans = (ans + sum[v + 1] + count[v + 1] * v) % MOD;
                sum[v] = (sum[v] + sum[v + 1] + count[v + 1] * v) % MOD;
                count[v] = (count[v] + count[v + 1]);
            }
            
            ans = (ans + v) % MOD;
            sum[v] = (sum[v] + v) %MOD;
            count[v] = (count[v] + 1) % MOD;
        }
        return (int) ans;
    }


    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        Printer.ENABLE_LOCAL_PRINT = true;
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */





        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        System.out.println((System.currentTimeMillis() - startTime) + ""ms"");
    }
}",1448212261
otto,_otto,170,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        
        def ok(idx):
            tmp = nums[idx: idx + 2 * k]
            #print(tmp)
            if len(tmp) < 2 * k:
                return False
            for i in range(1, k):
                if tmp[i] - tmp[i - 1] <= 0:
                    return False
            for i in range(k + 1, 2 * k):
                if tmp[i] - tmp[i - 1] <= 0:
                    return False
            return True
        for i in range(n):
            if ok(i):
                return True
        return False",1448182374
otto,_otto,170,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        
        n = len(nums)
        lo = 1
        hi = n // 2
        tmp = [1] * n
        for i in range(n - 2, -1, -1):
            if nums[i] < nums[i + 1]:
                tmp[i] = tmp[i + 1] + 1
            else:
                tmp[i] = 1
                    
        while lo < hi:
            mid = hi - (hi - lo) // 2
            ok = False
            for a in range(n - 2 * mid + 1):
                if tmp[a] >= mid and tmp[a + mid] >= mid:
                    ok = True
            if ok:
                lo = mid
            else:
                hi = mid - 1
        return lo",1448192372
otto,_otto,170,3631,python3,"f = [100] * 801
f[1] = 0
for i in range(2, 801):
    f[i] = 1 + f[i.bit_count()]
class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        if s == '0': return 0
        n = len(s)
        MOD = int(1e9 + 7)
        @cache
        def dfs(pos, cnt, up, started):
            if pos == n:
                return int(started and (not up) and (1 + f[cnt]) <= k)
            ans = 0
            max_digit = int(s[pos]) if up else 1
            for digit in range(0, max_digit + 1):
                new_ok = up and (digit == max_digit)
                ok = started or (digit == 1)
                new_cnt = cnt + digit if ok else cnt
                ans += dfs(pos + 1, new_cnt, new_ok, ok)
                ans %= MOD
            return ans
        ans = dfs(0, 0, True, False) % MOD
        dfs.cache_clear()
        return ans",1448257706
otto,_otto,170,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        MOD = int(1e9 + 7)
        cnt = defaultdict(int)
        sm = defaultdict(int)
        ans = 0

        for num in nums:
            curr = num
            fuck = 1
            if (num - 1) in cnt:
                curr += sm[num - 1] + cnt[num - 1] * num
                curr %= MOD
                fuck += cnt[num - 1]
                fuck %= MOD

            if (num + 1) in cnt:
                curr += sm[num + 1] + cnt[num + 1] * num
                curr %= MOD
                fuck += cnt[num + 1]
                fuck %= MOD


            sm[num] += curr
            cnt[num] += fuck
            sm[num] %= MOD
            cnt[num] %= MOD

            ans += curr
            ans %= MOD

        return ans",1448213780
Md Abedin,MdAbedin,172,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        return any(all(a < b for a,b in pairwise(nums[i:i+k])) and all(a < b for a,b in pairwise(nums[i+k:i+2*k])) for i in range(len(nums)-2*k+1))",1448181368
Md Abedin,MdAbedin,172,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        ss = [1]
        p = -1
        ans = 1
        
        for a,b in pairwise(nums):
            if b > a:
                ss.append(ss[-1]+1)
            else:
                p = ss[-1]
                ss.append(1)

            ans = max(ans,min(ss[-1],p),ss[-1]//2)

        return ans",1448186037
Md Abedin,MdAbedin,172,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        mod = 10**9+7
        dp = [0]*(len(s)+1)
        eq = 0
        
        for c in s:
            dp2 = [0]*(len(s)+1)
            
            if c == ""1"":
                eq += 1
                dp2[eq-1] += 1
                dp2[eq-1] %= mod

            for i in range(len(dp)):
                for i2 in [i,i+1]:
                    if i2 == len(dp2): continue
                    dp2[i2] += dp[i]
                    dp2[i2] %= mod
            
            dp = dp2

        ans = 0
        
        for b in range(1,len(dp)):
            b2 = b
            for _ in range(k-1): b2 = b2.bit_count()
            
            if b2 == 1:
                ans += dp[b]
                ans %= mod

        return ans",1448265322
Md Abedin,MdAbedin,172,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        mod = 10**9+7
        dp1 = Counter()
        dp2 = Counter()
        ans = 0

        for num in nums:
            ans += dp2[num+1]+dp2[num-1] + num*(dp1[num+1]+dp1[num-1]+1)
            ans %= mod
            dp2[num] += dp2[num+1]+dp2[num-1] + num*(dp1[num+1]+dp1[num-1]+1)
            dp2[num] %= mod
            dp1[num] += dp1[num+1]+dp1[num-1]+1
            dp1[num] %= mod

        return ans",1448203332
Ritik Rathor,ritik_369,174,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
      int n = nums.size() , ans = 0 ; 
      vector < int > rig(n + 3 , 0) ; 
      vector < int > lef(n + 3 , 0) ; 
      for(int i = 1 ; i <= n ; i += 1)
      {
         int h = nums[i-1] ; 
         if(i == 1)
         {
            lef[i] = 1 ; 
            continue ; 
         }
         lef[i] = 1 ; 
         if(nums[(i-1)-1] < h)
         {
            lef[i] = lef[i-1] + 1 ; 
         }
      }

      for(int i = n ; i >= 1 ; i -= 1)
      {
         int h = nums[i-1] ; 
         if(i == n)
         {
            rig[i] = 1 ; 
            continue ; 
         }
         rig[i] = 1 ; 
         if(nums[(i + 1)-1] > h)
         {
            rig[i] = rig[i+1] + 1 ; 
         }
      }
      for(int i = 1 ; i + 1 <= n ; i += 1)
      {
         ans = max(ans , min(lef[i] , rig[i + 1])) ; 
      }
      
      return ans>=k ; 
    }
};",1448263710
Ritik Rathor,ritik_369,174,3619,cpp,"

class Solution 
{
public:
   int maxIncreasingSubarrays(vector<int>& nums)
   {
      int n = nums.size() , ans = 0 ; 
      vector < int > rig(n + 3 , 0) ; 
      vector < int > lef(n + 3 , 0) ; 
      for(int i = 1 ; i <= n ; i += 1)
      {
         int h = nums[i-1] ; 
         if(i == 1)
         {
            lef[i] = 1 ; 
            continue ; 
         }
         lef[i] = 1 ; 
         if(nums[(i-1)-1] < h)
         {
            lef[i] = lef[i-1] + 1 ; 
         }
      }

      for(int i = n ; i >= 1 ; i -= 1)
      {
         int h = nums[i-1] ; 
         if(i == n)
         {
            rig[i] = 1 ; 
            continue ; 
         }
         rig[i] = 1 ; 
         if(nums[(i + 1)-1] > h)
         {
            rig[i] = rig[i+1] + 1 ; 
         }
      }
      for(int i = 1 ; i + 1 <= n ; i += 1)
      {
         ans = max(ans , min(lef[i] , rig[i + 1])) ; 
      }
      
      return ans ; 
   }
};
",1448263883
Ritik Rathor,ritik_369,174,3631,cpp,"#define bpc __builtin_popcount

int dp2[801][6] ; 
int ok(int n , int k)
{
   if(n == 1)return 1 ; 
   if(k <= 0)return 0 ;  
   if(dp2[n][k] != -1)return dp2[n][k] ; 
   return dp2[n][k] = ok(bpc(n) , k-1) ; 
}
vector < int > arr ; 

string ss ; 
int here = 0 ; 
const int N = 802 ; 
const int mod = 1e9 + 7;
int dp[N + 2][N + 2][2] ; 
int f(int idx , int t , int ct)
{
   if(idx == ss.size())
   {
      if(t)return 0 ; 
      return arr[ct] ; 
   }
   int  & res = dp[idx][ct][t] ; 
   if(res != -1)return res ; 
   res = 0 ; 
   int h = ((t)?((ss[idx]) - '0'):1) ; 
   for(int i = 0 ; i <= h ; i += 1)
   {
      int nt = (t & (i == h)) ; 
      res = (1ll * res + 1ll * f(idx + 1 , nt , ct + i)) % mod ; 
   }
   return res ; 
}

class Solution 
{
public:
   int countKReducibleNumbers(string s, int k) 
   {
      memset(dp , -1 , sizeof(dp)) ; 
      memset(dp2 , -1 , sizeof(dp2)) ; 
      arr = vector < int > (801 , 0) ; 
      for(int i = 0 ; i <= 800 ; i += 1)
         arr[i]=ok(i , k-1) ;
      ss = s ; 
      return f(0 , 1 , 0) ; 
   }
};",1448265416
Ritik Rathor,ritik_369,174,3646,cpp,"const int N = 1e5 , mod = 1e9 + 7 ; 
class Solution 
{
public:
   int sumOfGoodSubsequences(vector<int>& nums)
   {
      vector < long long > dp(1e5 + 10 , 0) ; 
      vector < long long > dp2(1e5 + 10 , 0) ; 

      for(int i = (int)nums.size()-1 ; i >= 0 ; i -= 1)
      {
         int h = nums[i] ; 
         dp2[h] = (dp2[h] + 1) % mod ; 
         dp2[h] = (1ll * dp2[h] + 1ll * dp2[h + 1]) % mod ; 
         if(h-1 >= 0)dp2[h] = (1ll * dp2[h] + 1ll * dp2[h - 1]) % mod ; 
         dp[h] = (dp[h] + h) % mod ; 
         dp[h] = ((1ll * dp[h] + 1ll * dp[h + 1]) % mod + (1ll * h * dp2[h + 1]) % mod) % mod ; 
         if(h-1 >= 0)dp[h] = ((1ll * dp[h]  + 1ll * dp[h - 1]) % mod + (1ll * h * dp2[h - 1]) % mod) % mod ; 
      }
      long long res = 0 ; 
      for(auto a : dp)
      {
         res = (1ll * res + 1ll * a) % mod ; 
      }
      return (int)res ; 
   }
};",1448264427
Hachieii,Hachieii,175,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
      const int n = nums.size();
      vector<int> a(n + 1);
      
      for (int i = 2; i <= n; ++i) {
        a[i] = nums[i - 1] > nums[i - 2];
        a[i] += a[i - 1];
      }

      for (int i = 1; i + k * 2 - 1 <= n; ++i) {
        const int sum1 = a[i + k - 1] - a[i];
        const int sum2 = a[i + k * 2 - 1] - a[i + k];
        if (sum1 == sum2 && sum1 == k - 1) return true;
      }

      return false;
    }
};",1448183925
Hachieii,Hachieii,175,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
      const int n = nums.size();
      vector<int> a(n + 1);
      
      for (int i = 2; i <= n; ++i) {
        a[i] = nums[i - 1] > nums[i - 2];
        a[i] += a[i - 1];
      }

      int l = 1, r = n;

      while (l < r) {
        const int k = (l + r) >> 1;
        bool ok = false;
        
        for (int i = 1; i + k * 2 - 1 <= n; ++i) {
          const int sum1 = a[i + k - 1] - a[i];
          const int sum2 = a[i + k * 2 - 1] - a[i + k];
          if (sum1 == sum2 && sum1 == k - 1) {
            ok = true;
            break;
          }
        }

        if (ok) l = k + 1;
        else r = k;
      }

      return l - 1;
    }
};",1448187220
Hachieii,Hachieii,175,3631,cpp,"const int mod = 1e9 + 7;
int dp[800 + 10][2][800 + 10];

class Solution {
private:
  vector<int> mark;
public:
    Solution(): mark(800 + 10) { ; }

    int get(int i) {
      int res = 0;
      while (i != 1) {
        ++res;
        i = __builtin_popcount(i);
      }
      return res;
    }

    void init(int k) {
      for (int i = 1; i <= 800; ++i) {
        int cnt = 1;
        cnt += get(i);
        mark[i] = cnt <= k;
      }
    }

    int dfs (string& s, int i, bool ok, int tot) {
      if (i >= s.size()) {
        return ok && mark[tot];
      }

      if (dp[i][ok][tot] != -1) return dp[i][ok][tot];

      int res = 0;
      const int mx = ok ? 1 : s[i] - '0';
      
      for (int c = 0; c <= mx; ++c) {
        const bool nxtOk = ok || c < mx;
        res = (res + dfs(s, i + 1, nxtOk, tot + (c == 1))) % mod;
      }

      return dp[i][ok][tot] = res;
    }

    int countKReducibleNumbers(string s, int k) {
      init(k);
      memset(dp, -1, sizeof dp);
      return dfs(s, 0, 0, 0);
    }
};",1448208557
Hachieii,Hachieii,175,3646,cpp,"const int mxn = 1e5 + 10;
long long cnt[mxn];
long long sum[mxn];
const int mod = 1e9 + 7;

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        memset(cnt, 0, sizeof cnt);
        memset(sum, 0, sizeof sum);

        long long res = 0;

        for (int v: nums) {
          ++v;
          cnt[v] = (cnt[v] + cnt[v - 1] + cnt[v + 1] + 1) % mod;
          sum[v] = (sum[v] + sum[v - 1] + sum[v + 1] + 1LL * (v - 1) * (cnt[v - 1] + cnt[v + 1] + 1) % mod) % mod;
          res = (res + sum[v - 1] + sum[v + 1] + 1LL * (v - 1) * (cnt[v - 1] + cnt[v + 1] + 1) % mod) % mod;
        }
        return res;
    }
};",1448243217
panshane56,panshane56,176,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> pref(n, 1), suf(n, 1);

        for (int i = 1; i < n; i++) {
            if (nums[i] > nums[i - 1]) {
                pref[i] = pref[i - 1] + 1;
            }
        }

        for (int i = n - 2; i >= 0; i--) {
            if (nums[i] < nums[i + 1]) {
                suf[i] = suf[i + 1] + 1;
            }
        }

        int ans = 0;
        for (int i = 1; i < n; i++) {
            ans = max(ans, min(pref[i - 1], suf[i]));
        }
        return ans >= k;
    }
};",1448221746
panshane56,panshane56,176,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> pref(n, 1), suf(n, 1);

        for (int i = 1; i < n; i++) {
            if (nums[i] > nums[i - 1]) {
                pref[i] = pref[i - 1] + 1;
            }
        }

        for (int i = n - 2; i >= 0; i--) {
            if (nums[i] < nums[i + 1]) {
                suf[i] = suf[i + 1] + 1;
            }
        }

        int ans = 0;
        for (int i = 1; i < n; i++) {
            ans = max(ans, min(pref[i - 1], suf[i]));
        }
        return ans;
    }
};",1448220361
panshane56,panshane56,176,3631,cpp,"class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        if (s.size() == 1 && (s[0] == '1' || s[0] == '0')) {
            return 0;
        }

        const int MOD = 1e9 + 7;

        int n = s.size();
        vector<int> f(n + 1, 1);
        for (int i = 2; i <= n; i++) {
            auto tmp = i;
            while (tmp != 1) {
                f[i]++;
                tmp = __builtin_popcount(tmp);
            }
        }

        vector<vector<int>> dp(n, vector<int>(n + 1, 0));
        int high1 = 1;
        for (int i = 1; i < n; i++) {
            // all 0
            dp[i][1] = 1;

            // upper bound
            if (s[i] == '1') {
                dp[i][high1] = (dp[i][high1] + 1) % MOD;
                high1++;
            }

            // other
            for (int x = 0; x <= n; x++) {
                dp[i][x] = (dp[i][x] + dp[i - 1][x]) % MOD;
                if (x)
                    dp[i][x] = (dp[i][x] + dp[i - 1][x - 1]) % MOD;
            }
        }

        int ans = 0;
        for (int i = 1; i <= n; i++) {
            if (f[i] <= k) {
                ans = (ans + dp[n - 1][i]) % MOD;
            }
        }
        return ans;
    }
};",1448265702
panshane56,panshane56,176,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(std::vector<int>& numbers) {
        std::unordered_map<int, long long> countMap, sumMap;
        int MODULO = 1E9 + 7;
        
        for (int i = 0; i < numbers.size(); ++i) {
            int current = numbers[i];

            countMap[current] = (countMap[current + 1] + countMap[current - 1] +
                                 1 + countMap[current]) %
                                MODULO;
            sumMap[current] =
                (sumMap[current + 1] + sumMap[current - 1] +
                 countMap[current + 1] * current +
                 +countMap[current - 1] * current + sumMap[current] + current) %
                MODULO;
        }
        
        int result = 0;
        for (auto& pii : sumMap) {
            result = (result + pii.second) % MODULO;
        }

        return result;
    }
};",1448210076
Wen-Chieh Tung,WJTung,178,3612,cpp,"class Solution {
 public:
  bool hasIncreasingSubarrays(vector<int>& nums, int k) {
    for (int i = 0; i + k * 2 <= nums.size(); ++i) {
      bool ok = true;
      for (int j = i; j + 1 < i + k; ++j) {
        if (!(nums[j + 1] > nums[j])) {
          ok = false;
        }
      }
      for (int j = i + k; j + 1 < i + k * 2; ++j) {
        if (!(nums[j + 1] > nums[j])) {
          ok = false;
        }
      }
      if (ok) {
        return true;
      }
    }
    return false;
  }
};",1448184036
Wen-Chieh Tung,WJTung,178,3619,cpp,"class Solution {
 public:
  int maxIncreasingSubarrays(vector<int>& nums) {
    vector<int> L(nums.size(), 1);
    int cur = 0;
    for (int i = 0; i < nums.size(); ++i) {
      ++cur;
      if (i + 1 == nums.size() || nums[i + 1] <= nums[i]) { 
        for (int j = i; j >= i + 1 - cur; --j) {
          L[j] = i - j + 1;
        }
        cur = 0;
      }
    }
    int ans = 1;
    for (int i = 0; i < nums.size(); ++i) {
      // cout << i << "": "" << L[i] << endl; 
      ans = max(L[i] / 2, ans);
      int start2 = i + L[i];
      if (start2 < nums.size() && L[start2] >= L[i]) {
        ans = max(L[i], ans);
      }
    }
    return ans;
  }
};",1448200914
Wen-Chieh Tung,WJTung,178,3631,cpp,"class Solution {
 public:
  const int MOD = 1E9 + 7;

  int T(int cur) {
    if (cur == 1) {
      return 0;
    }
    return 1 + T(__builtin_popcount(cur));
  }

  int countKReducibleNumbers(string s, int k) {
    // W[num one] = number of ways to be smaller than s with num one '1'
    vector<int> W(s.length() + 1, 0);
    int prefix_count = 0;
    for (int i = 0; i < s.length(); ++i) {
      vector<int> nextW(s.length() + 1, 0);

      if (i > 0) {
        // start here
        nextW[1] = (nextW[1] + 1) % MOD;
        // prefix + 0
        if (s[i] == '1') {
          nextW[prefix_count] = (nextW[prefix_count] + 1) % MOD;
        }
      }
      
      // add 0
      for (int j = 0; j <= s.length(); ++j) {
        nextW[j] = (nextW[j] + W[j]) % MOD;
      }
      // add 1
      for (int j = 0; j < s.length(); ++j) {
        nextW[j + 1] = (nextW[j + 1] + W[j]) % MOD;
      }

      if (s[i] == '1') {
        ++prefix_count;
      }

      W = move(nextW);
    }

    long long ans = 0;
    for (int i = 1; i <= s.length(); ++i) {
      if (W[i] > 0 && T(i) <= k - 1) {
        ans = (ans + W[i]) % MOD;
      }
    }
    return ans;
  }
};",1448258758
Wen-Chieh Tung,WJTung,178,3646,cpp,"class Solution {
 public:
  const long long MOD = 1E9 + 7;

  int sumOfGoodSubsequences(vector<int>& nums) {
    vector<pair<int, long long>> count_and_sum(100'001, pair<int, long long>(0, 0));
    for (int num : nums) {
      // starting here
      count_and_sum[num].first = (count_and_sum[num].first + 1) % MOD;
      count_and_sum[num].second = (count_and_sum[num].second + num) % MOD;
      // continue from num - 1
      if (num - 1 >= 0) {
        count_and_sum[num].first = (count_and_sum[num].first + count_and_sum[num - 1].first) % MOD;
        long long A = count_and_sum[num - 1].second + static_cast<long long>(num) * count_and_sum[num - 1].first;
        count_and_sum[num].second = (count_and_sum[num].second + A) % MOD;
      }
      // continue from num + 1
      if (num + 1 <= 100'000) {
        count_and_sum[num].first = (count_and_sum[num].first + count_and_sum[num + 1].first) % MOD;
        long long A = count_and_sum[num + 1].second + static_cast<long long>(num) * count_and_sum[num + 1].first;
        count_and_sum[num].second = (count_and_sum[num].second + A) % MOD;
      }
    }
    long long ans = 0;
    for (int i = 0; i <= 100'000; ++i) {
      ans = (ans + count_and_sum[i].second) % MOD;
    }
    return ans;
  }
};",1448224486
xlx2,xlx2,180,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        for i in range(n-2*k+1):
            if all(a < b for a,b in itertools.pairwise(nums[i:i+k])) and all(a < b for a,b in itertools.pairwise(nums[i+k:i+2*k])):
                return True
        return False",1448219324
xlx2,xlx2,180,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        f = [0] * n
        j = 0
        for i in range(n):
            j = max(j, i)
            while j+1 < n and nums[j] < nums[j+1]:
                j += 1
            f[i] = j-i+1
        
        g = []
        cnt = 0
        for i in range(n):
            if cnt:
                cnt -= 1
                continue
            g.append(f[i])
            cnt = f[i] - 1
        
        x = max((min(a,b) for a,b in itertools.pairwise(g)), default=0)
        return max(x, max(g) // 2)",1448218949
xlx2,xlx2,180,3631,python3,"N = 801
g = [math.inf] * N
g[1] = 0
for i in range(2, N):
    g[i] = 1 + g[i.bit_count()]


class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        M = 10**9 + 7
        n = len(s)
        if s.count('1') == 0: return 0
        @cache
        def f(i, eq, c):
            hi = int(s[i]) if eq else 1
            ans = 0
            if i == n-1:
                if c == 0:
                    if eq and hi == 1:
                        pass
                    else:
                        ans += (hi == 1)
                else:
                    for j in range(hi+1):
                        if eq and j == hi: continue
                        ans += (g[c+j] < k)
                return ans % M
            for j in range(hi+1):
                ans += f(i+1, eq and j == hi, c+j)
            return ans % M
        
        return f(0, 1, 0)",1448267110
xlx2,xlx2,180,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        M = 10**9 + 7
        n = len(nums)
        d = defaultdict(int)
        c = defaultdict(int)
        ans = 0
        for i,v in enumerate(nums):
            s = (v + d[v-1] + d[v+1] + v * (c[v-1] + c[v+1])) % M
            ans += s
            ans %= M
            # print(i, v, s, d, ans)
            c[v] += 1 + c[v-1] + c[v+1]
            c[v] %= M
            d[v] += s
            d[v] %= M
        return ans % M",1448218641
VILLANOVA_ECON,VILLANOVA_ECON,181,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        
        def check(arr):
            if len(set(arr)) == len(arr) and arr == sorted(arr):
                return True
            return False
        
        for i in range(len(nums)):
            zeb = nums[i:i+2*k]
            if len(zeb) != 2*k:
                break
            if check(zeb[:k]) and check(zeb[k:]):
                return True
        return False
        
                    ",1448184402
VILLANOVA_ECON,VILLANOVA_ECON,181,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        
        pref = [0]
        for i in range(1,len(nums)):
            if nums[i] > nums[i-1]:
                pref.append(pref[-1]+1)
            else:
                pref.append(pref[-1])
        # print
        # pref = list(itertools.accumulate(pref))
        
        #print(pref)
        def check(k):
            for i in range(len(pref)):
                if i+2*k > len(pref):
                    break
                #print(i,k,((pref[i+k-1]-pref[i]) == k-1) and ((pref[i+2*k-1]-pref[i+k]) == k-1))
                if ((pref[i+k-1]-pref[i]) == k-1) and ((pref[i+2*k-1]-pref[i+k]) == k-1):
                    return True
            return False
        
        l = 1
        r = len(nums)//2
        best_ans = 1
        while l <= r:
            mid = l +(r-l)//2
            if check(mid):
                best_ans = mid
                l = mid+1
            else:
                r= mid-1
        return best_ans",1448196069
VILLANOVA_ECON,VILLANOVA_ECON,181,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        modulo = 10** 9 + 7
        @lru_cache(None)
        def brute1(x):
            z = 0
            tt = k-1
            while x != 1 and tt > 0:
                x = bin(x).count(""1"")
                z += 1
                tt -= 1
            return int(x == 1)
        
        @lru_cache(None)
        def recur_fn(i,count,below):
            if i == len(s):
                if not below or count == 0:
                    return 0
                #print(count,below)
                return brute1(count)
            elif below:
                res = recur_fn(i+1,count+1,below) + recur_fn(i+1,count,below)
                if res >= modulo:
                    res %= modulo
                return res
            else:
                if s[i] == ""0"":
                    return recur_fn(i+1,count,below)
                else:
                    res = recur_fn(i+1,count+1,below) + recur_fn(i+1,count,True)
                    if res >= modulo:
                        res %= modulo
                    return res
        result =  recur_fn(0,0,False)%modulo
        recur_fn.cache_clear()
        return result
                
                ",1448252717
VILLANOVA_ECON,VILLANOVA_ECON,181,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        modulo = 10**9 + 7
        
        hash_table = {}
        
        
        dp = [0]*(max(nums)+10)
        dp_count = [0]*(max(nums)+10)
        
        for i,x in enumerate(nums):
            dp[x] += x
            dp_count[x] += 1
            if x-1 >= 0:
                dp[x] += (dp[x-1]) + x * dp_count[x-1]
                dp_count[x] += dp_count[x-1]
                if dp[x] >= modulo:
                    dp[x] %= modulo
            if x+1 < len(dp):
                dp[x] += (dp[x+1]) + x * dp_count[x+1]
                dp_count[x] += dp_count[x+1]
                if dp[x] >= modulo:
                    dp[x] %= modulo
            if dp[x] >= modulo:
                dp[x] %= modulo
            #print(dp,dp_count)
        #print(dp)
        #print(dp)
        #print(dp_count)
        ans = 0
        for x in dp:
            ans += x
            if ans >= modulo:
                ans %= modulo
        return ans",1448218503
Ajay Singh Deopa,singh_deopa,182,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = (int) nums.size();

        for (int i = 0; i <= n - k - k; i++) {
            bool can = true;
            
            for (int j = 1; j < k; j++) {
                if (nums[i + j] <= nums[i + j - 1]) {
                    can = false;
                    break;
                }
            }

            if (!can) continue;

            for (int j = 1; j < k; j++) {
                if (nums[i + k + j] <= nums[i + k + j - 1]) {
                    can = false;
                    break;
                }
            }

            if (can) {
                return true;
            }
        }

        return false;
    }
};",1448184789
Ajay Singh Deopa,singh_deopa,182,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = (int) nums.size();
        vector<int> suf(n);

        for (int i = n - 1; i >= 0; i--) {
            suf[i] = 1;

            if (i != n - 1 && nums[i] < nums[i + 1]) {
                suf[i] += suf[i + 1];
            }
        }

        int pre = 1;
        int res = 1;

        for (int i = 1; i < n - 1; i++) {
            if (nums[i] > nums[i - 1]) {
                pre++;
            }
            else {
                pre = 1;
            }

            res = max(res, min(pre, suf[i + 1]));
        }

        return res;
    }
};",1448191108
Ajay Singh Deopa,singh_deopa,182,3631,cpp,"typedef long long ll;

class Solution {
    void brute(string& s, int k) {
        int n = (int) s.size();
        ll val = 0;

        for (int i = 0; i < n; i++) {
            if (s[i] == '1') {
                val |= (1 << n - i - 1);
            }
        }

        vector<int> dp(val + 1, 0);
        int cnt = 0;

        for (int i = 1; i < val; i++) {
            if (i == 1) {
                dp[i] = 0;
            }
            else {
                dp[i] = 1 + dp[__builtin_popcount(i)];
            }

            if (dp[i] <= k) {
                cnt++;
            }
        }

        cout << s << "" "" << cnt << endl;
    }
public:
    int countKReducibleNumbers(string s, int k) {
        // brute(s, k);
        int n = (int) s.size();
        long long mod = 1000000007;
        vector<int> dp(n + 1, 0);

        for (int i = 2; i <= n; i++) {
            int bits = __builtin_popcount(i);
            dp[i] = 1 + dp[bits];
            // cout << i << "" "" << dp[i] << endl;
        }

        vector<vector<ll>> comb(n + 1, vector<ll>(n + 1, 0));

        for (int i = 0; i <= n; i++) {
            comb[i][i] = comb[i][0] = 1;

            for (int j = 1; j < i; j++) {
                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod;
            }
        }

        // for (auto a: comb) {
        //     for (auto b: a) cout << b << "" "" ;
        //     cout << endl;
        // }

        ll res = 0;
        
        for (int i = 1; i < n; i++) {
            for (int j = 1; j <= i; j++) {
                if (1 + dp[j] > k) continue;

                ll val = comb[i - 1][j - 1];
                res = (res + val) % mod;
            }
        }

        int ones = 1;

        for (int i = 1; i < n; i++) {
            if (s[i] == '0') continue;

            int rem = n - i - 1;

            for (int j = 0; j <= rem; j++) {
                if (1 + dp[ones + j] > k) {
                    continue;
                }

                res = (res + comb[rem][j]) % mod;
            }

            ones++;
        }

        return (int) res;
    }
};",1448260231
Ajay Singh Deopa,singh_deopa,182,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int n = (int) nums.size();
        long long mod = 1000000007;
        int mx = *max_element(nums.begin(), nums.end()) + 2;
        vector<long long> cnt(mx), sum(mx);

        for (int& i: nums) {
            cnt[i] = (cnt[i] + 1) % mod;
            sum[i] = (sum[i] + i) % mod;
            
            for (int d: {1, -1}) {
                int val = i + d;

                if (val < 0 || cnt[val] == 0) {
                    continue;
                }

                cnt[i] = (cnt[i] + cnt[val]) % mod;
                sum[i] = (sum[i] + sum[val] + 1LL * i * cnt[val] % mod) % mod;
            }
        }

        long long res = 0;

        for (int i = 0; i < mx; i++) {
            if (cnt[i] == 0) continue;

            res = (res + sum[i]) % mod;
            // cout << i << "" "" << cnt[i] << "" "" << sum[i] << endl;
        }

        return (int) res;
    }
};",1448218316
Thien-Phuoc Phung,phungthienphuoc,185,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n=len(nums)
        left=[0]*n
        for i in range(1,n):
            if nums[i]>nums[i-1]:
                left[i]=left[i-1]
            else:
                left[i]=i
        for i in range(2*k-1,n):
            if left[i]<=i-k+1 and left[i-k]<=i-2*k+1:
                return True
        return False",1448182815
Thien-Phuoc Phung,phungthienphuoc,185,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n=len(nums)
        left=[0]*n
        for i in range(1,n):
            if nums[i]>nums[i-1]:
                left[i]=left[i-1]
            else:
                left[i]=i
        
        def check(k):
            for i in range(2*k-1,n):
                if left[i]<=i-k+1 and left[i-k]<=i-2*k+1:
                    return True
            return False
        
        l,r=1,n//2
        while l<r:
            m=(l+r+1)//2
            if check(m):
                l=m
            else:
                r=m-1
        return l",1448191956
Thien-Phuoc Phung,phungthienphuoc,185,3631,python3,"mod=10**9+7

pre=[0]*801
for i in range(2,801):
    pre[i]=pre[i.bit_count()]+1

f=[1]*801
v=[1]*801
for i in range(2,801):
    f[i]=f[i-1]*i%mod
    v[i]=v[i-1]*pow(i,mod-2,mod)%mod

c=lambda n,k:f[n]*v[k]%mod*v[n-k]%mod
    
class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        d=0
        n=len(s)
        count=[0]*(n+1)
        for i,x in enumerate(s):
            if x=='1':
                for j in range(n-i):
                    count[j+d]=(c(n-i-1,j)+count[j+d])%mod
                d+=1
        res=0
        for i in range(1,n+1):
            if pre[i]<=k-1:
                res=(res+count[i])%mod
        return res",1448253045
Thien-Phuoc Phung,phungthienphuoc,185,3646,python3,"mod=10**9+7
class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        n=len(nums)
        s,d=defaultdict(int),defaultdict(int)
        for i,x in enumerate(nums):
            s[x]=(s[x]+x*(1+d[x-1]+d[x+1])+s[x-1]+s[x+1])%mod
            d[x]=(d[x]+1+d[x-1]+d[x+1])%mod
        return sum(s.values())%mod",1448202643
u50UoHd3Oy,u50UoHd3Oy,187,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        for (int i = 0; i < n; i++) {
            if (i + 2 * k - 1 < n){
                int j = i + 1;
                int ok = 1;
                while (j <= i + k - 1){
                    if (nums[j] <= nums[j - 1]) {
                        ok = 0;
                        break;
                    }
                    j++;
                }
                j++;
                while (j <= i + 2 * k - 1) {
                    if (nums[j] <= nums[j - 1]) {
                        ok = 0;
                        break;
                    }
                    j++;
                }

                if (ok) {
                    return true;
                }
            }
        }

        return false;
    }
};",1448192219
u50UoHd3Oy,u50UoHd3Oy,187,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> cnt(n, 1);
        int ans = 0;
        for (int i = 1; i < n; i++) {
            if (nums[i - 1] < nums[i]) {
                cnt[i] = cnt[i - 1] + 1;
            }
            ans = max(ans, cnt[i] / 2);
            if (i - cnt[i] >= 0) {
                ans = max(ans, min(cnt[i], cnt[i - cnt[i]]));
            }
        }

        return ans;
    }
};",1448206114
u50UoHd3Oy,u50UoHd3Oy,187,3631,cpp,"class Solution {
public:
    int binary_power(int num, int pow) {
        int result = 1;
        while (pow) {
            if (pow % 2) {
                result = (1LL * result * num) % mod;
            }
            num = (1LL * num * num) % mod;
            pow /= 2;
        }

        return result;
    }

    void initFactorial(int n) {
        factorial.assign(n + 1, 1);
        inv_factorial.assign(n + 1, 1);

        for (int i = 1; i <= n; i++) {
            factorial[i] = (1LL * factorial[i - 1] * i) % mod;
            inv_factorial[i] = (1LL * inv_factorial[i - 1] * binary_power(i, mod - 2)) % mod;
        }
    }

    int ncr(int n, int r) {
        if (r > n) {
            return 0;
        }

        int ans = factorial[n];
        ans = (1LL * ans * inv_factorial[r]) % mod;
        ans = (1LL * ans * inv_factorial[n - r]) % mod;

        return ans;
    }

    int countKReducibleNumbers(string s, int k) {
        int n = s.size();

        initFactorial(n);
        
        vector<int> minC(n + 1, 0);
        for (int i = 2; i <= n; i++) {
            int ti = i;
            int sc = 0;
            while (ti) {
                if (ti % 2) sc++;
                ti /= 2;
            }

            minC[i] = 1 + minC[sc];
        }

        int cur1 = 0;
        int ans = 0;
        for (int i = 0; i < n; i++) {
            if (s[i] == '1') {
                int rem = n - (i + 1);
                for (int sb = 0; sb <= n; sb++) {
                    if (cur1 + sb <= n && minC[cur1 + sb] + 1 <= k) {
                        ans = (ans + ncr(rem, sb)) % mod;
                    }
                }
                
                cur1++;
            }
        }

        ans = (ans - 1 + mod) % mod; 

        return ans;
    }
private:
    int mod = (int)(1e9 + 7);
    vector<int> factorial;
    vector<int> inv_factorial;
};",1448267968
u50UoHd3Oy,u50UoHd3Oy,187,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int max_num = *max_element(nums.begin(), nums.end());
        vector<long> dp(max_num + 1, 0);
        vector<long> sum(max_num + 1, 0);
        for (int i = 0; i < nums.size(); i++) {
            dp[nums[i]] = (dp[nums[i]] + 1) % mod;
            sum[nums[i]] = (sum[nums[i]] + nums[i]) % mod;
            if (nums[i] - 1 >= 0) {
                dp[nums[i]] = (dp[nums[i] - 1] + dp[nums[i]]) % mod;
                sum[nums[i]] = (
                    sum[nums[i]] 
                  + (1LL * dp[nums[i] - 1] * nums[i]) % mod
                  + sum[nums[i] - 1]
                ) % mod;
            }
            if (nums[i] + 1 <= max_num) {
                dp[nums[i]] = (dp[nums[i] + 1] + dp[nums[i]]) % mod;
                sum[nums[i]] = (
                    sum[nums[i]] 
                  + (1LL * dp[nums[i] + 1] * nums[i]) % mod
                  + sum[nums[i] + 1]
                ) % mod;
            }
        }

        int ans = 0;
        for (int i = 0; i <= max_num; i++) {
            ans = (ans + sum[i]) % mod;
        }

        return ans;
    }
private:
    const int mod = (int)(1e9 + 7);
};",1448230649
lozy219,lozy219,191,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        vector<int> diff;
        for (int i=1; i<nums.size(); ++i) {
            if (nums[i]>nums[i-1]) {
                diff.push_back(1);
            } else {
                diff.push_back(0);
            }
        }
        // cout << ""0 "";
        vector<int> psum(nums.size(), 0);
        for (int i=0; i<nums.size()-1; ++i) {
            psum[i+1]=psum[i]+diff[i];
            // cout << psum[i+1] << "" "";
        }
        // cout << endl;
        for (int i=k-1; i+k<nums.size(); ++i) {
            if (((psum[i]-psum[i-k+1])==k-1) && ((psum[i+k]-psum[i+1])==k-1)) {
                return true;
            }
        }
        return false;
    }
};",1448188574
lozy219,lozy219,191,3619,cpp,"class Solution {
public:
    bool gao(int k, vector<int>& nums, vector<int>& psum) {
        for (int i=k-1; i+k<nums.size(); ++i) {
            if (((psum[i]-psum[i-k+1])==k-1) && ((psum[i+k]-psum[i+1])==k-1)) {
                return true;
            }
        }
        return false;
    }
    int maxIncreasingSubarrays(vector<int>& nums) {
        vector<int> diff;
        for (int i=1; i<nums.size(); ++i) {
            if (nums[i]>nums[i-1]) {
                diff.push_back(1);
            } else {
                diff.push_back(0);
            }
        }
        vector<int> psum(nums.size(), 0);
        for (int i=0; i<nums.size()-1; ++i) {
            psum[i+1]=psum[i]+diff[i];
        }
        int left=1, right=nums.size();
        while (left<right) {
            int mid=(left+right+1)/2;
            if (gao(mid, nums, psum)) {
                left=mid;
            } else {
                right=mid-1;
            }
        }
        return left;
    }
};",1448193295
lozy219,lozy219,191,3631,cpp,"#define ll long long
vector<ll> fact;

class Solution {
    const ll MOD=1000000007;
public:
    template <typename T>
    T modpow(T base, T exp, T modulus) {
      base %= modulus;
      T result = 1;
      while (exp > 0) {
        if (exp & 1) result = (result * base) % modulus;
        base = (base * base) % modulus;
        exp >>= 1;
      }
      return result;
    }

    ll ncr(ll n, ll r) {
      ll top = fact[n];
      ll bot = fact[n-r]*fact[r]%MOD;

      return top*modpow(bot, MOD-2, MOD)%MOD;
    }

    int countKReducibleNumbers(string s, int k) {
        if (fact.size()==0) {
            fact=vector<ll>(805, 1);
            for (int i=1; i<805; ++i) {
                fact[i] = i*fact[i-1]%MOD;
            }
        }
        vector<int> dp(805, 0);
        for (int i=2; i<805; ++i) {
            dp[i]=dp[__builtin_popcount(i)]+1;
        }
        dp[0]=0x3f3f3f3f;
        long long res=0;
        int cur=0;
        for (int i=0; i<s.size(); ++i) {
            if (s[i]=='1') {
                // set this bit to '0' and count the rest
                int rem=s.size()-1-i;
                for (int j=0; j<=rem; ++j) {
                    int cnt=cur+j;
                    if (dp[cnt]+1<=k) {
                        res=(res+ncr(rem, j))%MOD;
                    }
                }
                cur++;
            }
        }
        return res;
    }
};",1448253977
lozy219,lozy219,191,3646,cpp,"class Solution {
    const int MOD=1000000007;
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        vector<long long> dpn(100005, 0);
        vector<long long> dpc(100005, 0);
        for (int i: nums) {
            if (i==0) {
                dpn[i]=(dpn[i]+(dpn[i+1]+i*dpc[i+1]%MOD))%MOD;
                dpc[i]=(dpc[i]+dpc[i+1])%MOD;
                dpn[i]=(dpn[i]+i)%MOD;
                dpc[i]=(dpc[i]+1)%MOD;
            } else {
                dpn[i]=(dpn[i]+(dpn[i-1]+dpn[i+1]+i*(dpc[i-1]+dpc[i+1])%MOD))%MOD;
                dpc[i]=(dpc[i]+dpc[i-1]+dpc[i+1])%MOD;
                dpn[i]=(dpn[i]+i)%MOD;
                dpc[i]=(dpc[i]+1)%MOD;
            }
        }
        int res=0;
        for (int i=0; i<100005; ++i) {
            res=(res+dpn[i])%MOD;
        }
        return res;
    }
};",1448211002
andy-lc,andy-lc,192,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        psum = [0]*len(nums)
        for i in range(1, len(nums)):
            psum[i] = psum[i-1] + (1 if nums[i] > nums[i-1] else 0)
        for i in range(len(nums)-2*k+1):
            if psum[i+k-1]-psum[i] == k-1 and psum[i+k+k-1]-psum[i+k] == k-1:
                return True
        return False",1448183006
andy-lc,andy-lc,192,3619,python3,"class Solution:
    def hasIncreasingSubarrays(self, psum: List[int], k: int) -> bool:
        for i in range(len(psum)-2*k+1):
            if psum[i+k-1]-psum[i] == k-1 and psum[i+k+k-1]-psum[i+k] == k-1:
                return True
        return False
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        psum = [0]*len(nums)
        for i in range(1, len(nums)):
            psum[i] = psum[i-1] + (1 if nums[i] > nums[i-1] else 0)
        L = 0
        R = len(nums)-1
        while L < R:
            M = L+(R-L+1)//2
            if self.hasIncreasingSubarrays(psum,M):
                L = M
            else:
                R = M-1
        return L",1448185533
andy-lc,andy-lc,192,3631,cpp,"#include <bits/stdc++.h>
#pragma GCC optimize(2)
#define rep(i, a, b) for (int i = (a); i < (b); ++i)
#define rep_(i, a, b) for (int i = (a); i > (b); --i)
#define CEIL_DIV(a, b) ((b) == 0 ? 0 : (((a) >= 0) ? ((a) + (b) - 1) / (b) : (a) / (b)))
#define FLOOR_DIV(a, b) (((a) / (b)) - ((a) % (b) != 0 && (((a) < 0) != ((b) < 0))))
#define mst(x, a) memset(x, a, sizeof(x))
#define all(a) begin(a), end(a)
#define lowbit(x) ((x) & (-(x)))
#define bitcnt(x) (__builtin_popcountll(x))
#define se second
#define fi first
#define pb push_back
#define maxe max_element
#define mine min_element
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<ll, ll> pll;
typedef pair<int, ll> pil;
typedef pair<int, int> pii;
typedef vector<int> vi;
typedef vector<ll> vll;
typedef vector<vi> vvi;
constexpr static int dirs[4][2] = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};
constexpr static int inf = 0x3f3f3f3f;
constexpr static int mod = 1e9 + 7;
const ll infl = 0x3f3f3f3f3f3f3f3fll;
template<class T> bool chmax(T &a, T b) {
    if (a >= b) return false;
    a = b; return true;
}
template<class T> bool chmin(T &a, T b) {
    if (a <= b) return false;
    a = b; return true;
}
template<class T> bool chsum(T &a, T b) {
    a = (a + b + mod) % mod;
    return false;
}

const int MAX_X = 800;

vi precompute_steps(int max_x){
    vi step(max_x + 1, 0);
    step[1] = 0;
    rep(x, 2, max_x + 1){
        int pop = bitcnt(x);
        if(pop <= max_x){
            step[x] = 1 + step[pop];
        }
        else{
            step[x] = 1 + step[max_x];
        }
    }
    return step;
}

vi STEPs = precompute_steps(MAX_X);

class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        vi bits;
        int L = s.size();
        bits.reserve(L);
        for(char c : s){
            bits.pb(c - '0');
        }
        
        vector<vi> dp_prev(L+1, vi(2, 0));
        dp_prev[0][1] = 1; 
        
        rep(pos, 0, L){
            vector<vi> dp(L+1, vi(2, 0));
            rep(cnt, 0, L+1){
                rep(t, 0, 2){
                    if(dp_prev[cnt][t] == 0){
                        continue;
                    }
                    int max_bit = (t ? bits[pos] : 1);
                    // Try placing both 0 and 1
                    rep(bit, 0, 2){
                        if(bit > max_bit){
                            continue;
                        }
                        int new_t = (t && (bit == max_bit)) ? 1 : 0;
                        int new_cnt = cnt + bit;
                        if(new_cnt > L){
                            continue;
                        }
                        dp[new_cnt][new_t] = (dp[new_cnt][new_t] + dp_prev[cnt][t]) % mod;
                    }
                }
            }
            dp_prev = dp;
        }
        
        vi cnt(L+1, 0);
        rep(c, 1, L+1){
            cnt[c] = (dp_prev[c][0] + dp_prev[c][1]) % mod;
        }
        
        ll res = 0;
        rep(x, 1, L+1){
            if(x <= MAX_X){
                if(STEPs[x] <= k-1){
                    res = (res + (ll)cnt[x]) % mod;
                }
            }
        }
        
        int x_n = 0;
        rep(i, 0, L){
            x_n += bits[i];
        }
        
        int step_n;
        if(x_n <= MAX_X){
            step_n = 1 + STEPs[x_n];
        }
        else{
            step_n = 1 + STEPs[MAX_X];
        }
        
        if(step_n <= k){
            res = (res - 1 + mod) % mod;
        }
        
        return res;
    }
};
",1448268534
andy-lc,andy-lc,192,3646,python3,"M = 1_000_000_007
class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        count = [0]*(max(nums)+2)
        sesum = [0]*(max(nums)+2)
        for x in nums:
            sesum[x] += ((sesum[x-1]+sesum[x+1])%M+(((count[x-1]+count[x+1])%M+1)*x)%M)%M
            count[x] += (count[x-1]+count[x+1])%M+1
            sesum[x] %= M
            count[x] %= M
        ans = 0
        for s in sesum:
            ans += s
            ans %= M
        return ans",1448195808
ninja_master2002,ninja_master2002,193,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int i=0;
        int n=nums.size();
        vector<int>ans(n,1);
        while(i<n){
            int j=i+1;
            while(j<n && nums[j]>nums[j-1]){
                ans[j]=(j-i+1);
                j++;
            }
            i=j;
        }
        // for(auto it:ans){
        //     cout<<it<<"" "";
        // }
        // cout<<endl;
        int maxi=1;
        for(int i=0;i<n-1;i++){
            if(ans[i]>maxi){
                int si=maxi+1,ei=ans[i],ans1=-1;
                if(i+maxi+1>=n)continue;
                // if(i==4){
                //     cout<<maxi<<endl;
                // }
                while(si<=ei){
                    int mid=si+(ei-si)/2;
                    if(i+mid<n && ans[i+mid]-ans[i+1]>=(mid-1)){
                        ans1=mid;
                        si=mid+1;
                    }
                    else{
                        ei=mid-1;
                    }
                }
                maxi=max(maxi,ans1);
            }
        }
        return maxi>=k;
    }
};",1448201299
ninja_master2002,ninja_master2002,193,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int i=0;
        int n=nums.size();
        vector<int>ans(n,1);
        while(i<n){
            int j=i+1;
            while(j<n && nums[j]>nums[j-1]){
                ans[j]=(j-i+1);
                j++;
            }
            i=j;
        }
        // for(auto it:ans){
        //     cout<<it<<"" "";
        // }
        // cout<<endl;
        int maxi=1;
        for(int i=0;i<n-1;i++){
            if(ans[i]>maxi){
                int si=maxi+1,ei=ans[i],ans1=-1;
                if(i+maxi+1>=n)continue;
                // if(i==4){
                //     cout<<maxi<<endl;
                // }
                while(si<=ei){
                    int mid=si+(ei-si)/2;
                    if(i+mid<n && ans[i+mid]-ans[i+1]>=(mid-1)){
                        ans1=mid;
                        si=mid+1;
                    }
                    else{
                        ei=mid-1;
                    }
                }
                maxi=max(maxi,ans1);
            }
        }
        return maxi;
    }
};",1448198148
ninja_master2002,ninja_master2002,193,3631,cpp,"const int MOD = 1e9+7;
template<const int mod>
struct mint {
    int val;
    constexpr mint(long long x = 0) : val((x % mod + mod) % mod) {}
    explicit operator int() const { return val; }
    mint& operator+=(const mint &b) { val += b.val; val -= mod * (val >= mod); return *this; }
    mint& operator-=(const mint &b) { val -= b.val; val += mod * (val < 0); return *this; }
    mint& operator*=(const mint &b) { val = 1ll * val * b.val % mod; return *this; }
    mint& operator/=(const mint &b) { return *this *= b.inv(); }
    mint inv() const { int x = 1, y = 0, t; for(int a=val, b=mod; b; swap(a, b), swap(x, y)) t = a/b, a -= t * b, x -= t * y; return mint(x); }
    mint power(int b) const { mint a = *this, res(1); for(; b; a *= a, b /= 2)  if(b & 1) res *= a; return res; }
    mint operator-() const { return val == 0 ? 0 : mod - val; }
    mint& operator++() { val = val == mod - 1 ? 0 : val + 1; return *this; }
    mint& operator--() { val = val == 0 ? mod - 1 : val - 1; return *this; }
    mint operator++(int32_t) { mint before = *this; ++*this; return before; }
    mint operator--(int32_t) { mint before = *this; --*this; return before; }
    friend mint operator+(const mint &a, const mint &b) {return mint(a) += b;}
    friend mint operator-(const mint &a, const mint &b) {return mint(a) -= b;}
    friend mint operator*(const mint &a, const mint &b) {return mint(a) *= b;}
    friend mint operator/(const mint &a, const mint &b) {return mint(a) /= b;}
    friend bool operator==(const mint &a, const mint &b) {return a.val == b.val;}
    friend bool operator!=(const mint &a, const mint &b) {return a.val != b.val;}
    friend bool operator<(const mint &a, const mint &b) {return a.val < b.val;}
    friend istream& operator>>(istream &in, mint &a) {return in >> a.val;}
    friend ostream& operator<<(ostream &os, const mint &a) {return os << a.val;}
};
using Mint = mint<MOD>;
 
namespace comb {
    int n(0);
    vector<Mint> _fac{1}, _invfac{1}, _inv{0};
    void init(int m) {
        m = min (m, MOD - 1);
        if (m <= n) return;
        _fac.resize(m + 1); _invfac.resize(m + 1); _inv.resize(m + 1);
        for (int i = n + 1; i <= m; i++) _fac[i] = _fac[i - 1] * i;
        _invfac[m] = _fac[m].inv();
        for (int i = m; i > n; i--) _invfac[i - 1] = _invfac[i] * i, _inv[i] = _invfac[i] * _fac[i - 1];
        n = m;
    }
    Mint fac(int m) { if (m > n) init(2 * m); return _fac[m]; }
    Mint invfac(int m) { if (m > n) init(2 * m); return _invfac[m]; }
    Mint inv(int m) { if (m > n) init(2 * m); return _inv[m]; }
    Mint ncr(int n, int r) { if (n < r || r < 0) return 0; return fac(n) * invfac(r) * invfac(n - r); }
}
using comb::fac; using comb::invfac; using comb::inv; using comb::ncr;
class Solution {
    #define ll long long
public:
    int countKReducibleNumbers(string s, int k) {
        vector<Mint>ans(801,0);
        ans[2]=1;
        ans[1]=0;
        ans[0]=10;
        for(int i=3;i<=800;i++){
            int d=__builtin_popcount(i);
            ans[i]=ans[d]+1;
        }
        // for(int i=0;i<=9;i++){
        //     cout<<ans[i]<<"" "";
        // }
        // cout<<endl;
        if(s==""1""){
            return 0;
        }
        int n=s.size();
        vector<ll>cnt(n);
        for(int i=0;i<n;i++){
            cnt[i]=(s[i]=='1');
            if(i)cnt[i]+=cnt[i-1];
        }
        Mint res=0;
        // cout<<res<<endl;
        // res++;
        for(int i=0;i<n;i++){
            if(s[i]=='0')continue;
            ll rem=n-i-1;
            ll t=cnt[i]-1;
            if(rem+t==0)continue;
            for(ll j=0;j<=rem;j++){
                if((int)ans[j+t]+1<=k){
                    // if(i==0){
                    //     cout<<j<<"" hello ""<<rem<<endl;
                    // }
                    Mint temp=ncr(rem,j);
                    
                    res+=temp;
                    // cout<<temp<<"" ""<<res<<endl;
                }
                // cout<<endl;
                
            }
            // cout<<res<<endl;
        }
        return (int)res;
        
        
        
    }
};",1448268796
ninja_master2002,ninja_master2002,193,3646,cpp,"class Solution {
    #define ll long long
    #define mod (ll)(1e9+7);    
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int n=nums.size();
        int maxi=*max_element(nums.begin(),nums.end());
        vector<ll>dp(maxi+1,0);
        dp[nums[0]]=nums[0];
        map<ll,ll>mp;
        mp[nums[0]]+=1;
        for(int i=1;i<n;i++){
            dp[nums[i]]+=nums[i];
            mp[nums[i]]++;
            dp[nums[i]]%=mod;
            
            if(nums[i]>0){
                ll temp=mp[nums[i]-1];
                temp%=mod;
                ll ans1=temp*nums[i];
                ans1%=mod;
                ans1+=dp[nums[i]-1];
                ans1%=mod;
                dp[nums[i]]+=ans1;
                dp[nums[i]]%=mod;
                mp[nums[i]]+=temp;
            }
            if(nums[i]<maxi){
                ll temp=mp[nums[i]+1];
                temp%=mod;
                ll ans1=temp*nums[i];
                ans1%=mod;
                ans1+=dp[nums[i]+1];
                ans1%=mod;
                dp[nums[i]]+=ans1;
                dp[nums[i]]%=mod;
                mp[nums[i]]+=temp;
            }
            // cout<<dp[nums[i]]<<"" "";
        }
        // cout<<endl;
        ll ans=0;
        for(int i=0;i<=maxi;i++){
            // cout<<dp[i]<<"" "";
            ans+=dp[i];
            ans%=mod;
        }
        // cout<<endl;
        return (int)ans;
    }
};",1448223454
w0w0,w0w0,194,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        prv = -inf
        cnt = 0
        for i in range(n):
            if nums[i] > prv:
                cnt += 1
            else:
                cnt = 1
            prv = nums[i]
            if cnt >= k:
                if n - i - 1 < k:
                    break
                flag = True
                for j in range(i + 2, i + k + 1):
                    if nums[j] <= nums[j - 1]:
                        flag = False
                        break

                if flag:
                    return True

        return False",1448186859
w0w0,w0w0,194,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        prv = -inf
        cnt = 0
        res = []
        for i in range(n):
            if nums[i] > prv:
                cnt += 1
            else:
                cnt = 1
            prv = nums[i]
            res.append(cnt)

        ans = 0
        n = len(nums)
        prv = 0
        for i in range(n):
            if res[i] == 1:
                prv = res[i - 1] if i else 0
            ans = max(ans, res[i] // 2, min(prv, res[i]))
        return ans",1448199772
w0w0,w0w0,194,3631,python3,"MOD = 10 ** 9 + 7

class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        n = len(s)

        def valid(x, k):
            if x == 1:
                return True
            if k == 0:
                return False

            y = bin(x)[2:].count(""1"")
            return valid(y, k - 1)

        @cache
        def dfs(i, j, tight):
            if j == 0:
                return 1
            if n - i < j:
                return 0

            if tight:
                end = int(s[i])
            else:
                end = 1

            res = 0
            for b in range(end + 1):
                res += dfs(i + 1, j - b, tight and b == end)
                res %= MOD
            return res

        ans = 0
        for x in range(1, n + 1):
            if valid(x, k - 1):
                ans += dfs(0, x, True)
                ans %= MOD

        if valid(s.count(""1""), k - 1):
            ans -= 1
            ans %= MOD

        return ans",1448254485
w0w0,w0w0,194,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        MOD = 10 ** 9 + 7
        n = len(nums)
        cnt = defaultdict(int)
        val = defaultdict(int)
        ans = 0
        for i in range(n):
            cnt[nums[i]] += cnt[nums[i] - 1] + cnt[nums[i] + 1] + 1
            cnt[nums[i]] %= MOD
            val[nums[i]] += val[nums[i] - 1] + val[nums[i] + 1] + (cnt[nums[i] - 1] + cnt[nums[i] + 1] + 1) * nums[i]
            val[nums[i]] %= MOD
            ans += val[nums[i] - 1] + val[nums[i] + 1] + (cnt[nums[i] - 1] + cnt[nums[i] + 1] + 1) * nums[i]
            ans %= MOD

        return ans",1448220961
kasi nathan,kasinathansj,198,3612,java,"class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        for(int i = 0 ; i <= nums.size()-2*k ; i++){
            int s1 = -1001;
            int e1 = -1001;
            boolean is = true;
            for(int j = 0 ; j < k ; j++){
                if(nums.get(i+j)<=s1)is = false;
                if(nums.get(i+k+j)<=e1)is = false;
                s1 = nums.get(i+j);
                e1 = nums.get(i+k+j);
            }
            if(is)return is;
        }
        return false;
    }
}",1448184909
kasi nathan,kasinathansj,198,3619,java,"class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        int pree[] = new int[nums.size()];
        int m = Integer.MAX_VALUE;
        int pre = 0;
        int c = 0;
        int ans = 1;
        for(int i = nums.size()-1 ; i >= 0 ; i--){
            if(nums.get(i)<m){
                c++;
                ans = Math.max(ans , Math.min(c , pre));
                ans = Math.max(ans , c/2);
            }else{
                pre = c;
                c = 1;
            }
            m = nums.get(i);
            pree[i] = c;
        }
        // System.out.println(Arrays.toString(pree));
        return ans;
    }
}",1448197467
kasi nathan,kasinathansj,198,3631,java,"class Solution {
    int k;
    int dp[][][];
    int mod = (int)1e9+7;
    public int countKReducibleNumbers(String s, int k) {
        this.k = k;
        dp = new int[s.length()+1][s.length()+1][2];
        for(int a[][] : dp)
            for(int b[] : a)
                Arrays.fill(b,-1);
        return count(0,0,0,s);
    }
    private int count(int c , int i , int ok ,String s){
        if(i==s.length()){
            if(ok==1)return isK(c);
            return 0;
        }
        if(dp[c][i][ok]!=-1)return dp[c][i][ok];
        int ans = 0;
        if(ok == 1){
            ans += count(c+1 , i+1,ok,s);
            ans %= mod;
            ans += count(c , i+1,ok,s);
            ans %= mod;
        }else{
            if(s.charAt(i)=='0'){
                ans += count(c,i+1,ok,s);
                ans %= mod;
            }else{
                ans += count(c,i+1,1,s);
                ans %= mod;
                ans += count(c+1,i+1,ok,s);
                ans %= mod;
            }
        }
        return dp[c][i][ok] = ans;
    }
    private int isK(int c){
        // System.out.println(c);
        for(int i = 1 ; i < k ; i++){
            int cnt = 0;
            while(c>0){
                c = c&(c-1);
                cnt++;
            }
            c = cnt;
            if(c==1)return 1;
        }
        
        if(c==1)return 1;
        return 0;
    }
}",1448255617
kasi nathan,kasinathansj,198,3646,java,"class Solution {
    int mod = (int)1e9+7;
    public int sumOfGoodSubsequences(int[] nums) {
        HashMap<Integer,Integer> hm = new HashMap<Integer,Integer>();
        HashMap<Integer,Integer> cnt = new HashMap<Integer,Integer>();
        for(int i : nums){
            int sum1 = hm.getOrDefault(i-1,-1);
            int sum2 = hm.getOrDefault(i+1,-1);
            int c1 = cnt.getOrDefault(i-1,-1);            
            int c2 = cnt.getOrDefault(i+1,-1);
            if(sum1!=-1){
                hm.merge(i,(int)((sum1+i*1l*c1)%mod),Integer::sum);
                hm.put(i,hm.get(i)%mod);
                cnt.merge(i,c1,Integer::sum);
                cnt.put(i,cnt.get(i)%mod);
            }
            if(sum2!=-1){
                hm.merge(i,(int)((sum2+i*1l*c2)%mod),Integer::sum);
                hm.put(i,hm.get(i)%mod);
                cnt.merge(i,c2,Integer::sum);
                cnt.put(i,cnt.get(i)%mod);
            }
            hm.merge(i,i,Integer::sum);
            hm.put(i,hm.get(i)%mod);
            cnt.merge(i,1,Integer::sum);
            cnt.put(i,cnt.get(i)%mod);
        }
        int sum = 0;
        for(int i : hm.values()){
            sum += i;
            sum %= mod;
        }
        return sum;
    }
}",1448232055
TulasiRaj,TulasiRaj,200,3612,java,"class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        int n = nums.size();
        int dp[] = new int[nums.size()];
        dp[n-1]=1; int max = 0;
        for(int i=n-2;i>=0;i--)
        {
            if(nums.get(i+1)>nums.get(i)) {
                dp[i] = dp[i+1]+1;
            }
            else dp[i] = 1;
            max = Math.max(max,dp[i]/2);
        }
        if(max>=k) return true;
        for(int i=0;i<n;i++)
        {
            if(dp[i]==k&&i+dp[i]<n) {
               if(dp[i+dp[i]]>=dp[i])
               {
                   return true;
               }
            }
        }
        return false;
    }
}",1448194767
TulasiRaj,TulasiRaj,200,3619,java,"class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        int n = nums.size();
        int dp[] = new int[nums.size()];
        dp[n-1]=1; int max = 0;
        for(int i=n-2;i>=0;i--)
        {
            if(nums.get(i+1)>nums.get(i)) {
                dp[i] = dp[i+1]+1;
            }
            else dp[i] = 1;
            max = Math.max(max,dp[i]/2);
        }
        for(int i=0;i<n;i++)
        {
            if(i+dp[i]<n) {
               if(dp[i+dp[i]]>=dp[i])
               {
                   max = Math.max(max,dp[i]);
               }
            }
        }
        return max;
    }
}",1448186737
TulasiRaj,TulasiRaj,200,3631,java,"class Solution {
    static int mod = 1000000007;
    static int dp[][][];
    public int countKReducibleNumbers(String s, int k) {
        int n = s.length();
        dp = new int[n][n+1][2];
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<=n;j++)
            {
                Arrays.fill(dp[i][j],-1);
            }
        }
        return f(s,n,0,1,0,k);
    }
    public int f(String s,int n, int i,int d,int set,int k)
    {
        if(i==n)
        {
            if(set>0&&d==0) {
                if(helper(set,k-1)) return 1;
            }
            return 0;
        }
        if(dp[i][set][d]!=-1) return dp[i][set][d];
        int val = s.charAt(i)-'0';
        int cnt1 = f(s,n,i+1,(d==1&&val==0)?1:0,set,k);
        int cnt2 = 0;
        if(d==0||val==1)
        {
           cnt2 = f(s,n,i+1,(d==1&&val==1)?1:0,set+1,k);
        }
        return dp[i][set][d] = (cnt1+cnt2)%mod;
    }
    public boolean helper(int n,int k)
    {
        int cnt = 0;
        while(n>1)
        {
           n =Integer.bitCount(n);
           cnt++;
           if(cnt>k) return false; 
        }
        return true;
    }
}",1448263013
TulasiRaj,TulasiRaj,200,3646,java,"class Solution {
    static long mod = 1000000007;
    public int sumOfGoodSubsequences(int[] nums) {
        int n = nums.length;
        long dp[] = new long[100006];
        long cnt[] = new long[100006];
        long sum = 0l;
        for(int i=0;i<n;i++)
        {
            int k = nums[i];
            if(k-1>=0)
            {
                dp[k] = dp[k]+ (dp[k-1]+ (cnt[k-1]*nums[i])%mod)%mod;
                dp[k]%=mod;
                cnt[k]+=cnt[k-1];
                cnt[k]%=mod;
            }
            if(k+1<=100005)
            {
                dp[k] = dp[k]+ (dp[k+1]+ (cnt[k+1]*nums[i])%mod)%mod;
                dp[k]%=mod;
                cnt[k]+=cnt[k+1];
                cnt[k]%=mod;
            }
            dp[k] = dp[k]+k;
            dp[k]%=mod;
            cnt[k] = cnt[k]+1;
            cnt[k]%=mod;
        }
        for(int i=0;i<=100005;i++) {
            sum = sum+dp[i];
            sum%=mod;
        }
        return (int)sum;
    }
}",1448234563
uday0506,udayk2977,202,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
    
    if (2 * k > n) {
        return false;
    }

    vector<int> inc_len(n, 1); 
    for (int i = n - 2; i >= 0; --i) {
        if (nums[i] < nums[i + 1]) {
            inc_len[i] = inc_len[i + 1] + 1;
        } else {
            inc_len[i] = 1;
        }
    }
    
    for (int a = 0; a + 2 * k <= n; ++a) {

        if (inc_len[a] >= k && inc_len[a + k] >= k) {
            return true;
        }
    }
    
    return false;
    }
};",1448191785
uday0506,udayk2977,202,3619,cpp,"class Solution {
public:
    vector<int> get_inc(const vector<int>& nums){
        int n = nums.size();
        vector<int> inc(n,1);
        for(int i=n-2;i>=0;i--){
            if(nums[i]<nums[i+1]) inc[i]=inc[i+1]+1;
        }
        return inc;
    }

    bool check_k(const vector<int>& inc, int k){
        int n = inc.size();
        for(int i=0;i + 2*k <=n;i++) if(inc[i]>=k && inc[i+k]>=k) return true;
        return false;
    }
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n=nums.size();
        vector<int> inc = get_inc(nums);
        int l=1, r=n/2, res=0;
        while(l<=r){
            int m = l + (r-l)/2;
            if(check_k(inc, m)){ res=m; l=m+1;}
            else r=m-1;
        }
        return res;
    }
};",1448201599
uday0506,udayk2977,202,3631,cpp,"#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int M = 1e9+7;

class Solution {
public:
    ll memo[801][801][2][2];
    int f[801];
    bool C[801];
    string s;
    int k;
    
    string sub_one(string s){
        int n = s.size()-1;
        while(n >=0 && s[n]=='0'){
            s[n]='1';
            n--;
        }
        if(n >=0){
            s[n]='0';
        }
        else{
            s=""0"";
        }
        return s;
    }
    
    ll dp(int p, int c, int t, int st){
        if(p == s.size()){
            if(!st) return 0;
            return C[c] ? 1 : 0;
        }
        if(memo[p][c][t][st] != -1) return memo[p][c][t][st];
        int lim = t ? (s[p]-'0') : 1;
        ll res = 0;
        for(int b = 0; b <= lim; b++){
            int nt = t && (b == lim);
            int ns = st || (b != 0);
            int nc = ns ? c + b : 0;
            res = (res + dp(p + 1, nc, nt, ns)) % M;
        }
        return memo[p][c][t][st] = res;
    }
    
    int countKReducibleNumbers(string S, int K){
        s = sub_one(S);
        k = K;
        f[1] = 0;
        for(int c = 2; c <= 800; c++) f[c] = 1 + f[__builtin_popcount(c)];
        for(int c = 1; c <= 800; c++) C[c] = (f[c] <= k - 1);
        memset(memo, -1, sizeof(memo));
        return dp(0, 0, 1, 0);
    }
};",1448233819
uday0506,udayk2977,202,3646,cpp,"#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int M = 1e9+7;

class Solution {
public:
    ll calc(int x, const vector<ll>& c, const vector<ll>& s, int shift) {
        ll tmp = x;
        if(x > 0) tmp = (tmp + (x * c[x - 1 + shift]) % M + s[x - 1 + shift]) % M;
        if(x + 1 + shift < c.size()) tmp = (tmp + (x * c[x + 1 + shift]) % M + s[x + 1 + shift]) % M;
        return tmp;
    }

    void update(int x, ll tmp, vector<ll>& c, vector<ll>& s, int shift) {
        s[x + shift] = (s[x + shift] + tmp) % M;
        c[x + shift] = (c[x + shift] + ((x > 0) ? c[x - 1 + shift] : 0) + ((x + 1 + shift < c.size()) ? c[x + 1 + shift] : 0) + 1) % M;
    }

    int sumOfGoodSubsequences(vector<int>& nums) {
        if(nums.empty()) return 0;
        
        int min_x = *min_element(nums.begin(), nums.end());
        int max_x = *max_element(nums.begin(), nums.end());
        int shift = (min_x <= 0) ? 1 - min_x : 0;
        
        vector<ll> c(max_x + shift + 2, 0), s(max_x + shift + 2, 0);
        ll total = 0;
        
        for(auto x : nums){
            ll tmp = calc(x, c, s, shift);
            update(x, tmp, c, s, shift);
            total = (total + tmp) % M;
        }
        
        return static_cast<int>(total);
    }
};
",1448211671
jason7708,jason7708,203,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size(), i = 0, pre = 0;
        while(i < n) {
            int st = i++;
            while(i < n && nums[i] > nums[i-1]) {
                i++;
            }
            int len = i - st;
            if(pre >= k && len >= k || len >= 2 * k) {
                return true;
            }
            pre = len;
        }
        return false;
    }
};",1448182492
jason7708,jason7708,203,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size(), i = 0, pre = 0;
        int ans = 0;
        while(i < n) {
            int st = i++;
            while(i < n && nums[i] > nums[i-1]) {
                i++;
            }
            int len = i - st;
            ans = max(ans, min(pre, len));
            ans = max(ans, len / 2);
            pre = len;
        }
        return ans;
    }
};",1448185402
jason7708,jason7708,203,3631,cpp,"class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        constexpr int mod = 1e9 + 7;
        int m = s.size();
        // int m = 800;

        vector<int> t(m+1, 0);
        t[0] = INT_MAX / 2;
        for(int i=2; i<=m; i++) {
            int pop_c = std::popcount(static_cast<unsigned int>(i));
            t[i] = t[pop_c] + 1;
        }
        vector<vector<int>> dp(m, vector<int>(m+1, -1));
        auto dfs = [&] (auto&& dfs, int i, int j, bool is_limit) ->int {
            if(i == m) {
                return !is_limit && (t[j] + 1) <= k;
            }
            if(dp[i][j] != -1 && !is_limit) {
                return dp[i][j];
            }
            char up = is_limit ? s[i] : '1';
            int res = 0;
            for(char c='0'; c<=up; c++) {
                auto r = dfs(dfs, i+1, j + (c - '0'), is_limit && c == up);
                // cout << i << ' ' << j + (c - '0') << ' ' << r << '\n';
                // res = (res + dfs(dfs, i+1, j + (c - '0'), is_limit && c == up)) % mod;
                res = (res + r) % mod;
            }
            if(!is_limit)
                dp[i][j] = res;
            return res;
        };
        
        return dfs(dfs, 0, 0, true);
    }
};",1448264019
jason7708,jason7708,203,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        constexpr int mod = 1e9 + 7;
        int n = nums.size();

        unordered_map<int, long long> dp, sum;
        for(int i=0; i<n; i++) {
            // (dp[nums[i]-1] * nums[i] % mod + sum[nums[i]-1]) % mod
            // (dp[nums[i]+1] * nums[i] % mod + sum[nums[i]+1]) % mod
            // nums[i]
            sum[nums[i]] = ((((dp[nums[i]-1] * nums[i] % mod + sum[nums[i]-1]) % mod + 
                            (dp[nums[i]+1] * nums[i] % mod + sum[nums[i]+1]) % mod) % mod + 
                            nums[i]) % mod + sum[nums[i]]) % mod;
            dp[nums[i]] = (dp[nums[i]] + (1 + (dp[nums[i] - 1] + dp[nums[i] + 1]) % mod) % mod) % mod;
            // cout << sum[nums[i]] << ' ' << dp[nums[i]] << '\n';
        }
        int ans = 0;
        for(const auto& [num, s] : sum) {
            ans = (ans + s) % mod;
        }
        return ans;
    }
};",1448214730
Brian Ahaneku,Ruvxei,207,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        for i in range(n - 2 * k + 3):
            if i + 2 * k - 1 >= n:
                return False
            fail = False
            for j in range(i + 1, i + k):
                if nums[j] <= nums[j - 1]:
                    fail = True
                    break
            if fail:
                continue
            for j in range(i + k + 1, i + 2 * k):
                if nums[j] <= nums[j - 1]:
                    fail = True
                    break
            if not fail:
                return True
        return False",1448183931
Brian Ahaneku,Ruvxei,207,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        dp = [1 for _ in range(n)]
        for i in range(n - 2, -1, -1):
            if nums[i] < nums[i + 1]:
                dp[i] = 1 + dp[i + 1]
        l = 1
        r = n // 2
        ans = 1
        while l <= r:
            m = (l + r) // 2
            success = False
            for i in range(n):
                if i + m >= n:
                    break
                if dp[i] >= m and dp[i + m] >= m:
                    success = True
                    break
            if success:
                l = m + 1
                ans = max(ans, m)
            else:
                r = m - 1
        return ans
                    
                ",1448195090
Brian Ahaneku,Ruvxei,207,3631,python3,"MOD = 10**9 + 7
class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        m = len(s)
        reduce = [False for _ in range(m + 1)]
        for i in range(1, m + 1):
            num = i
            tries = 0
            while num >= 1 and tries < k - 1:
                x = num
                cnt = 0
                while x > 0:
                    cnt += x & 1
                    x //= 2
                num = cnt
                tries += 1
            
            if num == 1:
                reduce[i] = True
        ans = 0
        for length in range(1, m):
            for numBits in range(1, length + 1):
                if reduce[numBits]:
                    ans = (ans + math.comb(length - 1, numBits - 1)) % MOD
        ones = 1
        for i in range(1, m):
            if s[i] == '1':
                for numBits in range((m - 1) - (i + 1) + 1 + 1):
                    if reduce[numBits + ones]:
                        ans = (ans + math.comb((m - 1) - (i + 1) + 1, numBits)) % MOD
                    
                ones += 1
                
        return ans
                    
                ",1448257954
Brian Ahaneku,Ruvxei,207,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        MOD = 10**9 + 7
        n = len(nums)
        total = defaultdict(int)
        sub = defaultdict(int)
        dp = [0 for _ in range(n + 1)]
        for i in range(n - 1, -1, -1):
            dp[i] = (nums[i] * ((sub[nums[i] + 1]) + (sub[nums[i] - 1]) + 1) + total[nums[i] + 1] + total[nums[i] - 1]) % MOD
            total[nums[i]] = (total[nums[i]] + dp[i]) % MOD
            sub[nums[i]] = sub[nums[i]] + sub[nums[i] + 1] + sub[nums[i] - 1] + 1
        return sum(dp) % MOD
        ",1448219377
hellotestabc,hellotestabc,208,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        for (int i = 0; i < nums.size() - 2 * k + 1; i++) {
            bool ok = true;
            
            for (int j = i; j < i + k - 1; j++) {
                // cout << ""first "" << j << endl;
                if (nums[j] < nums[j + 1]) {
                    
                } else {
                    ok = false;
                    break;
                }
            }

            for (int j = i + k; j < i + k + k - 1; j++) {
                // cout << ""second "" << j << endl;
                if (nums[j] < nums[j + 1]) {
                    
                } else {
                    ok = false;
                }
            }

            if (ok) {
                return ok;
            }
        }

        return false;
    }
};",1448182746
hellotestabc,hellotestabc,208,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        vector<int> arr(nums.size());
        arr[0] = 1;

        for (int i = 1; i < nums.size(); i++) {
            if (nums[i] > nums[i - 1]) {
                arr[i] = arr[i - 1] + 1;
            } else {
                arr[i] = 1;
            }
        }

        int low = 1;
        int high = nums.size();
        int best = 0;
        
        while (low <= high) {
            int mid = (low + high) / 2;

            bool ok = false;

            for (int i = 0; i < arr.size() - mid; i++) {
                if (arr[i] >= mid && arr[i + mid] >= mid) {
                    ok = true;
                    break;
                }
            }

            if (ok) {
                best = max(best, mid);
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }

        return best;
    }
};",1448194570
hellotestabc,hellotestabc,208,3631,cpp,"class Solution {
public:
    static constexpr int mod = 1e9 + 7;

    int traverse(int index, const string& s, bool leading, const int k, int setbits, vector<vector<vector<int>>>& dp) {
        if (index >= s.size()) {
            int val = setbits;
            
            for (int i = 0; i < k - 1; i++) {
                val = __builtin_popcount(val); 
            }

            return val == 1;
        }

        if (dp[index][leading][setbits] != -1) {
            return dp[index][leading][setbits];
        }

        // lets say we add a zero
        int total = 0;

        if (leading) {
            if (s[index] == '1') {
                total = (total + traverse(index + 1, s, leading, k, setbits + 1, dp)) % mod;
                total = (total + traverse(index + 1, s, false, k, setbits, dp)) % mod;
            } else {
                total = (total + traverse(index + 1, s, true, k, setbits, dp)) % mod;
            }   
        } else {
            total = (total + traverse(index + 1, s, false, k, setbits + 1, dp)) % mod;
            total = (total + traverse(index + 1, s, false, k, setbits, dp)) % mod;
        }

        return dp[index][leading][setbits] = total % mod;
    }

    int countKReducibleNumbers(string s, int k) {
        string lower = s;

        for (int i = lower.size() - 1; i >= 0; i--) {
            if (lower[i] == '1') {
                lower[i] = '0';
                break;
            } else {
                lower[i] = '1';
            }
        }

        while (lower[0] == '0') {
            lower = lower.substr(1, lower.size() - 1);
        }

        vector<vector<vector<int>>> dp(s.size(), vector<vector<int>>(2, vector<int>(s.size() + 1, -1)));

        return traverse(0, lower, true, k, 0, dp);
    }
};",1448258228
hellotestabc,hellotestabc,208,3646,cpp,"class Solution {
public:
    static constexpr int mod = 1e9 + 7;

    int sumOfGoodSubsequences(vector<int>& nums) {
        unordered_map<int, int> counts;
        unordered_map<int, int> totals;

        long long total = 0;

        for (long long i : nums) {
            int count = 1;
            long long sum = i;

            if (counts.contains(i - 1)) {
                count = (count + counts[i - 1]) % mod;
                sum = (sum % mod + totals[i - 1] % mod + (counts[i - 1] * i) % mod) % mod;
            }
            if (counts.contains(i + 1)) {
                count = (count + counts[i + 1]) % mod;
                sum = (sum % mod + totals[i + 1] % mod + (counts[i + 1] * i) % mod) % mod;
            }

            counts[i] = (counts[i] + count) % mod;
            totals[i] = (totals[i] + sum) % mod;

            total = (total + sum) % mod;
        }

        return total;
    }
};",1448223445
garyjhu,garyjhu,217,3612,java,"import java.util.List;

class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        int n = nums.size();
        for (int i = 0; i + k + k <= n; i++) {
            boolean flag = true;
            for (int j = i + 1; j < i + k; j++) {
                if (nums.get(j) <= nums.get(j - 1)) {
                    flag = false;
                    break;
                }
            }
            for (int j = i + k + 1; j < i + k + k; j++) {
                if (nums.get(j) <= nums.get(j - 1)) {
                    flag = false;
                    break;
                }
            }
            if (flag) return true;
        }
        return false;
    }
}
",1448183079
garyjhu,garyjhu,217,3619,java,"import java.util.List;

class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        int n = nums.size();
        int start = 0;
        int[] max = new int[n];
        for (int i = 1; i <= n; i++) {
            if (i < n && nums.get(i) > nums.get(i - 1)) continue;
            while (start < i) {
                max[start] = i;
                start++;
            }
        }
        int lo = 1, hi = n / 2;
        while (lo <= hi) {
            int mid = (lo + hi) / 2;
            boolean flag = false;
            for (int i = 0; i + mid + mid <= n; i++) {
                if (max[i] >= i + mid && max[i + mid] >= i + mid + mid) {
                    flag = true;
                    break;
                }
            }
            if (flag) lo = mid + 1;
            else hi = mid - 1;
        }
        return hi;
    }
}
",1448192567
garyjhu,garyjhu,217,3631,java,"import java.util.ArrayList;

class Solution {
    static ModIntFactory factory = new ModIntFactory(1_000_000_007);
    static int[] aux;
    String s;
    int k, n;
    public int countKReducibleNumbers(String s, int k) {
        if (aux == null) init();
        this.s = s;
        this.k = k;
        n = s.length();
        ModIntFactory.ModInt res = factory.create(0);
        int count = 0;
        for (int i = 0; i < n; i++) {
            if (s.charAt(i) == '0') continue;
            for (int j = 0; j <= n - 1 - i; j++) {
                if (aux[count + j] < k) {
                    res.addAsg(factory.combination(n - 1 - i, j));
//                    System.out.println(i + "" "" + j + "" "" + res);
                }
            }
            if (count == 0) {
                res.subAsg(1);
            }
//            System.out.println(i + "" "" + res);
            count++;
        }
        return res.value;
    }

    private static void init() {
        aux = new int[801];
        for (int i = 2; i <= 800; i++) aux[i] = aux[Integer.bitCount(i)] + 1;
    }

    static class ModIntFactory {
        private final ModArithmetic ma;
        private final int mod;

        private final boolean usesMontgomery;
        private final ModArithmetic.ModArithmeticMontgomery maMontgomery;

        private ArrayList<Integer> factorial;

        public ModIntFactory(int mod) {
            this.ma = ModArithmetic.of(mod);
            this.usesMontgomery = ma instanceof ModArithmetic.ModArithmeticMontgomery;
            this.maMontgomery = usesMontgomery ? (ModArithmetic.ModArithmeticMontgomery) ma : null;
            this.mod = mod;

            this.factorial = new ArrayList<>();
        }

        public ModInt create(long value) {
            if ((value %= mod) < 0) value += mod;
            if (usesMontgomery) {
                return new ModInt(maMontgomery.generate(value));
            } else {
                return new ModInt((int) value);
            }
        }

        private void prepareFactorial(int max){
            factorial.ensureCapacity(max+1);
            if(factorial.size()==0) factorial.add(1);
            if (usesMontgomery) {
                for(int i=factorial.size(); i<=max; i++){
                    factorial.add(ma.mul(factorial.get(i-1), maMontgomery.generate(i)));
                }
            } else {
                for(int i=factorial.size(); i<=max; i++){
                    factorial.add(ma.mul(factorial.get(i-1), i));
                }
            }
        }

        public ModInt factorial(int i){
            prepareFactorial(i);
            return create(factorial.get(i));
        }

        public ModInt permutation(int n, int r){
            if(n < 0 || r < 0 || n < r) return create(0);
            prepareFactorial(n);
            return create(ma.div(factorial.get(n), factorial.get(r)));
        }
        public ModInt combination(int n, int r){
            if(n < 0 || r < 0 || n < r) return create(0);
            prepareFactorial(n);
            return create(ma.div(factorial.get(n), ma.mul(factorial.get(r),factorial.get(n-r))));
        }

        public int getMod() {
            return mod;
        }

        public class ModInt {
            private int value;
            private ModInt(int value) {
                this.value = value;
            }
            public int mod() {
                return mod;
            }
            public int value() {
                if (usesMontgomery) {
                    return maMontgomery.reduce(value);
                }
                return value;
            }
            public ModInt add(ModInt mi) {
                return new ModInt(ma.add(value, mi.value));
            }
            public ModInt add(ModInt mi1, ModInt mi2) {
                return new ModInt(ma.add(value, mi1.value)).addAsg(mi2);
            }
            public ModInt add(ModInt mi1, ModInt mi2, ModInt mi3) {
                return new ModInt(ma.add(value, mi1.value)).addAsg(mi2).addAsg(mi3);
            }
            public ModInt add(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {
                return new ModInt(ma.add(value, mi1.value)).addAsg(mi2).addAsg(mi3).addAsg(mi4);
            }
            public ModInt add(ModInt mi1, ModInt... mis) {
                ModInt mi = add(mi1);
                for (ModInt m : mis) mi.addAsg(m);
                return mi;
            }
            public ModInt add(long mi) {
                return new ModInt(ma.add(value, ma.remainder(mi)));
            }
            public ModInt sub(ModInt mi) {
                return new ModInt(ma.sub(value, mi.value));
            }
            public ModInt sub(long mi) {
                return new ModInt(ma.sub(value, ma.remainder(mi)));
            }
            public ModInt mul(ModInt mi) {
                return new ModInt(ma.mul(value, mi.value));
            }
            public ModInt mul(ModInt mi1, ModInt mi2) {
                return new ModInt(ma.mul(value, mi1.value)).mulAsg(mi2);
            }
            public ModInt mul(ModInt mi1, ModInt mi2, ModInt mi3) {
                return new ModInt(ma.mul(value, mi1.value)).mulAsg(mi2).mulAsg(mi3);
            }
            public ModInt mul(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {
                return new ModInt(ma.mul(value, mi1.value)).mulAsg(mi2).mulAsg(mi3).mulAsg(mi4);
            }
            public ModInt mul(ModInt mi1, ModInt... mis) {
                ModInt mi = mul(mi1);
                for (ModInt m : mis) mi.mulAsg(m);
                return mi;
            }
            public ModInt mul(long mi) {
                return new ModInt(ma.mul(value, ma.remainder(mi)));
            }
            public ModInt div(ModInt mi) {
                return new ModInt(ma.div(value, mi.value));
            }
            public ModInt div(long mi) {
                return new ModInt(ma.div(value, ma.remainder(mi)));
            }
            public ModInt inv() {
                return new ModInt(ma.inv(value));
            }
            public ModInt pow(long b) {
                return new ModInt(ma.pow(value, b));
            }
            public ModInt addAsg(ModInt mi) {
                this.value = ma.add(value, mi.value);
                return this;
            }
            public ModInt addAsg(ModInt mi1, ModInt mi2) {
                return addAsg(mi1).addAsg(mi2);
            }
            public ModInt addAsg(ModInt mi1, ModInt mi2, ModInt mi3) {
                return addAsg(mi1).addAsg(mi2).addAsg(mi3);
            }
            public ModInt addAsg(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {
                return addAsg(mi1).addAsg(mi2).addAsg(mi3).addAsg(mi4);
            }
            public ModInt addAsg(ModInt... mis) {
                for (ModInt m : mis) addAsg(m);
                return this;
            }
            public ModInt addAsg(long mi) {
                this.value = ma.add(value, ma.remainder(mi));
                return this;
            }
            public ModInt subAsg(ModInt mi) {
                this.value = ma.sub(value, mi.value);
                return this;
            }
            public ModInt subAsg(long mi) {
                this.value = ma.sub(value, ma.remainder(mi));
                return this;
            }
            public ModInt mulAsg(ModInt mi) {
                this.value = ma.mul(value, mi.value);
                return this;
            }
            public ModInt mulAsg(ModInt mi1, ModInt mi2) {
                return mulAsg(mi1).mulAsg(mi2);
            }
            public ModInt mulAsg(ModInt mi1, ModInt mi2, ModInt mi3) {
                return mulAsg(mi1).mulAsg(mi2).mulAsg(mi3);
            }
            public ModInt mulAsg(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {
                return mulAsg(mi1).mulAsg(mi2).mulAsg(mi3).mulAsg(mi4);
            }
            public ModInt mulAsg(ModInt... mis) {
                for (ModInt m : mis) mulAsg(m);
                return this;
            }
            public ModInt mulAsg(long mi) {
                this.value = ma.mul(value, ma.remainder(mi));
                return this;
            }
            public ModInt divAsg(ModInt mi) {
                this.value = ma.div(value, mi.value);
                return this;
            }
            public ModInt divAsg(long mi) {
                this.value = ma.div(value, ma.remainder(mi));
                return this;
            }
            @Override
            public String toString() {
                return String.valueOf(value());
            }
            @Override
            public boolean equals(Object o) {
                if (o instanceof ModInt) {
                    ModInt mi = (ModInt) o;
                    return mod() == mi.mod() && value() == mi.value();
                }
                return false;
            }
            @Override
            public int hashCode() {
                return (1 * 37 + mod()) * 37 + value();
            }
        }

        private static abstract class ModArithmetic {
            abstract int mod();
            abstract int remainder(long value);
            abstract int add(int a, int b);
            abstract int sub(int a, int b);
            abstract int mul(int a, int b);
            int div(int a, int b) {
                return mul(a, inv(b));
            }
            int inv(int a) {
                int b = mod();
                if (b == 1) return 0;
                long u = 1, v = 0;
                while (b >= 1) {
                    int t = a / b;
                    a -= t * b;
                    int tmp1 = a; a = b; b = tmp1;
                    u -= t * v;
                    long tmp2 = u; u = v; v = tmp2;
                }
                if (a != 1) {
                    throw new ArithmeticException(""divide by zero"");
                }
                return remainder(u);
            }
            int pow(int a, long b) {
                if (b < 0) throw new ArithmeticException(""negative power"");
                int r = 1;
                int x = a;
                while (b > 0) {
                    if ((b & 1) == 1) r = mul(r, x);
                    x = mul(x, x);
                    b >>= 1;
                }
                return r;
            }

            static ModArithmetic of(int mod) {
                if (mod <= 0) {
                    throw new IllegalArgumentException();
                } else if (mod == 1) {
                    return new ModArithmetic1();
                } else if (mod == 2) {
                    return new ModArithmetic2();
                } else if (mod == 998244353) {
                    return new ModArithmetic998244353();
                } else if (mod == 1000000007) {
                    return new ModArithmetic1000000007();
                } else if ((mod & 1) == 1) {
                    return new ModArithmeticMontgomery(mod);
                } else {
                    return new ModArithmeticBarrett(mod);
                }
            }

            private static final class ModArithmetic1 extends ModArithmetic {
                int mod() {return 1;}
                int remainder(long value) {return 0;}
                int add(int a, int b) {return 0;}
                int sub(int a, int b) {return 0;}
                int mul(int a, int b) {return 0;}
                int pow(int a, long b) {return 0;}
            }
            private static final class ModArithmetic2 extends ModArithmetic {
                int mod() {return 2;}
                int remainder(long value) {return (int) (value & 1);}
                int add(int a, int b) {return a ^ b;}
                int sub(int a, int b) {return a ^ b;}
                int mul(int a, int b) {return a & b;}
            }
            private static final class ModArithmetic998244353 extends ModArithmetic {
                private final int mod = 998244353;
                int mod() {
                    return mod;
                }
                int remainder(long value) {
                    return (int) ((value %= mod) < 0 ? value + mod : value);
                }
                int add(int a, int b) {
                    int res = a + b;
                    return res >= mod ? res - mod : res;
                }
                int sub(int a, int b) {
                    int res = a - b;
                    return res < 0 ? res + mod : res;
                }
                int mul(int a, int b) {
                    return (int) (((long) a * b) % mod);
                }
            }
            private static final class ModArithmetic1000000007 extends ModArithmetic {
                private final int mod = 1000000007;
                int mod() {
                    return mod;
                }
                int remainder(long value) {
                    return (int) ((value %= mod) < 0 ? value + mod : value);
                }
                int add(int a, int b) {
                    int res = a + b;
                    return res >= mod ? res - mod : res;
                }
                int sub(int a, int b) {
                    int res = a - b;
                    return res < 0 ? res + mod : res;
                }
                int mul(int a, int b) {
                    return (int) (((long) a * b) % mod);
                }
            }
            private static final class ModArithmeticMontgomery extends ModArithmeticDynamic {
                private final long negInv;
                private final long r2;

                private ModArithmeticMontgomery(int mod) {
                    super(mod);
                    long inv = 0;
                    long s = 1, t = 0;
                    for (int i = 0; i < 32; i++) {
                        if ((t & 1) == 0) {
                            t += mod;
                            inv += s;
                        }
                        t >>= 1;
                        s <<= 1;
                    }
                    long r = (1l << 32) % mod;
                    this.negInv = inv;
                    this.r2 = (r * r) % mod;
                }
                private int generate(long x) {
                    return reduce(x * r2);
                }
                private int reduce(long x) {
                    x = (x + ((x * negInv) & 0xffff_ffffl) * mod) >>> 32;
                    return (int) (x < mod ? x : x - mod);
                }
                @Override
                int remainder(long value) {
                    return generate((value %= mod) < 0 ? value + mod : value);
                }
                @Override
                int mul(int a, int b) {
                    return reduce((long) a * b);
                }
                @Override
                int inv(int a) {
                    return super.inv(reduce(a));
                }
                @Override
                int pow(int a, long b) {
                    return generate(super.pow(a, b));
                }
            }
            private static final class ModArithmeticBarrett extends ModArithmeticDynamic {
                private static final long mask = 0xffff_ffffl;
                private final long mh;
                private final long ml;
                private ModArithmeticBarrett(int mod) {
                    super(mod);
                    /**
                     * m = floor(2^64/mod)
                     * 2^64 = p*mod + q, 2^32 = a*mod + b
                     * => (a*mod + b)^2 = p*mod + q
                     * => p = mod*a^2 + 2ab + floor(b^2/mod)
                     */
                    long a = (1l << 32) / mod;
                    long b = (1l << 32) % mod;
                    long m = a * a * mod + 2 * a * b + (b * b) / mod;
                    mh = m >>> 32;
                    ml = m & mask;
                }
                private int reduce(long x) {
                    long z = (x & mask) * ml;
                    z = (x & mask) * mh + (x >>> 32) * ml + (z >>> 32);
                    z = (x >>> 32) * mh + (z >>> 32);
                    x -= z * mod;
                    return (int) (x < mod ? x : x - mod);
                }
                @Override
                int remainder(long value) {
                    return (int) ((value %= mod) < 0 ? value + mod : value);
                }
                @Override
                int mul(int a, int b) {
                    return reduce((long) a * b);
                }
            }
            private static class ModArithmeticDynamic extends ModArithmetic {
                final int mod;
                ModArithmeticDynamic(int mod) {
                    this.mod = mod;
                }
                int mod() {
                    return mod;
                }
                int remainder(long value) {
                    return (int) ((value %= mod) < 0 ? value + mod : value);
                }
                int add(int a, int b) {
                    int sum = a + b;
                    return sum >= mod ? sum - mod : sum;
                }
                int sub(int a, int b) {
                    int sum = a - b;
                    return sum < 0 ? sum + mod : sum;
                }
                int mul(int a, int b) {
                    return (int) (((long) a * b) % mod);
                }
            }
        }
    }

}
",1448261100
garyjhu,garyjhu,217,3646,java,"import java.util.ArrayList;

class Solution {
    ModIntFactory factory = new ModIntFactory(1_000_000_007);
    public int sumOfGoodSubsequences(int[] nums) {
        int n = nums.length;
        int max = 0;
        for (int num : nums) max = Math.max(max, num);
        ModIntFactory.ModInt[] dp = new ModIntFactory.ModInt[max + 1];
        ModIntFactory.ModInt[] count = new ModIntFactory.ModInt[max + 1];
        for (int i = 0; i <= max; i++) {
            dp[i] = factory.create(0);
            count[i] = factory.create(0);
        }
        for (int i = 0; i < n; i++) {
            dp[nums[i]].addAsg(nums[i]);
            count[nums[i]].addAsg(1);
            if (nums[i] != 0) {
                dp[nums[i]].addAsg(dp[nums[i] - 1].add(count[nums[i] - 1].mul(nums[i])));
                count[nums[i]].addAsg(count[nums[i] - 1]);
            }
            if (nums[i] != max) {
                dp[nums[i]].addAsg(dp[nums[i] + 1].add(count[nums[i] + 1].mul(nums[i])));
                count[nums[i]].addAsg(count[nums[i] + 1]);
            }
//            for (int j = 0; j <= max; j++) System.out.print(dp[j] + "" "");
//            System.out.println();
//            for (int j = 0; j <= max; j++) System.out.print(count[j] + "" "");
//            System.out.println();
        }
//        System.out.println();
        ModIntFactory.ModInt res = factory.create(0);
        for (int i = 0; i <= max; i++) res.addAsg(dp[i]);
        return res.value;
    }

    static class ModIntFactory {
        private final ModArithmetic ma;
        private final int mod;

        private final boolean usesMontgomery;
        private final ModArithmetic.ModArithmeticMontgomery maMontgomery;

        private ArrayList<Integer> factorial;

        public ModIntFactory(int mod) {
            this.ma = ModArithmetic.of(mod);
            this.usesMontgomery = ma instanceof ModArithmetic.ModArithmeticMontgomery;
            this.maMontgomery = usesMontgomery ? (ModArithmetic.ModArithmeticMontgomery) ma : null;
            this.mod = mod;

            this.factorial = new ArrayList<>();
        }

        public ModInt create(long value) {
            if ((value %= mod) < 0) value += mod;
            if (usesMontgomery) {
                return new ModInt(maMontgomery.generate(value));
            } else {
                return new ModInt((int) value);
            }
        }

        private void prepareFactorial(int max){
            factorial.ensureCapacity(max+1);
            if(factorial.size()==0) factorial.add(1);
            if (usesMontgomery) {
                for(int i=factorial.size(); i<=max; i++){
                    factorial.add(ma.mul(factorial.get(i-1), maMontgomery.generate(i)));
                }
            } else {
                for(int i=factorial.size(); i<=max; i++){
                    factorial.add(ma.mul(factorial.get(i-1), i));
                }
            }
        }

        public ModInt factorial(int i){
            prepareFactorial(i);
            return create(factorial.get(i));
        }

        public ModInt permutation(int n, int r){
            if(n < 0 || r < 0 || n < r) return create(0);
            prepareFactorial(n);
            return create(ma.div(factorial.get(n), factorial.get(r)));
        }
        public ModInt combination(int n, int r){
            if(n < 0 || r < 0 || n < r) return create(0);
            prepareFactorial(n);
            return create(ma.div(factorial.get(n), ma.mul(factorial.get(r),factorial.get(n-r))));
        }

        public int getMod() {
            return mod;
        }

        public class ModInt {
            private int value;
            private ModInt(int value) {
                this.value = value;
            }
            public int mod() {
                return mod;
            }
            public int value() {
                if (usesMontgomery) {
                    return maMontgomery.reduce(value);
                }
                return value;
            }
            public ModInt add(ModInt mi) {
                return new ModInt(ma.add(value, mi.value));
            }
            public ModInt add(ModInt mi1, ModInt mi2) {
                return new ModInt(ma.add(value, mi1.value)).addAsg(mi2);
            }
            public ModInt add(ModInt mi1, ModInt mi2, ModInt mi3) {
                return new ModInt(ma.add(value, mi1.value)).addAsg(mi2).addAsg(mi3);
            }
            public ModInt add(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {
                return new ModInt(ma.add(value, mi1.value)).addAsg(mi2).addAsg(mi3).addAsg(mi4);
            }
            public ModInt add(ModInt mi1, ModInt... mis) {
                ModInt mi = add(mi1);
                for (ModInt m : mis) mi.addAsg(m);
                return mi;
            }
            public ModInt add(long mi) {
                return new ModInt(ma.add(value, ma.remainder(mi)));
            }
            public ModInt sub(ModInt mi) {
                return new ModInt(ma.sub(value, mi.value));
            }
            public ModInt sub(long mi) {
                return new ModInt(ma.sub(value, ma.remainder(mi)));
            }
            public ModInt mul(ModInt mi) {
                return new ModInt(ma.mul(value, mi.value));
            }
            public ModInt mul(ModInt mi1, ModInt mi2) {
                return new ModInt(ma.mul(value, mi1.value)).mulAsg(mi2);
            }
            public ModInt mul(ModInt mi1, ModInt mi2, ModInt mi3) {
                return new ModInt(ma.mul(value, mi1.value)).mulAsg(mi2).mulAsg(mi3);
            }
            public ModInt mul(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {
                return new ModInt(ma.mul(value, mi1.value)).mulAsg(mi2).mulAsg(mi3).mulAsg(mi4);
            }
            public ModInt mul(ModInt mi1, ModInt... mis) {
                ModInt mi = mul(mi1);
                for (ModInt m : mis) mi.mulAsg(m);
                return mi;
            }
            public ModInt mul(long mi) {
                return new ModInt(ma.mul(value, ma.remainder(mi)));
            }
            public ModInt div(ModInt mi) {
                return new ModInt(ma.div(value, mi.value));
            }
            public ModInt div(long mi) {
                return new ModInt(ma.div(value, ma.remainder(mi)));
            }
            public ModInt inv() {
                return new ModInt(ma.inv(value));
            }
            public ModInt pow(long b) {
                return new ModInt(ma.pow(value, b));
            }
            public ModInt addAsg(ModInt mi) {
                this.value = ma.add(value, mi.value);
                return this;
            }
            public ModInt addAsg(ModInt mi1, ModInt mi2) {
                return addAsg(mi1).addAsg(mi2);
            }
            public ModInt addAsg(ModInt mi1, ModInt mi2, ModInt mi3) {
                return addAsg(mi1).addAsg(mi2).addAsg(mi3);
            }
            public ModInt addAsg(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {
                return addAsg(mi1).addAsg(mi2).addAsg(mi3).addAsg(mi4);
            }
            public ModInt addAsg(ModInt... mis) {
                for (ModInt m : mis) addAsg(m);
                return this;
            }
            public ModInt addAsg(long mi) {
                this.value = ma.add(value, ma.remainder(mi));
                return this;
            }
            public ModInt subAsg(ModInt mi) {
                this.value = ma.sub(value, mi.value);
                return this;
            }
            public ModInt subAsg(long mi) {
                this.value = ma.sub(value, ma.remainder(mi));
                return this;
            }
            public ModInt mulAsg(ModInt mi) {
                this.value = ma.mul(value, mi.value);
                return this;
            }
            public ModInt mulAsg(ModInt mi1, ModInt mi2) {
                return mulAsg(mi1).mulAsg(mi2);
            }
            public ModInt mulAsg(ModInt mi1, ModInt mi2, ModInt mi3) {
                return mulAsg(mi1).mulAsg(mi2).mulAsg(mi3);
            }
            public ModInt mulAsg(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {
                return mulAsg(mi1).mulAsg(mi2).mulAsg(mi3).mulAsg(mi4);
            }
            public ModInt mulAsg(ModInt... mis) {
                for (ModInt m : mis) mulAsg(m);
                return this;
            }
            public ModInt mulAsg(long mi) {
                this.value = ma.mul(value, ma.remainder(mi));
                return this;
            }
            public ModInt divAsg(ModInt mi) {
                this.value = ma.div(value, mi.value);
                return this;
            }
            public ModInt divAsg(long mi) {
                this.value = ma.div(value, ma.remainder(mi));
                return this;
            }
            @Override
            public String toString() {
                return String.valueOf(value());
            }
            @Override
            public boolean equals(Object o) {
                if (o instanceof ModInt) {
                    ModInt mi = (ModInt) o;
                    return mod() == mi.mod() && value() == mi.value();
                }
                return false;
            }
            @Override
            public int hashCode() {
                return (1 * 37 + mod()) * 37 + value();
            }
        }

        private static abstract class ModArithmetic {
            abstract int mod();
            abstract int remainder(long value);
            abstract int add(int a, int b);
            abstract int sub(int a, int b);
            abstract int mul(int a, int b);
            int div(int a, int b) {
                return mul(a, inv(b));
            }
            int inv(int a) {
                int b = mod();
                if (b == 1) return 0;
                long u = 1, v = 0;
                while (b >= 1) {
                    int t = a / b;
                    a -= t * b;
                    int tmp1 = a; a = b; b = tmp1;
                    u -= t * v;
                    long tmp2 = u; u = v; v = tmp2;
                }
                if (a != 1) {
                    throw new ArithmeticException(""divide by zero"");
                }
                return remainder(u);
            }
            int pow(int a, long b) {
                if (b < 0) throw new ArithmeticException(""negative power"");
                int r = 1;
                int x = a;
                while (b > 0) {
                    if ((b & 1) == 1) r = mul(r, x);
                    x = mul(x, x);
                    b >>= 1;
                }
                return r;
            }

            static ModArithmetic of(int mod) {
                if (mod <= 0) {
                    throw new IllegalArgumentException();
                } else if (mod == 1) {
                    return new ModArithmetic1();
                } else if (mod == 2) {
                    return new ModArithmetic2();
                } else if (mod == 998244353) {
                    return new ModArithmetic998244353();
                } else if (mod == 1000000007) {
                    return new ModArithmetic1000000007();
                } else if ((mod & 1) == 1) {
                    return new ModArithmeticMontgomery(mod);
                } else {
                    return new ModArithmeticBarrett(mod);
                }
            }

            private static final class ModArithmetic1 extends ModArithmetic {
                int mod() {return 1;}
                int remainder(long value) {return 0;}
                int add(int a, int b) {return 0;}
                int sub(int a, int b) {return 0;}
                int mul(int a, int b) {return 0;}
                int pow(int a, long b) {return 0;}
            }
            private static final class ModArithmetic2 extends ModArithmetic {
                int mod() {return 2;}
                int remainder(long value) {return (int) (value & 1);}
                int add(int a, int b) {return a ^ b;}
                int sub(int a, int b) {return a ^ b;}
                int mul(int a, int b) {return a & b;}
            }
            private static final class ModArithmetic998244353 extends ModArithmetic {
                private final int mod = 998244353;
                int mod() {
                    return mod;
                }
                int remainder(long value) {
                    return (int) ((value %= mod) < 0 ? value + mod : value);
                }
                int add(int a, int b) {
                    int res = a + b;
                    return res >= mod ? res - mod : res;
                }
                int sub(int a, int b) {
                    int res = a - b;
                    return res < 0 ? res + mod : res;
                }
                int mul(int a, int b) {
                    return (int) (((long) a * b) % mod);
                }
            }
            private static final class ModArithmetic1000000007 extends ModArithmetic {
                private final int mod = 1000000007;
                int mod() {
                    return mod;
                }
                int remainder(long value) {
                    return (int) ((value %= mod) < 0 ? value + mod : value);
                }
                int add(int a, int b) {
                    int res = a + b;
                    return res >= mod ? res - mod : res;
                }
                int sub(int a, int b) {
                    int res = a - b;
                    return res < 0 ? res + mod : res;
                }
                int mul(int a, int b) {
                    return (int) (((long) a * b) % mod);
                }
            }
            private static final class ModArithmeticMontgomery extends ModArithmeticDynamic {
                private final long negInv;
                private final long r2;

                private ModArithmeticMontgomery(int mod) {
                    super(mod);
                    long inv = 0;
                    long s = 1, t = 0;
                    for (int i = 0; i < 32; i++) {
                        if ((t & 1) == 0) {
                            t += mod;
                            inv += s;
                        }
                        t >>= 1;
                        s <<= 1;
                    }
                    long r = (1l << 32) % mod;
                    this.negInv = inv;
                    this.r2 = (r * r) % mod;
                }
                private int generate(long x) {
                    return reduce(x * r2);
                }
                private int reduce(long x) {
                    x = (x + ((x * negInv) & 0xffff_ffffl) * mod) >>> 32;
                    return (int) (x < mod ? x : x - mod);
                }
                @Override
                int remainder(long value) {
                    return generate((value %= mod) < 0 ? value + mod : value);
                }
                @Override
                int mul(int a, int b) {
                    return reduce((long) a * b);
                }
                @Override
                int inv(int a) {
                    return super.inv(reduce(a));
                }
                @Override
                int pow(int a, long b) {
                    return generate(super.pow(a, b));
                }
            }
            private static final class ModArithmeticBarrett extends ModArithmeticDynamic {
                private static final long mask = 0xffff_ffffl;
                private final long mh;
                private final long ml;
                private ModArithmeticBarrett(int mod) {
                    super(mod);
                    /**
                     * m = floor(2^64/mod)
                     * 2^64 = p*mod + q, 2^32 = a*mod + b
                     * => (a*mod + b)^2 = p*mod + q
                     * => p = mod*a^2 + 2ab + floor(b^2/mod)
                     */
                    long a = (1l << 32) / mod;
                    long b = (1l << 32) % mod;
                    long m = a * a * mod + 2 * a * b + (b * b) / mod;
                    mh = m >>> 32;
                    ml = m & mask;
                }
                private int reduce(long x) {
                    long z = (x & mask) * ml;
                    z = (x & mask) * mh + (x >>> 32) * ml + (z >>> 32);
                    z = (x >>> 32) * mh + (z >>> 32);
                    x -= z * mod;
                    return (int) (x < mod ? x : x - mod);
                }
                @Override
                int remainder(long value) {
                    return (int) ((value %= mod) < 0 ? value + mod : value);
                }
                @Override
                int mul(int a, int b) {
                    return reduce((long) a * b);
                }
            }
            private static class ModArithmeticDynamic extends ModArithmetic {
                final int mod;
                ModArithmeticDynamic(int mod) {
                    this.mod = mod;
                }
                int mod() {
                    return mod;
                }
                int remainder(long value) {
                    return (int) ((value %= mod) < 0 ? value + mod : value);
                }
                int add(int a, int b) {
                    int sum = a + b;
                    return sum >= mod ? sum - mod : sum;
                }
                int sub(int a, int b) {
                    int sum = a - b;
                    return sum < 0 ? sum + mod : sum;
                }
                int mul(int a, int b) {
                    return (int) (((long) a * b) % mod);
                }
            }
        }
    }
}
",1448214685
Bhaskar,vilaparthibhaskar,218,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        for i in range(len(nums)):
            left = True
            if i + (2 * k) - 1 >= len(nums):
                break
            for j in range(i, i + k - 1):
                if nums[j] >= nums[j + 1]:
                    left = False
                    break
            if left == False:
                continue
            right = True
            for j in range(i + k, i + (2 * k) - 1):
                if nums[j] >= nums[j + 1]:
                    right = False
                    break
            if right == False:
                continue
            return True
        return False
        ",1448186068
Bhaskar,vilaparthibhaskar,218,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        l = len(nums)
        dp = [1] * l
        for i in range(l - 2, -1, -1):
            if nums[i] < nums[i + 1]:
                dp[i] = dp[i + 1] + 1
        mx = max(dp) // 2
        for i in range(l):
            left = dp[i]
            right = dp[i + left] if i + left < l else 0
            mx = max(mx, min(left, right))
        return mx
        ",1448195704
Bhaskar,vilaparthibhaskar,218,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        md = (10 ** 9) + 7
        l = len(s)

        fact = [1] * (l + 1)
        inv_fact = [1] * (l + 1)
        
        for i in range(2, l + 1):
            fact[i] = fact[i - 1] * i % md

        inv_fact[l] = pow(fact[l], md - 2, md)
        for i in range(l - 1, 0, -1):
            inv_fact[i] = inv_fact[i + 1] * (i + 1) % md
        inv_fact[0] = 1

        def comb(n, r):
            if r > n or r < 0:
                return 0
            return fact[n] * inv_fact[r] % md * inv_fact[n - r] % md
        
        helper = [float('inf')] * (l + 1)
        helper[0] = float('inf')
        helper[1] = 0
        for i in range(2, l + 1):
            b = bin(i)[2:]
            sm = sum(int(d) for d in b)
            helper[i] = 1 + helper[sm]        
        ans = 0
        hold = 0
        for i in range(l):
            if s[i] == '0':
                continue
            rem = l - i - 1
            for j in range(rem + 1):
                check = hold + j
                if helper[check] < k:
                    ans = (ans + comb(rem, j)) % md
            hold += 1    
        return ans % md

                
                
            
            
        
        ",1448275177
Bhaskar,vilaparthibhaskar,218,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        md = (10 ** 9) + 7
        mx = max(nums)
        dp = [[0 for _ in range(2)] for _ in range(mx + 2)]
        ans = 0
        l = len(nums)
        for i in range(l - 1, -1, -1):
            left_sm = 0
            left_count = 0
            val = nums[i]
            left_sm += dp[val - 1][0] + dp[val - 1][1] * val
            left_count += dp[val - 1][1]
            right_sm = 0
            right_count = 0
            right_sm += dp[val + 1][0] + dp[val + 1][1] * val
            right_count += dp[val + 1][1]
            sm = left_sm + right_sm + val
            count = left_count + right_count + 1
            dp[val][0] += sm
            dp[val][1] += count
        sm = 0
        for i in dp:
            sm += i[0]
        return sm % md
            
        ",1448227133
Sai Krishna,saikrishna17394,219,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();

        for (int i = 0; (i + 2 * k) <= n; i++) {
            bool ok = true;

            for (int j = i + 1; j < (i + k); j++) {
                if (nums[j] <= nums[j - 1]) {
                    ok = false;
                    break;
                }
            }

            for (int j = i + k + 1; j < (i + 2 * k); j++) {
                if (nums[j] <= nums[j - 1]) {
                    ok = false;
                    break;
                }
            }

            if (ok) { return ok; }
        }

        return false;
    }
};",1448183766
Sai Krishna,saikrishna17394,219,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        int ans = 1;
        
        vector<int> dp(n, 1);

        for (int i = n - 2; i >= 0; i--) {
            if (nums[i] < nums[i + 1]) {
                dp[i] = dp[i + 1] + 1;
            }
            else {
                dp[i] = 1;
            }

            ans = max(ans, dp[i] / 2);
        }


        for (int i = 0; i < n; i++) {
            if ((i + dp[i]) < n) {
                if (dp[i + dp[i]] >= dp[i]) {
                    ans = max(ans, dp[i]);
                }
            }
        }

        return ans;
    }
};",1448193522
Sai Krishna,saikrishna17394,219,3631,cpp,"class Solution {
    vector<long long> fac;
    vector<long long> afac;
    long long mod;

    long long ncr(long long n, long long k) {
        if (k > n) { return 0; }

        long long ret = (fac[n] * afac[k]) % mod;
        ret = (ret * afac[n - k]) % mod;

        return ret;
    }

    long long pow(long long n, long long k) {
        long long ret = 1;

        while (k > 0) {
            if (k & 1) {
                ret = (ret * n) % mod;
            }

            n = (n * n) % mod;
            k /= 2;
        }

        return ret;
    }

public:
    int countKReducibleNumbers(string s, int k) {
        int len = s.length();
        
        if (len == 1) { return 0; }

        mod = 1e9 + 7;
        int lim = 801;

        vector<int> dp(lim, 0);
        fac = vector<long long>(lim, 1);
        afac = vector<long long>(lim, 1);

        for (int i = 2; i < lim; i++) {
            fac[i] = ((long long) i * fac[i - 1]) % mod;
        }

        afac[lim - 1] = pow(fac[lim - 1], mod - 2);

        for (int i = lim - 2; i > 1; i--) {
            afac[i] = (afac[i + 1] * (long long)(i + 1)) % mod;
        }
        dp[1] = 1;

        for (int i = 2; i < lim; i++) {
            int sum = 0;
            int num = i;

            while (num > 0) {
                sum += (num % 2);
                num /= 2;
            }

            dp[i] = dp[sum] + 1;
        }

        // fix (len - 1)
        long long ans = 0;
        
        for (int i = 1; i < lim; i++) {
            if (dp[i] <= k) {
                 ans += ncr(len - 1, i);  
                ans %= mod;
            }
        }

        int pref_val = 1;

        for (int i = 1; i < len; i++) {
            if (s[i] == '0') {
                continue;
            }

            // remaining all zeros
            if (dp[pref_val] <= k) {
                ans++;
                ans %= mod;
            }

            for (int j = 1; (j + pref_val) < lim; j++) {
                if (dp[j + pref_val] <= k) {
                    ans += ncr(len - i - 1, j);
                    ans %= mod;                    
                }
            }
            
            pref_val++;
        }
        
        return (int)ans;
    }
};",1448275393
Sai Krishna,saikrishna17394,219,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int mod = 1e9 + 7;
        int lim = 1e5 + 1;
        int n = nums.size();
        
        vector<long long> dp(lim, 0);
        vector<long long> cnt(lim, 0);

        long long ans = 0;
        long long cur;
        
        for (int i = 0; i < n; i++) {
            cur = nums[i];
            cnt[nums[i]]++;

            if ((nums[i] - 1) >= 0) {
                cur += (nums[i] * cnt[nums[i] - 1]) % mod;
                cur += dp[nums[i] - 1];
                cnt[nums[i]] += cnt[nums[i] - 1];
            }
            

            if ((nums[i] + 1) < lim) {
                cur += (nums[i] * cnt[nums[i] + 1]) % mod;
                cur += dp[nums[i] + 1];
                cnt[nums[i]] += cnt[nums[i] + 1];
            }

            cur %= mod;
            ans = (ans + cur) % mod;
            dp[nums[i]] += cur;
            dp[nums[i]] %= mod;
            cnt[nums[i]] %= mod;
        }

        return ans;
    }
};",1448223546
Ayush Saluja,ayuchitsaluja8,220,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> dp(n,1);
        for(int i=1;i<n;++i){
            dp[i] = nums[i-1] < nums[i] ? 1 + dp[i-1] : 1;
        }
        for(int i=2*k-1;i<n;++i){
            if(min(dp[i],dp[i-k])>=k)return true;
        }
        return false;
    }
};",1448186138
Ayush Saluja,ayuchitsaluja8,220,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> dpl(n,1), dpr(n,1);

        for(int i=1;i<n;++i) dpl[i] = nums[i-1] < nums[i] ? 1 + dpl[i-1] : 1;
        for(int i=n-2;i>=0;--i) dpr[i] = nums[i] < nums[i+1] ? 1 + dpr[i+1] : 1;
        int ret =1;
        for(int i=1;i<n;++i){
            ret = max(ret, min(dpl[i-1],dpr[i]));
        }
        return ret;
        
    }
};",1448188810
Ayush Saluja,ayuchitsaluja8,220,3631,cpp,"class Solution {
public:
    static constexpr int mod = 1e9+7;
    int countKReducibleNumbers(string s, int k) {
        int n = s.size();
        vector<int> dp(n+1,0);
        vector<vector<int>> C(n+1,vector<int>(n+1,0));
        for(int i=2;i<=n;++i) dp[i] = 1 + dp[__builtin_popcount(i)];
        for(int i=0;i<=n;++i){
            C[i][0] = 1;
            for(int j=1;j<=i;++j) {
                C[i][j] = ( C[i-1][j-1] + C[i-1][j])%mod;
            }
        }
        int ret=0,one=0;
        for(char c: s)one += c=='1';

        for(int l=1;l<n;++l){
            if(l==1) ++ret;
            else {
                for(int j=1;j<=l;++j)if(1+dp[j]<=k){
                    ret = ( ret + C[l-1][j-1])%mod;
                }
            }
        }

        for(int i=1,x=1;i<n;++i)if(s[i]=='1'){
            int m = n-1-i;
            for(int j=0;j<=m;++j)if(1+dp[x+j]<=k){
                ret = (ret + C[m][j])%mod;
            }
            ++x;
        }
        return ret;
    }
};",1448261478
Ayush Saluja,ayuchitsaluja8,220,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        const int mod = 1e9+7;
        map<int,int> dp,cnt;

        int ret=0;
        for(int d: nums){
            int tcnt = (1 + cnt[d-1] + cnt[d+1])%mod;
            int now = (((1LL*tcnt*d)%mod + dp[d-1])%mod + dp[d+1])%mod;
            ret = ( ret + now)%mod;

            cnt[d] = ( cnt[d] + tcnt)%mod;
            dp[d] = ( dp[d] + now)%mod;
        }
        return ret;
    }
};",1448201304
Sagnik Biswas,SagnikBiswas1049,221,3612,java,"class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        for (int a = 0; a + 2*k <= nums.size(); a++) {
            boolean good = true;
            for (int j = a+1; j < a+k; j++) {
                if (nums.get(j) <= nums.get(j-1)) {
                    good = false;
                }
            }
            
            for (int j = a+k+1; j < a+2*k; j++) {
                if (nums.get(j) <= nums.get(j-1)) {
                    good = false;
                }
            }
            
            
            if (good) return true;
        }
        
        
        return false;
    }
}",1448187154
Sagnik Biswas,SagnikBiswas1049,221,3619,java,"class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        int n = nums.size();
        int lo = 1;
        int hi = n/2;
        
        int[] pref = new int[n+1];
        for (int i = 2; i <= n; i++) {
            pref[i] = pref[i-1];
            if (nums.get(i-1) > nums.get(i-2)) {
                pref[i]++;
            }
        }
        
        while (lo != hi) {
            int mid = (lo + hi + 1)/2;
            if (works(mid, pref, n)) {
                lo = mid;
            } else {
                hi = mid-1;
            }
        }
        
        
        return lo;
    }
    
    public boolean works(int mid, int[] pref, int n) {
        // see if subarrays of size mid work
        for (int i = 1; i + 2*mid-1 <= n; i++) {
            if (pref[i+mid-1] - pref[i] == mid-1) {
                if (pref[i+2*mid-1] - pref[i+mid] == mid-1) {
                    return true;
                }
            }
        }
        
        return false;
    }
}",1448196688
Sagnik Biswas,SagnikBiswas1049,221,3631,java,"class Solution {
    
    public int countKReducibleNumbers(String s, int k) {
        int n = s.length();
        boolean[] valid = new boolean[n+1];
        
        for (int i = 1; i <= n; i++) {
            if (r(i, k-1) == 1) {
                valid[i] = true;
                // System.out.println(i);
            }
        }
        
        // System.out.println("""");
        
        long mod = (long) (1e9 + 7);
        
        /*
        
        
        
        
        */
        
        /*
        dp[i][j]
        how many numbers less than or equal to s[i .... (n-1)] have exactly j bits
        
        */
        
        long[][] choose = new long[n+1][n+1];
        choose[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            choose[i][0] = 1;
            choose[i][i] = 1;
            for (int j = 1; j <= i; j++) {
                choose[i][j] = choose[i-1][j] + choose[i-1][j-1];
                choose[i][j] %= mod;
            }
        }
        
        // print(choose);
        
        long[][] dp = new long[n][n+1];
        long ans = 0;
        
        for (int i = n-1; i >= 0; i--) {
            for (int j = 1; j <= n-i; j++) {
                if (i == n-1) {
                    if (s.charAt(i) == '1') {
                        dp[i][j] = 1;
                    }
                    continue;
                }
                
                if (j == 1) {
                    if (i != n-1) {
                        if (s.charAt(i) == '1') {
                            dp[i][j] = n-i-1;
                        } else {
                            dp[i][j] = dp[i+1][j];
                        }
                    }
                    
                    
                    if (s.charAt(i) == '1') {
                        dp[i][j] += 1;
                        dp[i][j] %= mod;
                    }
                    
                    
                } else {
                    
                    if (i != n-1) {
                        if (s.charAt(i) == '1') {
                            dp[i][j] = choose[n-i-1][j];
                        } else {
                            dp[i][j] = dp[i+1][j];
                        }
                    }
                    
                    if (s.charAt(i) == '1') {
                        dp[i][j] += dp[i+1][j-1];
                        dp[i][j] %= mod;
                    }
                    
                }
                
                // System.out.printf(""dp[%d][%d] = %d\n"", i, j, dp[i][j]);
            }
        }
        
        
        for (int i = 1; i <= n; i++) {
            if (valid[i]) {
                ans += dp[0][i];
                ans %= mod;
            }
        }
        
        int ct = 0;
        for (int i = 0; i < n; i++) {
            if (s.charAt(i) == '1') {
                ct++;
            }
        }
        
        if (r(ct, k-1) == 1) {
            ans += (mod-1);
            ans %= mod;
        }
        
        // System.out.println(""done"");
        
        return (int) ans;
    }
    
    void print(long[][] table) {
        for (int i = 0; i < table.length; i++) {
            for (int j = 0; j < table[i].length; j++) {
                System.out.print(table[i][j] + "" "");
            }
            System.out.println();
        }
    }
    
    public int r(int n, int k) {
        for (int i = 0; i < k; i++) {
            n = Integer.bitCount(n);
        }
        
        return n;
    }
    
    
}",1448261487
Sagnik Biswas,SagnikBiswas1049,221,3646,java,"class Solution {
    public int sumOfGoodSubsequences(int[] nums) {
        /*
        
        dp[i] = number of sequences that the ith element exists in 
        
        R[i] = number of sequences including i where i is the right most element
        R[i] = 1 + R[i-1]
        
        
        
        
        
        */
        
        int n = nums.length;
        
        long[] L = new long[n];
        long[] R = new long[n];
        long[] V = new long[n];
        
        long mod = (long) (1e9 + 7);
        
        for (int i = 0; i < n; i++) {
            V[i] = nums[i];
        }
        
        HashMap<Long, Long> map = new HashMap<Long, Long>();
        
        for (int i = 0; i < n; i++) {
            R[i] = 1;
            
            if (map.containsKey(V[i] - 1)) {
                R[i] += map.get(V[i] - 1);
                R[i] %= mod;
            }
            
            if (map.containsKey(V[i] + 1)) {
                R[i] += map.get(V[i] + 1);
                R[i] %= mod;
            }
            
            if (map.containsKey(V[i])) {
                long nv = map.get(V[i]) + R[i];
                nv %= mod;
                map.put(V[i], nv);
            } else {
                map.put(V[i], R[i]);
            }
        }
        
        map = new HashMap<Long, Long>();
        
        for (int i = n-1; i >= 0; i--) {
            L[i]  = 1;
            
            if (map.containsKey(V[i] - 1)) {
                L[i] += map.get(V[i] - 1);
                L[i] %= mod;
            }
            
            if (map.containsKey(V[i] + 1)) {
                L[i] += map.get(V[i] + 1);
                L[i] %= mod;
            }
            
            if (map.containsKey(V[i])) {
                long nv = map.get(V[i]) + L[i];
                nv %= mod;
                map.put(V[i], nv);
            } else {
                map.put(V[i], L[i]);
            }

        }
        
        
        
        // System.out.println(Arrays.toString(L));
        // System.out.println(Arrays.toString(R));
        
        
        long ans = 0;
        
        
        for (int i = 0; i < n; i++) {
            long tot = L[i] * R[i];
            tot %= mod;
            long cont = tot * V[i];
            cont %= mod;
            ans += cont;
            ans %= mod;
        }
        
        return (int) (ans);
        
    }
}",1448213637
ysahu,ysahu,222,3612,java,"class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        int n = nums.size();
        out: for (int i = 0; i <= n - 2 * k; i++) {
            for (int j = i + 1; j < i + k; j++) {
                if (nums.get(j) <= nums.get(j - 1)) continue out;
            }
            for (int j = i + k + 1; j < i + 2 * k; j++) {
                if (nums.get(j) <= nums.get(j - 1)) continue out;
            }
            return true;
        }
        return false;
    }
}",1448182110
ysahu,ysahu,222,3619,java,"class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        int n = nums.size();
        ArrayList<Integer> v = new ArrayList<>();
        int size = 1;
        for (int i = 1; i < n; i++) {
            if (nums.get(i) > nums.get(i - 1)) size++;
            else {
                v.add(size);
                size = 1;
            }
        }
        v.add(size);

        int best = 0;
        for (int i = 1; i < v.size(); i++) {
            int m = Math.min(v.get(i - 1), v.get(i));
            if (m > best) best = m;
        }

        for (int vx : v) {
            int f = vx / 2;
            if (f > best) best = f;
        }

        return best;
    }
}",1448187356
ysahu,ysahu,222,3631,java,"class Solution {
    public int numSetBits(int c) {
        int cd = 0;
        while (c != 0) {
            cd += c & 1;
            c >>= 1;
        }
        return cd;
    }
    
    public int countKReducibleNumbers(String s, int k) {
        int n = s.length(), p = 1_000_000_007;
        int[] a = new int[n + 1];
        for (int i = 2; i <= n; i++) {
            int c = i;
            while (c != 1) {
                c = numSetBits(c);
                a[i]++;
            }
        }

        int[][] choose = new int[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            choose[i][0] = 1;
            choose[i][i] = 1;
        }

        for (int i = 0; i <= n; i++) {
            for (int j = 1; j < i; j++) {
                choose[i][j] = (choose[i - 1][j] + choose[i - 1][j - 1]) % p;
            }
        }

        int[] b = new int[n + 1];
        int t = 0;
        for (int i = 0; i < n; i++) {
            char c = s.charAt(i);
            if (c == '0') {
                continue;
            } else {
                int e = n - i - 1;
                for (int j = 0; j <= e; j++) {
                    b[t + j] = (b[t + j] + choose[e][j]) % p;
                }
                t++;
            }
        }

        if (k == 1) return b[1];
        k--;
        int out = 0;
        for (int i = 1; i <= n; i++) {
            if (a[i] <= k) out = (out + b[i]) % p;
        }

        return out;
    }
}",1448261548
ysahu,ysahu,222,3646,java,"class Solution {
    public int sumOfGoodSubsequences(int[] nums) {
        int max = 0;
        for (int num : nums) if (num > max) max = num;

        long[] sum = new long[max + 1];
        long[] count = new long[max + 1];

        for (int num : nums) {
            count[num] += 1 + (num == 0 ? 0 : count[num - 1]) +
                (num == max ? 0 : count[num + 1]);
            sum[num] += num + 
                (num == 0 ? 0 : sum[num - 1] + num * count[num - 1]) +
                (num == max ? 0 : sum[num + 1] + num * count[num + 1]);
            count[num] %= 1_000_000_007;
            sum[num] %= 1_000_000_007;
        }

        long t = 0;
        for (long s : sum) t += s;
        return (int) (t % 1_000_000_007);
    }
}",1448200698
Laplace233,Laplace233,223,3612,cpp,"constexpr int N = 250000;
int l[N],r[N];
class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums,int k) {
        int ans = 1;
        int n = nums.size();
        r[n - 1] = 1;
        for(int i = n - 2; i >= 0; i--){
            r[i] = 1;
            if(nums[i] < nums[i + 1]) r[i] += r[i + 1];
        }
        l[0] = 1;
        for(int i = 1; i < n; i++){
            l[i] = 1;
            if(nums[i] > nums[i - 1]) l[i] += l[i - 1];
        }
        for(int i = 0; i < n - 1; i++){
            ans = max(ans,min(l[i],r[i + 1]));
        }
        return (ans >= k);
    }
};",1448199674
Laplace233,Laplace233,223,3619,cpp,"constexpr int N = 250000;
int l[N],r[N];
class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int ans = 1;
        int n = nums.size();
        r[n - 1] = 1;
        for(int i = n - 2; i >= 0; i--){
            r[i] = 1;
            if(nums[i] < nums[i + 1]) r[i] += r[i + 1];
        }
        l[0] = 1;
        for(int i = 1; i < n; i++){
            l[i] = 1;
            if(nums[i] > nums[i - 1]) l[i] += l[i - 1];
        }
        for(int i = 0; i < n - 1; i++){
            ans = max(ans,min(l[i],r[i + 1]));
        }
        return ans;
    }
};",1448198019
Laplace233,Laplace233,223,3631,cpp,"#define ll long long
constexpr ll p = 1e9 + 7;
constexpr int N = 1000;
ll fac[N],inv[N];
class Solution {
public:
    string s;
    int n,k,f[N];
    int pp(int x){
        return __builtin_popcount(x);
    }
    ll mypow(ll x,ll tms){
        ll bas = x, res = 1;
        while(tms){
            if(tms & 1) res = res * bas % p;
            bas = bas * bas % p;
            tms >>= 1;
        }
        return res;
    }
    ll c(ll n,ll m){
        return fac[n] * inv[m] % p * inv[n - m] % p;
    }
    void init(){
        f[0] = 100;
        f[1] = 0;
        for(int i = 2; i < N; i++) f[i] = f[pp(i)] + 1;
        fac[0] = 1;
        for(int i = 1; i < N; i++) fac[i] = i * fac[i - 1] % p;
        inv[N - 1] = mypow(fac[N - 1], p - 2);
        for(int i = N - 2; i >= 0; i--) inv[i] = inv[i + 1] * (i + 1) % p;
    }
    ll dfs(ll sum,ll loc){
        if(loc == n + 1){
            return 0;
        }
        ll tmp = 0;
        if(s[loc] == '1'){
            int r = n - loc;
            for(int i = 0; i <= r; i++){
                if(f[sum + i] + 1 > k) continue;
                tmp += c(r,i);
                tmp %= p;
            }
        }
        tmp += dfs(sum + s[loc] - '0',loc + 1);
        return tmp % p;
    }
    int countKReducibleNumbers(string ss, int tk) {
        init();
        s = ss;
        n = s.length() - 1, k = tk;
        return dfs(0,0);
    }
};",1448261716
Laplace233,Laplace233,223,3646,cpp,"#define ll long long
constexpr int N = 120000;
constexpr ll p = 1e9 + 7;
ll sum[N],num[N],ans;
class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        ans = 0;
        for(int i = 0; i < N; i++) sum[i] = num[i] = 0;
        for(int i = 0; i < nums.size(); i++){
            int k = nums[i];
            if(k != 0) sum[k] += (num[k - 1] + num[k + 1] + 1) * k % p;
            if(k != 0) sum[k] += (sum[k - 1] + sum[k + 1]) % p;
            else sum[k] += sum[k + 1];
            if(k != 0) num[k] += num[k - 1] + num[k + 1] + 1;
            else num[k] += num[k + 1] + 1;
            sum[k] %= p, num[k] %= p;
        }
        for(int i = 0; i < N; i++) ans += sum[i], ans %= p;
        return ans;
    }
};",1448226971
Rohit Meena,Rohit_Meena,224,3612,cpp,"class Solution {
public:
    int get(int l, int r, vector<int> &diff){
        if(l == 0) return diff[r];
        return diff[r]-diff[l-1];
    }
    bool check(int len, vector<int> &diff){
        int n = diff.size();
        len--;
        for(int i = 0;i<n;i++){
            if(i + 2*len >= n) break;
            int lval = get(i, i + len - 1, diff);
            int rval = get(i + len + 1, i + 2*len, diff);
            if(lval == len && rval == len) return true;
        }
        return false;
    }
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        if(k == 1) return true;
        vector<int> diff(n-1);
        for(int i = 1;i<n;i++) diff[i-1] = nums[i] > nums[i-1];
        for(int i = 1;i<n-1;i++) diff[i] += diff[i-1];
        return check(k, diff);
    }
};",1448192744
Rohit Meena,Rohit_Meena,224,3619,cpp,"class Solution {
public:
    int get(int l, int r, vector<int> &diff){
        if(l == 0) return diff[r];
        return diff[r]-diff[l-1];
    }
    bool check(int len, vector<int> &diff){
        int n = diff.size();
        len--;
        for(int i = 0;i<n;i++){
            if(i + 2*len >= n) break;
            int lval = get(i, i + len - 1, diff);
            int rval = get(i + len + 1, i + 2*len, diff);
            if(lval == len && rval == len) return true;
        }
        return false;
    }
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> diff(n-1);
        for(int i = 1;i<n;i++) diff[i-1] = nums[i] > nums[i-1];
        for(int i = 1;i<n-1;i++) diff[i] += diff[i-1];
        int l = 2, r = n/2;
        int ans = 1;
        while(l<=r){
            int mid = l + (r-l)/2;
            if(check(mid, diff)){
                ans = mid;
                l = mid + 1;
            }
            else r = mid -1;
        }
        return ans;
    }
};",1448190389
Rohit Meena,Rohit_Meena,224,3631,cpp,"#define ll long long
class Solution {
public:
    int n, k;
    const int mod = 1e9 + 7;
    int dp[805][805][2];
    bool check(int bits, int kk){
        int x = bits;kk--;
        while(kk--){
            x = __builtin_popcount(x);
        }
        return x == 1;
    }
    int solve(int i, int sum, int tu, string &s){
        if(i == n) return check(sum, k);
        if(dp[i][sum][tu] != -1) return dp[i][sum][tu];
        ll ans = 0;
        if(tu == 0){
            ans += solve(i + 1, sum, tu, s);
            ans += solve(i + 1, sum + 1, tu, s);
        }
        else{
            if(s[i] == '1'){
                ans += solve(i +1 , sum , 0, s);
                ans += solve(i + 1, sum + 1, 1, s);
            }
            else{
                ans += solve(i + 1, sum, 1, s);
            }
        }
        return dp[i][sum][tu] = ans%mod;
    }
    int countKReducibleNumbers(string s, int k) {
        n = s.length();
        this->k = k;
        memset(dp, -1, sizeof(dp));
        
        ll ans = solve(0, 0, 1, s);
        if(check(count(s.begin(), s.end(), '1'), k)) ans--;
        return (ans + mod)%mod;
    }
};",1448261764
Rohit Meena,Rohit_Meena,224,3646,cpp,"class Solution {
public:
    const int mod = 1e9 + 7;
    const int MAXX = 1e5 + 1;
    int sumOfGoodSubsequences(vector<int>& nums) {
        int n = nums.size();
        map<int,int> arr;
        vector<int> dp1(n), dp2(n);
        for(int i = 0;i<n;i++){
            int x = nums[i];
            dp1[i] = (arr[x-1] + arr[x+1] + 1)%mod;
            arr[x] = (arr[x] + dp1[i])%mod;
        }
        arr.clear();
        for(int i = n-1;i>=0;i--){
            int x = nums[i];
            dp2[i] = (arr[x-1] + arr[x+1] + 1)%mod;
            arr[x] = (arr[x] + dp2[i])%mod;
        }
        // for(int i = 0;i<n;i++) cout<<dp1[i]<<"" \n""[i==n-1];
        // for(int i = 0;i<n;i++) cout<<dp2[i]<<"" \n""[i==n-1];
        long long ans = 0;
        for(int i = 0;i<n;i++){
            long long contri = (1LL*dp1[i]*dp2[i])%mod;
            contri = (contri*nums[i])%mod;
            ans = (ans + contri)%mod;
        }
        return ans;
    }
};",1448235140
kavascg,kavascgjmd39,225,3612,cpp,"#define ll long long 
#define vt vector
#define all(a) a.begin(), a.end()
#define rep(i, a, b) for (ll i = a; i < b; i++)
#define repr(i , n, a) for(ll i =n ; i>= a; i--)
#define pi pair
const ll N = 2e5+5;
const ll mod = 1e9+7;
class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
                int n = nums.size();
        vt<int>vals( n , 0);
        vals[0] = 1;
        rep(i , 1 , n){
            vals[i] = 1;
            if(nums[i] > nums[i-1]){
                vals[i] = vals[i-1]+1;
            }
        }
        int res = 0;
        rep(i , 1 , n ){
            if(i >= vals[i]){
            res = max(res, min(vals[i], vals[i-vals[i]]));}
            res = max(res, vals[i]/2);
            
        }
        return res >= k; 
    }
};",1448191428
kavascg,kavascgjmd39,225,3619,cpp,"#define ll long long 
#define vt vector
#define all(a) a.begin(), a.end()
#define rep(i, a, b) for (ll i = a; i < b; i++)
#define repr(i , n, a) for(ll i =n ; i>= a; i--)
#define pi pair
const ll N = 2e5+5;
const ll mod = 1e9+7;
class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vt<int>vals( n , 0);
        vals[0] = 1;
        rep(i , 1 , n){
            vals[i] = 1;
            if(nums[i] > nums[i-1]){
                vals[i] = vals[i-1]+1;
            }
        }
        int res = 0;
        rep(i , 1 , n ){
            if(i >= vals[i]){
            res = max(res, min(vals[i], vals[i-vals[i]]));}
            res = max(res, vals[i]/2);
            
        }
        return res;
    }
};",1448189802
kavascg,kavascgjmd39,225,3631,cpp,"#define ll long long 
#define vt vector
#define all(a) a.begin(), a.end()
#define rep(i, a, b) for (ll i = a; i < b; i++)
#define repr(i , n, a) for(ll i =n ; i>= a; i--)
#define pi pair
const ll N = 2e5+5;
const ll mod = 1e9+7;
class Solution {
public:
    int dp[801][801][2];
    int sol(int i, int tight, string & s, vt<int>&vals,int c  ){
        if(i == s.size()){
            
            return vals[c] && !tight;
        }
        if(dp[i][c][tight] != -1){
            return dp[i][c][tight];
        }
        int res = 0;
        if(tight){
            if(s[i] == '1'){
               res +=  sol(i+1, 1 , s, vals, c+1) % mod; res %= mod;
               res += sol(i+1 , 0 , s, vals, c ) % mod; res %= mod;
            }
            else {
                res += sol(i+1 , 1 , s, vals, c) % mod ; res %= mod;
            }
        }
        else {
            res +=sol(i+1 , 0 , s , vals, c+1) % mod ; res %= mod;;
            res += sol(i+1 , 0 , s, vals, c) % mod; res %= mod;
        }
        return dp[i][c][tight] = res;
    }
    int countKReducibleNumbers(string s, int k) {
     memset(dp , -1 , sizeof(dp));
        k--;
     vt<int>vals(801  , 1); vals[0] = 0;
     rep(i , 1 , 800){
             int x = i;
             int c = 0;
             while(__builtin_popcount(x) != x && c < k){
             x = __builtin_popcount(x);
             c++;
             }
             if(x != 1){
                 vals[i] = 0;
             }
     }
    
     return sol(0 , 1 , s, vals,0);
        
    }
};",1448269603
kavascg,kavascgjmd39,225,3646,cpp,"#define ll long long 
#define vt vector
#define all(a) a.begin(), a.end()
#define rep(i, a, b) for (ll i = a; i < b; i++)
#define repr(i , n, a) for(ll i =n ; i>= a; i--)
#define pi pair
const ll N = 2e5+5;
const ll mod = 1e9+7;
class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int n = nums.size();
        map<int,int>dp;
        map<int,int>ndp;
        rep(i , 0 , nums.size()){
            dp[nums[i]]++; dp[nums[i]] %= mod;
            ndp[nums[i]] += nums[i];
            if(dp.find(nums[i]-1) != dp.end()){
                dp[nums[i]] += dp[nums[i]-1] % mod; dp[nums[i]] %= mod;
                ndp[nums[i]] += ((ll)(dp[nums[i]-1] % mod)*(ll)(nums[i] % mod))%mod;
                  ndp[nums[i]] %= mod;
                ndp[nums[i]] += (ndp[nums[i]-1] % mod);
                ndp[nums[i]] %= mod;
            }
            if(dp.find(nums[i]+1) != dp.end()){
                dp[nums[i]] += dp[nums[i]+1] % mod; dp[nums[i]] %= mod;
                ndp[nums[i]] += ((ll)(dp[nums[i]+1] % mod)*(ll)(nums[i] % mod))%mod;
                ndp[nums[i]] %= mod;
                ndp[nums[i]] += (ndp[nums[i]+1] % mod);
                ndp[nums[i]] %= mod;
            }
        }
         ll res = 0;
         for(auto & x : ndp){
         res  += x.second % mod ; res %= mod;
         }
return res;
    }
};",1448221533
yolo12345,yolo12345,228,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n=nums.size();
        bool f=false;
        int prev=0;
        int i=0;
        while(i<n){
            int j=i;
            while(j+1<n && (nums[j+1]>nums[j])) j++;
            int len=j-i+1;
            if(k*2<=len) f=true;
            if(len>=k && (prev>=k)) f=true;
            prev=len;
            i=j+1;
        }
        return f;
    }
};",1448188897
yolo12345,yolo12345,228,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int ans=0;
        int n=nums.size();
        int prev=0;
        int i=0;
        while(i<n){
            int j=i;
            while(j+1<n && (nums[j+1]>nums[j])) j++;
            int len=j-i+1;
            ans=max(ans,len/2);
            ans=max(ans,min(prev,len));
            prev=len;
            i=j+1;
        }
        return ans;
    }
};",1448185888
yolo12345,yolo12345,228,3631,cpp,"using ll = long long;
const long long md=1e9+7;
vector<long long> fact(805),ifact(805);
long long power(long long x, long long y, long long p){
    long long ans = 1; x = x % p; if (x == 0) return 0; 
    while (y > 0){
        if (y & 1) ans = (ans*x) % p; y = y>>1; x = (x*x) % p;
    }return ans;
}

long long bin(long long a, long long b){
    return ((fact[a]*ifact[a-b]%md)*ifact[b])%md;
}
class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        long long range=801;
        fact[0]=1,ifact[0]=1;
        for(long long i=1;i<=range;i++) fact[i]=(i*fact[i-1])%md;
        ifact[range]=power(fact[range],md-2,md);
        for(long long i=range-1;i>0;i--) ifact[i]=(ifact[i+1]*(i+1))%md;
        vector<ll> ans(801,-1);
        ans[1]=0;
        for(int i=2;i<=800;i++){
            int cnt=0;
            int x=i;
            while(x>0){
                if(x&1) cnt++;
                x=x/2;
            }
            ans[i]=ans[cnt]+1;
            //cout<<ans[i]<<' ';
        }
        ll n=s.length();
        ll res=0;
        for(ll i=1;i<=n;i++){
            ll val=i;
            if(ans[i]<=k-1){
                for(ll j=0;j<n;j++){
                    if(s[j]=='1'){
                        ll rem=n-j-1;
                        if(rem<val-1) break;
                        if(rem>=val) res=(res+bin(rem,val))%md;
                        val--;
                        if(val<=0) { res++;  res%=md; break; }
                    }
                }
            }
            //cout<<res<<' ';
        }
        int tot=0;
        for(int i=0;i<n;i++){
            if(s[i]=='1') tot++;
        }
        if(ans[tot]<=k-1) res--;
        res+=md;
        res%=md;
        
        return res;
    }
};",1448276802
yolo12345,yolo12345,228,3646,cpp,"using ll = long long;
const long long md=1e9+7;
class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        ll ans=0;
        map<ll,ll> mp,cnt;
        int n=nums.size();
        for(int i=0;i<n;i++){
            ll res=nums[i];
            ll tot=0;
            if(mp.count(nums[i]-1)){
                res=(res+mp[nums[i]-1])%md;
                tot+=cnt[nums[i]-1];
            }
            if(mp.count(nums[i]+1)){
                res=(res+mp[nums[i]+1])%md;
                tot+=cnt[nums[i]+1];
            }
            res=(res+(tot*nums[i])%md)%md;
            tot++;
            cnt[nums[i]]+=tot;
            cnt[nums[i]]%=md;
            ans=(ans+res)%md;
            mp[nums[i]]+=res;
            mp[nums[i]]%=md;
            //cout<<ans<<' ';
        }
        ans=ans%md;
        int x=ans;
        return ans;
    }
};",1448209832
chh9976,chh9976,232,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        def check(a):
            for a, b in pairwise(a):
                if b <= a:
                    return False
            return True
        for i in range(len(nums)-2*k+1):
            if check(nums[i:i+k]) and check(nums[i+k:i+2*k]):
                return True
        return False",1448182883
chh9976,chh9976,232,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> pre(n, -1), suf(n, -1);
        {
        int r = 0;
        while(r < nums.size()){
            int prer = r;
            while(r < nums.size() - 1 && nums[r] < nums[r+1]) r++;
            for(int i=prer;i<=r;i++) pre[i] = prer;
            r++;
            prer = r;
        }
        }
        {
        int r = nums.size()-1;
        while(r >= 0){
            int prer = r;
            while(r > 0 && nums[r-1] < nums[r]) r--;
            for(int i=r;i<=prer;i++) suf[i] = prer;
            r--;
            prer = r;
        }
        }
        int ans = -1;
        for(int i=0;i<nums.size()-1;i++){
            ans = max(ans, min(i - pre[i] + 1, suf[i+1] - (i+1) + 1));
        }
        return ans;
    }
};",1448201903
chh9976,chh9976,232,3631,cpp,"
template<int MOD>
struct mint {
  unsigned x;
  mint() : x(0) { }
  mint(signed sig) : x(((sig)%MOD+MOD)%MOD) {}
  mint(signed long long sig) : x(((sig)%MOD+MOD)%MOD) { }
  int get() const { return (int)x; }
  mint pow(long long p) { mint res = 1, a = *this; while (p) { if (p & 1) res *= a; a *= a; p >>= 1; } return res; }
 
  mint &operator+=(mint that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }
  mint &operator-=(mint that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }
  mint &operator*=(mint that) { x = (unsigned long long)x * that.x % MOD; return *this; }
  mint &operator/=(mint that) { return (*this) *= that.pow(MOD - 2); }
 
  mint operator+(mint that) const { return mint(*this) += that; }
  mint operator-(mint that) const { return mint(*this) -= that; }
  mint operator*(mint that) const { return mint(*this) *= that; }
  mint operator/(mint that) const { return mint(*this) /= that; }
  bool operator<(mint that) const { return x < that.x; }
  
  friend mint operator+(int lhs, mint rhs) {return rhs + lhs;}
  friend mint operator-(int lhs, mint rhs) {return mint(lhs) - rhs;}
  friend mint operator*(int lhs, mint rhs) {return rhs * lhs;}
  friend mint operator/(int lhs, mint rhs) {return mint(lhs) / rhs;}

  friend ostream& operator<<(ostream &os, mint a) { os << a.x; return os; }
};
typedef mint<1000000007> mint17;
int MOD = 1e9 + 7;
class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        vector<mint17> bitcnt(s.size()+1), nowcnt(s.size()+1);
        int cntprebit = 0;
        for(auto c:s) cntprebit += c - 48;
        nowcnt[0] = 1;
        for(int i=0;i<s.size();i++){
            cntprebit -= s[s.size()-i-1] - 48;
            if(s[s.size()-i-1] == '1'){
                for(int j=0;j<s.size()-cntprebit+1;j++){
                    bitcnt[j+cntprebit] += nowcnt[j];
                }
            }
            for(int j=s.size();j>0;j--){
                nowcnt[j] += nowcnt[j-1];
            }
        }
        vector<int> step(s.size()+1, 0);
        for(int i=2;i<=s.size();i++){
            step[i] = step[__builtin_popcount(i)] + 1;
        }
        mint17 ans = 0;
        for(int i=1;i<=s.size();i++) if(step[i] + 1 <= k) ans += bitcnt[i];
        return ans.x;
    }
};",1448263849
chh9976,chh9976,232,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int MOD = 1e9 + 7;
        long long ans = 0;
        map<int, long long> c;
        map<int, long long> sz;
        for(int i=0;i<nums.size();i++){
            c[nums[i]] += (0ll + c[nums[i]-1] + c[nums[i]+1]) % MOD;;
            sz[nums[i]] += (sz[nums[i]-1] + sz[nums[i]+1]) % MOD;
            sz[nums[i]]++;
            c[nums[i]] += 1ll * ((sz[nums[i]-1] + sz[nums[i]+1] + 1) % MOD * nums[i]) % MOD;
        }
        for(auto [k, v]:c) ans += v, ans %= MOD;
        return ans % MOD;
    }
};",1448218483
gjp4_,gjp4_,233,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> len(n, 1);
        for(int i=n-2;i>=0;i--) {
            if(nums[i] < nums[i+1])len[i] += len[i+1];
        }
        for(int i=0;i<n-k;i++) {
            if(len[i] >= k && len[i+k] >= k)return true;
        }
        return false;
    }
};",1448182257
gjp4_,gjp4_,233,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> len(n, 1);
        for(int i=n-2;i>=0;i--) {
            if(nums[i] < nums[i+1])len[i] += len[i+1];
        }
        int l = 1, r = n/2, mid;
        while(l < r) {
            mid = (l + r + 1) / 2;
            bool ok = false;
            for(int i=0;i<n-mid;i++) {
                if(len[i]>=mid && len[i+mid] >=mid) {
                    ok = true;
                    break;
                }
            }
            if(ok)l = mid;
            else r = mid-1;
        }
        return l;
    }
};",1448184791
gjp4_,gjp4_,233,3631,cpp,"class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        int n = s.size();
        const int mx = 1e9;
        const long long MOD = 1e9 + 7;
        vector<int> dp(n + 1, 0);
        dp[0] = 1e9;
        for(int i=2;i<n+1;i++) {
            int b = __builtin_popcount(i);
            if(b == i)dp[i] = mx;
            else dp[i] = dp[b] + 1;
            dp[i] = min(mx, dp[i]);
        }
        vector<vector<vector<long long> > > dp1(n, vector<vector<long long> >(2, vector<long long>(n + 1, -1)));
        // cur, cnt // i, bit cnt
        auto dfs = [&](auto &&dfs, int cur, bool isup, int bit) -> long long{
            if(cur == n) {
                return !isup && dp[bit] < k;
            }
            long long &ret = dp1[cur][isup][bit];
            if(ret != -1)return ret;
            ret = 0;
            int up = isup ? s[cur] - '0': 1;
            for(int i=0;i<=up;i++) {
                ret = (ret + dfs(dfs, cur+1, isup && (i == s[cur]-'0'), bit + i)) % MOD;
            }
            return ret;
        };
        return dfs(dfs, 0, 1, 0);
    }
};",1448270978
gjp4_,gjp4_,233,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        const long long MOD = 1e9 + 7;
        int n = nums.size();
        long long ans = 0;
        map<int, long long> mp, cnt;
        
        for(int i=0;i<n;i++) {
            if(mp.find(nums[i] - 1) != mp.end()) {
                long long total = cnt[nums[i]-1] * nums[i] % MOD;
                ans = (ans + ((mp[nums[i]-1] + total) % MOD) % MOD)% MOD;
                mp[nums[i]] += (mp[nums[i]-1] + total) % MOD;
                mp[nums[i]] %= MOD;
                cnt[nums[i]] += cnt[nums[i]-1];
                cnt[nums[i]] %= MOD;
            }
            if(mp.find(nums[i] +1) != mp.end()) {
                long long total = cnt[nums[i] + 1] * nums[i];
                ans += (mp[nums[i]+1] + total) % MOD;
                ans %= MOD;
                mp[nums[i]] += (mp[nums[i]+1] + total) % MOD;
                mp[nums[i]] %= MOD;
                cnt[nums[i]] += cnt[nums[i] + 1];
                cnt[nums[i]] %= MOD;
            }
            mp[nums[i]] += nums[i];
            mp[nums[i]] %= MOD;
            cnt[nums[i]]++;
            cnt[nums[i]] %= MOD;
            ans += nums[i];
            ans %= MOD;
        }
        return ans;
    }
};",1448243423
Eshaan Aggarwal,eshaanagg,234,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& arr, int k) {
        int n = arr.size();
        vector<int> l(n);
        for (int i = 0; i < n; i++) {
            int cnt = 1, st = i;
            while (i + 1 < n && arr[i + 1] > arr[i]) {
                i++;
                cnt++;
            }
            for (int j = st; j <= i; j++) {
                l[j] = cnt;
                cnt--;
            }
        }

        for (int i = 0; i + k < n; i++) if (l[i] >= k && l[i + k] >= k)
            return 1;
        return 0;
    }
};",1448205435
Eshaan Aggarwal,eshaanagg,234,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& arr) {
        int n = arr.size();
        vector<int> l(n);
        
        for (int i = 0; i < n; i++) {
            int cnt = 1, st = i;
            while (i + 1 < n && arr[i + 1] > arr[i]) {
                i++;
                cnt++;
            }
            for (int j = st; j <= i; j++) {
                l[j] = cnt;
                cnt--;
            }
        }

        int ans = 0;
        for (int i = 0; i < n; i++) {
            ans = max(ans, l[i] / 2);
            if (i + l[i] < n && l[i + l[i]] >= l[i])
                ans = max(ans, l[i]);
        }

        return ans;
    }
};",1448226729
Eshaan Aggarwal,eshaanagg,234,3631,cpp,"class Solution {
    bool check(int n, int k) {
        if (n == 1)
            return 1;
        
        for (int i = 1; i < k; i++) {
            int p = __builtin_popcount(n);
            if (p == 1)
                return 1;
            n = p;
        }

        return 0;
    }

    int MOD = 1e9 + 7;

    int get(int idx, int pop, bool eq, string &s, vector<vector<vector<int>>> &dp) {
        if (idx == s.size())
            return pop == 0 && !eq;
        
        if (dp[idx][pop][eq] != -1)
            return dp[idx][pop][eq];

        int ans = 0;
        for (int d = 0; d <= (eq ? s[idx] - '0' : 1); d++) {
            int newEq = eq && (s[idx] - '0' == d);
            int newPop = pop - (d == 1);
            if (newPop >= 0) {
                ans += get(idx + 1, newPop, newEq, s, dp);
                ans %= MOD;
            }
        }

        return dp[idx][pop][eq] = ans;
    }

public:
    int countKReducibleNumbers(string s, int k) {
        int n = s.size();
    
        vector<vector<vector<int>>> dp(n, vector<vector<int>> (n + 1, vector<int> (2, -1)));
        int ans = 0;
        
        for (int i = 0; i <= n; i++) 
            if (check(i, k)) {
                ans += get(0, i, 1, s, dp);
                ans %= MOD;
            }

        return ans;
    }
};",1448264191
Eshaan Aggarwal,eshaanagg,234,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& arr) {
        long long MOD = 1e9 + 7;
        vector<long long> sum(1e5 + 10, 0), cnt(1e5 + 10, 0);

        for (int x: arr) {
            for (int d: {1, -1}) {
                if (x + d >= 0) {
                    cnt[x] += cnt[x + d];
                    cnt[x] %= MOD;
                    sum[x] += sum[x + d] + cnt[x + d] * (long long)x;
                    sum[x] %= MOD;
                }
            }
            
            sum[x] += x;
            sum[x] %= MOD;
            cnt[x]++;
            cnt[x] %= MOD;
        }

        long long ans = accumulate(sum.begin(), sum.end(), 0LL);
        return ans % MOD;
    }
};",1448237896
Abhitrio1110,Abhitrio1110,236,3612,cpp,"class Solution {
public:
    
    bool checkIncreasing(const vector<int>& nums, int start, int k) {
        for (int i = start; i < start + k - 1; ++i) {
            if (nums[i] >= nums[i + 1]) {
                return false;
            }
        }   
        return true;
    }
    
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
    int n = nums.size();

    // Iterate through all possible starting indices of the first subarray
    for (int a = 0; a <= n - 2 * k; ++a) {
        // Check if both subarrays starting at `a` and `a + k` are strictly increasing
        if (checkIncreasing(nums, a, k) && checkIncreasing(nums, a + k, k)) {
            return true;
        }
    }   

        // No such pair found
        return false;
    }

};",1448189044
Abhitrio1110,Abhitrio1110,236,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& v) {
        int n=v.size();
        vector<int>sfx(n,1),pfx(n,1);
        for(int i=n-2;i>=0;i--){
            if(v[i]<v[i+1]){
                sfx[i]+=sfx[i+1];
            }
        }
        //int pfx[n]={1};
        for(int i=1;i<n;i++){
            if(v[i]>v[i-1]){
                pfx[i]+=pfx[i-1];
            }
        }
        int res=1;
        for(int i=0;i+1<n;i++){
            res=max(res,min(pfx[i],sfx[i+1]));
        }
        return res;
        
    }
};",1448206013
Abhitrio1110,Abhitrio1110,236,3631,cpp,"class Solution {
public:
#define setbits(x) __builtin_popcount(x) 

const int N = 1e9 + 7;
unordered_map<int, bool> mp;
vector<vector<vector<int>>>dp;
void fun(int n, int k) {
    //cout<<""Welcome""<<endl;
    mp[0] = false;
    mp[1] = true;
    for (int i = 2; i <= n; i++) {
        int op = 1;
        int num = i;
        while (setbits(num) != 1) {
            op++;
            num = setbits(num);
        }
        if (op < k) {
            mp[i] = true;
        } else {
            mp[i] = false;
        }
        //if(mp[i])cout<<i<<endl;
    }
}
    
    int sol(int i, int j, int limit, vector<int>&v){
        if(i==v.size()){
            return mp[j];
        }
        if(dp[i][j][limit]!=-1) return dp[i][j][limit];
        long long ans=0;
        if(limit==1){
            if(v[i]==0){
                //Only use 0
                ans=(ans+sol(i+1,j,limit,v))%N;
            }
            else{
                //Use 0
                ans=(ans+sol(i+1,j,0,v))%N;
                //Use 1
                ans=(ans+sol(i+1,j+1,limit,v))%N;
            }
        }
        else{
            //Use 0
            ans=(ans+sol(i+1,j,0,v))%N;
            //Use 1
            ans=(ans+sol(i+1,j+1,0,v))%N;
        }
        return dp[i][j][limit]=ans;
    }
    
    
    int countKReducibleNumbers(string s, int k) {
        int n=s.size();
        fun(n+1,k);
        vector<int>v;
        for(auto &i:s){
            v.push_back(i-'0');
        }
        dp.assign(n+1,vector<vector<int>>(n+1,vector<int>(2,-1)));
        long long num=sol(0,0,1, v);
        int cnt=0;
        for(auto &i:v)if(i==1)cnt++;
        if(mp[cnt]) num=(num-1+N)%N;
        return num;
    }
};",1448257069
Abhitrio1110,Abhitrio1110,236,3646,cpp,"class Solution {
public:
    const int N=1e9+7;
    int sumOfGoodSubsequences(vector<int>& v) {
        long long ans=0;
        map<int,int>mp,sum;
        for(int i=0;i<v.size();i++){
            //take v[i]-1
            int k1=v[i]-1;
            long long cnt1=mp[k1]+1;
            long long curr1=(cnt1*v[i])%N;
            ans=(ans+sum[k1]+curr1)%N;
            mp[v[i]]+=cnt1;
            mp[v[i]]%=N;
            sum[v[i]]+=(sum[k1]+curr1)%N;
            sum[v[i]]%=N;
            //take v[i]-1
            int k2=v[i]+1;
            long long cnt2=mp[k2];
            long long curr2=(cnt2*v[i])%N;
            ans=(ans+sum[k2]+curr2)%N;
            mp[v[i]]+=cnt2;
            mp[v[i]]%=N;
            sum[v[i]]+=(sum[k2]+curr2)%N;
            sum[v[i]]%=N;
            //cout<<i<<' '<<sum[v[i]]<<endl;
            //ans=(ans+sum[v[i]])%N;
        }
        return ans;
    }
};",1448225053
Chiefis,Chiefis,237,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        start_k = set()
        curr = 2000
        curr_l = 0 
        for (i, num) in enumerate(nums):
            if num > curr:
                curr = num 
                curr_l += 1 
                if curr_l >= k:
                    start_k.add(i - k + 1)
            else:
                curr = num 
                curr_l = 1 
                if curr_l >= k:
                    start_k.add(i - k + 1)
        for num in start_k:
            if num + k in start_k:
                return True 
        return False
        ",1448188463
Chiefis,Chiefis,237,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        start_k = []
        curr = nums[0] + 1
        curr_l = 0 
        curr_start = 0
        for (i, num) in enumerate(nums):
            if num > curr:
                curr = num 
                curr_l += 1 
            else:
                start_k.append(curr_l)
                curr = num 
                curr_l = 1 
        start_k.append(curr_l)
        best = 0 
        for (i, num) in enumerate(start_k):
            if i < len(start_k) - 1:
                best = max(best, min(num, start_k[i + 1]))
            best = max(best, num//2)
        return best
        ",1448202010
Chiefis,Chiefis,237,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        ops_counts = [0 for i in range(801)]
        for num in range(2, 801):
            count = self.count_one(num)
            ops_counts[num] = ops_counts[count] + 1 
        #print(ops_counts[:10])
        s_list = list(s)
        answer = {}
        result = 0
        quotient = 1000000007
        for i in range(1, 801):
            if ops_counts[i] + 1 <= k:
                result += self.dp(s_list, 0, i, answer)
                result %= quotient 
        return result
        
        
        
    def count_one(self, num: int) -> int:
        bin_num = bin(num)[2:]
        count = 0 
        for c in bin_num:
            if c == '1':
                count += 1 
        return count
    
    def dp(self, s_list, idx, num_ones, answer):
        quotient = 1000000007
        if (idx, num_ones) in answer:
            return answer[(idx, num_ones)]
        if len(s_list) - idx < num_ones:
            result = 0 
        else:
            if num_ones == 0:
                result = 0 
                for i in range(idx, len(s_list)):
                    if s_list[i] == '1':
                        result = 1 
                        break
            elif s_list[idx] == '0':
                result = self.dp(s_list, idx + 1, num_ones, answer)
            else:
                result = self.dp(s_list, idx + 1, num_ones - 1, answer)
                if len(s_list) - idx - 1 >= num_ones:
                    result += math.comb(len(s_list) - idx - 1, num_ones)
        result %= quotient 
        answer[(idx, num_ones)] = result 
        return result",1448278334
Chiefis,Chiefis,237,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        quotient = 1000000007
        seqs = [1 for i in range(len(nums))]
        past_seqs = {}
        for i in range(len(seqs) -1, -1, -1):
            num = nums[i]
            new_sum = nums[i]
            for neighbor in [num + 1, num - 1]:
                if neighbor in past_seqs:
                    (seq_count, seq_sum) = past_seqs[neighbor]
                    seqs[i] += seq_count
                    seqs[i] %= quotient 
                    new_sum += seq_sum
                    new_sum += seq_count * nums[i]
                    new_sum %= quotient
                    
            if num in past_seqs:
                past_count, past_sum = past_seqs[num]
                past_seqs[num] = ((past_count + seqs[i])%quotient, (new_sum + past_sum)%quotient)
            else:
                past_seqs[num] = (seqs[i], new_sum)
        ans = 0 
        for (i, num) in past_seqs.items():
            ans += num[1]
            ans %= quotient 
        return ans",1448233795
Anson Lai,ansonll,239,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        if k > n // 2: 
            return False
        
        dp = [1] * (n)
        for i in range(1, n):
            if nums[i] > nums[i - 1]:
                dp[i] = dp[i - 1] + 1
            if dp[i] >= k and dp[i - k] >= k:
                return True

        return False",1448185682
Anson Lai,ansonll,239,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        
        def check(nums, k):
            n = len(nums)

            dp = [1] * (n)
            for i in range(1, n):
                if nums[i] > nums[i - 1]:
                    dp[i] = dp[i - 1] + 1
                if dp[i] >= k and dp[i - k] >= k:
                    return True

            return False
        
        l, r = 0, len(nums) // 2
        while l < r:
            m = l + (r - l + 1) // 2
            if check(nums, m):
                l = m
            else:
                r = m - 1
        return l
                ",1448189514
Anson Lai,ansonll,239,3631,python3,"

class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        MOD = 10**9 + 7
        n = s
        L = len(n)
        max_cnt = L

        steps = [float('inf')] * (max_cnt + 1)
        for cnt in range(1, max_cnt + 1):
            c = cnt
            stp = 0
            while c != 1:
                c = bin(c).count('1')
                stp += 1
            steps[cnt] = stp

        k_counts = set()
        for cnt in range(1, max_cnt + 1):
            if steps[cnt] + 1 <= k:
                k_counts.add(cnt)

        dp = [ [ [0]*2 for _ in range(L + 2) ] for _ in range(2) ]
        dp[0][0][1] = 1

        for pos in range(L):
            curr_dp = dp[pos % 2]
            next_dp = dp[(pos + 1) % 2]
            for ones in range(L + 1):
                next_dp[ones][0] = 0
                next_dp[ones][1] = 0

            d = int(n[pos])
            for ones in range(L + 1):
                for t in [0, 1]:
                    cnt = curr_dp[ones][t]
                    if cnt == 0:
                        continue
                    max_d = d if t else 1
                    for digit in [0, 1]:
                        if digit > max_d:
                            continue
                        new_ones = ones + digit
                        if new_ones > L:
                            continue
                        new_t = t and (digit == max_d)
                        next_dp[new_ones][new_t] = (next_dp[new_ones][new_t] + cnt) % MOD

        ans = 0
        for ones in range(1, L + 1):
            if ones in k_counts:
                ans += dp[L % 2][ones][0]
                ans += dp[L % 2][ones][1]
                ans %= MOD
        n_ones = n.count('1')
        if n_ones in k_counts:
            ans = (ans - 1 + MOD) % MOD

        return ans",1448250030
Anson Lai,ansonll,239,3646,python3,"MOD = 10**9 + 7
class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        max_num = max(nums) + 2
        count = [0] * max_num
        total = [0] * max_num

        result = 0

        for num in nums:
            new_count = 1
            new_total = num

            for diff in [-1, 1]:
                neighbor = num + diff
                if 0 <= neighbor < max_num and count[neighbor] > 0:
                    new_count = (new_count + count[neighbor]) % MOD
                    new_total = (new_total + total[neighbor] + count[neighbor] * num) % MOD

            count[num] = (count[num] + new_count) % MOD
            total[num] = (total[num] + new_total) % MOD

            result = (result + new_total) % MOD

        return result",1448220443
prashant_kashyap9759,prashant_kashyap9759,240,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n=nums.size();
        vector<int>right(n+1);
        right[n-1]=1;
        for(int i=n-2;i>-1;i--){
            if(nums[i]<nums[i+1])right[i]=1+right[i+1];
            else right[i]=1;
        }
        int left=1;
        for(int i=1;i<n;i++){
            if(right[i]>=k&&left>=k)return 1;
            if(nums[i]>nums[i-1])left++;
            else left=1;
        }
        return 0;
    }
};",1448183991
prashant_kashyap9759,prashant_kashyap9759,240,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n=nums.size();
        vector<int>right(n+1);
        right[n-1]=1;
        for(int i=n-2;i>-1;i--){
            if(nums[i]<nums[i+1])right[i]=1+right[i+1];
            else right[i]=1;
        }
        int left=1, ans=1;
        for(int i=1;i<n;i++){
            ans=max(ans,min(right[i],left));
            if(nums[i]>nums[i-1])left++;
            else left=1;
        }
        return ans;
    }
};
",1448186464
prashant_kashyap9759,prashant_kashyap9759,240,3631,cpp,"class Solution {
public:
    const int q=1e9+7;
    bool vec[801];
    void help(int num,int k){
        int str=num;
        k--;
        while(k>0&&num>1){
            int cnt=0;
            while(num>0){
                cnt+=(num&1);
                num>>=1;
            }
            k--;
            num=cnt;
        }
        vec[str]=(num==1);
    }
        int solve(int idx,int cnt,bool high,string&s,vector<vector<vector<int>>>&dp){
            if(idx>=int(s.size())){
                return vec[cnt];
            }
            if(dp[idx][cnt][high]!=-1)return dp[idx][cnt][high];
            long long ans=0;
            if(high){
                ans=solve(idx+1,cnt+1,high,s,dp);
                ans=((long long)ans+solve(idx+1,cnt,high,s,dp))%q;
            }
            else{
                bool chck=high;
                if(s[idx]=='1')chck=1;
                ans=solve(idx+1,cnt,chck,s,dp);
                if(s[idx]=='1')ans=((long long)ans+solve(idx+1,cnt+1,high,s,dp))%q;
            }
            return dp[idx][cnt][high]=ans;
        }
    int countKReducibleNumbers(string s, int k) {
        int n=s.size();
        int cnt=0;
        for(auto ch:s)cnt+=(ch-'0');
        vector<vector<vector<int>>>dp(n+1,vector<vector<int>>(n+1,vector<int>(2,-1)));
        for(int i=0;i<=n;i++)help(i,k);
        cnt=vec[cnt];
        return solve(0,0,0,s,dp)-cnt;
    }
};",1448271777
prashant_kashyap9759,prashant_kashyap9759,240,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int q=1e9+7;
        unordered_map<int,pair<int,int>>ump;
        long long ans=0;
        for(auto num:nums){
            pair<int,int> total={0,0};
            if(ump.count(num-1))total=ump[num-1];
            if(ump.count(num+1)){
                auto item=ump[num+1];
                total.first=((long long)total.first+item.first)%q;
                total.second=((long long)total.second+item.second)%q;
            }
            long long curr=((long long)total.first+((long long)total.second*1ll*num)%q)%q;
            curr=((long long)curr+num)%q;
            auto item=ump[num];
            auto x=((long long)(total.second+1))%q;
            x=((long long)x+item.second)%q;
            ump[num]={((long long)curr+item.first)%q,x};
                ans=((long long)ans+curr)%q;
        }
        return ans;
    }
};",1448214475
svmh,SupervisorMayHap,243,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)


        def check(arr):
            for i in range(1, len(arr)):
                if arr[i] <= arr[i - 1]:
                    return False
            return True
        
        for i in range(n - 2 * k + 1):
            if check(nums[i:i + k]) and check(nums[i+k:i +k+k]):
                return True

        return False
            ",1448182198
svmh,SupervisorMayHap,243,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        last = 0
        res = 0

        cur = 1
        n = len(nums)
        for i in range(1, n):
            if nums[i] > nums[i-1]:
                cur += 1
            else:
                last = cur
                cur = 1
            res = max(res, cur // 2, min(last, cur))
        return res

        ",1448187250
svmh,SupervisorMayHap,243,3631,python3,"from functools import lru_cache

class Solution:


    def countKReducibleNumbers(self, s: str, k: int) -> int:
        mod = 1000000007
    
        n = len(s)
        dp = {}
        for i in range(1, n + 1):
            cur = i
            count = 0
            while cur > 1:
                cur = bin(cur).count('1')
                count += 1
            dp[i] = count
    
        dp1 = [[0, 0] for _ in range(n + 1)]
        dp1[0][1] = 1
    
        for i in range(n):
            dp2 = [[0, 0] for _ in range(n + 1)]
            for j in range(0, i + 1):
                if dp1[j][0]:
                    new_j = j
                    dp2[new_j][0] = (dp2[new_j][0] + dp1[j][0]) % mod
    
                    new_j = j + 1
                    dp2[new_j][0] = (dp2[new_j][0] + dp1[j][0]) % mod
    
                if dp1[j][1]:
                    flag = int(s[i]) 
                    new_flag = 1 if (0 == flag) else 0
                    dp2[j][new_flag] = (dp2[j][new_flag] + dp1[j][1]) % mod
    
                    if 1 <= flag:
                        new_j = j + 1
                        new_flag = 1 if (1 == flag) else 0
                        dp2[new_j][new_flag] = (dp2[new_j][new_flag] + dp1[j][1]) % mod
            dp1 = dp2 
    
        res = 0
        for i in range(1, n + 1):
            if dp[i] <= k - 1:
                res = (res + dp1[i][0]) % mod
        return res",1448272173
svmh,SupervisorMayHap,243,3646,python3,"from collections import defaultdict


class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        mod = 1000000007
        dp = defaultdict(int)
        cnt = defaultdict(int)
        res = 0
        for num in nums:
            if num - 1 in cnt:
                cnt[num] += cnt[num - 1]
                dp[num] += dp[num - 1] + num * cnt[num - 1]
                res += dp[num - 1] + num * cnt[num - 1]
            if num + 1 in cnt:
                cnt[num] += cnt[num + 1]
                dp[num] += dp[num + 1] + num * cnt[num + 1]
                res += dp[num + 1] + num * cnt[num + 1]
            cnt[num] += 1
            cnt[num] %= mod
    
            dp[num] += num
            dp[num] %= mod
    
            res += num
            res %= mod
            # print(cnt, dp)
        # print(dp)
        return res",1448206244
尾玉,louisfghbvc,244,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        // goal: find two length k
        
        
        int n = nums.size();
        vector<int> arr;
        for (int i = 0, j; i < n; i = j) {
            j = i;
            while (j < n) {
                if (j != i) {
                    if (nums[j] <= nums[j-1]) break;
                }
                j++;
            }
            arr.push_back(j-i);
        }
        
        int ans = 0;
        for (int i = 0; i < arr.size(); ++i) {
            ans = max(ans, arr[i]/2);
            if (i+1 < arr.size()) 
                ans = max(ans, min(arr[i], arr[i+1]));
        }
        return ans >= k;
    }
};",1448230543
尾玉,louisfghbvc,244,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        // goal: find the maximum increasing array such that two subarray is strictly increase
        
        // idea:
        // visited number at most once
        // starting from each smallest number
        // two possible
        // 1. self half
        // 2. min(arr[i], arr[i+1])
        
        int n = nums.size();
        vector<int> arr;
        for (int i = 0, j; i < n; i = j) {
            j = i;
            while (j < n) {
                if (j != i) {
                    if (nums[j] <= nums[j-1]) break;
                }
                j++;
            }
            arr.push_back(j-i);
        }
        
        int ans = 0;
        for (int i = 0; i < arr.size(); ++i) {
            ans = max(ans, arr[i]/2);
            if (i+1 < arr.size()) 
                ans = max(ans, min(arr[i], arr[i+1]));
        }
        return ans;
    }
};",1448230330
尾玉,louisfghbvc,244,3631,cpp,"class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        // goal: count the number such that we can reduce the value to 1 at most k times
        
        // idea: digit dp
        // dp[i][isbound][isZ][cnt]: number of ways, starting from index i, is leading zero
        
        int mod = 1e9+7;
        
        int n = s.size();
        vector dp(n, vector(2, vector(2, vector(n+1, -1))));
        
        auto eval = [&](int x) {
            int cnt = 1;
            while (x != 1) {
                cnt++;
                x = __builtin_popcount(x);
            }   
            return cnt;
        };
        
        auto dfs = [&](auto &self, int i, int isB, int isZ, int cnt) -> int {
            if (i >= n) return (!isZ && eval(cnt) <= k);
            
            auto& res = dp[i][isB][isZ][cnt];
            if (res != -1) return res;
            
            res = 0;
            int b = isB ? s[i]-'0' : 1;
            for (int d = 0; d <= b; ++d) {
                int nB = isB && (d == s[i]-'0');
                int nisZ = isZ && (d == 0);
                // speical case one
                if (i == n-1 && isZ && d == 1)
                    res = (res + 1) % mod;
                else
                    res = (res + self(self, i+1, nB, nisZ, cnt + (d==1))) % mod;
            }
            
            return res;
        };
        
        // check if self is reducible
        int one = count(s.begin(), s.end(), '1');
        // cout << one << endl;
        
        return (dfs(dfs, 0, 1, 1, 0) - (eval(one)<=k) + mod) % mod;
    }
};",1448272311
尾玉,louisfghbvc,244,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        // goal: find the sum of all good subsequence
        // good seq: adj dif by 1
        
        // idea:
        // [1,2,1,1,2]
        //  ^ 1     2
        
        // think about dp
        // do reverse
        // x => try to add previous x-1, 
        // dp[i] += dp[j], a[i]=a[j]-1/a[j]+1
        
        // think distribution
        // [1,2,1,3,1,2]
        //  x will increase a[x-1], a[x+1] sum        
        
        // dp[i]: ending at index i, number of subsequence
        // two dp, first is sum, second is cnt
        
        // 1,2,1
        // [1], s=1,c=1
        // [1,2] [2], s=5,c=2
        // [1,2,1], [2,1], [1], s=5+c*x, c=3
        
        // what is duplicate?
        // [10,10,1,9]
        // [10]
        // [10]
        // [1]
        // [10,9],[10,9],[9]
        
        int mod = 1e9+7;
        unordered_map<int, long> sum, cnt;
        
        long ans = 0;
        for (long x: nums) {
            long prev_sum = sum[x-1] + sum[x+1];
            long prev_cnt = cnt[x-1] + cnt[x+1];
            cnt[x] += prev_cnt+1;
            cnt[x] %= mod;
            
            long add = prev_sum + (prev_cnt+1)*x;
            ans = (ans + add) % mod;
            sum[x] += add;
            sum[x] %= mod;
        }
        return ans;
    }
};",1448238596
Rahul Singh,Pirate-Emperor,246,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& arr, int k) {
        int n=arr.size();
        vector<int> dif;
        int a=0;
        for (int i=0;i<n;i++)
        {
            if (i==0) a++;
            else
            {
                if (arr[i]<=arr[i-1])
                {
                    dif.push_back(a);
                    a=1;
                }
                else a++;
            }
        }
        if (a>0) dif.push_back(a);
        int resu=0;
        int b=0;
        for (int i=0;i<dif.size();i++)
        {
            if (i!=0) resu=max(resu,min(dif[i],dif[i-1]));
            b=max(dif[i],b);
        }
        resu=max(resu,b/2);
        return resu>=k;
}
};",1448198628
Rahul Singh,Pirate-Emperor,246,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& arr) {
        int n=arr.size();
        vector<int> dif;
        int a=0;
        for (int i=0;i<n;i++)
        {
            if (i==0) a++;
            else
            {
                if (arr[i]<=arr[i-1])
                {
                    dif.push_back(a);
                    a=1;
                }
                else a++;
            }
        }
        if (a>0) dif.push_back(a);
        int resu=0;
        int b=0;
        for (int i=0;i<dif.size();i++)
        {
            if (i!=0) resu=max(resu,min(dif[i],dif[i-1]));
            b=max(dif[i],b);
        }
        resu=max(resu,b/2);
        return resu;
    }
};",1448199907
Rahul Singh,Pirate-Emperor,246,3631,cpp,"#define ll long long

class Solution {
public:
    ll MOD = 1e9+7;
    ll qexp(ll a, ll b, ll m) {
        ll res = 1;
        while (b) {
            if (b % 2) res = res * a % m;
            a = a * a % m;
            b /= 2;
        }
        return res;
    }
    vector<ll> fact, invf;

    void precompute(int n) {
        fact.assign(n + 1, 1); 
        for (int i = 1; i <= n; i++) fact[i] = fact[i - 1] * i % MOD;
        invf.assign(n + 1, 1);
        invf[n] = qexp(fact[n], MOD - 2, MOD);
        for (int i = n - 1; i > 0; i--) invf[i] = invf[i + 1] * (i + 1) % MOD;
    }

    ll nCk(int n, int k) {
        if (k < 0 || k > n) return 0;
        return fact[n] * invf[k] % MOD * invf[n - k] % MOD;
    }
    int countKReducibleNumbers(string s, int k) {
        int n = s.size();
        precompute(n+100);
        vector<long long> dp(n+1,0);
        dp[0]=0;
        dp[1]=1;
        for (int i=2;i<=n;i++)
        {
            dp[i] = dp[__builtin_popcount(i)]+1;
        }
        
        long long a=0;
        ll resu=0;
        for (int i=0;i<n;i++)
        {
            if (s[i]=='0') continue;
            for (int j=0;j<n-i;j++)
            {
                long long tem=a+j;
                if (tem<=0) continue;
                if (dp[tem]<=k) 
                {
                    resu = (resu + nCk(n-i-1,j))%MOD;;
                }
            }
            a++;
        }
        
        return resu;
    }
};",1448265742
Rahul Singh,Pirate-Emperor,246,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& arr) {
        int n=arr.size();
        long long MOD=1e9+7,resu=0;
        vector<long long> dp(1e5+10,0),sdp(1e5+10,0);
        for (int i=0;i<n;i++)
        {
            long long tem=0;
            if (arr[i]!=0) 
            {
                dp[arr[i]]=(dp[arr[i]]+dp[arr[i]-1])%MOD;
                sdp[arr[i]]=(sdp[arr[i]]+sdp[arr[i]-1])%MOD;
                tem = (tem+dp[arr[i]-1])%MOD;
            }
            dp[arr[i]]=(dp[arr[i]]+dp[arr[i]+1])%MOD;
            sdp[arr[i]]=(sdp[arr[i]]+sdp[arr[i]+1])%MOD;
            tem = (tem+dp[arr[i]+1]+1)%MOD;
            dp[arr[i]]=(dp[arr[i]]+1)%MOD;
            sdp[arr[i]] = (sdp[arr[i]] + (tem*arr[i])%MOD)%MOD;
        }
        for (int i=0;i<1e5+10;i++)
        {
            resu = (resu + sdp[i])%MOD;
        }
        return  resu;
    }
};",1448225919
Lucky Orb,megurine,247,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, a: List[int], k: int) -> bool:
        n = len(a)
        f1 = [0] * (n + 1)
        f2 = [0] * (n + 2)
        p = -inf
        for i in range(n):
            if a[i] > p:
                f1[i + 1] = f1[i] + 1
            else:
                f1[i + 1] = 1
            p = a[i]
        p = inf
        for i in range(n - 1, -1, -1):
            if a[i] < p:
                f2[i + 1] = f2[i + 2] + 1
            else:
                f2[i + 1] = 1
            p = a[i]
        # print(f1, f2)
        for i in range(n):
            if f1[i + 1] >= k and f2[i + 2] >= k:
                return True
        return False",1448187126
Lucky Orb,megurine,247,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, a: List[int]) -> bool:
        n = len(a)
        f1 = [0] * (n + 1)
        f2 = [0] * (n + 2)
        p = -inf
        for i in range(n):
            if a[i] > p:
                f1[i + 1] = f1[i] + 1
            else:
                f1[i + 1] = 1
            p = a[i]
        p = inf
        for i in range(n - 1, -1, -1):
            if a[i] < p:
                f2[i + 1] = f2[i + 2] + 1
            else:
                f2[i + 1] = 1
            p = a[i]
        lo, hi = 0, n
        while lo < hi:
            mid = (lo + hi + 1) // 2
            for i in range(n):
                if f1[i + 1] >= mid and f2[i + 2] >= mid:
                    lo = mid
                    break
            else:
                hi = mid - 1
        return lo",1448192696
Lucky Orb,megurine,247,3631,python3,"mod = int(1e9 + 7)
class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        m = len(s)
        f = [False] * (m + 1)
        for v in range(1, m + 1):
            vv = v
            op = 1
            while v > 1 and op < k:
                v = v.bit_count()
                op += 1
            f[vv] = op <= k and v == 1
        
        A = list(map(int, s[::-1]))
        mem = {}
        def dfs(pos, pre, rem, is_limit, is_valid):
            if pos < 0:
                return int(is_valid and f[rem])
            if not is_limit and is_valid and (pos, pre, rem) in mem:
                return mem[pos, pre, rem]
            cur = 0
            for x in range(2):
                if not is_limit or A[pos] >= x:
                    cur += dfs(pos - 1, x, rem + x, is_limit and x == A[pos], is_valid or x > 0)
                    cur %= mod
            if not is_limit and is_valid:
                mem[pos, pre, rem] = cur
            return cur
        ans = dfs(len(A) - 1, 0, 0, True, False)
        tmp = s.count('1')
        op = 1
        while tmp > 1 and op < k:
            tmp = tmp.bit_count()
            op += 1
        ans -= op <= k and tmp == 1
        mem.clear()
        return ans % mod
# sol = Solution()
# print(sol.countKReducibleNumbers('1' * 800, 5))
        ",1448251855
Lucky Orb,megurine,247,3646,python3,"mod = int(1e9 + 7)
class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        f1 = Counter() # 以x为结尾的序列的和
        f2 = Counter() # 以x为结尾的序列的数量
        for x in nums:
            v1 = f1[x] + x
            v2 = f2[x] + 1
            if x - 1 in f1:
                v1 += f1[x - 1] + f2[x - 1] * x
                v2 += f2[x - 1]
            if x + 1 in f1:
                v1 += f1[x + 1] + f2[x + 1] * x
                v2 += f2[x + 1]
            f1[x] = v1 % mod
            f2[x] = v2 % mod
        ans = 0
        for x in f1:
            ans += f1[x]
            ans %= mod
        return ans
        ",1448209047
Adithya V,astronom1cal,250,3612,cpp,"#include <iostream>
#include <cstdlib>
#include <ctime>
#include <climits>
#include <numeric>
#include <iomanip>
#include <fstream>
#include <string>
#include <algorithm>
#include <cmath>
#include <bitset>
#include <utility>
#include <array>
#include <vector>
#include <deque>
#include <forward_list>
#include <list>
#include <set>
#include <unordered_set>
#include <map>
#include <unordered_map>
#include <stack>
#include <queue>
#include <functional>
#include <popcntintrin.h>
#include <ext/pb_ds/assoc_container.hpp>

// LLONG_MAX is 9,223,372,036,854,775,807 (19 digits)
// ULLONG_MAX is 18,446,744,073,709,551,615 (20 digits)

using namespace __gnu_pbds;
template <typename T>
using ordered_set = tree<T, null_type, std::less<T>, rb_tree_tag, tree_order_statistics_node_update>;
template <typename T>
using ordered_multiset = tree<std::pair<T, T>, null_type, std::less<std::pair<T, T>>, rb_tree_tag, tree_order_statistics_node_update>;

// use a map to keep track of duplicates in ordered multiset, like 2-1, 2-2, 2-3, and so on

using ll = long long;
using ld = long double;
using namespace std;

class Solution
{
public:
    bool hasIncreasingSubarrays(vector<int> &nums, int k)
    {
        ll n = (ll) nums.size();

        if (k == 1)
        {
            return true;
        }

        for (ll i = 0; i <= n - 2 * k; i++)
        {
            bool ok = true;
            ll j = i + 1;

            while (j < i + k)
            {
                if ((nums[j] <= nums[j - 1]) || (nums[j + k] <= nums[j + k - 1]))
                {
                    ok = false;
                }

                j++;
            }

            if (ok)
            {
                return true;
            }
        }

        return false;
    }
};",1448184059
Adithya V,astronom1cal,250,3619,cpp,"#include <iostream>
#include <cstdlib>
#include <ctime>
#include <climits>
#include <numeric>
#include <iomanip>
#include <fstream>
#include <string>
#include <algorithm>
#include <cmath>
#include <bitset>
#include <utility>
#include <array>
#include <vector>
#include <deque>
#include <forward_list>
#include <list>
#include <set>
#include <unordered_set>
#include <map>
#include <unordered_map>
#include <stack>
#include <queue>
#include <functional>
#include <popcntintrin.h>
#include <ext/pb_ds/assoc_container.hpp>

// LLONG_MAX is 9,223,372,036,854,775,807 (19 digits)
// ULLONG_MAX is 18,446,744,073,709,551,615 (20 digits)

using namespace __gnu_pbds;
template <typename T>
using ordered_set = tree<T, null_type, std::less<T>, rb_tree_tag, tree_order_statistics_node_update>;
template <typename T>
using ordered_multiset = tree<std::pair<T, T>, null_type, std::less<std::pair<T, T>>, rb_tree_tag, tree_order_statistics_node_update>;

// use a map to keep track of duplicates in ordered multiset, like 2-1, 2-2, 2-3, and so on

using ll = long long;
using ld = long double;
using namespace std;

class Solution
{
public:
    int maxIncreasingSubarrays(vector<int> &nums)
    {
        ll n = (ll) nums.size();

        ll cnt = 0;

        vector<ll> len(n, 1);
        ll ans = 1;

        for (ll i = n - 2; i >= 0; i--)
        {
            if (nums[i] < nums[i + 1])
            {
                len[i] = len[i + 1] + 1;
            }

            ans = max(ans, len[i] / 2);

            if (i + len[i] < n && len[i + len[i]] >= len[i])
            {
                ans = max(ans, len[i]);
            }
        }

        return ans;
    }
};",1448198861
Adithya V,astronom1cal,250,3631,cpp,"#include <iostream>
#include <cstdlib>
#include <ctime>
#include <climits>
#include <numeric>
#include <iomanip>
#include <fstream>
#include <string>
#include <algorithm>
#include <cmath>
#include <bitset>
#include <utility>
#include <array>
#include <vector>
#include <deque>
#include <forward_list>
#include <list>
#include <set>
#include <unordered_set>
#include <map>
#include <unordered_map>
#include <stack>
#include <queue>
#include <functional>
#include <popcntintrin.h>
#include <ext/pb_ds/assoc_container.hpp>

// LLONG_MAX is 9,223,372,036,854,775,807 (19 digits)
// ULLONG_MAX is 18,446,744,073,709,551,615 (20 digits)

using namespace __gnu_pbds;
template <typename T>
using ordered_set = tree<T, null_type, std::less<T>, rb_tree_tag, tree_order_statistics_node_update>;
template <typename T>
using ordered_multiset = tree<std::pair<T, T>, null_type, std::less<std::pair<T, T>>, rb_tree_tag, tree_order_statistics_node_update>;

// use a map to keep track of duplicates in ordered multiset, like 2-1, 2-2, 2-3, and so on

using ll = long long;
using ld = long double;
using namespace std;

// Modular Inverse (modinv)

// Given a number a and mod m, consider the equation a * ainv = 1 (mod m)
// Basically (a * ainv) % m = 1
// ainv is the modular inverse of a

// Uses extended euclidean algorithm to find x for a.x + m.y = 1
// then make x positive and take mod
// that gives us the modular inverse of a

// Example: the modular inverse of 3 wrt 7 is 5
// (3 * 5) % 7 = 1
// 15 % 7 = 1

// Works in O(log(min(a, m))) time

pair<ll, ll> extended_euclidean(ll a, ll b)
{
    if (b == 0)
    {
        return {1, 0};
    }

    auto [x, y] = extended_euclidean(b, a % b);

    return {y, x - y * (a / b)};
}

ll modinv(ll a, ll m)
{
    ll x = extended_euclidean(a, m).first;

    return (x % m + m) % m;
}

class Solution
{
public:
    int countKReducibleNumbers(string s, int k)
    {
        ll n = (ll)s.length();

        auto good = [&](ll cnt)
        {
            ll K = k - 1;

            while (K > 0)
            {
                cnt = __builtin_popcount(cnt);
                K--;
            }

            return (cnt == 1);
        };

        vector<ll> fact(n + 1);
        vector<ll> inv_fact(n + 1);

        fact[0] = fact[1] = inv_fact[0] = inv_fact[1] = 1;

        const ll mod = 1e9 + 7;

        for (ll i = 2; i <= n; i++)
        {
            fact[i] = (fact[i - 1] * i) % mod;
            inv_fact[i] = modinv(fact[i], mod);
        }

        auto C = [&](ll N, ll R)
        {
            return ((fact[N] * ((inv_fact[N - R] * inv_fact[R]) % mod)) % mod);
        };

        ll ans = 0;

        for (ll i = 0; i < n; i++)
        {
            if (i == 0)
            {
                ll cnt = 1;

                for (ll k = 1; k < n; k++)
                {
                    if (s[k] == '1')
                    {
                        ll empty = n - k - 1;

                        for (ll j = 0; j <= empty; j++)
                        {
                            if (good(cnt + j))
                            {
                                ans += C(empty, j);
                                ans %= mod;
                            }
                        }

                        cnt++;
                    }
                }
            }

            else
            {
                ll empty = n - i - 1;

                for (ll j = 0; j <= empty; j++)
                {
                    if (good(j + 1))
                    {
                        ans += C(empty, j);
                        ans %= mod;
                    }
                }
            }
        }

        return ans;
    }
};",1448267012
Adithya V,astronom1cal,250,3646,cpp,"#include <iostream>
#include <cstdlib>
#include <ctime>
#include <climits>
#include <numeric>
#include <iomanip>
#include <fstream>
#include <string>
#include <algorithm>
#include <cmath>
#include <bitset>
#include <utility>
#include <array>
#include <vector>
#include <deque>
#include <forward_list>
#include <list>
#include <set>
#include <unordered_set>
#include <map>
#include <unordered_map>
#include <stack>
#include <queue>
#include <functional>
#include <popcntintrin.h>
#include <ext/pb_ds/assoc_container.hpp>

// LLONG_MAX is 9,223,372,036,854,775,807 (19 digits)
// ULLONG_MAX is 18,446,744,073,709,551,615 (20 digits)

using namespace __gnu_pbds;
template <typename T>
using ordered_set = tree<T, null_type, std::less<T>, rb_tree_tag, tree_order_statistics_node_update>;
template <typename T>
using ordered_multiset = tree<std::pair<T, T>, null_type, std::less<std::pair<T, T>>, rb_tree_tag, tree_order_statistics_node_update>;

// use a map to keep track of duplicates in ordered multiset, like 2-1, 2-2, 2-3, and so on

using ll = long long;
using ld = long double;
using namespace std;

class Solution
{
public:
    int sumOfGoodSubsequences(vector<int> &nums)
    {
        ll n = (ll) nums.size();

        ll mx = *max_element(nums.begin(), nums.end());

        vector<ll> cnt(mx + 1, 0);
        vector<ll> sum(mx + 1, 0);

        const ll mod = 1e9 + 7;

        for (ll i = 0; i < n; i++)
        {
            ll x = nums[i] - 1, y = nums[i] + 1;

            if (x >= 0 && x <= mx)
            {
                cnt[nums[i]] += cnt[x];
                cnt[nums[i]] %= mod;

                sum[nums[i]] += (sum[x] + (cnt[x] * nums[i]) % mod) % mod;
                sum[nums[i]] %= mod;
            }

            if (y >= 0 && y <= mx)
            {
                cnt[nums[i]] += cnt[y];
                cnt[nums[i]] %= mod;

                sum[nums[i]] += (sum[y] + (cnt[y] * nums[i]) % mod) % mod;
                sum[nums[i]] %= mod;
            }

            cnt[nums[i]]++;
            sum[nums[i]] += nums[i];
        }

        ll ans = 0;

        for (ll i = 0; i <= mx; i++)
        {
            ans += sum[i];
            ans %= mod;
        }

        return ans;
    }
};",1448224039
Yucheng Dai,Rainingcity,251,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        for(int i = 0; i + 2 * k <= n; i++) {
            bool flag = true;
            for(int j = i + 1; j < i + k; j++) {
                if (nums[j] <= nums[j - 1]) flag = false;
            }
            for(int j = i + k + 1; j < i + 2 * k; j++) {
                if (nums[j] <= nums[j - 1]) flag = false;
            }
            if (flag) return true;
        }
        return false;
    }
};",1448181974
Yucheng Dai,Rainingcity,251,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<pair<int, int>> v{}; // inc segs
        int i = 0;
        while(i < n) {
            int j = i + 1;
            while(j < n && nums[j] > nums[j - 1]) j++;
            v.push_back(make_pair(i, j));
            i = j;
        }
        // for(auto x: v) {
        //     cout << x.first << "" "" << x.second << endl;
        // }
        int ans = 0;
        for(int i = 0; i < v.size(); i++) {
            ans = max(ans, (v[i].second - v[i].first) / 2);
            if (i > 0) {
                ans = max(ans, min(v[i].second - v[i].first, v[i - 1].second - v[i - 1].first));
            }
        }
        return ans;
    }
};",1448192822
Yucheng Dai,Rainingcity,251,3631,cpp,"const int MOD = 1000000007;
int getSB(int x) {
    int res = 0;
    while(x != 0) {
        x -= x & (-x);
        res++;
    }
    return res;
}
void buildC(int C[801][801], int n) {
    C[0][0] = C[1][0] = C[1][1] = 1;
    for(int i = 2; i <= n; i++) {
        C[i][0] = C[i][i] = 1;
        for(int j = 1; j < i; j++) {
            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
        }
    }
}
class Solution {
private:
    int red[801];
    int C[801][801];
    int getFull(int n, int prev, int k) {
        int res = 0;
        for(int i = 0; i <= n; i++) {
            if (red[prev + i] < k) {
                res = (res + C[n][i]) % MOD;
            }
        }
        return res;
    }
public:
    Solution() {
        // build red
        red[0] = 0;
        for(int i = 1; i <= 800; i++) {
            int tmp = i;
            red[i] = 0;
            while(tmp != 1) {
                red[i]++;
                tmp = getSB(tmp);
            }
        }
        // build C
        buildC(C, 800);
    }
    int countKReducibleNumbers(string s, int k) {
        int n = s.length();
        int prev = 0;
        int ans = 0;
        for(int i = 0; i < n; i++) {
            if (s[i] == '1') {
                ans = (ans + getFull(n - i - 1, prev, k)) % MOD;
                prev++;
            }
        }
        return (ans - 1 + MOD) % MOD;
    }
};",1448267071
Yucheng Dai,Rainingcity,251,3646,cpp,"typedef long long ll;
const ll MOD = 1000000007;
class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int mx = 0;
        vector<ll> sums(100100, 0);
        vector<ll> cnts(100100, 0);
        for(int x: nums) {
            x++;
            mx = max(mx, x);
            ll xcnt = 1 + cnts[x - 1] + cnts[x + 1];
            sums[x] = (sums[x] + sums[x - 1] + sums[x + 1] + xcnt * (x - 1)) % MOD;
            cnts[x] = (cnts[x] + xcnt) % MOD;
        }
        ll ans = 0;
        for(int i = 0; i <= mx; i++) {
            ans = (ans + sums[i]) % MOD;
        }
        return (int)ans;
    }
};",1448211015
James Jialun Zhao,frixxxer,252,3612,python3,"class Solution:
    
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        def search_from(nums, k, i):
            last = -10000
            for j in range(k):
                if i + j >= len(nums) or nums[i + j] <= last:
                    return False
                last = nums[i+j]
            return True
        for i in range(len(nums)):
            if search_from(nums, k, i) and search_from(nums, k, i + k):
                return True
        return False",1448184903
James Jialun Zhao,frixxxer,252,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        last = None
        chain = 0
        lisa = [1] * len(nums)
        for i, n in enumerate(nums):
            if last is None or n <= last:
                chain = 1
            else:
                chain += 1
            last = n
            lisa[i] = chain
        lo, hi = 0, len(nums) // 2 + 1
        def check(lisa, k):
            # 0 1 2 3 4 5 6 7 8 9 10
            for i in range(k - 1, len(lisa) - k):
                if lisa[i] >= k and lisa[i + k] >= k:
                    return True
            return False
        while lo < hi:
            mi = (lo + hi) // 2
            val = not check(lisa, mi)
            if not val:
                lo = mi + 1
            else:
                hi = mi
        return lo - 1",1448198838
James Jialun Zhao,frixxxer,252,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        set_bits = s.count(""1"")
        mod = 1_000_000_007

        @cache
        def reducible(n, k):
            if type(n) == int:
                n = bin(n)[2:]
            if n == ""1"":
                return True
            if k == 0 or n == ""0"":
                return False
            else:
                ct = bin(n.count(""1""))[2:]
                return reducible(ct, k-1)

        # for i in range(5):
        #     print(i, reducible(i, k))
        @cache
        def ct_reducible(bits, offset):
            nonlocal k, mod
            if bits < 0:
                z = reducible(offset, k-1)
                o = 0
            elif bits == 0:
                z = reducible(0 + offset, k - 1)
                o = reducible(1 + offset, k - 1)
            else:
                z = ct_reducible(bits - 1, offset)
                o = ct_reducible(bits - 1, offset + 1)
            # print(f""ct_reducible {bits=} {offset=} {(z+o) % mod}"")
            return (z + o) % mod
        summ = 0
        off = 0
        for i, c in enumerate(s):
            bits = len(s) - 1 - i
            if c == ""1"":
                summ = (summ + ct_reducible(bits - 1, off)) % mod
                off += 1
        extras = [reducible(r, k - 1) for r in range(1, set_bits)]
        # print(f""{extras=}"")
        return (summ) % mod
            ",1448280886
James Jialun Zhao,frixxxer,252,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        freq, sums = defaultdict(int), defaultdict(int)
        mod = 1_000_000_007
        for n in nums:
            f_nm1, s_nm1 = freq[n-1], sums[n-1]
            f_np1, s_np1 = freq[n+1], sums[n+1]
            s_nm1 += f_nm1 * n
            s_np1 += f_np1 * n
            sums[n] += (s_nm1 + s_np1 + n) % mod
            freq[n] += (f_nm1 + f_np1 + 1) % mod
        return reduce(lambda acc, x: (acc + x) % mod, sums.values(), 0)",1448211551
icicl,icicl,256,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        for i in range(len(nums)-2*k+1):
            if all(nums[i+j] < nums[i+j+1] and nums[i+j+k] < nums[i+j+k+1] for j in range(k-1)): return True
        return False",1448182004
icicl,icicl,256,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        run = [1]*len(nums)
        for i in range(1,len(nums)):
            if nums[i] > nums[i-1]: run[i] = run[i-1]+1
        l = 1
        r = len(nums)
        while r > l+1:
            m = (l+r)//2
            ok = False
            for i in range(m):
                prev = False
                for j in run[i::m]:
                    if j >= m:
                        if prev: ok = True
                        prev = True
                    else:
                        prev = False
            if ok:
                l = m
            else:
                r = m
        return l
        ",1448194383
icicl,icicl,256,3631,python3,"M = 10**9+7

@lru_cache(maxsize=1024)
def fact(n):
    if n < 2: return 1
    return (fact(n-1)*n)%M

@lru_cache(maxsize=(1<<16))
def ncr(n,r):
    return (fact(n)*pow(fact(r),-1,M)*pow(fact(n-r),-1,M))%M

class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        onepos = []
        result = 0
        for i in range(len(s)):
            if s[-1-i] == '1': onepos.append(i)
        for numbits in range(1,len(s)+1):
            b = numbits
            for _ in range(k-1):
                b = bin(b).count('1')
            if b > 1: continue
            nb = numbits
            m = 1
            for op in onepos[::-1]:
                if op < nb: break
                result += ncr(op, nb)
#                print(nb,op,result)
                nb -= 1
                if nb < 0: break
        return result%(10**9+7)
            ",1448252943
icicl,icicl,256,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        tally = {}
        for i in nums:
            if not i in tally: tally[i] = [0,0]
            tally[i][0] += i
            tally[i][1] += 1
            if i-1 in tally:
                tally[i][0] += tally[i-1][0] + i*tally[i-1][1]
                tally[i][1] += tally[i-1][1]
            if i+1 in tally:
                tally[i][0] += tally[i+1][0] + i*tally[i+1][1]
                tally[i][1] += tally[i+1][1]
#            print(tally)
        return (sum(i[0] for i in tally.values()))%((10**9+7))
                ",1448210051
user9821NM,user9821NM,257,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        
        vector<int>prefix(nums.size());
        
        for(int i = 1; i < nums.size(); i++) {
            prefix[i] = prefix[i - 1] + (nums[i] > nums[i - 1] ? 1 : 0);
        }
        
        for(int i = 0; i + 2 * k - 1 < nums.size(); i++) {
            if((prefix[i + k - 1] - prefix[i] == k - 1) && (prefix[i + 2*k - 1] - prefix[i + k] == k - 1)) {
                return true;
            }
        }
        
        return false;
        
    }
};",1448200562
user9821NM,user9821NM,257,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        
        int left = 1, right = nums.size() / 2, answer = 1;
        
        vector<int>prefix(nums.size());
        
        for(int i = 1; i < nums.size(); i++) {
            prefix[i] = prefix[i - 1] + (nums[i] > nums[i - 1] ? 1 : 0);
        }
            
        auto okay = [&](int k) {
            for(int i = 0; i + 2 * k - 1 < nums.size(); i++) {
                if((prefix[i + k - 1] - prefix[i] == k - 1) && (prefix[i + 2*k - 1] - prefix[i + k] == k - 1)) {
                    return true;
                }
            }
            return false;
        };
        
        while(left <= right) {
            int mid = (left + right) / 2;
            if(okay(mid)) answer = mid, left = mid + 1;
            else right = mid - 1;
        }
        
        return answer;
    }
};",1448204760
user9821NM,user9821NM,257,3631,cpp,"class Solution {
public:
    const int N = 800 + 1;
    const int MOD = 1e9 + 7;
    
    int countKReducibleNumbers(string s, int k) {
        vector<int>isReducible(N);
        
        auto reduce = [&](int n, int len, auto &&self) -> int {
            if(n == 1) return (len < k);
            return self(__builtin_popcount(n), len + 1, self);
        };
        
        for(int i = 1; i < N; i++) {
            isReducible[i] = reduce(i, 0, reduce);
        }
        
        vector<vector<vector<int>>>dp(s.size(), vector<vector<int>>(s.size() + 1, vector<int>(2, -1)));
        
        auto f = [&](int index, int sum, int isBound, auto self) -> int {    
            if(index == s.size()) {
                return (isBound == false && isReducible[sum]);
            }
            
            if(dp[index][sum][isBound] != -1) return dp[index][sum][isBound];
            
            int one = self(index + 1, sum + 1, (isBound && s[index] == '1'), self);
            int zero = self(index + 1, sum + 0, (isBound && s[index] == '0'), self);
                        
            return dp[index][sum][isBound] = (zero + (isBound && s[index] == '0' ? 0 : one)) % MOD;
        };
        
        return f(0, 0, 1, f);
    }
};",1448268051
user9821NM,user9821NM,257,3646,cpp,"class Solution {
public:
    const int MOD = 1e9 + 7;
    const int N = 1e5 + 1;
    
    int sumOfGoodSubsequences(vector<int>& nums) {
        vector<pair<int,int>>dp(N);
        
        auto contribution = [&](int value) -> pair<int,int> {
            if(value >= N || value < 0) return {0, 0};
            return dp[value];
        };
        
        for(int i = 0; i < nums.size(); i++) {
            pair<int,int>plusOne = contribution(nums[i] + 1);
            pair<int,int>minusOne = contribution(nums[i] - 1);
            
            dp[nums[i]].first += (1 + plusOne.first + minusOne.first) % MOD; 
            dp[nums[i]].second += (nums[i] + (1ll * nums[i] * plusOne.first + 1ll * plusOne.second) % MOD + 
                                    (1ll * nums[i] * minusOne.first + 1ll * minusOne.second) % MOD) % MOD; 
            dp[nums[i]].first %= MOD; dp[nums[i]].second %= MOD;            
        }
        
        int answer = 0;
        for(auto &i : dp) answer = (answer + i.second) % MOD;
        return answer;
    }
};",1448232024
Aaryadeep,aaryadeep21122003,258,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& a, int k) {
        int n = a.size();
        vector<int> pre(n);
        pre[0] = 1;
        int ans = 0, prev = 0;
        for(int i=1;i<n;i++) {
            if(a[i]>a[i-1]) pre[i] = pre[i-1] + 1;
            else pre[i] = 1, prev = pre[i-1];
            ans = max(ans, pre[i]/2);
            ans = max(ans, min(pre[i], prev));
        }
        return ans >= k;
    }
};",1448190190
Aaryadeep,aaryadeep21122003,258,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& a) {
        int n = a.size();
        vector<int> pre(n);
        pre[0] = 1;
        int ans = 0, prev = 0;
        for(int i=1;i<n;i++) {
            if(a[i]>a[i-1]) pre[i] = pre[i-1] + 1;
            else pre[i] = 1, prev = pre[i-1];
            ans = max(ans, pre[i]/2);
            ans = max(ans, min(pre[i], prev));
        }
        return ans;
    }
};",1448187369
Aaryadeep,aaryadeep21122003,258,3631,cpp,"#define ll long long

class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        vector<ll> ways(805);
        const int mod = 1e9 + 7;
        auto add = [&](ll x, ll y) {
            return (x%mod + y%mod) % mod;
        };
        
        int n = s.size();
        int cnt = 0;
        for(int i=0;i<n;i++) {
            vector<ll> nways(805);
            if(s[i]=='1') {
                for(int j=0;j<=800;j++) {
                    nways[j] = add(nways[j], ways[j]);
                    if(j>0) nways[j] = add(nways[j], ways[j-1]);
                }
                nways[cnt] = add(nways[cnt], 1);
                cnt++;
            }
            else {
                for(int j=0;j<=800;j++) {
                    nways[j] = add(nways[j], ways[j]);
                    if(j>0) nways[j] = add(nways[j], ways[j-1]);
                }
            }
            ways = nways;
        }
        // ways[cnt] = add(ways[cnt], 1);

        auto sbits = [](int x) {
            int res = 0;
            for(int i=0;i<12;i++) {
                if(x&(1<<i)) res++;
            }
            return res;
        };

        ll ans = 0;
        
        for(int x=1;x<=800;x++) {
            int kk = k-1, val = x;
            while(kk) {
                val = sbits(val);
                kk--;
            }
            if(val==1) ans = add(ans, ways[x]); 
        }
        return ans;
    }
};",1448275089
Aaryadeep,aaryadeep21122003,258,3646,cpp,"#define ll long long

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& a) {
        const int mod = 1e9 + 7;
        int n = a.size();

        auto add = [&](ll x, ll y) {
            return (x%mod + y%mod) % mod;
        };
        
        map<int, ll> sum, ways;
        ll ans = 0;
        for(auto x: a) {
            //ans = add(ans, sum[x-1]);
            // ans = add(ans, ways[x-1]*x);
            sum[x] = add(sum[x], sum[x-1]);
            sum[x] = add(sum[x], ways[x-1]*x);
            ways[x] = add(ways[x], ways[x-1]);

            sum[x] = add(sum[x], sum[x+1]);
            sum[x] = add(sum[x], ways[x+1]*x);
            ways[x] = add(ways[x], ways[x+1]);

            sum[x] = add(sum[x], x);
            ways[x] = add(ways[x], 1);
        } 
        for(auto [x,y]: sum) {
            ans = add(ans, y);
        }
        return ans;
    }
};",1448228738
xy-li,xy-li,260,3612,python3,"from functools import cache
class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        @cache
        def check_increasing_subarray(i, k):
            # print(nums[i+1:i+k+1])
            if k == 1:
                return True
            for j in range(i + 1, i + k):
                if nums[j] <= nums[j - 1]:
                    return False
            return True
        
        for i in range(len(nums) - 2*k+1):
            # print(nums[i:i+k], nums[i+k:i+2*k],check_increasing_subarray(i, k), check_increasing_subarray(i + k, k))
            if check_increasing_subarray(i, k) and check_increasing_subarray(i + k, k):
                return True
        return False",1448187946
xy-li,xy-li,260,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        last = 0
        res = 1
        segs = []
        for i in range(n):
            if i > 0 and nums[i] <= nums[i - 1]:
                segs.append((i - last))
                last = i
        segs.append(n - last)
        res = segs[0]//2
        for i in range(1, len(segs)):
            res = max(res, segs[i]//2, min(segs[i], segs[i - 1]))
        return res",1448206400
xy-li,xy-li,260,3631,python3,"from collections import Counter
from functools import cache
M = 10**9 + 7
N = 800

frac = [1]
for i in range(1, N+1):
    frac.append(frac[-1] * i % M)

inv = [pow(num, -1, M) for num in frac]


@cache
def f(num):
    if num == 1:
        return 0
    return f(num.bit_count()) + 1

class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        cnt = Counter()
        n = len(s)
        prefix = 0
        for i in range(n):
            if s[i] == '0':
                continue
            # the rest n - i - 1 digits, how many ones (j)?
            for j in range(n-i):
                cnt[prefix + j] += frac[n-i-1] * inv[j] * inv[n-i-1-j]
                cnt[prefix + j] %= M
            prefix += 1
        if 0 in cnt:
            del cnt[0]
        # cnt[prefix] += 1
        
        res = 0
        # print(cnt)
        for c in cnt:
            if c!=0 and f(c) <= k - 1:
                # print(c, f(c), k, cnt[c])
                res += cnt[c]
                res %= M
        return res
        ",1448268557
xy-li,xy-li,260,3646,python3,"M = 10**9 + 7

from collections import Counter
class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        c = Counter()
        s = Counter()
        res = 0
        for num in nums:
            cur = c[num - 1] + c[num + 1] + 1
            s[num] += (s[num - 1] + s[num + 1] + cur * num) % M
            s[num] %= M
            res += (s[num - 1] + s[num + 1] + cur * num) % M
            res %= M
            c[num] += cur
            c[num] %= M
        
        return res
            ",1448233723
cro_poder,cro_poder,262,3612,cpp," 

class Solution {
public:
    bool hasIncreasingSubarrays(std::vector<int>& nums, int k) {
        int n = nums.size();
 
        for (int i = 0; i <= n - 2 * k; ++i) {
            bool f1 = true;
            bool f2 = true;
 
            for (int j = 0; j < k - 1; ++j) {
                if (nums[i + j] >= nums[i + j + 1]) {
                    f1 = false;
                    break;
                }
            }
 
            if (f1) {
                for (int j = 0; j < k - 1; ++j) {
                    if (nums[i + k + j] >= nums[i + k + j + 1]) {
                        f2 = false;
                        break;
                    }
                }
 
                if (f2) {
                    return true;
                }
            }
        }

        return false;   
    }
};
",1448200016
cro_poder,cro_poder,262,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        vector<int>v;
        for(int i=0;i<nums.size()-1;i++){
            if(nums[i]<nums[i+1])v.push_back(1);
            else v.push_back(-1);
        }
        vector<int>v2;
        for(int i=v.size()-1;i>=0;i--){
            if(v[i]==-1)v2.push_back(0);
            else{
                v2.push_back(1+(v2.size()?v2.back():0));
            }
        }
        reverse(v2.begin(),v2.end());
        v2.push_back(0);
        for(auto&it:v2)it++;
        int ans = 0;
        for(int i=0;i<v2.size();i++){
            int e = v2[i];
            if(e){
                int f = i+e;
                if(f<v2.size()&&v2[f]>=e){
                    ans = max(ans,e);
                }
            }
            if(e){
                int f = i-e;
                if(f>=0&&v2[f]>=2*e){
                    ans = max(ans,e);
                }
            }
        }
        return ans;
    }
};",1448197808
cro_poder,cro_poder,262,3631,cpp,"class Solution {
public:
    const int MOD = 1e9 + 7;
    vector<unsigned long long> factorial;
    vector<unsigned long long> invFactorial;

    Solution() {
        precomputeFactorials(800, MOD);
    }
 
    void precomputeFactorials(int maxN, int mod) {
        factorial.resize(maxN + 1, 1);
        invFactorial.resize(maxN + 1, 1);
        
        for (int i = 2; i <= maxN; i++) {
            factorial[i] = (factorial[i - 1] * i) % mod;
        }
        invFactorial[maxN] = modInverse(factorial[maxN], mod);
        for (int i = maxN - 1; i > 0; i--) {
            invFactorial[i] = (invFactorial[i + 1] * (i + 1)) % mod;
        }
    }

    unsigned long long modInverse(unsigned long long n, int mod) {
        unsigned long long result = 1;
        int exp = mod - 2;
        while (exp > 0) {
            if (exp % 2 == 1) result = (result * n) % mod;
            n = (n * n) % mod;
            exp /= 2;
        }
        return result;
    }
 
    unsigned long long nCrMod(int n, int r, int mod) {
        if (n < r) return 0;
        return ((factorial[n] * invFactorial[r]) % mod * invFactorial[n - r]) % mod;
    }

    int countKReducibleNumbers(string s, int k) {
        vector<int> hash(800, 0);
        hash[0] = 1e9; 
        auto calculateKReducibility = [&](int x) -> int {
            int steps = 0;
            while (x > 1) {
                x = bitset<32>(x).count();
                steps++;
            }
            return steps;
        };

        for (int i = 1; i < 800; i++) {
            hash[i] = calculateKReducibility(i);
        }

        int ta = count(s.begin(), s.end(), '1');
        int back = 0;
        int ans = 0;

        for (int i = s.size() - 1; i >= 0; i--) {
            if (s[i] == '1') {
                ta--;
                int lc = ta;

                for (int j = 0; j <= back; j++) {
                    if (hash[lc + j] < k) {
                        ans = (ans + nCrMod(back, j, MOD)) % MOD;
                    }
                }
            }
            back++;
        }

        return ans;
    }
};
",1448268835
cro_poder,cro_poder,262,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        const int MOD = 1e9 + 7;
        int n = nums.size();
        vector<int> dp(n);
        map<int, int> mp1, mp2;

        dp[n - 1] = nums[n - 1] % MOD;
        mp1[nums[n - 1]] = 1;
        mp2[nums[n - 1]] = nums[n - 1] % MOD;

        for (int i = n - 2; i >= 0; i--) {
            int ue = nums[i] - 1, le = nums[i] + 1;

            int eff = (mp1[ue] + mp1[le] + 1) % MOD;
            int cs = (mp2[ue] + mp2[le]) % MOD;
            cs = (cs + 1LL * eff * nums[i]) % MOD;

            dp[i] = cs;
            mp1[nums[i]] = (mp1[nums[i]] + eff) % MOD;
            mp2[nums[i]] = (mp2[nums[i]] + cs) % MOD;
        }
 
        int result = 0;
        for (int i = 0; i < n; i++) {
            result = (result + dp[i]) % MOD;
        }

        return result;
    }
};
",1448222660
Marmaduke,Marmaduke,264,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n= nums.size();
        vector<int> dp(n);
        int prev = 2e9+7;
        for(int i = 0; i < n; i++)
        {
            int x = nums[i];
            if(x > prev)
            {
                dp[i] = dp[i-1] + 1;
            }
            else
            {
                dp[i] = 1;
            }
            prev = x;
        }
        
        for(int i = k-1; i+k < n; i++)
        {
            int a = dp[i];
            int b = dp[i+k];
            int z = min(a,b);
            if(z >= k)
            {
                return true;
            }
        }
        
        return false;
    }
};",1448183650
Marmaduke,Marmaduke,264,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n= nums.size();
        vector<int> dp(n);
        int prev = 2e9+7;
        for(int i = 0; i < n; i++)
        {
            int x = nums[i];
            if(x > prev)
            {
                dp[i] = dp[i-1] + 1;
            }
            else
            {
                dp[i] = 1;
            }
            prev = x;
        }
        
        int high = n;
        int low = 1;
        while(low < high)
        {
            int mid = (low+high+1)/2;
            bool found = false;
            //cout << ""mid = "" << mid << endl;
            for(int i = mid-1; i+mid < n; i++)
            {
                
                int a = dp[i];
                int b = dp[i+mid];
                //cout << i << "" "" << a << "" "" << b << endl;
                int z = min(a,b);
                if(z >= mid)
                {
                    found = true;
                    break;
                }
            }
            if(found)
            {
                low = mid;
            }
            else
            {
                high = mid-1;
            }
        }
        
        return low;
    }
};",1448190312
Marmaduke,Marmaduke,264,3631,cpp,"const int M = 1000;
vector<long long int> brc;
vector<vector<long long int>> pc;
const int mod = 1e9+7;
class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        if(brc.empty())
        {
            long long int high = 0;
            brc = vector<long long int>(M);
            brc[0] = 0;
            brc[1] = 0;
            for(int i = 2; i < M; i++)
            {
                int p = 0;
                int t = i;
                while(t)
                {
                    if(t&1)
                    {
                        p++;
                    }
                    t /= 2;
                }
                
                brc[i] = 1+brc[p];
                //cout << i << "" "" << p << "" "" << brc[i] << endl;
                high = max(high, brc[i]);
            }
            
            //cout << high << endl;
            
            pc = vector<vector<long long int>>(M, vector<long long int>(M,0));
            pc[0][0] = 1;
            pc[1][0] = 1;
            pc[1][1] = 1;
            for(int L = 2; L < M; L++)
            {
                pc[L][0] = 1;
                for(int i = 1; i <= L; i++)
                {
                    pc[L][i] = (pc[L-1][i] + pc[L-1][i-1]) % mod;
                    //cout << L << "" "" << i << "" "" << pc[L][i] << endl;
                }
            }
        }
        
        int n = s.length();
        long long int ans = 0;
        int bit = 0;
        for(int i = 0; i < n; i++)
        {
            long long int g = n-1-i; // length of string to the immediate right
            if(s[i] == '1')
            {
                //cout << ""i = "" << i << endl;
                long long int sub = 0;
                for(int j = 0; j <= g; j++)
                {
                    if(1 + brc[bit+j] <= k)
                    {
                        //cout << ""j = "" << j << endl;
                        sub += pc[g][j];
                    }
                }
                ans += sub;
                ans %= mod;
                bit++;
                //cout << i << "" "" << sub << endl;
            }
        }
        ans = (ans + mod - 1) % mod; // zero was counted above
        return ans;
    }
};",1448276178
Marmaduke,Marmaduke,264,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        const int mod = 1e9+7;
        int M = 1e5+7;
        vector<long long int> ct(M,0);
        vector<long long int> sum(M,0);
        long long int ans = 0;
        for(int i = 0; i < nums.size(); i++)
        {
            long long int u = nums[i];
            long long int p = u;
            long long int t = 1;
            p += (sum[u+1]) + u*ct[u+1];
            p %= mod;
            t += ct[u+1];
            if(u > 0)
            {
                p += (sum[u-1]) + u*ct[u-1];
                p %= mod;
                t += ct[u-1];
            }
            ans = (ans + p) % mod;
            ct[u] = (ct[u] + t) % mod;
            sum[u] = (sum[u] + p) % mod;
            //cout << i << "" "" << t << "" "" << p << endl;
        }
        
        return ans;
    }
};",1448213560
Sammy Taubman,staubman1,265,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        increasingLengths = [0 for i in range(len(nums))]

        last = -1001
        length = 0
        for i, n in enumerate(nums):
            if n > last:
                length += 1
            else:
                length = 1
            last = n
            increasingLengths[i] = length
     

        for left in range(k - 1, len(nums) - k):
            if increasingLengths[left] >= k and increasingLengths[left + k] >= k:
                return True

        return False",1448184554
Sammy Taubman,staubman1,265,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        increasingLengths = [0 for i in range(len(nums))]
        
        last = -1001
        length = 0
        for i, num in enumerate(nums):
            if num > last:
                length += 1
            else:
                length = 1
            last = num
            increasingLengths[i] = length
        
        k = 0
        
        for i in range(0, len(nums)):
            if i + k + 1>= len(nums):
                return k
            
            potential = k + 1
            while (i + potential < len(nums) and increasingLengths[i] >= potential and increasingLengths[i + potential] >= potential):
                k += 1
                potential += 1
        
        return k",1448192725
Sammy Taubman,staubman1,265,3631,python3,"import math

class Solution:
    def isKReducible(self, n, k):
        if n == 1:
            return True
        for i in range(k):
            n = n.bit_count()
            if n == 1:
                return True
        return False
    
    def waysToPlace(self, s, o):
        MOD = (10 ** 9) + 7
    
        # calculate ways to place o 1s s.t the result is less than s
        # idea is scan and solve how many ways when we place all 1s to the left of index
        rem = o
        total = 0
        for i, c in enumerate(s):
            if c == '1':
                if rem == 0:
                    return total + 1
                # (len(s) - i - 1) spots to place (rem ones)
                # (len(s) - i - 1) choose rem
                total += math.comb(len(s) - i - 1, rem) % MOD
                rem -= 1
        return total
    
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        # after one iteration, we are at max 800 -- so manually solve that
        # then question is, how many numbers less than n with correct number of
        # it's giving stars and bars but < is annoying
        
        MOD = (10 ** 9) + 7
        
        if k == 5:
            # every number between 1 and 800 is 4-reducible, so we could set every bit if we want
            # therefore answer is n - 1
            return (int(s, 2) - 1) % MOD
        
        total = 0
        
        for i in range(1, len(s)):
            if self.isKReducible(i, k - 1):
                total += self.waysToPlace(s, i) % MOD
                total = total % MOD
        
        return total",1448255018
Sammy Taubman,staubman1,265,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        # sum based on starting num
        # go in reverse storing count + sum
        # to be efficient, use dict and check num + 1 and num - 1
        
        MOD = (10 ** 9) + 7
        
        # num: (count, sum)
        dp = {}
        total = 0
        
        for i in range(0, len(nums)):
            idx = len(nums) - i - 1
            
            count = 1
            seqSum = nums[idx]
            
            if nums[idx] + 1 in dp:
                otherCount, otherSum = dp[nums[idx] + 1]
                count += otherCount
                seqSum += (otherCount * nums[idx]) + otherSum
                seqSum %= MOD
            if nums[idx] - 1 in dp:
                otherCount, otherSum = dp[nums[idx] - 1]
                count += otherCount
                seqSum += (otherCount * nums[idx]) + otherSum
                seqSum %= MOD
            
            total += seqSum
            total %= MOD
            oldCount, oldSum = dp.get(nums[idx], (0, 0))
            dp[nums[idx]] = (count + oldCount, (seqSum + oldSum) % MOD)
        
        return total
        ",1448210984
Tushar Agarwal,techtushar2002,268,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k)
    {
        int n = nums.size();
        vector<int> inc(n,0);
        for(int i=1; i<n; i++)
            {
                inc[i] = inc[i-1];
                if(nums[i] > nums[i-1])
                    inc[i]++;
            }
        for(int i=0; i<n; i++)
            {
                if(i+2*k <= n)
                {
                    if(inc[i+k-1]-inc[i] == k-1 && inc[i+2*k-1]-inc[i+k] == k-1)
                        return true;
                }
                else break;
            }
        return false;
    }
};",1448185170
Tushar Agarwal,techtushar2002,268,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size(), ans = 0;
        vector<int> inc(n,1);
        for(int i=n-2; i>=0; i--)
            {
                if(nums[i] < nums[i+1])
                    inc[i] = inc[i+1] + 1;
            }
        for(int i=0; i<n; i++)
            {
                ans = max(ans, inc[i]/2);
                if(i+inc[i] < n)
                    ans = max(ans,min(inc[i],inc[i+inc[i]]));
            }
        return ans;
    }
};",1448200101
Tushar Agarwal,techtushar2002,268,3631,cpp,"long long mod = 1e9+7;
long long power(long long x,long long y)
{
    if(x==0) return 1;
    if(y==0) return 1;
    long long value = 0;
    value = power(x,y/2);
    value = (value*value)%mod;
    if(y&1LL) value *= x;
    return value%mod;
}

int inversemod(long long x) 
{
    return power(x,mod-2)%mod;
}

class Solution {
public:
    int countKReducibleNumbers(string s, int k)
    {
    	vector<long long> fac(801,1), inv(801,1);
    	for(long long i=1; i<=800; i++)
    	{
    	    fac[i] = fac[i-1]*i;
    	    fac[i] %= mod;
    	}
    	inv[800] = inversemod(fac[800]);
        for (long long i = 799; i >= 0; i--)
            inv[i] = inv[i+1] * (i+1) % mod;
        
        vector<long long> f(801,0);
        long long count = 0;
        for(int i=2; i<=800; i++)
            {
                int popc = __builtin_popcount(i);
                f[i] = f[popc]+1;
            }
        int n = s.size(), pre = 0;
        for(int i=0; i<n; i++)
        {
            if(s[i] == '1')
            {
                int x = n-i-1;
                for(int j=0; j<=x; j++)
                    {
                        if(f[pre+j] < k)
                        {
                            count += (fac[x]%mod*inv[j]%mod*inv[x-j]%mod);
                            count %= mod;
                        }
                    }
                pre++;
            }
        }
        return count-1;
    }
};
",1448283272
Tushar Agarwal,techtushar2002,268,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums)
    {
        int n = nums.size();
        long long res = 0, mod = 1e9+7;
        vector<long long> end(1e5+2,0),sum(1e5+2,0); 
        for(int i=0; i<n; i++)
            {
                long long num = nums[i];
                if(num != 0) end[num] += end[num-1];
                end[num] += end[num+1];
                end[num]++;
                end[num] %= mod;
                if(num != 0) sum[num] += sum[num-1] + num*end[num-1];
                sum[num] += sum[num+1] + num*end[num+1];
                sum[num] += num;
                sum[num] %= mod;
            }
        for(int i=0; i<=1e5; i++)
            {
                res += sum[i];
                res %= mod;
            }
        return res;
    }
};",1448233010
Terry,tttyyy49,269,3612,java,"class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        int n = nums.size();
        int[] dp = new int[n];
        Arrays.fill(dp, 1);
        for (int i = 1; i < n; ++i) {
            if (nums.get(i) > nums.get(i - 1)) {
                dp[i] = dp[i - 1] + 1;
            }
        }
        
        for (int j = 0; j + k < n; ++j) {
            if (dp[j] >= k && dp[j + k] >= k) return true;
        }
        return false;
    }
}",1448187263
Terry,tttyyy49,269,3619,java,"class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        int n = nums.size();
        int[] dp = new int[n];
        Arrays.fill(dp, 1);
        for (int i = 1; i < n; ++i) {
            if (nums.get(i) > nums.get(i - 1)) {
                dp[i] = dp[i - 1] + 1;
            }
        }
        
        int start = 1;
        int end = n / 2;
        while (start + 1 < end) {
            int mid = (start + end) / 2;
            if (good(mid, dp)) {
                start = mid;
            } else {
                end = mid;
            }
        }
        if (good(end, dp)) return end;
        return start;
    }
    
    boolean good(int k, int[] dp) {
        for (int j = 0; j + k < dp.length; ++j) {
            if (dp[j] >= k && dp[j + k] >= k) return true;
        }
        return false;
    }
}",1448193233
Terry,tttyyy49,269,3631,java,"class Solution {
    static final long MOD = (long) 1e9 + 7;
    
    public int countKReducibleNumbers(String s, int k) {
        int n = s.length();
        
        // [i][bitCount][tight?1:0]
        long[][][] dp = new long[n + 1][n + 1][2];
        
        dp[0][0][0] = 0;
        dp[0][0][1] = 1;
        
        for (int i = 0; i < n; ++i) {
            int d = s.charAt(i) - '0';
            if (d == 0) {
                for (int j = 0; j <= n; ++j) {
                    dp[i + 1][j][1] += dp[i][j][1];
                    dp[i + 1][j][1] %= MOD;
                    
                    dp[i + 1][j][0] += dp[i][j][0];
                    dp[i + 1][j][0] %= MOD;
                    if (j + 1 <= n) {
                        dp[i + 1][j + 1][0] += dp[i][j][0];
                        dp[i + 1][j + 1][0] %= MOD;
                    }
                }
            } else { // d == 1
                for (int j = 0; j <= n; ++j) {
                    if (j + 1 <= n) {
                        dp[i + 1][j + 1][1] = dp[i][j][1];
                        dp[i + 1][j + 1][1] %= MOD;
                    }
                    
                    dp[i + 1][j][0] += dp[i][j][1];
                    dp[i + 1][j][0] %= MOD;
                    
                    dp[i + 1][j][0] += dp[i][j][0];
                    dp[i + 1][j][0] %= MOD;
                    
                    if (j + 1 <= n) {
                        dp[i + 1][j + 1][0] += dp[i][j][0];
                        dp[i + 1][j + 1][0] %= MOD;
                    }
                }
            }
        }
        
        long res = 0;
        for (int j = 1; j <= n; ++j) {
            if (isKReducible(j, k)) {
                res += dp[n][j][0];
                res %= MOD;
            }
        }
        return (int) res;
    }
    
    boolean isKReducible(int x, int k) {
        for (int i = 1; i < k; ++i) {
            x = Integer.bitCount(x);
        }
        return x == 1;
    }
}",1448283496
Terry,tttyyy49,269,3646,java,"class Solution {
    final static long MOD = (long) 1e9 + 7;
    
    public int sumOfGoodSubsequences(int[] nums) {
        // endingNum -> count of subsequence ending with endingNum
        Map<Integer, Long> dp = new HashMap<>();
        // endingNum -> sum of subsequence ending with endingNum
        Map<Integer, Long> sum = new HashMap<>();
        
        long res = 0;
        for (int x : nums) {
            long cnt = 1; // self
            cnt += dp.getOrDefault(x - 1, 0L);
            cnt += dp.getOrDefault(x + 1, 0L);
            cnt %= MOD;
            
            long s = (cnt * x) % MOD;
            s += sum.getOrDefault(x - 1, 0L);
            s %= MOD;
            s += sum.getOrDefault(x + 1, 0L);
            s %= MOD;
            
            dp.put(x, (dp.getOrDefault(x, 0L) + cnt) % MOD);
            sum.put(x, (sum.getOrDefault(x, 0L) + s) % MOD);
        }
        
        for (int x : sum.keySet()) {
            res += sum.get(x);
            res %= MOD;
        }
        
        return (int) res;
    }
}",1448221026
All Shahoriar Tonmoy,astthecoder,270,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        vector<int> x;
        int c=1;
        for(int i=1;i<nums.size();i++){
            if(nums[i]<=nums[i-1]){
                x.push_back(c);
                c=0;
            }
            c++;
        }
        x.push_back(c);
        for(int i=0;i<x.size();i++){
            if(x[i]>=2*k) return true;
            if(i && x[i]>=k && x[i-1]>=k) return true;
        }
        return false;
    }
};",1448192609
All Shahoriar Tonmoy,astthecoder,270,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        vector<int> x;
        int c=1;
        for(int i=1;i<nums.size();i++){
            if(nums[i]<=nums[i-1]){
                x.push_back(c);
                c=0;
            }
            c++;
        }
        x.push_back(c);
        int ans=0;
        for(int i=0;i<x.size();i++){
            ans=max(ans, x[i]/2);
            if(i) ans=max(ans,min(x[i],x[i-1]));
        }
        return ans;
    }
};",1448197205
All Shahoriar Tonmoy,astthecoder,270,3631,cpp,"#define ll long long int
class Solution {
public:
    string t;
    ll dp[801][801][2], mod=1000000007, cnt[801];

    ll solve(ll i, ll c, ll f){
        if(i==t.size()){
            if(!c && f) return 1;
            else return 0;
        }
        if(dp[i][c][f]!=-1) return dp[i][c][f];
        dp[i][c][f]=0;
        if(t[i]=='0'){
            dp[i][c][f] = (dp[i][c][f] + solve(i+1, c, f)) % mod;
            if(f && c) dp[i][c][f] = (dp[i][c][f] + solve(i+1, c-1, f)) % mod;
        }
        else{
            dp[i][c][f] = (dp[i][c][f] + solve(i+1, c, 1)) % mod;
            if(c) dp[i][c][f] = (dp[i][c][f] + solve(i+1, c-1, f)) % mod;
        }
        return dp[i][c][f];
    }

    int countKReducibleNumbers(string s, int k) {
        memset(dp, -1, sizeof(dp));
        memset(cnt, 0, sizeof(cnt));
        t=s;
        ll ans=0;
        for(ll i=1;i<=800;i++){
            ll x=0, temp=i;
            while(temp){
                x+=(temp%2);
                temp/=2;
            }
            cnt[i]=cnt[x]+1;
            if(cnt[i] <= k)
                ans = (ans + solve(0, i, 0)) %mod;
        }
        return ans;
    }
};",1448269926
All Shahoriar Tonmoy,astthecoder,270,3646,cpp,"#define ll long long int
class Solution {
public:
    ll mod = 1000000007;
    ll cnt[100005], p[100005];

    int sumOfGoodSubsequences(vector<int>& nums) {
        memset(cnt, 0, sizeof(cnt));
        for(ll i=0;i<nums.size();i++){
            nums[i]++;
            ll c=cnt[nums[i]-1]+cnt[nums[i]+1];
            p[i] = c+1;
            cnt[nums[i]]+=p[i];
            cnt[nums[i]] %=mod;
        }
        ll ans=0;
        memset(cnt, 0, sizeof(cnt));
        for(ll i=nums.size()-1;i>=0;i--){
            ll c=cnt[nums[i]-1]+cnt[nums[i]+1];
            p[i] = (p[i] * (c + 1)) % mod;
            cnt[nums[i]]+=(c+1);
            cnt[nums[i]] %=mod;
            ll x=((nums[i] - 1)*p[i])%mod;
            ans=(ans+x)%mod;
        }        

        return ans;
    }
};",1448236642
ocavue,ocavue,271,3612,python3,"from typing import List


def is_strictly_increasing(nums: List[int]) -> bool:
    for i in range(1, len(nums)):
        if nums[i] <= nums[i - 1]:
            return False
    return True


class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)

        for a in range(n):
            b = a + k
            c = b + k

            if c > n:
                break

            nums1 = nums[a:b]
            nums2 = nums[b:c]

            if is_strictly_increasing(nums1) and is_strictly_increasing(nums2):
                return True
        return False

 ",1448182701
ocavue,ocavue,271,3619,python3,"from typing import List


def check(nums: List[int]) -> bool:
    n = len(nums)

    dp = [1] * n

    for i in range(n - 2, -1, -1):
        j = i + 1
        if nums[i] < nums[j]:
            dp[i] = dp[j] + 1

    best = 1

    for j in range(1, n):
        k = dp[j]
        i = j - k
        if i < 0:
            continue

        if dp[i] >= k:
            best = max(best, k)

    return best


class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        case1 = check(nums)
        case2 = check([-num for num in nums[::-1]])
        return max(case1, case2)

 ",1448198968
ocavue,ocavue,271,3631,python3,"from functools import cache

inf = float(""inf"")
MOD = 10**9 + 7


# def logger(func):
#     def new_func(*args, **kwargs):
#         result = func(*args, **kwargs)

#         print_args = "", "".join([repr(a) for a in args])
#         print_kwargs = "", "".join([f""{k}={repr(v)}"" for k, v in kwargs.items()])
#         print_all = "", "".join([p for p in [print_args, print_kwargs] if p])
#         print(f""{func.__name__}({print_all}) == {result}"")
#         return result

#     return new_func


@cache
# @logger
def get_k(num: int) -> int:
    if num == 1:
        return 0
    bit_count = num.bit_count()
    if num == bit_count:
        return inf
    # assert bit_count < num
    return get_k(bit_count) + 1


for i in range(1, 10):
    get_k(i)


class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        n = len(s)

        @cache
        # @logger
        def dfs(i: int, equal: bool, ones_before: int) -> int:
            # assert ones_before <= 800
            # assert 0 <= i < n

            if i == n - 1:
                if equal:
                    if s[i] == ""0"":
                        return 0
                    else:
                        case0 = 1 if get_k(ones_before) < k else 0
                        return case0
                else:
                    case1 = 1 if get_k(ones_before + 1) < k else 0
                    case0 = 1 if get_k(ones_before) < k else 0
                    return case1 + case0

            # assert i < n - 1
            if equal:
                if s[i] == ""0"":
                    case0 = dfs(i + 1, True, ones_before)
                    return case0
                else:
                    case1 = dfs(i + 1, True, ones_before + 1)
                    case0 = dfs(i + 1, False, ones_before)
                    return (case1 + case0) % MOD
            else:
                # print(""case1"", i + 1, False, ones_before + 1)
                case1 = dfs(i + 1, False, ones_before + 1)
                case2 = dfs(i + 1, False, ones_before)
                return (case1 + case2) % MOD

        return dfs(0, True, 0)
 ",1448276767
ocavue,ocavue,271,3646,python3,"from collections import Counter
from typing import List

MOD = 10**9 + 7


class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        n = len(nums)
        result = 0

        num_to_sum = Counter()
        num_to_count = Counter()

        for i in range(n - 1, -1, -1):
            num = nums[i]

            c = num_to_count[num + 1] + num_to_count[num - 1] + 1
            s = num_to_sum[num + 1] + num_to_sum[num - 1] + c * num

            num_to_sum[num] += s
            num_to_sum[num] %= MOD

            num_to_count[num] += c
            num_to_count[num] %= MOD

            result += s
            result %= MOD

        return result % MOD

 ",1448222958
svxvdp,svxvdp,272,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        N = len(nums)

        def ok(lo):
            for i in range(lo, lo + k - 1):
                if nums[i + 1] <= nums[i]:
                    return False
            return True
                
        for lo in range(N - 2 * k + 1):
            if ok(lo) and ok(lo + k):
                return True
        return False
                
            
        ",1448184902
svxvdp,svxvdp,272,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        N = len(nums)
        l = []

        cnt = 1
        i = 1
        for i in range(1, N):
            if nums[i] > nums[i - 1]:
                cnt += 1
            else:
                l.append(cnt)
                cnt = 1
        l.append(cnt)

        ans = max(l) // 2

        for i in range(len(l) - 1):
            ans = max(ans, min(l[i], l[i + 1]))
        return ans

        ",1448196745
svxvdp,svxvdp,272,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        import math

        def main(count):
            s_count1 = s.count('1')
            ans = 0
            for i in range(N):
                if s[i] == '0':
                    continue

                # choice 1. use 0.
                ans += math.comb(N - i - 1, count)

                s_count1 -= 1
                if s_count1 == 0:
                    return ans

                # choice 2. use 1.
                count -= 1

                if count == 0:
                    return ans + 1

            return ans
            


        MOD = 10 ** 9 + 7
        N = len(s)


        lk = [0 for _ in range(N + 5)]
        lk[1] = 0
        for i in range(2, N):
            lk[i] = lk[i.bit_count()] + 1
        
        
        L = []
        for i in range(1, N):
            if lk[i] <= k - 1:
                L.append(i)
        # print(L)
        

        ans = 0
        for count in L:
            # print(count, main(count))
            ans = (ans + main(count)) % MOD
        return ans

        ",1448283778
svxvdp,svxvdp,272,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        MOD = 10 ** 9 + 7

        D = {}
        for e in nums:
            A, B = D.get(e, (0, 0))
            A += 1
            B += e

            for t in [e + 1, e - 1]:
                X, Y = D.get(t, (0, 0))

                A += X
                B += Y + e * X
            
            D[e] = (A % MOD, B % MOD)
        
        ans = 0
        for _, B in D.values():
            ans = (ans + B) % MOD
        return ans

        ",1448213658
a7174812,a7174812,274,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        vector<int> v(nums.size()+1);
        v[1] = 1;
        for(int i = 1; i < nums.size(); ++i){
            if(nums[i] > nums[i-1])
                v[i+1] = v[i] + 1;
            else
                v[i+1] = 1;
        }
        // for(auto i : v)
        //     cout<<i<<"" "";
        for(int i = k*2-1; i < nums.size(); ++i){
            if(v[i+1] >= k && v[i+1-k] >= k)
                return true;
        }

        return false;
    }
};",1448191481
a7174812,a7174812,274,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        vector<int> v(nums.size()+1);
        v[1] = 1;
        for(int i = 1; i < nums.size(); ++i){
            if(nums[i] > nums[i-1])
                v[i+1] = v[i] + 1;
            else
                v[i+1] = 1;
        }
        int lo = 0;
        int hi = nums.size() / 2 + 1;
        while(lo < hi){
            int mid = lo + (hi - lo) / 2;
            if(check(v, mid))
                lo = mid + 1;
            else
                hi = mid;
        }
        return lo - 1;
    }
    bool check(vector<int>& v, int k){
        for(int i = k*2; i < v.size(); ++i){
            if(v[i] >= k && v[i-k] >= k)
                return true;
        }

        return false;
    }
};",1448197742
a7174812,a7174812,274,3631,cpp,"class Solution {
public:
    vector<vector<int>> C;
    int ans = 0;
    const int mod = 1e9 + 7;
    vector<int> times;
    int k;
    int countKReducibleNumbers(string s, int _k) {
        k = _k;
        times.resize(801);
        times[1] = 1;
        for(int i = 2; i <= 800; ++i){
            int x = __builtin_popcount(i);
            // cout<<x<<endl;
            times[i] = times[x] + 1;
        }
        C = getCombArray(s.size());
        perm(s,0,0);
        return ((ans - 1) + mod) % mod;
    }

    void perm(string& s, int idx, int cnt){
        if(idx == s.size())
            return;
        if(s[idx] == '1'){
            int m = s.size() - idx - 1;
            for(int n = 0; n <= m; ++n){
                if(times[n+cnt] <= k)
                    ans = (ans + C[m][n]) % mod;
            }
                
            perm(s, idx+1, cnt+1);    
        }else{
            perm(s, idx+1, cnt);    
        }
        
    }

    vector<vector<int>> getCombArray(int n){
        const int mod = 1e9 + 7;
        vector<vector<int>> C(n+1, vector<int>(n+1));
        C[0][0] = 1;
        for(int i = 1; i <= n; ++i){
            C[i][0] = 1;
            for(int j = 1; j <= i; ++j){
                C[i][j] = (C[i-1][j] + C[i-1][j-1]) % mod;
            }
        }
        
        return C;
    }
};",1448263644
a7174812,a7174812,274,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        const int mod = 1e9 + 7;
        unordered_map<int, long long> cnt, sum;
        long long ans = 0;
        for(auto i : nums){
            long long t = 1;
            if(cnt.count(i+1)){
                t = (cnt[i+1] + t) % mod;
                sum[i] = (sum[i] + cnt[i+1] * i + sum[i+1]) % mod;
                ans = (ans + sum[i+1] + cnt[i+1] * i) % mod;
            }
            if(cnt.count(i-1)){
                t = (cnt[i-1] + t) % mod;
                sum[i] = (sum[i] + cnt[i-1] * i + sum[i-1]) % mod;
                ans = (ans + sum[i-1] + cnt[i-1] * i) % mod;
            }
            cnt[i] = (cnt[i] + t) % mod;
            sum[i] = (sum[i] + i) % mod;
            ans = (ans + i) % mod;
        }
        

        return ans;
    }
};",1448225844
czjnbb,czjnbb,275,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        
        leng = len(nums)
        
        for i in range(k-1, leng - k):
            f = True
            for j in range(i-k+2, i+1):
                if nums[j] <= nums[j-1]:
                    f = False
                    break
                    
            f2 = True
            for j in range(i+2, i+k+1):
                if nums[j] <= nums[j-1]:
                    f2 = False
                    break
                    
            if f and f2:
                return True
            
        return False
            ",1448185828
czjnbb,czjnbb,275,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        
        leng = len(nums)
        res = 1
        
        dp = [1]
        
        for i in range(1, leng):
            cur = nums[i]
            if cur > nums[i-1]:
                dp.append(dp[-1] + 1)
            else:
                dp.append(1)
        
        for i,d in enumerate(dp):
            res = max(res, d // 2)
            if (i - d) >= 0 and dp[i-d] >= d:
                res = max(res, d)
                
        return res
        
            ",1448194242
czjnbb,czjnbb,275,3631,python3,"mem = {}
mem[1] = 0
        
for i in range(2, 801):
    step = 1
    cur = bin(i).count('1')
    while cur > 1:
        step += 1
        cur = bin(cur).count('1')
    mem[i] = step
    
    
### pre-calc combination number
### comb2[i][j] is eq to comb(i, j)

comb2 = [[1]]
mod = 10**9 + 7

for i in range(1, 800 + 1):
    comb2.append([1])
    for j in range(i - 1):
        comb2[-1].append((comb2[-2][j] + comb2[-2][j+1]) % mod)
    comb2[-1].append(1)



class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        
        lens = len(s)
        tot1 = 1
        cl = lens - 1
        res = 0
        
        
        for i in range(1, lens):
            cnt = comb2[cl][i]
            step = mem[i] + 1
            if step <= k:
                res = (res + cnt) % mod
                
                
        for i in range(1, lens):
            if s[i] == '0':
                continue
            
            
            cl = lens - i - 1
            for j in range(cl + 1):
                cnt = comb2[cl][j]
                step = mem[j + tot1] + 1
                if step <= k:
                    res = (res + cnt) % mod
            tot1 += 1
            
        return res
            
            
        
        
        
        
        
        
            
        ",1448270862
czjnbb,czjnbb,275,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        
        mod = 10**9 + 7
        run = 1
        accu = nums[0]
        leng = len(nums)
        
        dp = defaultdict(int)
        cnt = defaultdict(int)
        
        dp[nums[0]] = nums[0]
        cnt[nums[0]] = 1
                
        for i in range(1, leng):
            cur = nums[i]
            tot = 1
            sums = 0
            if cur - 1 in cnt:
                tot += cnt[cur - 1]
                sums += dp[cur - 1]
            if cur + 1 in cnt:
                tot += cnt[cur + 1]
                sums += dp[cur + 1]
            
            ans = (sums + tot * cur) % mod
            dp[cur] += ans
            dp[cur] %= mod
            
            cnt[cur] += tot
            cnt[cur] %= mod
            

                
        return sum(dp.values()) % mod
            
            ",1448235016
kzyKT,kzyKT,277,3612,cpp,"#define F first
#define S second
#define R cin>>
#define ll long long
#define ln cout<<'\n'
#define in(a) insert(a)
#define pb(a) push_back(a)
#define pd(a) printf(""%.10f\n"",a)
#define mem(a) memset(a,0,sizeof(a))
#define all(c) (c).begin(),(c).end()
#define iter(c) __typeof((c).begin())
#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)
#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)
#define rep(i,n) REP(i,0,n)
#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)
ll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}
template<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?"" "":"""");pr(b...);}
template<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}
const ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={0,-1,0,1,-1,-1,1,1},dy[8]={-1,0,1,0,-1,1,1,-1};
typedef pair<ll,ll> P;

class Solution {
public:
  bool hasIncreasingSubarrays(vector<int>& a, int k) {
    REP(j,k,a.size()-k+1) {
      ll f=1;
      REP(i,1,k) {
        if(a[j+i-1]>=a[j+i]) f=0;
        if(a[j+i-k-1]>=a[j+i-k]) f=0;
      }
      if(f) return 1;
    }
    return 0;
  }
};",1448186199
kzyKT,kzyKT,277,3619,cpp,"#define F first
#define S second
#define R cin>>
#define ll long long
#define ln cout<<'\n'
#define in(a) insert(a)
#define pb(a) push_back(a)
#define pd(a) printf(""%.10f\n"",a)
#define mem(a) memset(a,0,sizeof(a))
#define all(c) (c).begin(),(c).end()
#define iter(c) __typeof((c).begin())
#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)
#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)
#define rep(i,n) REP(i,0,n)
#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)
ll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}
template<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?"" "":"""");pr(b...);}
template<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}
const ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={0,-1,0,1,-1,-1,1,1},dy[8]={-1,0,1,0,-1,1,1,-1};
typedef pair<ll,ll> P;

class Solution {
public:
  int maxIncreasingSubarrays(vector<int>& a) {
    ll n=a.size();
    ll d[n];
    mem(d);
    rep(i,n-1) d[i+1]=d[i]+(a[i]<a[i+1]);
    ll ans=0;
    REP(j,1,n) {
      ll l=0,r=n;
      while(l+1<r) {
        ll m=(l+r)/2;
        ll x1=j-m,y1=j-1;
        ll x2=j,y2=j+m-1;
        if(x1<0||y2>=n) {
          r=m;
          continue;
        }
        ll d1=d[y1]-d[x1],d2=d[y2]-d[x2];
        if(d1==m-1&&d2==m-1) l=m;
        else r=m;
      }
      ans=max(ans,l);
    }
    return ans;
  }
};",1448201883
kzyKT,kzyKT,277,3631,cpp,"#define F first
#define S second
#define R cin>>
#define ll long long
#define ln cout<<'\n'
#define in(a) insert(a)
#define pb(a) push_back(a)
#define pd(a) printf(""%.10f\n"",a)
#define mem(a) memset(a,0,sizeof(a))
#define all(c) (c).begin(),(c).end()
#define iter(c) __typeof((c).begin())
#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)
#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)
#define rep(i,n) REP(i,0,n)
#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)
ll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}
template<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?"" "":"""");pr(b...);}
template<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}
const ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={0,-1,0,1,-1,-1,1,1},dy[8]={-1,0,1,0,-1,1,1,-1};
typedef pair<ll,ll> P;

void extended_euclid(ll x,ll y,ll *c,ll *a,ll *b){
  ll a0,a1,a2,b0,b1,b2,r0,r1,r2,q;r0=x;r1=y;a0=1;a1=0;b0=0;b1=1;
  while(r1>0){q=r0/r1;r2=r0%r1;a2=a0-q*a1;b2=b0-q*b1;r0=r1;r1=r2;a0=a1;a1=a2;b0=b1;b1=b2;}
  *c=r0;*a=a0;*b=b0;
}

ll get_inv(ll n, ll p){
  ll a,b,c;
  extended_euclid(n,p,&c,&a,&b);
  if(a<p) a+=p;
  return a%p;
}

ll fact[2100],fact_inv[2100];

void init() {
  fact[0]=1;
  REP(i,1,2100) fact[i]=fact[i-1]*i%MAX;
  fact_inv[2050]=get_inv(fact[2050],MAX);
  rrep(i,2050)fact_inv[i]=fact_inv[i+1]*(i+1)%MAX;
}

ll nCr(ll N,ll K){
  if(K<0||K>N)return 0;
  return fact[N]*fact_inv[K]%MAX*fact_inv[N-K]%MAX;
}

class Solution {
public:
  int countKReducibleNumbers(string s, int k) {
    init();
    ll n=s.size();
    ll d[888];mem(d);
    d[0]=MAX;
    REP(i,1,888) {
      ll x=i;
      if(x>1) d[i]++;
      while(x>1) {
        x=__builtin_popcount(x);
        d[i]++;
        if(d[i]>k) break;
      }
    }
    ll ans=0,c=0;
    rep(i,n) {
      if(s[i]=='1') {
        ll m=n-i-1;
        rep(j,m+1) {
          if(d[j+c]<=k) {
            ans+=nCr(m,j);
            ans%=MAX;
          }
        }
        c++;
      }
    }
    return ans;
  }
};",1448256889
kzyKT,kzyKT,277,3646,cpp,"#define F first
#define S second
#define R cin>>
#define ll long long
#define ln cout<<'\n'
#define in(a) insert(a)
#define pb(a) push_back(a)
#define pd(a) printf(""%.10f\n"",a)
#define mem(a) memset(a,0,sizeof(a))
#define all(c) (c).begin(),(c).end()
#define iter(c) __typeof((c).begin())
#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)
#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)
#define rep(i,n) REP(i,0,n)
#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)
ll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}
template<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?"" "":"""");pr(b...);}
template<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}
const ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={0,-1,0,1,-1,-1,1,1},dy[8]={-1,0,1,0,-1,1,1,-1};
typedef pair<ll,ll> P;

class Solution {
public:
  int sumOfGoodSubsequences(vector<int>& a) {
    ll n=a.size();
    map<ll,ll> dp[2];
    ll d1[n],d2[n];
    mem(d1),mem(d2);
    rep(i,n) {
      dp[1][a[i]]++;
      d1[i]++;
      if(dp[0].count(a[i]-1)) {
        dp[1][a[i]]+=dp[0][a[i]-1];
        d1[i]+=dp[0][a[i]-1];
      }
      if(dp[0].count(a[i]+1)) {
        dp[1][a[i]]+=dp[0][a[i]+1];
        d1[i]+=dp[0][a[i]+1];
      }
      dp[1][a[i]]%=MAX;
      d1[i]%=MAX;
      tr(it,dp[1]) dp[0][it->F]+=it->S;
      dp[1].clear();
    }
    dp[0].clear();
    rrep(i,n) {
      dp[1][a[i]]++;
      d2[i]++;
      if(dp[0].count(a[i]-1)) {
        dp[1][a[i]]+=dp[0][a[i]-1];
        d2[i]+=dp[0][a[i]-1];
      }
      if(dp[0].count(a[i]+1)) {
        dp[1][a[i]]+=dp[0][a[i]+1];
        d2[i]+=dp[0][a[i]+1];
      }
      dp[1][a[i]]%=MAX;
      d2[i]%=MAX;
      tr(it,dp[1]) dp[0][it->F]+=it->S;
      dp[1].clear();
    }
    ll ans=0;
    rep(i,n) {
      ans+=a[i]*d1[i]%MAX*d2[i];
      ans%=MAX;
    }
    return ans;
  }
};
",1448221346
LGM70,LGM70,278,3612,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        max_inc_len = [0] * len(nums)
        l = 1
        for i, num in enumerate(nums[1:]):
            if num > nums[i]:
                l += 1
            else:
                max_inc_len[i] = l
                l = 1
        max_inc_len[-1] = l
        rslt = 0
        i = len(nums) - 1
        while i >= 0:
            rslt = max(rslt, max_inc_len[i] // 2)
            pre_i = i - max_inc_len[i]
            if pre_i >= 0:
                rslt = max(rslt, min(max_inc_len[i], max_inc_len[pre_i]))
            i = pre_i
        return rslt

    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        return self.maxIncreasingSubarrays(nums) >= k",1448193928
LGM70,LGM70,278,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        max_inc_len = [0] * len(nums)
        l = 1
        for i, num in enumerate(nums[1:]):
            if num > nums[i]:
                l += 1
            else:
                max_inc_len[i] = l
                l = 1
        max_inc_len[-1] = l
        rslt = 0
        i = len(nums) - 1
        while i >= 0:
            rslt = max(rslt, max_inc_len[i] // 2)
            pre_i = i - max_inc_len[i]
            if pre_i >= 0:
                rslt = max(rslt, min(max_inc_len[i], max_inc_len[pre_i]))
            i = pre_i
        return rslt",1448191473
LGM70,LGM70,278,3631,python3,"class Solution:
    def __init__(self):
        self.M = int(1e9) + 7
        self.N = 800
        self.fac = [1] * (self.N + 1)
        self.inv_fac = [1] * (self.N + 1)
        for i in range(1, len(self.fac)):
            self.fac[i] = (self.fac[i - 1] * i) % self.M
        self.inv_fac[-1] = pow(self.fac[-1], -1, self.M)
        for i in range(len(self.inv_fac) - 2, -1, -1):
            self.inv_fac[i] = (self.inv_fac[i + 1] * (i + 1)) % self.M

    def countKReducibleNumbers(self, s: str, k: int) -> int:
        def is_k_reducible(x: int, k: int) -> bool:
            if x == 1:
                return True
            for _ in range(k):
                x = x.bit_count()
                if x == 1:
                    return True
            return False

        def comb(n: int, k: int) -> int:
            return (self.fac[n] * self.inv_fac[k] % self.M) * self.inv_fac[n - k] % self.M

        def calc(l: int, cnt: int, k: int) -> int:
            rslt = 0
            for ones in range(0, l + 1):
                if is_k_reducible(ones + cnt, k - 1):
                    rslt = (rslt + comb(l, ones)) % self.M
            return rslt

        rslt = 0
        cnt = 0
        for i, c in enumerate(s):
            if c == '1':
                rslt = (rslt + calc(len(s) - i - 1, cnt, k)) % self.M
                cnt += 1
        return rslt
",1448278361
LGM70,LGM70,278,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        M = int(1e9) + 7
        dp = {}
        for num in nums:
            if num in dp:
                dp[num][0] = (dp[num][0] + 1) % M
                dp[num][1] = (dp[num][1] + num) % M
            else:
                dp[num] = [1, num]
            if num - 1 in dp:
                dp[num][0] = (dp[num][0] + dp[num - 1][0]) % M
                dp[num][1] = (dp[num][1] + dp[num - 1][1] + num * dp[num - 1][0]) % M
            if num + 1 in dp:
                dp[num][0] = (dp[num][0] + dp[num + 1][0]) % M
                dp[num][1] = (dp[num][1] + dp[num + 1][1] + num * dp[num + 1][0]) % M
        rslt = 0
        for _, v in dp.items():
            rslt = (rslt + v[1]) % M
        return rslt",1448206916
canisolve4,canisolve4,279,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        a = 0
        b = 0
        p = -inf
        for n in nums:
            if n > p:
                b += 1
            else:
                a = b
                b = 1
            p = n
            if a >= k and b >= k or b >= 2 * k:
                return True
        return False",1448183497
canisolve4,canisolve4,279,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        m = 0
        a = 0
        b = 0
        p = -inf
        for n in nums:
            if n > p:
                b += 1
            else:
                a = b
                b = 1
            p = n
            m = max(m, min(a, b), b // 2)
        return m",1448185572
canisolve4,canisolve4,279,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        m = 10**9 + 7
        n = len(s)
        l = []
        for i in range(n + 1):
            a = i
            for _ in range(k - 1):
                a = a.bit_count()
            if a == 1:
                l.append(i)

        f = [1]
        for i in range(1, n + 1):
            f.append(f[-1] * i % m)

        r = 0
        c = 0
        for i, d in enumerate(s):
            d = int(d)
            if d == 1:
                for j in l:
                    x = j - c
                    y = n - 1 - i
                    if 0 <= x <= y:
                        r = (r + f[y] * pow(f[x], -1, m) * pow(f[y-x], -1, m)) % m
            c += d

        return r",1448285352
canisolve4,canisolve4,279,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        c = [0] * (10**5+2)
        s = [0] * (10**5+2)
        m = 10**9+7
        for n in nums:
            d = (1 + c[n-1] + c[n+1]) % m
            c[n] = (c[n] + d) % m
            s[n] = (s[n] + n * d + s[n-1] + s[n+1]) % m
        return sum(s) % m",1448222721
Varun Deep Saini,sojabhai,280,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        
        for(int i = 0; i <= n - 2 * k; i++) {
            bool one = 1;
            for(int j = i; j < i + k - 1; j++) {
                if(nums[j] >= nums[j + 1]) {
                    one = 0;
                    break;
                }
            }

            if(one) {
                int b = i + k; 
                bool two = 1;
                for(int j = b; j < b + k - 1; j++) {
                    if(nums[j] >= nums[j + 1]) {
                        two = 0;
                        break;
                    }
                }

                if(two) {
                    return 1;
                }
            }
        }

        return 0;
    }
};",1448239468
Varun Deep Saini,sojabhai,280,3619,cpp,"class Solution {
public:


    bool ok(int k, vector<int>& a, int n){
        for(int i = 0; i <= n - 2*k; i++){
            if(a[i] >= k && a[i +k] >= k){
                return 1;
            }
        }
        return 0;
    }

    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        if (n < 2) return 0; 
        vector<int> prefixSum(n, 1);
        for(int i = n - 2; i >=0; --i){
            if(nums[i] < nums[i+1]){
                prefixSum[i] = prefixSum[i+1] + 1;
            }else{
                prefixSum[i] = 1;
            }
        }

        int l = 1;
        int r = n / 2;
        int ans = 0;

        while(l <= r){
            int mid = l + (r - l) / 2;
            if(ok(mid, prefixSum, n)){
                ans = mid; 
                l = mid +1; 
            }
            else{
                r = mid -1;
            }
        }

        return ans;
    }

};",1448244555
Varun Deep Saini,sojabhai,280,3631,cpp,"class Solution {
public:
    const int MOD = 1e9 + 7;
    string s;
    int k;
    int dp[801][2][801][2]; 

    int f(int ones_count) {
        if (ones_count == 0) return 1000;
        if (ones_count == 1) return 0;
        int cnt = 1 + f(__builtin_popcountl(ones_count));
        return cnt;
    }
    string ss;

    int rec(int pos, int tight, int ones_count, int started) {
        if (pos == s.size()) {
            if (!started) return 0;
            if (tight == 1) return 0;
            int steps = f(ones_count);
            if (steps >= k) return 0;
            // cout << ss << endl;
            return 1;
        }
        if (dp[pos][tight][ones_count][started] != -1)
            return dp[pos][tight][ones_count][started];
        int res = 0;

        int limit = tight ? s[pos] - '0' : 1;

        if(0 <= limit)res = (res + rec(pos + 1, tight && (0 == limit), ones_count, started)) % MOD;
        if(1 <= limit)res = (res + rec(pos + 1, tight && (1 == limit), ones_count + 1, 1)) % MOD;
        
        return dp[pos][tight][ones_count][started] = res;
    }

    int countKReducibleNumbers(string s, int k) {
        this->s = s;
        this->k = k;
        memset(dp, -1, sizeof(dp));
        int ans = rec(0, 1, 0, 0);
        return ans;
    }
};
",1448285590
Varun Deep Saini,sojabhai,280,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        #define int long long
        const int mod = 1e9 + 7;
        map<int, int> dp; 
        map<int, int> sum;   

        for (auto &i : nums) {
            int cnt = 1; 
            int s = i; 
            for (int dx = -1; dx <= 1; dx += 2) {
                int neighbor = i + dx;
                if (dp.count(neighbor)) {
                    cnt = (cnt + dp[neighbor]) % mod;
                    s = (s + sum[neighbor] + dp[neighbor] * i % mod) % mod;
                }
            }

            dp[i] = (dp[i] + cnt) % mod;
            sum[i] = (sum[i] + s) % mod;
        }

        int ans = 0;
        for (auto& i : sum) {
            ans += i.second;
            ans %= mod;
        }
        #undef int 
        return (int)ans;
    }
};
",1448257745
naresh50,naresh50,281,3612,java,"class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        int n = nums.size();
        int[] arrStart = new int[n];
        int[] arrEnd = new int[n];

        for (int i = 0; i < n; i++) {
            if (arrStart[i] == 0) helper(arrStart, nums, i);
        }
        for (int i = n - 1; i >= 0; i--) {
            if (arrEnd[i] == 0) helper2(arrEnd, nums, i);
        }

        int ans = 0;
        for (int i = 0; i < n - 1; i++) {
            int tempAns = Math.min(arrEnd[i], arrStart[i + 1]);
            ans = Math.max(ans, tempAns);
        }

        if(ans>=k) return true;
        else return false;
    }
    public int helper(int[] arr, List<Integer> nums, int index) {
        if (index == nums.size() - 1 || nums.get(index) >= nums.get(index + 1)) {
            return arr[index] = 1;
        }
        return arr[index] = helper(arr, nums, index + 1) + 1;
    }

    public int helper2(int[] arr, List<Integer> nums, int index) {
        if (index == 0 || nums.get(index) <= nums.get(index - 1)) {
            return arr[index] = 1;
        }
        return arr[index] = helper2(arr, nums, index - 1) + 1;
    }
}",1448202340
naresh50,naresh50,281,3619,java,"import java.util.List;

class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        int n = nums.size();
        int[] arrStart = new int[n];
        int[] arrEnd = new int[n];

        for (int i = 0; i < n; i++) {
            if (arrStart[i] == 0) helper(arrStart, nums, i);
        }
        for (int i = n - 1; i >= 0; i--) {
            if (arrEnd[i] == 0) helper2(arrEnd, nums, i);
        }

        int ans = 0;
        for (int i = 0; i < n - 1; i++) {
            int tempAns = Math.min(arrEnd[i], arrStart[i + 1]);
            ans = Math.max(ans, tempAns);
        }
        return ans;
    }

    public int helper(int[] arr, List<Integer> nums, int index) {
        if (index == nums.size() - 1 || nums.get(index) >= nums.get(index + 1)) {
            return arr[index] = 1;
        }
        return arr[index] = helper(arr, nums, index + 1) + 1;
    }

    public int helper2(int[] arr, List<Integer> nums, int index) {
        if (index == 0 || nums.get(index) <= nums.get(index - 1)) {
            return arr[index] = 1;
        }
        return arr[index] = helper2(arr, nums, index - 1) + 1;
    }
}
",1448199668
naresh50,naresh50,281,3631,java,"class Solution {
    int MOD = (int)1e9+7;
    int k;
    String binaryString;
    int[] reductionSteps; 
    Integer[][][][] dp;

    public int countKReducibleNumbers(String s, int k) {
        binaryString = s;
        this.k = k;
        compute();
        int length = s.length();
        dp = new Integer[length + 1][length + 1][2][2];
        
        return findCount(0, 0, 1, 0);
    }

    void compute() {
        reductionSteps = new int[801]; 
        Arrays.fill(reductionSteps, -1);
        reductionSteps[1] = 0;
        for (int count = 2; count <= 800; count++) {
            int steps = 0;
            int temp = count;
            while (temp != 1) {
                temp = Integer.bitCount(temp);
                steps++;
            }
            reductionSteps[count] = steps;
        }
    }

   
    int findCount(int index, int onesCount, int tight, int hasStarted) {
        if (index == binaryString.length()) {
            if (hasStarted == 1) {
                if (tight == 1) {
                    return 0; 
                }
                int totalSteps = onesCount == 1 ? 0 : reductionSteps[onesCount] + 1;
                return totalSteps <= k ? 1 : 0;
            }
            return 0;
        }
        if (dp[index][onesCount][tight][hasStarted] != null) {
            return dp[index][onesCount][tight][hasStarted];
        }
        int maxDigit = tight == 1 ? binaryString.charAt(index) - '0' : 1;
        int count = 0;
        for (int digit = 0; digit <= maxDigit; digit++) {
            int newHasStarted = hasStarted;
            if (hasStarted == 0 && digit != 0) {
                newHasStarted = 1;
            }
            int newOnesCount = onesCount;
            if (newHasStarted == 1 && digit == 1) {
                newOnesCount += 1;
            }
            int newtight = tight;
            if (tight == 1 && digit < maxDigit) {
                newtight = 0;
            }
            count = (count + findCount(index + 1, newOnesCount, newtight, newHasStarted)) % MOD;
        }
        dp[index][onesCount][tight][hasStarted] = count;
        return count;
    }
}
",1448285659
naresh50,naresh50,281,3646,java,"class Solution {
    public int sumOfGoodSubsequences(int[] nums) { 
        int MOD = 1000000007;
        HashMap<Integer, Integer> cntMap = new HashMap<>();
        HashMap<Integer, Integer> smMap = new HashMap<>();
        
        for (int num : nums) {
            int cnt = 1; 
            int sm = num;
            
            for (int x = num - 1; x <= num + 1; x += 2) {
                if (cntMap.containsKey(x)) {
                    int prevCnt = cntMap.get(x);
                    int prevSm = smMap.get(x);
                    cnt = (cnt + prevCnt) % MOD;
                    sm = (int)(((long)sm + prevSm + (long)num * prevCnt) % MOD);
                }
            }
            cntMap.put(num, (cntMap.getOrDefault(num, 0) + cnt) % MOD);
            smMap.put(num, (smMap.getOrDefault(num, 0) + sm) % MOD);
        }
        
        int result = 0;
        for (int val : smMap.values()) {
            result = (result + val) % MOD;
        }
        return result;
    }
}",1448241217
Andrew H. Pometta,apometta,282,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        for i in range(n):
            if i + 2 * k > n: break

            success = True
            for j in range(i + 1, i + k):
                if nums[j] <= nums[j - 1]:
                    success = False
                    break
            if not success: continue

            for j in range(i + k + 1, i + (k * 2)):
                if nums[j] <= nums[j - 1]:
                    success = False
                    break

            if success: return True

        return False",1448184100
Andrew H. Pometta,apometta,282,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        streaks = []
        n = len(nums)

        curr = 1
        for i in range(1, n):
            if nums[i] > nums[i - 1]:
                curr += 1
            else:
                streaks.append(curr)
                curr = 1
        streaks.append(curr)

        best = streaks[0] // 2
        for i in range(1, len(streaks)):
            best = max(best, max(streaks[i] // 2, min(streaks[i - 1], streaks[i])))
        return best",1448193722
Andrew H. Pometta,apometta,282,3631,python3,"set_reductions = [-1] * 801
set_reductions[1] = 0
for i in range(2, len(set_reductions)):
    n = i
    bits = 0
    while n > 0:
        bits += (n & 1)
        n >>= 1
    set_reductions[i] = set_reductions[bits] + 1

class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        #constraints show that s[0] MUST be 1
        #otherwise we would prune until it is
        while len(s) > 0 and s[0] == '0':
            s = s[1:]
        if len(s) <= 1: return 0
        zeros, ones = s.count('0'), s.count('1')
            
        global set_reductions
        answer = 0
        LEN = len(s)
        BASE = 1_000_000_007

        for set_bits in range(1, LEN):
            if set_reductions[set_bits] + 1 > k: continue #irrelevant
            
            remaining = set_bits
            i = 0

            while i < LEN:
                if s[i] == '0':
                    i += 1
                    continue

                if remaining == 0:
                    answer += 1
                    answer %= BASE
                    break
                
                answer += comb(LEN - (i + 1), remaining)
                answer %= BASE
                remaining -= 1
                i += 1
        return answer",1448285662
Andrew H. Pometta,apometta,282,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        BASE = 1_000_000_007
        goods = 0
        cache = {}

        for i in range(len(nums) - 1, -1, -1):
            n = nums[i]
            if n not in cache:
                cache[n] = [0, 0]

            for j in (n + 1, n - 1):
                if j not in cache: continue
                
                count, total = cache[j]
                inc = count * n
                goods += total + inc
                cache[n][0] += count
                cache[n][1] += total + inc

                cache[n][0] %= BASE
                cache[n][1] %= BASE
                goods %= BASE

            cache[n][0] += 1
            cache[n][1] += n
            goods += n
            cache[n][0] %= BASE
            cache[n][1] %= BASE
            goods %= BASE

        return goods",1448210529
Sahil Kumar,user2672IT,285,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n=nums.size();
        vector<int> pref(n),suff(n);
        pref[0]=1;
        for(int i=1;i<n;i++){
            if(nums[i]>nums[i-1]){
                pref[i]=pref[i-1]+1;
            }else{
                pref[i]=1;
            }
            // cout<<pref[i]<<"" "";
        }
        
        
        suff[n-1]=1;
        for(int i=n-2;i>=0;i--){
            if(nums[i]<nums[i+1]){
                suff[i]=suff[i+1]+1;
            } else{
                suff[i]=1;
            }
            // cout<<suff[i]<<"" "";
        }
        int ans=1;
        for(int i=0;i<n-1;i++){
            ans=max(ans,min(pref[i],suff[i+1]));
        }
        return ans>=k;
    }
};",1448192686
Sahil Kumar,user2672IT,285,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n=nums.size();
        vector<int> pref(n),suff(n);
        pref[0]=1;
        for(int i=1;i<n;i++){
            if(nums[i]>nums[i-1]){
                pref[i]=pref[i-1]+1;
            }else{
                pref[i]=1;
            }
            // cout<<pref[i]<<"" "";
        }
        
        
        suff[n-1]=1;
        for(int i=n-2;i>=0;i--){
            if(nums[i]<nums[i+1]){
                suff[i]=suff[i+1]+1;
            } else{
                suff[i]=1;
            }
            // cout<<suff[i]<<"" "";
        }
        int ans=1;
        for(int i=0;i<n-1;i++){
            ans=max(ans,min(pref[i],suff[i+1]));
        }
        return ans;
    }
};",1448190347
Sahil Kumar,user2672IT,285,3631,cpp,"long long mod=1e9+7;

class Solution {
public:
    int oper;
    vector<int> res;
    vector<vector<vector<int>>> dp;
    int rec(int idx,string &s,int state,int sum){
        
        if(idx==s.size()){
            return res[sum]<=oper-1;
        }
        if(dp[state][idx][sum]!=-1)return dp[state][idx][sum];
        long long ans=0;
         if(state){
             if(s[idx]=='0'){
                 ans+=rec(idx+1,s,state,sum);
                 
             }else{
                 ans+=rec(idx+1,s,state,sum+1);
                 ans+=rec(idx+1,s,0,sum);
             }
         } else{
             
             ans+=rec(idx+1,s,0,sum);
             ans+=rec(idx+1,s,0,sum+1);
         }
        
        ans%=mod;
        return dp[state][idx][sum]=ans;
    }
    int countKReducibleNumbers(string s, int k) {
        
         int n=s.size();
         res=vector<int>(n+1);
         res[0]=k+1;
         int sum=0;
         for(int i=0;i<n;i++){
             sum+=(s[i]-'0');
         }
         for(int i=n;i>=1;i--){
             
             int temp=i;
             int cur=0;
             while(temp>1){
                 temp=__builtin_popcount(temp);
                 cur+=1;
             }
             res[i]=cur;
         }
        
        oper=k;
        dp=vector<vector<vector<int>>> (2,vector<vector<int>>(n,vector<int>(n+1,-1)));
        
        int ans=rec(0,s,1,0);
        if(res[sum]<=oper-1)
          ans-=1;
        ans+=mod;
        ans%=mod;
        
        return ans;
    }
};",1448286206
Sahil Kumar,user2672IT,285,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        long long mod=1e9+7;
        
        map<int,long long> dpnumber;
        map<int,long long> dpsum;
        int n=nums.size();
        int ans=0;
        for(int i=0;i<n;i++){
            dpnumber[nums[i]]+=dpnumber[nums[i]-1]+dpnumber[nums[i]+1]+1;
            dpnumber[nums[i]]%=mod;
            long long curr_sum=(dpnumber[nums[i]-1]+dpnumber[nums[i]+1]+1)*nums[i]+dpsum[nums[i]-1]+dpsum[nums[i]+1];
            curr_sum%=mod;
            dpsum[nums[i]]+=curr_sum;
            dpsum[nums[i]]%=mod;
            // cout<<dpsum[nums[i]]<<"" "";
            ans+=curr_sum;
            
            ans%=mod;
        }
        
        return ans;
    }
};",1448240819
zokumyoin,zokumyoin,286,3612,java,"class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        return maxIncreasingSubarrays(nums) >= k;
    }
    
    private int maxIncreasingSubarrays(List<Integer> nums) {

        int[] max = new int[nums.size()];
        for (int i = 0; i < nums.size(); i++) {
            if (i == 0) {
                max[i] = 1;
            } else if (nums.get(i) > nums.get(i - 1)) {
                max[i] = max[i - 1] + 1;
            } else {
                max[i] = 1;
            }
        }
        int lo = 1, hi = nums.size();
        while (lo < hi) {
            int mid = lo + (hi - lo + 1) / 2;
            boolean exists = false;
            for (int i = 0; i + mid < nums.size(); i++) {
                if (max[i] >= mid && max[i + mid] >= mid) {
                    exists = true;
                    break;
                }
            }
            if (exists) {
                lo = mid;
            } else {
                hi = mid - 1;
            }
        }
        return hi;

    }
}",1448190339
zokumyoin,zokumyoin,286,3619,java,"import java.util.Arrays;
import java.util.List;

class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {

        int[] max = new int[nums.size()];
        for (int i = 0; i < nums.size(); i++) {
            if (i == 0) {
                max[i] = 1;
            } else if (nums.get(i) > nums.get(i - 1)) {
                max[i] = max[i - 1] + 1;
            } else {
                max[i] = 1;
            }
        }
        int lo = 1, hi = nums.size();
        while (lo < hi) {
            int mid = lo + (hi - lo + 1) / 2;
            boolean exists = false;
            for (int i = 0; i + mid < nums.size(); i++) {
                if (max[i] >= mid && max[i + mid] >= mid) {
                    exists = true;
                    break;
                }
            }
            if (exists) {
                lo = mid;
            } else {
                hi = mid - 1;
            }
        }
        return hi;

    }
}",1448189450
zokumyoin,zokumyoin,286,3631,java,"import java.util.HashSet;

class Solution {
    public int countKReducibleNumbers(String s, int k) {

        // 1-reducible: has 1 one (1, 2, 4, 8 ..)
        // 2-reducible: has 1, 2, 4, 8 .. bits set

        // reduce s once -> a value <= 800

        int MOD = 1_000_000_007;

        int len = s.length();
        boolean[] canUseAsBitCount = new boolean[len + 1];

        for (int i = 1; i <= len; i++) {
            int times = 0;
            int v = i;
            while (v > 1) {
                times++;
                v = Integer.bitCount(v);
            }
            if (times <= k - 1) {
                canUseAsBitCount[i] = true;
            }
        }
        int[] prefOnes = new int[s.length()];
        for (int i = 0; i < s.length(); i++) {
            prefOnes[i] = s.charAt(i) - '0' + (i == 0 ? 0 : prefOnes[i - 1]);
        }

        int[][] dp = new int[s.length()][s.length()];

        dp[0][0] = 1;


        if (s.length() > 1) {
            dp[0][1] = 1;
        }

        for (int i = 1; i < s.length(); i++) {
            int bit = s.charAt(i) - '0';

            for (int j = 0; j < s.length(); j++) {
                int cnt = 0;

                // append 0
                cnt += dp[i - 1][j];

                // append 1
                if (j - 1 >= 0) {
                    cnt += dp[i - 1][j - 1];
                    cnt %= MOD;

                    // e.g.
                    // s =    101110...
                    // we get 101111
                    if (bit == 0 && prefOnes[i] == j - 1 && dp[i - 1][j - 1] > 0) {
                        cnt--;
                        cnt += MOD;
                        cnt %= MOD;
                    }
                }
                dp[i][j] = cnt;
//                System.out.printf(""dp[%d][%d]=%d\n"", i, j, cnt);
            }
        }

        int bitCount = 0;
        for (char c : s.toCharArray()) {
            if (c == '1') {
                bitCount++;
            }
        }
        if (bitCount < dp[0].length) {

            dp[s.length() - 1][bitCount]--;
            dp[s.length() - 1][bitCount] += MOD;
            dp[s.length() - 1][bitCount] %= MOD;
        }


        int ans = 0;
        for (int i = 1; i < s.length(); i++) {
            if (canUseAsBitCount[i]) {
//                System.out.printf(""dp[%d][%d]=%d\n"", s.length() - 1, i, dp[s.length() - 1][i]);
                ans += dp[s.length() - 1][i];
                ans %= MOD;
            }
        }
        return ans;


    }
}",1448279490
zokumyoin,zokumyoin,286,3646,java,"import java.util.Arrays;

class Solution {
    public int sumOfGoodSubsequences(int[] arr) {

        int MOD = 1_000_000_007;

        long ans = 0;

        int[] cntAtTail = new int[arr.length];
        int[] combined = new int[100001];


        for (int i = 0; i < arr.length; i++) {
            int v = arr[i];
            int cnt = 1;
            if (v - 1 >= 0) {
                cnt += combined[v - 1];
                cnt %= MOD;
            }
            if (v + 1 < combined.length) {
                cnt += combined[v + 1];
                cnt %= MOD;
            }
            cntAtTail[i] = cnt;

            combined[v] += cntAtTail[i];
            combined[v] %= MOD;
        }

        Arrays.fill(combined, 0);
        int[] cntAtHead = new int[arr.length];
        for (int i = arr.length - 1; i >= 0; i--) {
            int v = arr[i];
            int cnt = 1;
            if (v - 1 >= 0) {
                cnt += combined[v - 1];
                cnt %= MOD;
            }
            if (v + 1 < combined.length) {
                cnt += combined[v + 1];
                cnt %= MOD;
            }
            cntAtHead[i] = cnt;

            combined[v] += cntAtHead[i];
            combined[v] %= MOD;
        }

        for (int i = 0; i < arr.length; i++) {
            long totalCnt = (long) cntAtTail[i] * cntAtHead[i] % MOD;
            ans += totalCnt * arr[i] % MOD;
            ans %= MOD;
        }

        return (int) ans;


    }
}",1448223024
abhishek vaish,abhishekvaish,290,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        inc = [1] * n
        for i in range(1,n):
            if nums[i] > nums[i-1]:
                inc[i] = inc[i-1] + 1
        pre = [0] * (n+1)
        for i in range(n):
            pre[i+1] = inc[i] + pre[i]
        
        # print(""---""*n)
        # print(inc)
        req = (k * (k+1)) // 2
        for i in range(n-(2*k)+1):
            left = pre[i+k]-pre[i] - ((inc[i]-1)*k)
            right = pre[i+2*k] - pre[i+k] - ((inc[i+k]-1)*k)
            # print(i,left, right)
            if left == req and right == req:
                return True
        return False
            ",1448194070
abhishek vaish,abhishekvaish,290,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        inc = [1] * n
        for i in range(1,n):
            if nums[i] > nums[i-1]:
                inc[i] = inc[i-1] + 1
        pre = [0] * (n+1)
        for i in range(n):
            pre[i+1] = inc[i] + pre[i]
        
        # print(""---""*n)
        # print(inc)
        def possible(k):
            req = (k * (k+1)) // 2
            for i in range(n-(2*k)+1):
                left = pre[i+k]-pre[i] - ((inc[i]-1)*k)
                right = pre[i+2*k] - pre[i+k] - ((inc[i+k]-1)*k)
                # print(i,left, right)
                if left == req and right == req:
                    return True
            return False
        
        b,e = 1,(n//2) + 1
        while b < e:
            m = (b+e)//2
            if not possible(m):
                e = m
            else:
                b = m + 1
        return b-1
                
        
        ",1448198307
abhishek vaish,abhishekvaish,290,3631,python3,"from functools import cache
m = 801
inf = float('inf')
count = [inf] * m
count[1] = 0
for i in range(2,m):
    count[i] = 1 + count[i.bit_count()]

# fact = [1]*m
# ifact = [1]*m
MOD =10**9+7
# for i in range(2,m):
#     fact[i] = (i * fact[i-1]) % MOD
    
# ifact[m-1] = pow(fact[m-1],-1,MOD)
# for i in reversed(range(m-1)):
#     ifact[i] = ((i+1) * ifact[i+1] ) % MOD


class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        n = len(s)
        if n == 1: return 0
        @cache
        def DP(i,cnt,upper):
            if i == n:
                if upper: return 0
                return 0 if  count[cnt] + 1 > k else 1
            
            res = 0
            if upper:
                if s[i] == '0':
                    res = DP(i+1,cnt,True)
                else:
                    res = DP(i+1,cnt,False) + DP(i+1,cnt+1,True)
            else:
                res = DP(i+1,cnt+1,False) + DP(i+1,cnt,False)
            
            return res % MOD
        
        return DP(0,0,True)
                
        
        
        # m = 0
        # for x in s: 
        #     if x == '1':
        #         m += 1
        # print((fact[3]*ifact[1]*ifact[2])%MOD)
#         print(""---""*n)
        
#         res = 0
#         for i in range(1,m+1):
#             if count[i]+1 > k: continue
#             # nCi
#             print(i,(fact[n] * ifact[i] * ifact[n-i])%MOD)
#             res += (fact[n] * ifact[i] * ifact[n-i])%MOD
#             res %= MOD
        # return res
            
        
        
        ",1448280143
abhishek vaish,abhishekvaish,290,3646,python3,"MOD = 10**9+7
class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        # [3,4,5]
        # [19,13,5]
        n = len(nums)
        m = max(nums) + 3
        DP = [0]*m
        count = [0] * m
        # idx = [m-1] * m
        for i in reversed(range(n)):
            x = nums[i]
            
            # DP[x] = x 
            count[x] += (1 + count[x+1] + count[x-1])
            DP[x] += (x + x*count[x+1] + DP[x+1] + DP[x-1] + x*count[x-1]) % MOD
            
            DP[x] %= MOD
            count[x] %= MOD
            
#             if DP[x+1] > 0:
#                 DP[x] += x + DP[x+1]
#             if DP[x-1] > 0:
#                 DP[x] += x + DP[x-1]
                
#             DP[x] %= MOD
        
        s = 0 
        for x in DP:
            s = (s+x)%MOD
        return s",1448232992
Chou,a0920732333,292,3612,cpp,"class Solution 
{
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) 
    {
        int n = nums.size(), l = 0;
        vector<int> left(n);
        for(int r = 1; r < n; r++)
        {
            if(nums[r] > nums[r - 1])
            {
                left[r] = l;
            }
            else
            {
                left[r] = r;
                l = r;
            }
        }
        for(int i = k * 2 - 1; i < n; i++)
        {
            if(i - left[i] + 1 >= k && i - k - left[i - k] + 1 >= k)
            {
                return true;
            }
        }
        return false;
    }
};",1448185780
Chou,a0920732333,292,3619,cpp,"class Solution 
{
public:
    int maxIncreasingSubarrays(vector<int>& nums) 
    {
        int n = nums.size(), l = 0, r = 1;
        vector<int> left(n);
        for(; r < n; r++)
        {
            if(nums[r] > nums[r - 1])
            {
                left[r] = l;
            }
            else
            {
                left[r] = r;
                l = r;
            }
        }
        vector<int> right(n);
        r = n - 1;
        l = n - 2;
        right[r] = r;
        for(; l >= 0; l--)
        {
            if(nums[l] < nums[l + 1])
            {
                right[l] = r;
            }
            else
            {
                right[l] = l;
                r = l;
            }
        }
        int k = 1;
        for(int i = 0; i + 1 < n; i++)
        {
            k = max(k, min(i - left[i] + 1, right[i + 1] - (i + 1) + 1));
        }
        return k;
    }
};",1448194259
Chou,a0920732333,292,3631,cpp,"class Solution 
{
public:
    const int mod = 1e9 + 7;
    vector<long long> factorial, moduleInverse_factorial;
    long long fastPower(long long a, long long b)//a ^ b
    {
        long long ans = 1;
        while(b)
        {
            if(b & 1)
            {
                ans = (ans * a) % mod;
            }
            a = (a * a) % mod;
            b >>= 1;
        }
        return ans;
    }
    long long C(int a, int b)//a!/b!/(a-b)!, a <= 40, b <= 40
    {
        return ((factorial[a] * moduleInverse_factorial[b]) % mod * moduleInverse_factorial[a - b]) % mod;
    }
    long long moduleInverse(long long a, long long p)//a^(p - 2)
    {
        return fastPower(a, p - 2);
    }
    int reduce(int n)
    {
        int t = 1;
        while(n != 1)
        {
            n = __builtin_popcount(n);
            t++;
        }
        return t;
    }
    int countKReducibleNumbers(string s, int k) 
    {
        long long ans = 0;
        int n = s.length();
        factorial.resize(n + 1);
        moduleInverse_factorial.resize(n + 1);
        factorial[0] = factorial[1] = 1;
        moduleInverse_factorial[0] = moduleInverse_factorial[1] = 1;
        for(int i = 2; i < n + 1; i++)
        {
            factorial[i] = (factorial[i - 1] * i) % mod;
            moduleInverse_factorial[i] = moduleInverse(factorial[i], mod);
        }
        int pre = 0;
        for(int i = 0; i < n; i++)
        {
            if(s[i] == '1')
            {
                int digit = n - i - 1;
                //0 1
                if(i != 0)
                {
                    ans = (ans + (reduce(pre) <= k)) % mod;
                }
                for(int j = 1; j <= digit; j++)
                {
                    if(reduce(j + pre) <= k)
                    {
                        ans = (ans + C(digit, j)) % mod;
                        // cout << i << ' ' << j << ' ' << digit << ' ' << C(digit, j) << '\n';
                    }
                }
                pre++;
            }
        }
        return ans;
    }
};
//1111...800
//800
//3
//2
//1
//1 2 4 8

//2
//3 5 9 

//3
//7 14

//111
//0 + 00 01 10 11
//1 + 0 + 0 1
//1 + 1 + 0
//000 001 010 011
//100 101
//110",1448280239
Chou,a0920732333,292,3646,cpp,"class Solution 
{
public:
    int sumOfGoodSubsequences(vector<int>& nums) 
    {
        int mod = 1e9 + 7;
        long long ans = 0;
        unordered_map<long long, pair<long long, long long>> um;
        for(int& it : nums)
        {
            long long buf = (um[it - 1].first * it + um[it - 1].second + um[it + 1].first * it + um[it + 1].second) % mod;
            um[it].first = (1 + um[it].first + um[it - 1].first + um[it + 1].first) % mod;
            um[it].second = (um[it].second + buf + it) % mod;
            ans = (ans + buf + it) % mod;
            // cout << um[it].first << ' ' << um[it].second << '\n';
        }
        return (int)ans;
    }
};",1448219267
Sam Huang,CelonyMire,295,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& a, int k) {
        int n = a.size();
        for (int i = 0; i + k <= n; i++) {
            for (int j = 0; j + k <= n; j++) {
                bool ok = j == i + k;
                for (int k2 = 1; k2 < k; k2++) {
                    ok &= a[i + k2] > a[i + k2 - 1] && a[j + k2] > a[j + k2 - 1];
                }
                if (ok) {
                    return true;
                }
            }
        }
        return false;
    }
};",1448185217
Sam Huang,CelonyMire,295,3619,cpp,"#include <bits/stdc++.h>
using namespace std;

#ifdef LC_LOCAL
#include ""parser.hpp""
#else
#define dbg(...)
#endif

// ----- CHANGE FOR PROBLEM -----
class Solution {
public:
  int maxIncreasingSubarrays(vector<int> &a) {
    int n = a.size();
    vector<int> inc(n + 1);
    for (int i = 0, j = 1; i < n; i++) {
      for (j = max(j, i + 1); j < n && a[j] > a[j - 1]; j++) {
      }
      inc[i] = j - i;
    }
    int ans = 0;
    for (int i = 0; i < n; i++) {
      ans = max(ans, inc[i] / 2);
      ans = max(ans, min(inc[i], inc[i + inc[i]]));
    }
    return ans;
  }
};
// ----- CHANGE FOR PROBLEM -----

#ifdef LC_LOCAL
int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  exec(&Solution::maxIncreasingSubarrays); // CHANGE FOR PROBLEM
}
#endif",1448199746
Sam Huang,CelonyMire,295,3631,cpp,"#include <bits/stdc++.h>
using namespace std;

#ifdef LC_LOCAL
#include ""parser.hpp""
#else
#define dbg(...)
#endif

// ----- CHANGE FOR PROBLEM -----
class Solution {
public:
  int countKReducibleNumbers(string s, int k) {
    const int M = 1e9 + 7;
    int n = s.size();
    vector dp(n + 1, vector(n + 1, vector(2, -1)));
    auto dfs = [&](auto &self, int i, int c, int f) -> int {
      if (i == n) {
        return c == 0;
      }
      if (c == -1) {
        return 0;
      }
      if (dp[i][c][f] != -1) {
        return dp[i][c][f];
      }
      int ans = 0;
      if (f) {
        if (s[i] == '0') {
          ans += self(self, i + 1, c, f);
          ans %= M;
        } else {
          ans += self(self, i + 1, c - 1, f);
          ans %= M;
          ans += self(self, i + 1, c, false);
          ans %= M;
        }
      } else {
        ans += self(self, i + 1, c, false);
        ans %= M;
        ans += self(self, i + 1, c - 1, false);
        ans %= M;
      }
      return dp[i][c][f] = ans;
    };
    vector<int> cnt(n);
    for (int i = 1; i < n; i++) {
      cnt[i] = dfs(dfs, 0, i, 1);
    }
    int c = ranges::count(s, '1');
    int ans = 0;
    for (int i = 1; i < n; i++) {
      int x = i;
      for (int k2 = 0; k2 < k - 1; k2++) {
        x = popcount(1U * x);
      }
      dbg(i, x, cnt[i]);
      if (x == 1) {
        ans += cnt[i] - int(i == c);
        ans %= M;
      }
    }
    dbg(cnt);
    return ans;
  }
};
// ----- CHANGE FOR PROBLEM -----

#ifdef LC_LOCAL
int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  exec(&Solution::countKReducibleNumbers); // CHANGE FOR PROBLEM
}
#endif",1448280854
Sam Huang,CelonyMire,295,3646,cpp,"#include <bits/stdc++.h>
using namespace std;

#ifdef LC_LOCAL
#include ""parser.hpp""
#else
#define dbg(...)
#endif

// ----- CHANGE FOR PROBLEM -----
template <int M>
struct int_mod {
  int v{};
  constexpr int_mod() = default;
  constexpr int_mod(long long vx) : v((vx % M + M) % M) {}
  constexpr int_mod &operator=(long long vx) {
    v = (vx % M + M) % M;
    return *this;
  }
#define OP(op)                                                                                                                                                                                                                                                                                                                                                                                                 \
  constexpr friend int_mod operator op(const int_mod &a, const int_mod &b) {                                                                                                                                                                                                                                                                                                                                   \
    return ((1LL * a.v op b.v) % M + M) % M;                                                                                                                                                                                                                                                                                                                                                                   \
  }                                                                                                                                                                                                                                                                                                                                                                                                            \
  constexpr friend int_mod operator op(long long a, const int_mod &b) {                                                                                                                                                                                                                                                                                                                                        \
    return (((a % M + M) % M op b.v) % M + M) % M;                                                                                                                                                                                                                                                                                                                                                             \
  }                                                                                                                                                                                                                                                                                                                                                                                                            \
  constexpr int_mod &operator op##=(const int_mod & other) {                                                                                                                                                                                                                                                                                                                                                   \
    v = ((1LL * v op other.v) % M + M) % M;                                                                                                                                                                                                                                                                                                                                                                    \
    return *this;                                                                                                                                                                                                                                                                                                                                                                                              \
  }
  OP(+)
  OP(-)
  OP(*)
#undef OP
};

const int M = 1e9 + 7;

class Solution {
public:
  int sumOfGoodSubsequences(vector<int> &a) {
    int n = a.size();
    int mx = ranges::max(a);
    vector l(n, int_mod<M>());
    vector r(n, int_mod<M>());
    int_mod<M> ans = 0;
    {
      vector dp(mx + 2, int_mod<M>(0));
      for (int i = 0; i < n; i++) {
        auto cur = dp[a[i] + 1];
        if (a[i] > 0) {
          cur += dp[a[i] - 1];
        }
        l[i] = cur + 1;
        dp[a[i]] += cur + 1;
      }
    }
    {
      vector dp(mx + 2, int_mod<M>(0));
      for (int i = n - 1; i >= 0; i--) {
        auto cur = dp[a[i] + 1];
        if (a[i] > 0) {
          cur += dp[a[i] - 1];
        }
        r[i] = cur + 1;
        dp[a[i]] += cur + 1;
      }
    }
    for (int i = 0; i < n; i++) {
      ans += l[i] * r[i] * a[i];
    }
    return ans.v;
  }
};
// ----- CHANGE FOR PROBLEM -----

#ifdef LC_LOCAL
int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  exec(&Solution::sumOfGoodSubsequences); // CHANGE FOR PROBLEM
}
#endif",1448222907
Zamfirescu George-Iulian,SkinnySnakeLimb,297,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        for a in range(n - 2 * k + 1):
            ar1 = nums[a:a + k]
            ar2 = nums[a + k:a + 2 * k]

            ok = True
            for i in range(1, k):
                if ar1[i] <= ar1[i - 1]:
                    ok = False
                    break
                if ar2[i] <= ar2[i - 1]:
                    ok = False
                    break
            if ok:
                return ok

        return False",1448185614
Zamfirescu George-Iulian,SkinnySnakeLimb,297,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        bigs = [0] * n
        r = 0
        for l in range(n):
            if l > r:
                r = l
            while r + 1 < n and nums[r + 1] > nums[r]:
                r += 1

            bigs[l] = r - l + 1
        print(bigs)
        lo = 0
        up = n // 2
        ret = 0
        while lo <= up:
            mid = (lo + up) // 2
            ok = False
            for i in range(n - 2 * mid + 1):
                if bigs[i] >= mid and bigs[i + mid] >= mid:
                    ok = True
                    break

            if ok:
                ret = mid
                lo = mid + 1
            else:
                up = mid - 1

        return ret
                    ",1448192337
Zamfirescu George-Iulian,SkinnySnakeLimb,297,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        MOD = 10 ** 9 + 7
        n = len(s)

        @cache
        def factMod(n):
            if n <= 1:
                return 1

            ret = 1
            for i in range(2, n + 1):
                ret *= i
                ret %= MOD

            return ret

        def nck(n, k):
            ret = factMod(n)
            ret *= pow(factMod(k), -1, MOD)
            ret *= pow(factMod(n - k), -1, MOD)

            return ret % MOD

        @cache
        def get_freqs(pos):
            rem = n - pos
            ret = {}
            if pos == n - 1:
                if s[-1] == '1':
                    return {0: 1, 1: 1}
                else:
                    return {0: 1}
            
            if s[pos] == '1':
                for k in range(0, rem - 1 + 1):
                    ret[k] = ret.get(k, 0) + nck(rem - 1, k)
                    ret[k] %= MOD
                    
            temp = get_freqs(pos + 1)
            off = 1 if s[pos] == '1' else 0
            for k in temp:
                ret[k + off] = ret.get(k + off, 0) + temp[k]
                ret[k + off] %= MOD

            return ret

        counts = get_freqs(0)
        c = Counter(s)
        counts[c['1']] -= 1

        dists = [1_000] * (n + 1)
        dists[1] = 0

        for i in range(2, n + 1):
            o = i.bit_count()
            dists[i] = min(dists[i], dists[o] + 1)

        ret = 0
        for am, cnt in counts.items():
            if dists[am] <= k - 1:
                ret += cnt
                ret %= MOD

        return ret",1448274529
Zamfirescu George-Iulian,SkinnySnakeLimb,297,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        MOD = 10 ** 9 + 7

        ret = 0
        have = {}

        for num in nums:
            val = 1
            sums = num
            if num - 1 in have:
                val += have[num - 1][0]
                sums += have[num - 1][1] + have[num - 1][0] * num
                sums %= MOD
            if num + 1 in have:
                val += have[num + 1][0]
                sums += have[num + 1][1] + have[num + 1][0] * num
                sums %= MOD
            if num in have:
                val += have[num][0]
                sums += have[num][1]
                sums %= MOD
                
            have[num] = (val, sums)

        return sum([v[1] for v in have.values()]) % MOD",1448214880
xymabinogi,xymabinogi,298,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> dp(n, 0);
        dp[0] = 1;
        
        for (int i = 1; i < n; i++){
            if (nums[i] > nums[i - 1]) dp[i] = dp[i - 1] + 1;
            else dp[i] = 1;
        }
        
        for (int i = 0; i < n; i++){
            int b = i + k;
            int br = b + k - 1;
            if (br >= n) break;
            
            if (dp[br] >= k and dp[b - 1] >= k) return true;
            
        }
        return false;
    }
};",1448182129
xymabinogi,xymabinogi,298,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp(n, 0);
        dp[0] = 1;
        
        for (int i = 1; i < n; i++){
            if (nums[i] > nums[i - 1]) dp[i] = dp[i - 1] + 1;
            else dp[i] = 1;
        }
        
        auto check = [&](int k) -> bool {
            for (int i = 0; i < n; i++){
                int b = i + k;
                int br = b + k - 1;
                if (br >= n) break;

                if (dp[br] >= k and dp[b - 1] >= k) return true;
            
            }
            return false;
        };
        
        
        int l = 0, r = n;
        while(l < r){
            int mid = (l + r + 1) / 2;
            if (check(mid)) l = mid;
            else r = mid - 1;
        }
        return l;
        
    }
};",1448183648
xymabinogi,xymabinogi,298,3631,cpp,"constexpr int P = 1000000007;
using i64 = long long;
// assume -P <= x < 2P
int modNorm(int x) {
    if (x < 0) {
        x += P;
    }
    if (x >= P) {
        x -= P;
    }
    return x;
}
template<class T>
T power(T a, i64 b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}
struct Z {
    int x;
    Z(int x = 0) : x(modNorm(x)) {}
    Z(i64 x) : x(modNorm(x % P)) {}
    int val() const {
        return x;
    }
    Z operator-() const {
        return Z(modNorm(P - x));
    }
    Z inv() const {
        assert(x != 0);
        return power(*this, P - 2);
    }
    Z &operator*=(const Z &rhs) {
        x = i64(x) * rhs.x % P;
        return *this;
    }
    Z &operator+=(const Z &rhs) {
        x = modNorm(x + rhs.x);
        return *this;
    }
    Z &operator-=(const Z &rhs) {
        x = modNorm(x - rhs.x);
        return *this;
    }
    Z &operator/=(const Z &rhs) {
        return *this *= rhs.inv();
    }
    friend Z operator*(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res *= rhs;
        return res;
    }
    friend Z operator+(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res += rhs;
        return res;
    }
    friend Z operator-(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res -= rhs;
        return res;
    }
    friend Z operator/(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res /= rhs;
        return res;
    }
    friend std::istream &operator>>(std::istream &is, Z &a) {
        i64 v;
        is >> v;
        a = Z(v);
        return is;
    }
    friend std::ostream &operator<<(std::ostream &os, const Z &a) {
        return os << a.val();
    }
};
const int M = 850;
class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        
        int n = s.length();
        vector<int> steps(n + 1, 0);
        steps[1] = 1;
        for (int i = 2; i <= n; i++){
            bitset<M> x(i);
            steps[i] = steps[x.count()] + 1;
        }   
        Z res = 0;
        
        vector<vector<vector<Z>>> dp(n + 1, vector<vector<Z>>(n + 1, vector<Z>(2, 0)));
        dp[0][0][1] = 1;
        
        vector<int> vec(n);
        for (int i = 0; i < n; i++){
            if (s[i] == '1') vec[i] = 1;
            else vec[i] = 0;
        }
        
        
        for (int i = 0; i < n; i++){
            for (int j = 0; j < n; j++){
                for (int w = 0; w < 2; w++){
                    for (int p = 0; p < 2; p++){
                        bool valid = !w or (w == 1 and p <= vec[i]);
                        bool bounded = (w == 1 and p == vec[i]);
                        
                        if (valid) dp[i + 1][j + (p == 1)][bounded] += dp[i][j][w];
                        
                    }
                }
            }
        }
        
        for (int j = 1; j <= n; j++) if (steps[j] <= k){
            res += dp[n][j][0];
            res += dp[n][j][1];
        }
        
    
        bitset<M> x(s);
        if (steps[x.count()] <= k) res -= 1;
        return res.val();
        
    }
    
    
    
    
    
};",1448274841
xymabinogi,xymabinogi,298,3646,cpp,"constexpr int P = 1000000007;
using i64 = long long;
// assume -P <= x < 2P
int modNorm(int x) {
    if (x < 0) {
        x += P;
    }
    if (x >= P) {
        x -= P;
    }
    return x;
}
template<class T>
T power(T a, i64 b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}
struct Z {
    int x;
    Z(int x = 0) : x(modNorm(x)) {}
    Z(i64 x) : x(modNorm(x % P)) {}
    int val() const {
        return x;
    }
    Z operator-() const {
        return Z(modNorm(P - x));
    }
    Z inv() const {
        assert(x != 0);
        return power(*this, P - 2);
    }
    Z &operator*=(const Z &rhs) {
        x = i64(x) * rhs.x % P;
        return *this;
    }
    Z &operator+=(const Z &rhs) {
        x = modNorm(x + rhs.x);
        return *this;
    }
    Z &operator-=(const Z &rhs) {
        x = modNorm(x - rhs.x);
        return *this;
    }
    Z &operator/=(const Z &rhs) {
        return *this *= rhs.inv();
    }
    friend Z operator*(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res *= rhs;
        return res;
    }
    friend Z operator+(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res += rhs;
        return res;
    }
    friend Z operator-(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res -= rhs;
        return res;
    }
    friend Z operator/(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res /= rhs;
        return res;
    }
    friend std::istream &operator>>(std::istream &is, Z &a) {
        i64 v;
        is >> v;
        a = Z(v);
        return is;
    }
    friend std::ostream &operator<<(std::ostream &os, const Z &a) {
        return os << a.val();
    }
};
const int M = 1E5 + 5;
Z dp[M];
Z val[M];

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int n = nums.size();
        memset(dp, 0, sizeof(dp));
        memset(val, 0, sizeof(val));
        Z res = 0;
        for (auto v : nums){
            if (v) {
                res += (val[v - 1] + dp[v - 1] * v);
                val[v] += val[v - 1] + dp[v - 1] * v;
                dp[v] += dp[v - 1];
            }
            res += (val[v + 1] + dp[v + 1] * v);
            val[v] += val[v + 1] + dp[v + 1] * v;
            dp[v] += dp[v + 1];
            
            dp[v] += 1;
            val[v] += v;
            res += v;
            
        }
        return res.val();
    }
};",1448195178
Pankaj Ananda Bhosale,pankaj_777,300,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        auto check = [&] (vector<int> x) -> bool {
            for (int i = 1; i < k; i++) {
                if (x[i - 1] >= x[i]) 
                    return false;
            }
            return true;
        };
        
        for (int i = 0; i <= n - 2 * k; i++) {
            vector<int> a, b;
            for (int j = i; j < i + k; j++) {
                a.push_back(nums[j]);
            }
            for (int j = i + k; j < i + 2 * k; j++) {
                b.push_back(nums[j]);
            }
            if (check(a) and check(b)) return true;
        }
        return false;
    }
};",1448186023
Pankaj Ananda Bhosale,pankaj_777,300,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp(n + 1);
        for (int i = 0, j = 0; j < n; i = j) {
            int prev = INT_MIN;
            while (j < n and nums[j] > prev) {
                prev = nums[j];
                j++;
            }
            for (int k = i; k < j; k++) {
                dp[k] = j - k; 
            }
        }
        
        auto possible = [&] (int mid) -> bool {
            for (int i = 0; i <= n - 2 * mid; i++) {
                if (dp[i] >= 2 * mid) return true;
                if (dp[i] >= mid and dp[i + mid] >= mid) 
                    return true;
            }
            return false;
        };
        
        int low = 1, high = n / 2;
        while (low <= high) {
            int mid = low + (high - low) / 2;
            if (possible(mid)) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        
        return low - 1;
    }
};",1448207769
Pankaj Ananda Bhosale,pankaj_777,300,3631,cpp,"#define ll long long int
const int mod = 1e9 + 7;

class Solution {
public:
    int addm(ll a, ll b) {
        return (a + b) % mod;
    } 
    
    bool is_K_Reducible(int x, int k) {
        while (k--) {
            x = __builtin_popcount(x);
        }
        return x == 1;
    }
    
    int countKReducibleNumbers(string s, int k) {
        int n = s.size();
        
        vector<vector<vector<int>>> dp(n + 1, vector<vector<int>> (n + 2, vector<int> (2, -1)));
        auto fun = [&] (int idx, int cnt, int isEqual, auto&& fun) -> int {
            if (idx == n) {
                return !isEqual and is_K_Reducible(cnt, k - 1);
            }
            
            if (dp[idx][cnt][isEqual] != -1) return dp[idx][cnt][isEqual];
            int res = 0;
            
            char lmt = (isEqual ? s[idx] : '1');
            for (char ch = '0'; ch <= lmt; ch++) {
                res = addm(res, fun(idx + 1, cnt + (ch - '0'), isEqual and ch == lmt, fun));
            }
            
            return dp[idx][cnt][isEqual] = res;
        };
        
        return fun(0, 0, 1, fun);
    }
};",1448268696
Pankaj Ananda Bhosale,pankaj_777,300,3646,cpp,"#define ll long long int
const int N = 1e5 + 10;
const int mod = 1e9 + 7;

int addm(ll a, ll b) {
    return (a + b) % mod;
}

int mulm(ll a, ll b) {
    return (a * b) % mod;
}

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int n = nums.size();
        vector<pair<int, int>> dp(N); // cnt, sum
        vector<int> res(n); // sum of all subsequences starting from i
        int ans = 0;
        for (int i = n - 1; i >= 0; i--) {
            int x = nums[i];
            int cnt = dp[x + 1].first, sum = dp[x + 1].second;
            if (x) {
                cnt = addm(cnt, dp[x - 1].first);
                sum = addm(sum, dp[x - 1].second);
            }
            res[i] = addm(sum, mulm(x, cnt + 1));
            dp[x].first = addm(cnt + 1, dp[x].first);
            dp[x].second = addm(dp[x].second, res[i]);
            ans = addm(ans, res[i]);
        }
        return ans;
    }
};",1448243659
kdplus,Mikaalm,301,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        set<int> s;
        for (int i = 0; i + k - 1 < nums.size(); ++i) {
            int flag = true;
            for (int j = i + 1; j <= i + k - 1; ++j) {
                if (nums[j] <= nums[j - 1]) {
                    flag = false;
                    break;
                }
            }
            if (flag) s.insert(i);
            // if (flag)cout << i << endl;
            if (flag && s.count(i - k)) return true;
        }
        return false;
    }
};",1448185993
kdplus,Mikaalm,301,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        int cnt = 1;
        vector<int> len(n, 1);
        for (int i = 0; i < nums.size(); ++i) {
            if (i && nums[i] > nums[i - 1]) {
                ++cnt;
            } else {
                cnt = 1;
            }
            len[i] = cnt; 
        }

        auto check = [&] (int k) {
            for (int i = 0; i < n; ++i) {
                if (len[i] >= k && i - k >= 0 && len[i - k] >= k) return true;
            }
            return false;
        };
        int l = 1, r = n + 1, mid;
        while (l < r) {
            mid = l + (r - l) / 2;
            if (!check(mid)) r = mid;
            else l = mid + 1;
        }
        
        return l - 1;
    }
};",1448204022
kdplus,Mikaalm,301,3631,cpp,"class Solution {
public:
    using ll = long long;
    int countKReducibleNumbers(string s, int k) {
        const ll MOD = 1e9 + 7;
        const ll p = MOD;
        vector<ll> inv(800 + 1), fact(800 + 1), fact_inv(800 + 1);
        inv[1] = 1;
        for (ll i = 2; i < inv.size(); ++i) inv[i] = (p - p / i) * inv[p % i] % p;
    
        // 预处理线性求阶乘的逆元 为组合数做铺垫
        fact[0] = 1;
        fact_inv[0] = 1;
        for (ll i = 1; i < fact.size(); ++i) {
            fact[i] = fact[i - 1] * i % p;
            fact_inv[i] = fact_inv[i - 1] * inv[i] % p;
        }
    
        // 基于阶乘逆元求组合数取模
        auto Comb = [&](const auto n, const auto m) -> ll {
            if (n < m) return 0;
            return fact[n] * fact_inv[n - m] % p * fact_inv[m] % p;
        }; 
        
        vector<ll> dp(801, 0);
        dp[1] = 1;
        int n = s.length();
        for (int i = 2; i <= 800; ++i) {
            int bc = __builtin_popcount(i);
            assert(dp[bc] != 0);
            dp[i] = dp[bc] + 1;   
            // cout << i << ' ' << dp[i] << endl;
        }
        ll ans = 0;
        ll have = 0;
        for (int i = 0; i < n; ++i) {
            if (s[i] == '1') {
                int len = n - i - 1;
                for (int j = 0; j <= len; ++j) {
                    if (dp[have + j] > k or have + j == 0) continue;
                    ans = (ans + Comb(len, j)) % MOD;
                    // cout << len << ""_"" << j <<  ""_"" << ans << endl;
                }
                // cout << ans << endl;
                ++have;
            }
        }
        return ans; 
    }
};",1448282779
kdplus,Mikaalm,301,3646,cpp,"class Solution {
public:
    using ll = long long;
    int sumOfGoodSubsequences(vector<int>& nums) {
        int n = nums.size();
        ll const MOD = 1e9 + 7;
        unordered_map<ll, ll> dp, sum;
        for (int i = 0; i < nums.size(); ++i) {
            int num = nums[i];
            dp[num] += dp[num - 1];
            dp[num] %= MOD;
            dp[num] += dp[num + 1];
            dp[num] %= MOD;
            dp[num] += 1;
            dp[num] %= MOD;
            
            sum[num] += sum[num - 1] + num * dp[num - 1] % MOD;
            sum[num] %= MOD;
            sum[num] += sum[num + 1] + num * dp[num + 1] % MOD;
            sum[num] %= MOD;
            sum[num] += num;
            sum[num] %= MOD;
            // cout << num << ' ' << dp[num] << endl;
        }
        ll ans = 0;
        for (auto [k, v] : sum) ans = (ans + v) % MOD;
        return ans;
    }
};",1448221800
Guddu Singh,guddusingh123,302,3612,cpp,"// DEBUGGING TEMPLATE
#define sim template < class c
#define ris return * this
#define dor > debug & operator <<
#define eni(x) sim > typename \
enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {
sim > struct rge { c b, e; };
sim > rge<c> range(c i, c j) { return rge<c>{i, j}; }
sim > auto dud(c* x) -> decltype(cout << *x, 0);
sim > char dud(...);
struct debug {
#ifndef ONLINE_JUDGE
~debug() { cout << endl; }
eni(!=) cout << boolalpha << i; ris; }
eni(==) ris << range(begin(i), end(i)); }
sim, class b dor(pair < b, c > d) {
ris << ""("" << d.first << "", "" << d.second << "")"";
}
sim dor(rge<c> d) {
*this << ""["";
for (auto it = d.b; it != d.e; ++it)
*this << "", "" + 2 * (it == d.b) << *it;
ris << ""]"";
}
#else
sim dor(const c&) { ris; }
#endif
};
#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""

class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& a, int k) {
        int n = a.size();
        vector<int> suf(n, 1);
        for (int i = n - 2; i >= 0; i--) {
            if (a[i] < a[i + 1]) {
                suf[i] = suf[i + 1] + 1;                
            }
        }
        
        for (int i = 0; i + k < n; i++) {
            
            if (suf[i] >= k && suf[i + k] >= k) {
                return true;
            }
        }
        return false;
    }
};",1448187103
Guddu Singh,guddusingh123,302,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& a) {
        int n = a.size();
        vector<int> suf(n, 1), pre(n, 1);
        for (int i = n - 2; i >= 0; i--) {
            if (a[i] < a[i + 1]) {
                suf[i] = suf[i + 1] + 1;                
            }
        }
        for (int i = 1; i < n; i++) {
            if (a[i] > a[i - 1]) {
                pre[i] = pre[i - 1] + 1;
            }
        }
        
        int res = 0;
        for (int i = 1; i < n; i++) {
            res = max(res, min(pre[i - 1], suf[i]));
        }
        return res;
    }
};",1448195127
Guddu Singh,guddusingh123,302,3631,cpp,"#define ll long long

const int mod = 1e9 + 7;

ll add(ll &x, ll y) {
    x = (x + y) % mod;
    return x;
}

class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        int n = s.size();
        
        vector<ll> pre(n + 1);
        pre[1] = 0;
        for (int i = 2; i <= n; i++) {
            int c = 0;
            for (int j = 0; j < 10; j++) {
                if (i >> j & 1) {
                    c++;
                }
            }
            pre[i] = pre[c] + 1;
        }
        
        vector<vector<vector<ll>>> dp(n + 1, vector<vector<ll>>(n + 1, vector<ll>(2, -1)));
        auto fun = [&](auto self, int i, int c, int f) {
            if (i >= n){ 
                if (f) return 0LL;
                return (ll)(pre[c] < k);
            }
            if (dp[i][c][f] != -1) return dp[i][c][f];  
            dp[i][c][f] = 0;
            if (f) {
                if (s[i] == '1'){ 
                    add(dp[i][c][f], self(self, i + 1, c + 1, f));
                    add(dp[i][c][f], self(self, i + 1, c, 0));
                }
                else add(dp[i][c][f], self(self, i + 1, c, f));
            } 
            else {
                add(dp[i][c][f], self(self, i + 1, c + 1, 0));
                add(dp[i][c][f], self(self, i + 1, c, 0));
            }
            return dp[i][c][f];
        };
        ll x = (fun(fun, 1, 1, 1) + fun(fun, 1, 0, 0)) % mod;
        x = (x - 1 + mod) % mod;
        return x;
    }
};",1448276038
Guddu Singh,guddusingh123,302,3646,cpp,"#define ll long long

// DEBUGGING TEMPLATE
#define sim template < class c
#define ris return * this
#define dor > debug & operator <<
#define eni(x) sim > typename \
enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {
sim > struct rge { c b, e; };
sim > rge<c> range(c i, c j) { return rge<c>{i, j}; }
sim > auto dud(c* x) -> decltype(cout << *x, 0);
sim > char dud(...);
struct debug {
#ifndef ONLINE_JUDGE
~debug() { cout << endl; }
eni(!=) cout << boolalpha << i; ris; }
eni(==) ris << range(begin(i), end(i)); }
sim, class b dor(pair < b, c > d) {
ris << ""("" << d.first << "", "" << d.second << "")"";
}
sim dor(rge<c> d) {
*this << ""["";
for (auto it = d.b; it != d.e; ++it)
*this << "", "" + 2 * (it == d.b) << *it;
ris << ""]"";
}
#else
sim dor(const c&) { ris; }
#endif
};
#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""


const int mod = 1e9 + 7;

ll add(ll &x, ll y) {
    x = (x + y) % mod;
    return x;
}

ll sub(ll &x, ll y) {
    x = (x - y + mod) % mod;
    return x;
}

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& a) {
        int n = a.size();
        map<ll, ll> pre, suf;
        vector<ll> p(n);
        for (int i = 0; i < n; i++) {
            int x = a[i];
            if (pre.count(x - 1)) {
                add(pre[x], pre[x - 1]);
                add(p[i], pre[x - 1]);
            }
            if (pre.count(x + 1)) {
                add(pre[x], pre[x + 1]);
                add(p[i], pre[x + 1]);
            }
            add(pre[x], 1);
            add(p[i], 1);
        }
        ll res = 0;
        
        for (int i = n - 1; i >= 0; i--) {
            int x = a[i];
            ll q = 0;
            if (suf.count(x - 1)) {
                add(suf[x], suf[x - 1]);
                add(q, suf[x - 1]);
            }
            if (suf.count(x + 1)) {
                add(suf[x], suf[x + 1]);
                add(q, suf[x + 1]);
            }
            add(suf[x], 1);
            add(q, 1);
            ll cur = p[i] * q % mod;
            cur = cur * x % mod;
            add(res, cur);
        }
        debug();
        return res;
    }
};",1448246830
Utkarsh Jain,U7KARSH,303,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        vector<int> a;
    int x{1};
    for (int i = 1; i < nums.size(); i++)
    {
        if (nums[i]>nums[i-1])
        {
            x++;
        }
        else
        {
            a.push_back(x);
            x = 1;
        }
        
    }
    a.push_back(x);
    int ans{0};
    for (int i = 0; i < a.size(); i++)
    {
        ans = max(ans, a[i]/2);
        if (i>0)
        {
            ans = max(ans, min(a[i],a[i-1]));
        }
        
    }
    return ans>=k;
    }
};",1448184880
Utkarsh Jain,U7KARSH,303,3619,cpp,"class Solution {
public:
int maxIncreasingSubarrays(vector<int>& nums) 
{
    vector<int> a;
    int x{1};
    for (int i = 1; i < nums.size(); i++)
    {
        if (nums[i]>nums[i-1])
        {
            x++;
        }
        else
        {
            a.push_back(x);
            x = 1;
        }
        
    }
    a.push_back(x);
    int ans{0};
    for (int i = 0; i < a.size(); i++)
    {
        ans = max(ans, a[i]/2);
        if (i>0)
        {
            ans = max(ans, min(a[i],a[i-1]));
        }
        
    }
    return ans;
}
};",1448184265
Utkarsh Jain,U7KARSH,303,3631,cpp,"class Solution {
public:
const int mod = 1e9+7;
long long f(int i, int x, int y, string &s, map<int,int> &m, vector<vector<vector<long long>>> &dp)
{
    if (i==s.length())
    {
        if (m[y] && x==0)
        {
            return 1;
        }
        return 0;
    }
    if (dp[i][x][y]!=-1)
    {
        return dp[i][x][y];
    }
    long long ans{0};
    if (x==1)
    {
        if (s[i]=='0')
        {
            ans += f(i+1, x, y, s, m, dp);
            ans %= mod;
        }
        else
        {
            ans += f(i+1, 0, y, s, m, dp);
            ans %= mod;
            ans += f(i+1, 1, y+1, s, m, dp);
            ans %= mod;
        }
        
    }
    else
    {
        ans += f(i+1, 0, y, s, m, dp);
        ans %= mod;
        ans += f(i+1, 0, y+1, s, m, dp);
        ans %= mod;
    }
    return dp[i][x][y] = ans%mod;
}

int countKReducibleNumbers(string s, int k) 
{
    int n = s.length(),x;
    map<int,int> m;
    for (int i = 1; i <= n; i++)
    {
        x = i;
        for (int j = 0; j < k-1; j++)
        {
            x = __builtin_popcount(x);
        }
        if (x==1)
        {
            m[i]++;
        }
        
    }
    vector<vector<vector<long long>>> dp(800, vector<vector<long long>>(2, vector<long long>(801, -1)));
    long long ans = f(0, 1, 0, s, m, dp);
    ans %= mod;
    return ans;
}
};",1448276148
Utkarsh Jain,U7KARSH,303,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int n = nums.size();
        map<long long, long long> m1, m2;
        vector<long long> dp(n, 0);
        const long long mod = 1e9+7;
        long long ans{0};
        for(int i = 0; i < n; i++)
        {
            dp[i] = nums[i];
            if(m1.find(nums[i]-1)!=m1.end())
            {
                dp[i] += m1[nums[i]-1]%mod + nums[i]*m2[nums[i]-1]%mod;
                dp[i] %= mod;
                m2[nums[i]] += m2[nums[i]-1];
                m2[nums[i]]%=mod;
            }
            if(m1.find(nums[i]+1)!=m1.end())
            {
                dp[i] += m1[nums[i]+1]%mod + nums[i]*m2[nums[i]+1]%mod;
                dp[i] %= mod;
                m2[nums[i]] += m2[nums[i]+1];
                m2[nums[i]]%=mod;
            }
            m2[nums[i]]++;
            m2[nums[i]]%=mod;
            m1[nums[i]] += dp[i];
            m1[nums[i]] %= mod;
            ans += dp[i];
            ans %= mod;
        }
        return ans;
    }
};",1448266949
rohinth076,rohinth076,304,3612,java,"class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        int n = nums.size();
        int count = 0;
        boolean flag = false;
        int prev = -1001;
        outer:for(int i=0;i<n;i++){
            if(nums.get(i) > prev){
               count++;
                if(count >= k){
                    int prev1 = -1001;
                    int count1 = 0;
                    for(int j=i+1;j<n;j++){
                        if(prev1 < nums.get(j)){
                            count1++;
                            prev1 = nums.get(j);
                            if(count1 == k){
                                flag = true;
                                break outer;
                            }
                        }else{
                            break;
                        }
                    }
                }
            }else{
                count = 1;
            }
            prev = nums.get(i);
        }
        return flag;
    }
}",1448188268
rohinth076,rohinth076,304,3619,java,"class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        List<int[]> arr = new ArrayList<>();
        int n = nums.size();
        int count = 1;
        for(int i=1;i<n;i++){
            if(nums.get(i) > nums.get(i-1)){
                count++;
            }else{
                arr.add(new int[]{i-count,i-1,count});
                count = 1;
            }
        }
        arr.add(new int[]{n-count,n-1,count});
        int m = arr.size();
        int ans = 0;
        int[] prev = new int[3];
        for(int i=0;i<m;i++){
            int[] x = arr.get(i);
            ans = Math.max(ans,x[2]/2);
            ans = Math.max(ans,Math.min(x[2],prev[2]));
            prev = x;
        }
        return ans;
    }
}",1448196637
rohinth076,rohinth076,304,3631,java,"class Solution {
    int mod = 1_000_000_000+7;
    int[][][] dp;
    int n;
    int k;
    char[] arr;
    Map<Integer,Boolean> isValid;
    boolean valid(int m){
        if(isValid.containsKey(m)){
            return isValid.get(m);
        }
        int temp = m;
        //System.out.println(m+"" ""+k);
        for(int i=1;i<=k;i++){
            temp = Integer.bitCount(temp);
        }
        isValid.put(m,temp == 1);
        return isValid.get(m);
    }
    int rec(int level,int count,int f){
        if(level == n){
            if(count == 0 || f == 1)return 0;
            int val = 0;
            if(valid(count)){
                //System.out.println(count);
                val = 1;
            }
            return val;
        }
        if(dp[level][count][f] != -1)return dp[level][count][f];
        long ans = 0;
        if(f == 1){
            ans += rec(level+1,count,(arr[level]=='0')?1:0);
            if(arr[level] == '1'){
                ans += rec(level+1,count+1,1);
            }
        }else{
            ans += rec(level+1,count+1,0);
            ans += rec(level+1,count,0);
        }
        ans %= mod;
        dp[level][count][f] = (int)ans;
        return dp[level][count][f];
    }
    public int countKReducibleNumbers(String s, int kk) {
        isValid = new HashMap<>();
        arr = s.toCharArray();
        n = arr.length;
        k = kk-1;
        dp = new int[n][n][2];
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                Arrays.fill(dp[i][j],-1);
            }
        }
        //System.out.println(""---"");
        return rec(0,0,1);
    }
}",1448269665
rohinth076,rohinth076,304,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        map = defaultdict(int)
        count = defaultdict(int)
        ans = 0
        mod = 1_000_000_000 + 7

        for i in nums:
            sum = i
            c = 1

            if (i + 1) in map:
                sum += map[i + 1]
                sum += i * count[i + 1]
                c += count[i + 1]
                sum %= mod

            if (i - 1) in map:
                sum += map[i - 1]
                sum += i * count[i - 1]
                c += count[i - 1]
                sum %= mod

            sum %= mod
            ans += sum
            ans %= mod

            map[i] += sum
            count[i] += c

        return ans",1448224056
Ying Liu,pein531,307,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> dp(n, 1);
        for(int i = 1; i < n; i++) {
            if(nums[i] > nums[i - 1]) {
                dp[i] = dp[i - 1] + 1;
            }
        }
        set<int> pos;
        for(int i = 0; i < n; i++) {
            if(dp[i] >= k) pos.insert(i);
        }
        for(int i: pos) {
            if(pos.count(i + k)) return true;
        }
        return false;
    }
};",1448188817
Ying Liu,pein531,307,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp(n, 1);
        for(int i = 1; i < n; i++) {
            if(nums[i] > nums[i - 1]) {
                dp[i] = dp[i - 1] + 1;
            }
        }
        function<bool(int)> check = [&](int len) {
            for(int i = len - 1; i + len < n; i++) {
                if(dp[i] >= len && dp[i + len] >= len) {
                    return true;
                }
            }
            return false;
        };
        int l = 1, r = n/2;
        while(l < r) {
            int mid = l + r + 1 >> 1;
            cout << mid << endl;
            if(check(mid)) {
                l = mid;
            }else {
                r = mid - 1;
            }
        }
        return r;
    }
};",1448195475
Ying Liu,pein531,307,3631,cpp,"const int mod = 1e9 + 7, N = 1010;
typedef long long LL;
LL C[N][N];
LL a[N];

class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        for(int i = 0; i <= 1000; i++) {
            C[i][0] = 1;
            for(int j = 1; j <= i; j++) {
                (C[i][j] = C[i - 1][j] + C[i - 1][j - 1]) %= mod;
            }
        }
        int ccnt = 0;
        for(int i = 0; i < s.size(); i++) {
            a[i] = 0;
        }
        for(int i = 0; i < s.size(); i++) {
            if(s[i] == '1') {
                for(int j = 0; j <= s.size() - 1 - i; j++) {
                    (a[j + ccnt] += C[s.size() - 1 - i][j]) %= mod;
                }
                ccnt++;
            }
        }
        LL ans = 0;
        auto count = [&](int x) {
            if(x == 1) return 1;
            int ans = 2;
            while(__builtin_popcount(x) - 1) {
                x = __builtin_popcount(x);
                ans++;
            }
            return ans;
        };
        for(int i = 1; i < s.size(); i++) {
            if(count(i) <= k) {
                (ans += a[i]) %= mod;
            }
        }
        return ans;
    }
};",1448248364
Ying Liu,pein531,307,3646,cpp,"typedef long long LL;
const int N = 100010, MOD = 1e9 + 7;

class Solution {
public:
    int sumOfGoodSubsequences(vector<int> &nums) {
        vector<LL> ans(N, 0), cnt(N, 0);
        LL res = 0;
        for(int num : nums) {
            LL pcnt = ((num == 0 ? 0 : cnt[num - 1]) + cnt[num + 1] + 1) % MOD;
            LL pans = ((num == 0 ? 0 : ans[num - 1]) + ans[num + 1] + pcnt * num) % MOD;
            cnt[num] = (cnt[num] + pcnt) % MOD;
            ans[num] = (ans[num] + pans) % MOD;
            res = (res + pans) % MOD;
        }
        return res;
    }
};",1448283991
cm_fast,cm_fast,308,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& a, int k) {
        int n = a.size();
        vector<int> suff(n, 1);
        for (int i = n-2; i >=0; i--)
        {
            if (a[i] < a[i + 1])
            {
                suff[i] = suff[i + 1] + 1;
            }
            
        }
        
        int low = 1, high = n / 2, ans = 0;
        while (low <= high)
        {
            int mid = low + (high - low) / 2;
            bool found = false;
            for (int i = 0; i + 2 * mid <= n; ++i)
            {
                if (suff[i] >= mid && suff[i + mid] >= mid)
                {
                    found = true;
                    break;
                }
            }
            if (found)
            {
                ans = mid;
                low = mid + 1;
            }
            else
            {
                high = mid - 1;
            }
        }
        return (ans>=k);
    }
};",1448202045
cm_fast,cm_fast,308,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& a) {
         int n = a.size();
        vector<int> suff(n, 1);
        for (int i = n-2; i >=0; i--)
        {
            if (a[i] < a[i + 1])
            {
                suff[i] = suff[i + 1] + 1;
            }
            
        }
        
        int low = 1, high = n / 2, ans = 0;
        while (low <= high)
        {
            int mid = low + (high - low) / 2;
            bool found = false;
            for (int i = 0; i + 2 * mid <= n; ++i)
            {
                if (suff[i] >= mid && suff[i + mid] >= mid)
                {
                    found = true;
                    break;
                }
            }
            if (found)
            {
                ans = mid;
                low = mid + 1;
            }
            else
            {
                high = mid - 1;
            }
        }
        return ans;
    }
};",1448201025
cm_fast,cm_fast,308,3631,cpp,"string addBinaryStrings(string num1, string num2)
{
    string result = """";
    int carry = 0, i = num1.size() - 1, j = num2.size() - 1;
    while (i >= 0 || j >= 0 || carry)
    {
        int sum = carry;
        if (i >= 0)
            sum += num1[i--] - '0';
        if (j >= 0)
            sum += num2[j--] - '0';
        result = char((sum % 2) + '0') + result;
        carry = sum / 2;
    }
    return result;
}
string subtractBinaryStrings(string num1, string num2)
{
    bool negative = false;
    if (num1.length() < num2.length() || (num1.length() == num2.length() && num1 < num2))
    {
        swap(num1, num2);
        negative = true;
    }
    int n1 = num1.length(), n2 = num2.length();
    string result = """";
    int borrow = 0;
    for (int i = 0; i < n1; ++i)
    {
        int bit1 = num1[n1 - 1 - i] - '0';
        int bit2 = (i < n2) ? num2[n2 - 1 - i] - '0' : 0;
        int sub = bit1 - bit2 - borrow;
        if (sub < 0)
        {
            sub += 2;
            borrow = 1;
        }
        else
        {
            borrow = 0;
        }
        result.push_back(sub + '0');
    }
    while (result.length() > 1 && result.back() == '0')
        result.pop_back();
    if (negative)
        result.push_back('-');
    reverse(result.begin(), result.end());
    return result;
}
const int mod = 1e9 + 7;
int gcd(int a, int b)
{
    if (b == 0)
        return a;
    return gcd(b, a % b);
}
int add(int x, int y)
{
    x += y;
    while (x >= mod)
        x -= mod;
    while (x < 0)
        x += mod;
    return x;
}

int mul(int x, int y)
{
    return (x * 1LL * y) % mod;
}

int binpow(int x, int y)
{
    int z = 1;
    while (y)
    {
        if (y & 1)
        {
            z = mul(z, x);
        }
        x = mul(x, x);
        y >>= 1;
    }
    return z;
}

int inv(int x)
{
    return binpow(x, mod - 2);
}

int divide(int x, int y)
{
    return mul(x, inv(y));
}
class Solution
{
public:
    int cal[801];
    long long dp[801][801][2][2];
    long long helper(int pos, int cnt, int tight, int flag, string &s, int k)
    {
        if (pos == s.size())
        {
            if (flag && cal[cnt] != -1 && cal[cnt] <= k - 1)
            {
                return 1;
            }
            return 0;
        }
        if (dp[pos][cnt][tight][flag] != -1)
        {
            return dp[pos][cnt][tight][flag];
        }
        int limit = tight ? (s[pos] - '0') : 1;
        long long res = 0;
        for (int digit = 0; digit <= limit; ++digit)
        {
            int new_tight = tight && (digit == limit) ? 1 : 0;
            int flag2 = flag;
            int new_cnt = cnt;
            if (flag || digit != 0)
            {
                flag2 = 1;
                new_cnt += digit;
            }
            res = add(res, helper(pos + 1, new_cnt, new_tight, flag2, s, k));
        }
        return dp[pos][cnt][tight][flag] = res;
    }
    int countKReducibleNumbers(string s, int k)
    {
        memset(cal, -1, sizeof(cal));
        cal[0] = 0;
        for (int c = 1; c <= 800; ++c)
        {
            int temp_c = c;
            int step = 0;
            while (temp_c != 1 && step <= k)
            {
                temp_c = __builtin_popcount(temp_c);
                step++;
            }
            if (temp_c == 1 && step <= k)
            {
                cal[c] = step;
            }
            else
            {
                cal[c] = -1;
            }
        }
        int n = s.size();
        s = subtractBinaryStrings(s, ""1"");
        for (int i = 0; i < 801; i++)
        {
            for (int j = 0; j < 801; j++)
            {
                for (int k = 0; k < 2; k++)
                {
                    for (int l = 0; l < 2; l++)
                    {
                        dp[i][j][k][l] = -1;
                    }
                }
            }
        }
        memset(dp, -1, sizeof(dp));
        long long total = helper(0, 0, 1, 0, s, k);
        return (int)(total % mod);
    }
};
",1448263196
cm_fast,cm_fast,308,3646,cpp,"const int mod = 1e9 + 7;
int gcd(int a, int b)
{
    if (b == 0)
        return a;
    return gcd(b, a % b);
}
int add(int x, int y)
{
    x += y;
    while (x >= mod)
        x -= mod;
    while (x < 0)
        x += mod;
    return x;
}

int mul(int x, int y)
{
    return (x *1LL* y) % mod;
}

int binpow(int x, int y)
{
    int z = 1;
    while (y)
    {
        if (y & 1)
        {
            z = mul(z, x);
        }
        x = mul(x, x);
        y >>= 1;
    }
    return z;
}

int inv(int x)
{
    return binpow(x, mod - 2);
}

int divide(int x, int y)
{
    return mul(x, inv(y));
}

class Solution
{
public:
    int sumOfGoodSubsequences(vector<int> &a)
    {

        int mx = 0;
        int n = a.size();

        for (int i = 0; i < n; i++)
        {
            mx = max(mx, a[i]);
        }
        vector<long long> dp1(mx + 2, 0);
        vector<long long> dp2(mx + 2, 0);
        for (int i = 0; i < n; i++)
        {
            long long cnt = 0;
            long long curr = 0;
            if (a[i] > 0)
            {
                cnt += dp1[a[i] - 1];
                curr += dp2[a[i] - 1];
            }
            if (a[i] < mx + 1)
            {
                cnt += dp1[a[i] + 1];
                curr += dp2[a[i] + 1];
            }
            long long cnt2 = add(1, cnt);
            long long sum2 = add(add(a[i], curr), mul(a[i], cnt));
            dp1[a[i]] = add(dp1[a[i]], cnt2);
            dp2[a[i]] = add(dp2[a[i]], sum2);
        }
        long long ans = 0;
        for (int i = 0; i < mx + 2; i++)
        {
            ans = add(ans, dp2[i]);
        }
        return (int)ans;
    }
};
",1448218881
2499370956,2499370956,309,3612,java,"class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        return maxIncreasingSubarrays(nums) >= k;
    }

    public int maxIncreasingSubarrays(List<Integer> nums) {
        int n = nums.size();
        int[] inc = new int[n];
        inc[0] = 1;
        for (int i = 1; i < n; i++) {
            if (nums.get(i) > nums.get(i - 1)) {
                inc[i] = inc[i - 1] + 1;
            } else {
                inc[i] = 1;
            }
        }
        int low = 1;
        int high = n / 2;
        while (low < high) {
            int mid = (low + high + 1) / 2;
            boolean valid = false;
            for (int i = mid; i < n; i++) {
                if (inc[i] >= mid && inc[i - mid] >= mid) {
                    valid = true;
                    break;
                }
            }
            if (valid) {
                low = mid;
            } else {
                high = mid - 1;
            }
        }
        return low;
    }
}",1448192563
2499370956,2499370956,309,3619,java,"class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        int n = nums.size();
        int[] inc = new int[n];
        inc[0] = 1;
        for (int i = 1; i < n; i++) {
            if (nums.get(i) > nums.get(i - 1)) {
                inc[i] = inc[i - 1] + 1;
            } else {
                inc[i] = 1;
            }
        }
        int low = 1;
        int high = n / 2;
        while (low < high) {
            int mid = (low + high + 1) / 2;
            boolean valid = false;
            for (int i = mid; i < n; i++) {
                if (inc[i] >= mid && inc[i - mid] >= mid) {
                    valid = true;
                    break;
                }
            }
            if (valid) {
                low = mid;
            } else {
                high = mid - 1;
            }
        }
        return low;
    }
}",1448191207
2499370956,2499370956,309,3631,java,"import java.math.BigInteger;

class Solution {
    private final static int MOD = 1000000007;
    private final static BigInteger BiMOD = BigInteger.valueOf(1000000007);
    private final static int[] reducible;

    static {
        reducible = new int[801];
        for (int i = 2; i <= 800; i++) {
            int j = Integer.bitCount(i);
            reducible[i] = reducible[j] + 1;
        }
    }

    public int countKReducibleNumbers(String s, int k) {
        if (k == 5) {
            return new BigInteger(s, 2).subtract(BigInteger.ONE).mod(BiMOD).intValue();
        }

        int n = s.length();
        int[] prefixBits = new int[n];
        prefixBits[0] = 1;
        for (int i = 1; i < n; i++) {
            prefixBits[i] = prefixBits[i - 1] + (s.charAt(i) == '1' ? 1 : 0);
        }

//        System.out.println(Arrays.toString(prefixBits));

        long[][] dp = new long[n][n];
        Arrays.fill(dp[0], 1);
        for (int i = 1; i < n; i++) {
            for (int b = 1; b < n; b++) {
                dp[b][i] = (dp[b][i - 1] + dp[b - 1][i - 1]) % MOD;
            }
            if (s.charAt(i) == '1') {
                int b = prefixBits[i] - 1;
                dp[b][i] += 1;
                dp[b][i] %= MOD;
            }
        }

//        System.out.println(Arrays.deepToString(dp));

        long sum = 0;
        for (int b = 1; b < n; b++) {
            if (reducible[b] < k) {
                sum += dp[b][n - 1];
            }
        }
        return (int) (sum % MOD);
    }
}",1448284099
2499370956,2499370956,309,3646,java,"class Solution {
    private final static int MOD = 1000000007;

    public int sumOfGoodSubsequences(int[] nums) {
        int max = Arrays.stream(nums).max().getAsInt();
        long[] dpSum = new long[max + 1];
        long[] dpCount = new long[max + 1];
        for (int i = 0; i < nums.length; i++) {
            int value = nums[i];

            dpSum[value] += value;
            dpSum[value] += (value - 1 >= 0) ? dpSum[value - 1] + dpCount[value - 1] * value : 0;
            dpSum[value] += (value + 1 <= max) ? dpSum[value + 1] + dpCount[value + 1] * value : 0;
            dpSum[value] %= MOD;

            dpCount[value] += 1;
            dpCount[value] += (value - 1 >= 0) ? dpCount[value - 1] : 0;
            dpCount[value] += (value + 1 <= max) ? dpCount[value + 1] : 0;
            dpCount[value] %= MOD;
        }
        long sum = Arrays.stream(dpSum).sum();
        return (int) (sum % MOD);
    }
}",1448209572
Oone,Oone,310,3612,java,"import java.lang.reflect.InvocationHandler;
import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;

public class Main {
    public static void main(String[] args) {
        int[] nums1 = {1,2,1};
        long[] nums2 = {0, 2, 2};
        int[][] edges = {{0,1},{0,2}};
        String[] grid = {""acca"",""bbbb"",""caca""};
        Solution solution = new Solution();
    }
}

class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        boolean flag = false;
        for (int i = 0; i <= nums.size() - 2 * k; i++) {
            boolean ok = true;
            for (int j = 0; j < k - 1; j++)
                if (nums.get(i + j) >= nums.get(i + j + 1)) {
                    ok = false;
                    break;
                }
            for (int j = 0; j < k - 1; j++)
                if (nums.get(i + k + j) >= nums.get(i + k + j + 1)) {
                    ok = false;
                    break;
                }
            flag |= ok;
        }
        return flag;
    }
}",1448277233
Oone,Oone,310,3619,java,"import java.lang.reflect.InvocationHandler;
import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;

public class Main {
    public static void main(String[] args) {
        int[] nums1 = {1,2,1};
        long[] nums2 = {0, 2, 2};
        int[][] edges = {{0,1},{0,2}};
        String[] grid = {""acca"",""bbbb"",""caca""};
        Solution solution = new Solution();
    }
}

class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        int n=nums.size();
        int[] l=new int[n+10];
        int[] r=new int[n+10];
        for(int i=0;i<n;++i){
            l[i]=1;
            if(i>0&&nums.get(i-1)<nums.get(i))
                l[i]=l[i-1]+1;
        }
        int ans=0;
        r[n]=0;
        for(int i=n-1;i>=0;--i) {
            r[i] = 1;
            if (i < n - 1 && nums.get(i + 1) > nums.get(i))
                r[i] = r[i + 1] + 1;
            ans = Math.max(ans, Math.min(l[i], r[i + 1]));
        }
        return ans;
    }
}",1448272998
Oone,Oone,310,3631,java,"import java.lang.reflect.InvocationHandler;
import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;

public class Main {
    public static void main(String[] args) {
        int[] nums1 = {3,4,5,1,6,7};
        long[] nums2 = {0, 2, 2};
        int[][] edges = {{0,1},{0,2}};
        String[] grid = {""acca"",""bbbb"",""caca""};
        Solution solution = new Solution();
        solution.countKReducibleNumbers(""1000"",2);
    }
}

class Solution {
    int mod = 1000000007, k, n;
    int[] num, cnt;
    long[][] dp;

    long DFS(int pos, int st, int op) {
        if (pos == -1) {
            if (cnt[st] < k)
                return 1;
            else return 0;
        }
        if (op == 0 && dp[pos][st] != -1) return dp[pos][st];
        int up = (op != 0 ? num[n - pos - 1] : 1);
        long ret = 0;
        for (int i = 0; i <= up; ++i)
            ret = (ret + DFS(pos - 1, st + (i == 1 ? 1 : 0), op & (i == up ? 1 : 0))) % mod;
        if (op == 0) dp[pos][st] = ret;
        return ret;
    }

    public int countKReducibleNumbers(String s, int k) {
        if(s.length()==1)return 0;
        n = s.length();
        this.k = k;
        cnt = new int[n + 10];
        num = new int[n + 10];
        dp = new long[n + 10][n + 10];
        cnt[0] = k + 1;
        for (int i = 0; i <= n; ++i)
            for (int j = 0; j <= n; ++j)
                dp[i][j] = -1;
        for (int i = 1; i <= n; ++i) {
            int tmp = i;
            int sum = 0;
            while (tmp != 1 && sum < k) {
                int tmp_ = tmp;
                tmp = 0;
                while (tmp_ != 0) {
                    tmp += tmp_ & 1;
                    tmp_ >>= 1;
                }
                sum++;
            }
            cnt[i] = sum;
        }
        int flag = 0;
        for (int i = 0; i < n; ++i)
            if (s.charAt(i) == '1') {
                num[i] = 1;
                flag++;
            } else num[i] = 0;
        return (int)(DFS(n - 1, 0, 1) - (cnt[flag] < k ? 1 : 0) + mod) % mod;
    }
}",1448242865
Oone,Oone,310,3646,java,"import java.lang.reflect.InvocationHandler;
import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;

public class Main {
    public static void main(String[] args) {
        int[] nums1 = {1,2,1};
        long[] nums2 = {0, 2, 2};
        int[][] edges = {{0,1},{0,2}};
        String[] grid = {""acca"",""bbbb"",""caca""};
        Solution solution = new Solution();
        solution.sumOfGoodSubsequences(nums1);
    }
}

class Solution {
    public int sumOfGoodSubsequences(int[] nums) {
        int mod = 1000000007;
        HashMap<Integer, Long> map = new HashMap<>();
        int n = nums.length;
        long[] l = new long[n + 10];
        for (int i = 0; i < n; ++i) {
            l[i] = ((map.getOrDefault(nums[i] - 1, 0L) + map.getOrDefault(nums[i] + 1, 0L)) % mod + 1) % mod;
            map.put(nums[i], (map.getOrDefault(nums[i], 0L) + l[i]) % mod);
        }
        long ans = 0;
        map.clear();
        for (int i = n - 1; i >= 0; --i) {
            long tmp = ((map.getOrDefault(nums[i] - 1, 0L) + map.getOrDefault(nums[i] + 1, 0L)) % mod + 1) % mod;
            ans = (ans + nums[i] * l[i] % mod * tmp % mod) % mod;
            map.put(nums[i], (map.getOrDefault(nums[i], 0L) + tmp) % mod);
        }
        return (int) ans;
    }
}",1448263876
JOZLEETCODE,JLZ998112,311,3612,java,"class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> a, int len) {
        int n = a.size();
        int i = 0;
        while(i<n){
            int j = i+1;
            while(j<n && a.get(j)>a.get(j-1) && j-i<len){
                ++j;
            }
          //  System.out.println(i+""...""+j);
            int len1 = j-i;
            if(len1==len){
                int k = j+1;
                while(k<n && a.get(k)>a.get(k-1) && k-j<len){
                    ++k;
                }
            //    System.out.println(j+""...""+k);
                int len2 = k-j;
                if(len2==len){
                    return true;
                }
            }
            ++i;
        }
        return false;
    }
}",1448184359
JOZLEETCODE,JLZ998112,311,3619,java,"class Solution {
    public int maxIncreasingSubarrays(List<Integer> a) {
        int n = a.size();
        int[] end = new int[n];
        int[] start = new int[n];
        int i = 0;
        while(i<n){
            int j = i+1;
            while(j<n && a.get(j)>a.get(j-1)){
                ++j;
            }
            int len = j-i;
            for(int p = i; p<j; ++p){
                start[p] = len - (p-i);
                end[p] = (p-i)+1;
            }
            i = j;
        }
        int res = 0;
        for(i=0; i+1<n; ++i){
            int l1 = end[i];
            int l2 = start[i+1];
            int cur = Math.min(l1, l2);
            res = Math.max(res, cur);
        }
        return res;
    }
}",1448197698
JOZLEETCODE,JLZ998112,311,3631,java,"class Solution {
   private int[] reducible;
    private int limit = 900;
    private long Mod = (long) (1e9 + 7);
    private long[][][] dp;

    public int countKReducibleNumbers(String s, int k) {
        char[] c = s.toCharArray();
        int n = c.length;
        dp = new long[n][2][n + 1];
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < 2; ++j) {
                Arrays.fill(dp[i][j], -1);
            }
        }

        reducible = new int[limit + 10];
        reducible[1] = 1;
        for (int i = 2; i <= limit; ++i) {
            int cur = i;
            int ck = k - 1;
            while (cur > 1 && ck > 0) {
                int count = Integer.bitCount(cur);
                cur = count;
                --ck;
            }
            if (cur == 1) {
                reducible[i] = 1;
            }
        }

        long rt = solve(c, 0, 0, 0);
        return (int) rt;
    }

    private long solve(char[] c, int i, int sm, int bits) {
        int n = c.length;
        if (i == n) {
            return sm == 0 ? 0 : reducible[bits];
        }
        if (dp[i][sm][bits] != -1) {
            return dp[i][sm][bits];
        }
        int nsm = sm;
        if (sm == 0 && c[i] == '1') {
            nsm = 1;
        }
        long way1 = solve(c, i + 1, nsm, bits);
        long way2 = 0;
        if (sm == 0 && c[i] == '1') {
            way2 = solve(c, i + 1, sm, bits + 1);
        } else if (sm == 1) {
            way2 = solve(c, i + 1, sm, bits + 1);
        }
        long res = way1 + way2;
        res %= Mod;
        dp[i][sm][bits] = res;
        return res;
    }
}",1448270549
JOZLEETCODE,JLZ998112,311,3646,java,"class Solution {
    private long Mod = (long) (1e9 + 7);

    public int sumOfGoodSubsequences(int[] a) {
        int n = a.length;
        int maxv = 0;
        for (int ai : a) {
            maxv = Math.max(maxv, ai);
        }
        long[] dp = new long[maxv + 5];
        long[] count = new long[maxv + 5];
        for (int i = 0; i < n; ++i) {
            int v = a[i];
            if (v - 1 >= 0) {
                long cvm1 = count[v - 1];
                dp[v] += dp[v - 1] + cvm1 * v;
                dp[v] %= Mod;
                count[v] += cvm1;
                count[v] %= Mod;
            }
            long cvp1 = count[v + 1];
            dp[v] += dp[v + 1] + cvp1 * v;
            dp[v] %= Mod;
            count[v] += cvp1;
            count[v] %= Mod;
            dp[v] += v;
            dp[v] %= Mod;
            count[v] += 1;
            count[v] %= Mod;
        }
        long sum = 0;
        for (int i = 0; i < dp.length; ++i) {
            sum += dp[i];
            sum %= Mod;
        }
        return (int) sum;
    }
}",1448225601
sveng101,sveng101,314,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        incr_lens = []
        prev = float(""inf"")
        for i, num in enumerate(nums):
            incr_lens.append((incr_lens[-1] if num > prev else 0) + 1)
            if i >= k and incr_lens[i] >= k and incr_lens[i - k] >= k:
                return True
            #print(incr_lens)
            prev = num
        
        return False
                ",1448185003
sveng101,sveng101,314,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        incr_lens = []
        prev = float(""inf"")
        res = 0
        for i, num in enumerate(nums):
            incr_lens.append((incr_lens[-1] if num > prev else 0) + 1)
            prev = num
            res = max(res, incr_lens[-1] >> 1)
            if incr_lens[-1] <= i and incr_lens[i - incr_lens[-1]] >= incr_lens[-1]:
                res = max(res, incr_lens[-1])
        #print(incr_lens)
        return res",1448195004
sveng101,sveng101,314,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        md = 10 ** 9 + 7
        res = 0
        if not k: return 0 if s == ""1"" else 1
        
        n = len(s)

        op_cnt = [float(""inf""), 0]
        for num in range(2, n + 1):
            op_cnt.append(op_cnt[num.bit_count()] + 1)
        #print(op_cnt)

        seen_ones_cnt = 0
        res = 0
        for i, l in enumerate(s):
            if l == ""0"": continue
            n_bits = n - i - 1
            for n_ones in range(n_bits + 1):
                if op_cnt[n_ones + seen_ones_cnt] < k:
                    res = (res + math.comb(n_bits, n_ones)) % md
            #print(i, res)
            seen_ones_cnt += 1
        return res
        """"""
        bitcount_ops_cnts_cumu = [[0]]
        for n_bit in range(1, n):
            ops_cnt_cumu = []
            for n_ones in range(n_bit + 1):
                cnt = math.comb(n_bit, n_ones)
                while len(ops_cnt_cumu) <= op_cnt[n_ones] + 1:
                    ops_cnt_cumu.append(0)
                ops_cnt_cumu[op_cnt[n_ones] + 1] = (ops_cnt_cumu[op_cnt[n_ones] + 1] + cnt) % md
            #if len(ops_cnt_cumu) > 1:
            #    ops_cnt_cumu[1] -= 2
            #    ops_cnt_cumu[0] += 2
            while not ops_cnt_cumu[-1]:
                ops_cnt_cumu.pop()
            for i in range(1, len(ops_cnt_cumu)):
                ops_cnt_cumu[i] = (ops_cnt_cumu[i] + ops_cnt_cumu[i - 1]) % md
            bitcount_ops_cnts_cumu.append(ops_cnt_cumu)
        print(n, len(bitcount_ops_cnts_cumu))
        print(bitcount_ops_cnts_cumu[n - 1])
        res = 0 #bitcount_ops_cnts_cumu[n - 1][min(k, len(bitcount_ops_cnts_cumu[n - 1]) - 1)] - 1
        print(bitcount_ops_cnts_cumu)
        #print(res)
        cnt = 0
        for i, l in enumerate(s):
            if l == ""0"": continue
            res = (res + bitcount_ops_cnts_cumu[n - i - 1][min(k - cnt, len(bitcount_ops_cnts_cumu[n - i - 1]) - 1)]) % md
            print(i, res)
            cnt += 1
        
        return (res - 1) % md
        """"""",1448291593
sveng101,sveng101,314,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        md = 10 ** 9 + 7
        res = 0
        seen_cnts = {}
        seen_sms = {}
        for num in nums:
            cnt = (1 + seen_cnts.get(num - 1, 0) + seen_cnts.get(num + 1, 0)) % md
            sm = (seen_sms.get(num - 1, 0) + seen_sms.get(num + 1, 0) + cnt * num) % md
            seen_cnts[num] = (seen_cnts.get(num, 0) + cnt) % md
            seen_sms[num] = (seen_sms.get(num, 0) + sm) % md
            
        return sum(seen_sms.values()) % md",1448208639
VIV,VIkkY53,315,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        vector<int> v;
        int n = nums.size();
        for (int i = 0; i < n;) {
            int end = i + 1;
            while (end < n && nums[end - 1] < nums[end]) {
                end++;
            }
            v.push_back(end - i);
            i = end;
        }
        int ans = v[0] / 2;
        for (int i = 0; i < v.size() - 1; i++) {
            ans = max(ans, v[i + 1] / 2);
            ans = max(ans, min(v[i], v[i + 1]));
        }
        return ans >= k;
    }
};",1448188447
VIV,VIkkY53,315,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        vector<int> v;
        int n = nums.size();
        for (int i = 0; i < n;) {
            int end = i + 1;
            while (end < n && nums[end - 1] < nums[end]) {
                end++;
            }
            v.push_back(end - i);
            i = end;
        }
        int ans = v[0] / 2;
        for (int i = 0; i < v.size() - 1; i++) {
            ans = max(ans, v[i + 1] / 2);
            ans = max(ans, min(v[i], v[i + 1]));
        }
        return ans;
    }
};",1448187283
VIV,VIkkY53,315,3631,cpp,"class Solution {
public:
    typedef long long ll;
    int countKReducibleNumbers(string s, int k) {
       vector<vector<ll>> ncr(1001, vector<ll>(1001, 0));
        ll mod = 1e9 + 7;
        ncr[1][0] = 1;
        ncr[1][1] = 1;
        for (int i = 2; i <= 1000; i++) {
            ncr[i][0] = ncr[i][i] = 1;
            for (int j = 1; j < i; j++) {
                ncr[i][j] = ncr[i - 1][j] + ncr[i - 1][j - 1];
                ncr[i][j] %= mod;
            }
        }
        vector<ll> kred(800, 0);
        kred[0] = k + 1;
        kred[1] = 0;
        for (ll i = 2; i < 800; i++) {
            kred[i] = 1 + kred[__builtin_popcount(i)];
        }
        ll ans = 0;
        int n = s.size();
        ll alreadySB = 0;
        for (int i = 0; i < n - 1; i++) {
            if (s[i] == '1') {
                ll l = (n - i) - 1;
                for (ll j = 0; j <= l; j++) {
                    ll currSB = alreadySB + j;
                    ll cnt = ncr[l][j];
                    ans += (1 + kred[currSB] <= k ? cnt : 0);
                    ans %= mod;
                    // cout << i << "" "" << j << "" "" << cnt << "" "" << kred[currSB] << endl;
                }
                alreadySB++;
            } 
        }
        if (s[n - 1] == '1') {
            ans += (1 + kred[alreadySB] <= k ? 1 : 0);
            ans %= mod;
        }
        return ans;
    }
};",1448278245
VIV,VIkkY53,315,3646,cpp,"class Solution {
public:
    typedef long long ll;
    int sumOfGoodSubsequences(vector<int>& nums) {
        vector<ll> dp(1e5 + 1, 0);
        vector<ll> dpf(1e5 + 1, 0);
        ll mod = 1e9 + 7;
        dp[nums[0]] = nums[0];
        dpf[nums[0]] = 1;
        int n = nums.size();
        for (ll i = 1; i < n; i++) {
            ll a = nums[i];
            dp[a] += a + (a - 1 >= 0 ? (dp[a - 1] + (a * dpf[a - 1])) % mod : 0) + (a + 1 <= 1e5 ? (dp[a + 1] + (a * dpf[a + 1])) % mod : 0);
            dp[a] %= mod;
            dpf[a] += 1 + (a - 1 >= 0 ? dpf[a - 1] : 0) + (a + 1 <= 1e5 ? dpf[a + 1] : 0);
            dpf[a] %= mod;
        }
        ll ans = 0;
        for (int i = 0; i <= 1e5; i++) {
            if (dp[i]) {
                // cout << i << "" "" << dp[i] << "" "" << dpf[i] << endl;
            }
            ans += dp[i] % mod;
            ans %= mod;
        }
        return (int)ans;
    }
};",1448219456
Umesh Kumar,icosa,317,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        if(k == 1) return true;
        for(int i=0; i<nums.size()-2*k+1; i++){
            bool ok = true;
            for(int j=1; j<k; j++) if(nums[j+i] <= nums[j+i-1]) ok = false;
            for(int j=1; j<k; j++) if(nums[j+i+k] <= nums[j+i+k-1]) ok = false;
            if(ok) return true;
        }
        return false;
    }
};",1448186136
Umesh Kumar,icosa,317,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        nums.push_back(-1e9-7);
        int prev = 0, cur = 1, ans = 1;
        int n = nums.size();
        for(int i=1; i<n; i++){
            if(nums[i] > nums[i-1]){
                cur++;
            }
            else{
                ans = max(ans, min(prev, cur));
                ans = max(ans, cur/2);
                prev = cur;
                cur = 1;
            }
        }
        return ans;
    }
};",1448199686
Umesh Kumar,icosa,317,3631,cpp,"#define ll long long
#define FOR(i,l,r) for(int i=l; i<r; i++)
const ll mod = 1e9+7;
const int MAX = 807;
int red[MAX];

template <int MOD, int RT>
struct mint {
  static const int mod = MOD;
  static constexpr mint rt() { return RT; }  // primitive root for FFT
  int v;
  explicit operator int() const {
    return v;
  }  // explicit -> don't silently convert to int
  mint() : v(0) {}
  mint(ll _v) {
    v = int((-MOD < _v && _v < MOD) ? _v : _v % MOD);
    if (v < 0) v += MOD;
  }
  bool operator==(const mint &o) const { return v == o.v; }
  friend bool operator!=(const mint &a, const mint &b) { return !(a == b); }
  friend bool operator<(const mint &a, const mint &b) { return a.v < b.v; }
  friend void re(mint &a) {
    ll x;
    cin >> x;
    a = mint(x);
  }
  // friend str ts(mint a) { return ts(a.v); }

  mint &operator+=(const mint &o) {
    if ((v += o.v) >= MOD) v -= MOD;
    return *this;
  }
  mint &operator-=(const mint &o) {
    if ((v -= o.v) < 0) v += MOD;
    return *this;
  }
  mint &operator*=(const mint &o) {
    v = int((ll)v * o.v % MOD);
    return *this;
  }
  mint &operator/=(const mint &o) { return (*this) *= inv(o); }
  friend mint pow(mint a, ll p) {
    mint ans = 1;
    assert(p >= 0);
    for (; p; p /= 2, a *= a)
      if (p & 1) ans *= a;
    return ans;
  }
  friend mint inv(const mint &a) {
    assert(a.v != 0);
    return pow(a, MOD - 2);
  }

  mint operator-() const { return mint(-v); }
  mint &operator++() { return *this += 1; }
  mint &operator--() { return *this -= 1; }
  friend mint operator+(mint a, const mint &b) { return a += b; }
  friend mint operator-(mint a, const mint &b) { return a -= b; }
  friend mint operator*(mint a, const mint &b) { return a *= b; }
  friend mint operator/(mint a, const mint &b) { return a /= b; }
};

const ll MOD = 1e9 + 7;
using mi = mint<MOD, 5>;  // 5 is primitive root for both common mods
using vmi = vector<mi>;
using pmi = pair<mi, mi>;
using vpmi = vector<pmi>;

/**
 * Description: pre-compute factorial mod inverses,
 * assumes $MOD$ is prime and $SZ < MOD$.
 * Time: O(SZ)
 * Source: KACTL
 * Verification: https://dmoj.ca/problem/tle17c4p5
 */

vmi invs, fac, ifac;
void genFac(int SZ) {
  invs.resize(SZ), fac.resize(SZ), ifac.resize(SZ);
  invs[1] = fac[0] = ifac[0] = 1;
  FOR(i, 2, SZ) invs[i] = mi(-(ll)MOD / i * (int)invs[MOD % i]);
  FOR(i, 1, SZ) fac[i] = fac[i - 1] * i, ifac[i] = ifac[i - 1] * invs[i];
}
mi comb(int a, int b) {
  if (a < b || b < 0) return 0;
  return fac[a] * ifac[b] * ifac[a - b];
}

class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        genFac(MAX);
        red[1] = 0;
        for(int i=2; i<MAX; i++){
            red[i] = 1 + red[__builtin_popcount(i)];
        }

        ll ans = 0, n1 = 0;
        for(int i=0; i<s.size(); i++){
            char c = s[i];
            if(c == '1'){
                int m = s.size() - i - 1;
                for(int ones=(n1 > 0 ? 0 : 1); ones <= m; ones++){
                    if(red[n1 + ones] < k){
                        ans = (ans + (int)comb(m, ones)) % mod;
                    }
                }
                n1++;
            }
        }

        return ans;
    }
};",1448257772
Umesh Kumar,icosa,317,3646,cpp,"#define ll long long
const ll mod = 1e9+7;
const int MAX = 1e5+7;
ll dp[MAX], sdp[MAX];

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int n = nums.size();
        memset(dp, 0, sizeof(dp));
        memset(sdp, 0, sizeof(sdp));
        ll sum = 0;
        for(auto x: nums){
            ll cur = dp[x+1], scur = (dp[x+1] * x + sdp[x+1])%mod;
            if(x > 0) {
                cur += dp[x-1];
                scur = (scur + dp[x-1] * x + sdp[x-1]) % mod;
            }
            cur++;
            scur += x;
            sum = (sum + scur) % mod;
            dp[x] = (dp[x] + cur) % mod;
            sdp[x] = (sdp[x] + scur) % mod;
        }
        return sum;
    }
};",1448222393
Satj,Satj,318,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& a, int k) {
        int n = a.size();
        int prev = 0, cur = 0;
        int ret = 0;
        for (int i = 0; i < n; i++) {
            if (i == 0 || a[i - 1] >= a[i]) {
                ret = max({ret, min(prev, cur), prev / 2, cur / 2});
                prev = cur; cur = 1;
                continue ;
            }
            cur++;
        }
        ret = max({ret, min(prev, cur), prev / 2, cur / 2});
        return ret >= k;
    }
};",1448251322
Satj,Satj,318,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& a) {
        int n = a.size();
        int prev = 0, cur = 0;
        int ret = 0;
        for (int i = 0; i < n; i++) {
            if (i == 0 || a[i - 1] >= a[i]) {
                ret = max({ret, min(prev, cur), prev / 2, cur / 2});
                prev = cur; cur = 1;
                continue ;
            }
            cur++;
        }
        ret = max({ret, min(prev, cur), prev / 2, cur / 2});
        return ret;
    }
};",1448249013
Satj,Satj,318,3631,cpp,"
class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        init(s);
        long ret = 0;
        int shift = 0;
        vector <long> cnt(n + 1, 0);
        for (int i = 0; i < n; i++) {
            if (s[i] == '0') continue ;
            int p = n - i - 1;
            for (int j = 0; j <= p; j++)
                cnt[j + shift] = (cnt[j + shift] + comb[p][j]) % mod;
            shift++;
        }
        // for (int i = 0; i <= n; i++) cout << cnt[i] << "" ""; cout << endl;
        // for (int i = 0; i <= n; i++) cout << res[i] << "" ""; cout << endl;
        for (int i = 1; i <= n; i++) {
            if (res[i] + 1 <= k)
                ret = (ret + cnt[i]) % mod;
        }
        return ret;
    }
private:
    long comb[801][801] = {};
    long res[801] = {};
    int n;
    int mod = 1e9 + 7;
    int reduce(int x) {
        int ret = 0;
        while (x > 1) {
            x = __builtin_popcount(x);
            ret++;
        }
        return ret;
    }
    void init(string &s) {
        n = s.size();
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i; j++)
                comb[i][j] = (j == 0 || j == i) ? 1 : (comb[i - 1][j] + comb[i - 1][j - 1]) % mod;
        }
        for (int i = 0; i <= n; i++) {
            res[i] = reduce(i);
        }
    }
};",1448233021
Satj,Satj,318,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& a) {
        int mod = 1e9 + 7;
        int n = a.size();
        int m = *max_element(a.begin(), a.end());
        vector <long> tot(m + 1, 0);
        vector <long> cnt(m + 1, 0);
        long ret = 0;
        for (auto x : a) {
            // options 2 ? 
            int cur_cnt = 0;
            long cur_tot = 0;
            if (x - 1 >= 0) {
                cur_cnt = (cur_cnt + cnt[x - 1]) % mod;
                cur_tot = (cur_tot + cnt[x - 1] * x + tot[x - 1]) % mod;
            }
            if (x + 1 <= m) {
                cur_cnt = (cur_cnt + cnt[x + 1]) % mod;
                cur_tot = (cur_tot + cnt[x + 1] * x + tot[x + 1]) % mod;
            }
            cur_cnt += 1;
            cur_tot += x;
            ret = (ret + cur_tot) % mod;
            cnt[x] = (cur_cnt + cnt[x]) % mod;
            tot[x] = (cur_tot + tot[x]) % mod;
        }
        return ret;
    }
};",1448292234
Edeeva,KYR4,319,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& a, int k) {
        int n = a.size();
        for (int i = 0; i + 2 * k <= n; i++)
        {
            bool bad = false;
            int j = i + k;
            for (int x = i + 1; x < i + k; x++)
            {
                if (a[x] <= a[x - 1])
                {
                    bad = true;
                    break;
                }
            }
            for (int x = j + 1; x < j + k; x++)
            {
                if (a[x] <= a[x - 1])
                {   
                    bad = true;
                    break;
                }
            }
            if (!bad) return true;
        }
        return false;
    }
};",1448185628
Edeeva,KYR4,319,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& a) {
        int n = a.size();
        vector<int> bad; 
        bad.push_back(0);
        for (int i = 0; i + 1 < n; i++)
        {
            if (a[i] >= a[i + 1])
            {
                bad.push_back(i + 1);
            }
        }
        bad.push_back(n);
        int m = bad.size();
        int ans = 1;
        for (int i = 0; i + 2 < m; i++)
        {
            int x = bad[i + 1] - bad[i];
            int y = bad[i + 2] - bad[i + 1];
            ans = max(ans, min(x, y));
        }
        for (int i = 0; i + 1 < m; i++)
        {
            int x = bad[i + 1] - bad[i];
            ans = max(ans, x / 2);
        }
        return ans;
        
    }
};",1448195862
Edeeva,KYR4,319,3631,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp> 
#include <ext/pb_ds/tree_policy.hpp>
#define rep(i,a,b) for (int i = a; i < b; i++)
#define mp make_pair
#define pii pair<int,int> 
#define pb push_back
#define pll pair<long long, long long>
#define fi first
#define se second
#define speedboost ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0)
using namespace std;
using namespace __gnu_pbds;
typedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;
typedef tree<pair<int,int>, null_type,  less<pair<int,int>>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;
typedef vector<int> vi;
typedef vector<string> vs;
typedef vector<long long> vll;
typedef long long ll;
typedef long double ld;
ll mod = 1000000007;
const int N = 800;
const int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1};
const char dir[4]{'D','R','U','L'};
#define all(x) begin(x), end(x)
string yes = ""YES\n"";
string no = ""NO\n"";
int inf = 1e9;

vll fac(N + 1, 1);

ll power(ll base, ll ex)
{
    ll res = 1;
    ll x = base;
    ll y = ex;
    while (y > 0)
    {
        if (y & 1)
        {
            y--;
            res *= x;
            res %= mod;
        }
        else
        {
            y >>= 1;
            x = x* x;
            x %= mod;
        }
    }
    return res;
}

ll inverse(ll x)
{
    return power(x, mod - 2);
}
 
ll binomial(int n, int k) {
    return fac[n] * inverse(fac[k] * fac[n - k] % mod) % mod;
}

void cntfac()
{
    for (int i = 2; i <= N; i++)
    {
        fac[i] = fac[i - 1] * i;
        fac[i] %= mod;
    }
}

int n, m;
vector<int> pos;

ll cntans(int idx, int p)
{
   // cout << ""CNT "" << idx << ' ' << p << ""\n"";
    if (p == 0) return 1;
    int curpos = pos[idx];
    ll add = 0;
    if (curpos >= p)
    {
        add += binomial(curpos, p);
       // cout << ""ADD BINOM "" << add << ""\n"";
    }
    if (idx != m - 1)
    {
        ll rec = cntans(idx + 1, p - 1);
        add += rec;
        add %= mod;
        cout << ""ADD P-1 "" << rec << ""\n""; 
    }
    return add;
}

class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        cntfac(); pos.clear();
        ll ans = 0;
        int n = s.size();
        vector<int> need(n + 1);
        need[1] = 1;
        for (int i = 2; i <= n; i++)
        {
            need[i] = need[__builtin_popcount(i)] + 1;
            //cout << i << "" NEED "" << need[i] << ""\n"";
        }
        int curbit = 0;
        for (int i = n - 1; i >= 0; i--)
        {
            if (s[i] == '1')
            {
                pos.pb(curbit);
            }
            curbit++;
        }
        m = pos.size();
        reverse(all(pos));
        for (int p = 1; p <= n; p++)
        {
            if (need[p] <= k)
            {
                ans += cntans(0, p);
                ans %= mod;
            }
        }
        int ret = ans;
        return ret;
    }
};",1448272618
Edeeva,KYR4,319,3646,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp> 
#include <ext/pb_ds/tree_policy.hpp>
#define rep(i,a,b) for (int i = a; i < b; i++)
#define mp make_pair
#define pii pair<int,int> 
#define pb push_back
#define pll pair<long long, long long>
#define fi first
#define se second
#define speedboost ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0)
using namespace std;
using namespace __gnu_pbds;
typedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;
typedef tree<pair<int,int>, null_type,  less<pair<int,int>>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;
typedef vector<int> vi;
typedef vector<string> vs;
typedef vector<long long> vll;
typedef long long ll;
typedef long double ld;
ll mod = 1000000007;
const int N = 200000;
const int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1};
const char dir[4]{'D','R','U','L'};
#define all(x) begin(x), end(x)
string yes = ""YES\n"";
string no = ""NO\n"";
int inf = 1e9;
ll V = 100050;

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        vector<ll> ways(V + 1, 0);
        vector<ll> sum(V + 1, 0);
        for (ll x : nums)
        {
            ll curway = 1;
            ll cursum = x;
            curway += ways[x];
            cursum += sum[x];
            curway %= mod; cursum %= mod;
            if (x > 0)
            {
                curway += ways[x - 1];
                cursum += (sum[x - 1] + (ways[x - 1] * x));
                curway %= mod; cursum %= mod;
            }
            curway += ways[x + 1];
            cursum += (sum[x + 1] + (ways[x + 1] * x));
            curway %= mod; cursum %= mod;
            ways[x] = curway;
            sum[x] = cursum;
        }
        ll ans = 0;
        for (int v = 0; v <= V; v++) {
            ans = (ans + sum[v]) % mod;
        }
        return ans;
    }
};",1448225369
phongtran82148,phongtran82148,320,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        vector<int> arr;
        int cur = 1;
        for (int i = 1; i < nums.size(); i++) {
            if (nums[i] > nums[i - 1]) {
                cur++;
            } else {
                arr.push_back(cur);
                cur = 1;
            }
        }
        arr.push_back(cur);
        int output = 0;
        for (int i = 0; i < arr.size(); i++) {
            output = max(output, arr[i]);
        }
        output /= 2;
        for (int i = 1; i < arr.size(); i++) {
            output = max(output, min(arr[i], arr[i - 1]));
        }
        return (k <= output);
    }
};",1448185403
phongtran82148,phongtran82148,320,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        vector<int> arr;
        int cur = 1;
        for (int i = 1; i < nums.size(); i++) {
            if (nums[i] > nums[i - 1]) {
                cur++;
            } else {
                arr.push_back(cur);
                cur = 1;
            }
        }
        arr.push_back(cur);
        int output = 0;
        for (int i = 0; i < arr.size(); i++) {
            output = max(output, arr[i]);
        }
        output /= 2;
        for (int i = 1; i < arr.size(); i++) {
            output = max(output, min(arr[i], arr[i - 1]));
        }
        return output;
    }
};",1448184155
phongtran82148,phongtran82148,320,3631,cpp,"class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        int N = 1000000007;
        vector<long long> cmb(1, 1);
        vector<long long> cnt(801, 0);
        int bts = 0;
        long long output = 0;
        for (int i = 0; i < s.size(); i++) bts += (s[i] - '0');
        for (int i = s.size() - 1; i >= 0; i--) {
            if (s[i] == '1') {
                bts--;
                for (int j = 0; j < cmb.size(); j++) {
                    cnt[bts + j] = (cnt[bts + j] + cmb[j]) % N;
                }
            }
            cmb.push_back(0);
            for (int j = cmb.size() - 1; j >= 1; j--) {
                cmb[j] = (cmb[j] + cmb[j - 1]) % N;
            }
        }
        for (int i = 1; i < cnt.size(); i++) {
            int kk = 0;
            int t = i;
            while (t > 1) {
                int tt = t;
                int ss = 0;
                while (tt > 0) {
                    ss += (tt % 2 != 0) ? 1 : 0;
                    tt /= 2;
                }
                t = ss;
                kk++;
            }
            if (kk <= k - 1) output = (output + cnt[i]) % N;
        }
        // for (int i = 0; i < 30; i++) cout << cnt[i] << "" "";
        // cout << endl;
        return output;
    }
};

",1448292796
phongtran82148,phongtran82148,320,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int N = 1000000007;
        vector<long long> cnt(100004, 0);
        vector<long long> sm(100004, 0);
        long long output = 0;
        for (int i = nums.size() - 1; i >= 0; i--) {
            long long tmp = (cnt[nums[i] + 1] + (nums[i] > 0 ? cnt[nums[i] - 1] : 0) + 1) % N;
            cnt[nums[i]] = (cnt[nums[i]] + tmp) % N;
            long long tmp2 = (sm[nums[i] + 1] + (nums[i] > 0 ? sm[nums[i] - 1] : 0) + tmp * nums[i]) % N;
            sm[nums[i]] = (sm[nums[i]] + tmp2) % N;
            output = (output + tmp2) % N;
        }
        return output;
    }
};\",1448244862
Kalix1110,Kalix1110,321,3612,cpp,"
/*
	Name :- Tafheem Ahemad
	its always me vs me
*/
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
template <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

template<typename A,typename B>istream&operator>>(istream&is,pair<A,B>&p){is>>p.first>>p.second;return is;}
template<typename A,typename B>ostream&operator<<(ostream&os,pair<A,B>p){os<<p.first<<' '<<p.second<<endl;return os;}
template<typename T>istream&operator>>(istream&is,vector<T>&vc){for(T&x:vc)is>>x;return is;}
template<typename T>ostream&operator<<(ostream&os,vector<T>vc){for(int i=0;i<(int)vc.size();i++)os<<vc[i]<<"" "";return os;}

#define ll long long int
#define ld long double
#define F first
#define S second
#define vl vector<ll>
#define vi vector<int>
#define vb vector<bool>
#define vs vector<string>
#define vll vector<vl>
#define vii vector<vi>
#define pii pair<int,int>
#define pll pair<ll,ll>
#define ump unordered_map
#define all(v) v.begin(),v.end()
#define take_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cin>>a[i][j];}}
#define print_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cout<<a[i][j]<<' ';}cout<<endl;}
#define yes(x) if(x) cout<<""YES""<<endl; else cout<<""NO""<<endl;
#define cl(n) for(int i=0;i<=n+5;i++) g[i].clear()
#define memset(arr,val) memset(arr,val,sizeof(arr))
#define bpc(x) __builtin_popcountll(x)
#define __lcm(a,b) (a/__gcd(a, b)*b)
#define pq_max priority_queue<ll>
#define pq_min priority_queue<ll,vl,greater<ll>>
#define in insert
#define pb push_back
#define fast() ios::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);cout.precision(numeric_limits<double>::max_digits10);
mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
const int MOD=1e9+7;
vector<vector<ll>>delta1={{1,0},{-1,0},{0,-1},{0,1}};
vector<vector<ll>>delta2={{1,0},{-1,0},{0,-1},{0,1},{1,1},{-1,1},{1,-1},{-1,-1}};


class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        ll n=nums.size();
        vl dp1(n,0);
        vl dp2(n,0);
        
        dp1[0]=1;
        for(int i=1;i<n;i++){
            if(nums[i]>nums[i-1]){
                dp1[i]=dp1[i-1]+1;
            }else{
                dp1[i]=1;
            }
        }
        
        dp2[n-1]=1;
        for(int i=n-2;i>=0;i--){
            if(nums[i]<nums[i+1]){
                dp2[i]=dp2[i+1]+1;
            }else{
                dp2[i]=1;
            }
        }
        
        ll mx=0;
        for(int i=0;i<n-1;i++){
            if(min(dp1[i],dp2[i+1]) >= k) return 1;
        }
        
        return 0;
    }
};",1448189378
Kalix1110,Kalix1110,321,3619,cpp,"/*
	Name :- Tafheem Ahemad
	its always me vs me
*/
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
template <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

template<typename A,typename B>istream&operator>>(istream&is,pair<A,B>&p){is>>p.first>>p.second;return is;}
template<typename A,typename B>ostream&operator<<(ostream&os,pair<A,B>p){os<<p.first<<' '<<p.second<<endl;return os;}
template<typename T>istream&operator>>(istream&is,vector<T>&vc){for(T&x:vc)is>>x;return is;}
template<typename T>ostream&operator<<(ostream&os,vector<T>vc){for(int i=0;i<(int)vc.size();i++)os<<vc[i]<<"" "";return os;}

#define ll long long int
#define ld long double
#define F first
#define S second
#define vl vector<ll>
#define vi vector<int>
#define vb vector<bool>
#define vs vector<string>
#define vll vector<vl>
#define vii vector<vi>
#define pii pair<int,int>
#define pll pair<ll,ll>
#define ump unordered_map
#define all(v) v.begin(),v.end()
#define take_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cin>>a[i][j];}}
#define print_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cout<<a[i][j]<<' ';}cout<<endl;}
#define yes(x) if(x) cout<<""YES""<<endl; else cout<<""NO""<<endl;
#define cl(n) for(int i=0;i<=n+5;i++) g[i].clear()
#define memset(arr,val) memset(arr,val,sizeof(arr))
#define bpc(x) __builtin_popcountll(x)
#define __lcm(a,b) (a/__gcd(a, b)*b)
#define pq_max priority_queue<ll>
#define pq_min priority_queue<ll,vl,greater<ll>>
#define in insert
#define pb push_back
#define fast() ios::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);cout.precision(numeric_limits<double>::max_digits10);
mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
const int MOD=1e9+7;
vector<vector<ll>>delta1={{1,0},{-1,0},{0,-1},{0,1}};
vector<vector<ll>>delta2={{1,0},{-1,0},{0,-1},{0,1},{1,1},{-1,1},{1,-1},{-1,-1}};


class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        ll n=nums.size();
        vl dp1(n,0);
        vl dp2(n,0);
        
        dp1[0]=1;
        for(int i=1;i<n;i++){
            if(nums[i]>nums[i-1]){
                dp1[i]=dp1[i-1]+1;
            }else{
                dp1[i]=1;
            }
        }
        
        dp2[n-1]=1;
        for(int i=n-2;i>=0;i--){
            if(nums[i]<nums[i+1]){
                dp2[i]=dp2[i+1]+1;
            }else{
                dp2[i]=1;
            }
        }
        
        ll mx=0;
        for(int i=0;i<n-1;i++){
            mx=max(mx,min(dp1[i],dp2[i+1]));
        }
        
        return mx;
    }
};",1448185931
Kalix1110,Kalix1110,321,3631,cpp,"/*
	Name :- Tafheem Ahemad
	its always me vs me
*/
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
template <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

template<typename A,typename B>istream&operator>>(istream&is,pair<A,B>&p){is>>p.first>>p.second;return is;}
template<typename A,typename B>ostream&operator<<(ostream&os,pair<A,B>p){os<<p.first<<' '<<p.second<<endl;return os;}
template<typename T>istream&operator>>(istream&is,vector<T>&vc){for(T&x:vc)is>>x;return is;}
template<typename T>ostream&operator<<(ostream&os,vector<T>vc){for(int i=0;i<(int)vc.size();i++)os<<vc[i]<<"" "";return os;}

#define ll long long int
#define ld long double
#define F first
#define S second
#define vl vector<ll>
#define vi vector<int>
#define vb vector<bool>
#define vs vector<string>
#define vll vector<vl>
#define vii vector<vi>
#define pii pair<int,int>
#define pll pair<ll,ll>
#define ump unordered_map
#define all(v) v.begin(),v.end()
#define take_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cin>>a[i][j];}}
#define print_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cout<<a[i][j]<<' ';}cout<<endl;}
#define yes(x) if(x) cout<<""YES""<<endl; else cout<<""NO""<<endl;
#define cl(n) for(int i=0;i<=n+5;i++) g[i].clear()
#define memset(arr,val) memset(arr,val,sizeof(arr))
#define bpc(x) __builtin_popcountll(x)
#define __lcm(a,b) (a/__gcd(a, b)*b)
#define pq_max priority_queue<ll>
#define pq_min priority_queue<ll,vl,greater<ll>>
#define in insert
#define pb push_back
#define fast() ios::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);cout.precision(numeric_limits<double>::max_digits10);
mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
const int MOD=1e9+7;
vector<vector<ll>>delta1={{1,0},{-1,0},{0,-1},{0,1}};
vector<vector<ll>>delta2={{1,0},{-1,0},{0,-1},{0,1},{1,1},{-1,1},{1,-1},{-1,-1}};

class Solution {
public:
    ll n;
    string s;
    ll dp[800+5][900+2][2];
    ll countLexicographicallySmallest(int pos, int count, bool tight) {
        if(count<0) return 0;
    if (pos == n) {

        return count == 0 ? 1 : 0;
    }
    
    if (dp[pos][count][tight] != -1) {
        return dp[pos][count][tight];
    }

    ll limit = tight ? (s[pos] - '0') : 1;
    ll totalWays = 0;

    for (int digit = 0; digit <= limit; digit++) {
        int newCount = count - digit;
        
            totalWays += countLexicographicallySmallest(pos + 1, newCount, tight && (digit == limit));
            totalWays%=MOD;

    }

    return dp[pos][count][tight] = totalWays%MOD;
}
    
    ll step(ll x){
        ll c=0;
        while(x>1){
            x=bpc(x);
            c++;
        }
        
        return c;
    }
    int countKReducibleNumbers(string _s, int k) {
        s=_s;
        n=s.size();
        ll ans=0;
        memset(dp,-1);
        ll c=0;
        for(auto &it:s){
            if(it=='1') c++;
        }
        
        // ll x=0;
        for(int i=1;i<=900;i++){
            int st=step(i);
            if(st<k){
                
                ans+=countLexicographicallySmallest(0,i,1);
                if(c==i) ans--;
                ans=(ans+MOD)%MOD;
                
                // x++;
            }
        }
        
        // cout<<x<<endl;
        return ans;
    }
};",1448279411
Kalix1110,Kalix1110,321,3646,cpp,"/*
	Name :- Tafheem Ahemad
	its always me vs me
*/
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
template <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

template<typename A,typename B>istream&operator>>(istream&is,pair<A,B>&p){is>>p.first>>p.second;return is;}
template<typename A,typename B>ostream&operator<<(ostream&os,pair<A,B>p){os<<p.first<<' '<<p.second<<endl;return os;}
template<typename T>istream&operator>>(istream&is,vector<T>&vc){for(T&x:vc)is>>x;return is;}
template<typename T>ostream&operator<<(ostream&os,vector<T>vc){for(int i=0;i<(int)vc.size();i++)os<<vc[i]<<"" "";return os;}

#define ll long long int
#define ld long double
#define F first
#define S second
#define vl vector<ll>
#define vi vector<int>
#define vb vector<bool>
#define vs vector<string>
#define vll vector<vl>
#define vii vector<vi>
#define pii pair<int,int>
#define pll pair<ll,ll>
#define ump unordered_map
#define all(v) v.begin(),v.end()
#define take_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cin>>a[i][j];}}
#define print_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cout<<a[i][j]<<' ';}cout<<endl;}
#define yes(x) if(x) cout<<""YES""<<endl; else cout<<""NO""<<endl;
#define cl(n) for(int i=0;i<=n+5;i++) g[i].clear()
#define memset(arr,val) memset(arr,val,sizeof(arr))
#define bpc(x) __builtin_popcountll(x)
#define __lcm(a,b) (a/__gcd(a, b)*b)
#define pq_max priority_queue<ll>
#define pq_min priority_queue<ll,vl,greater<ll>>
#define in insert
#define pb push_back
#define fast() ios::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);cout.precision(numeric_limits<double>::max_digits10);
mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
const int MOD=1e9+7;
vector<vector<ll>>delta1={{1,0},{-1,0},{0,-1},{0,1}};
vector<vector<ll>>delta2={{1,0},{-1,0},{0,-1},{0,1},{1,1},{-1,1},{1,-1},{-1,-1}};

   
class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        ll n = nums.size();
        ll sum=0;
        
        map<ll,ll>mp;
        map<ll,ll>mp2;
        for(int i=0;i<n;i++){
            ll a=mp[nums[i]-1];
            a+=mp[nums[i]+1];
            a++;
            a%=MOD;
            
            ll s1=mp2[nums[i]-1];
            s1+=mp2[nums[i]+1];
            s1%=MOD;
            
            
            ll p=((a*nums[i])%MOD + s1%MOD)%MOD;
            sum+=p;
            sum%=MOD;
            // cout<<p<<endl;
            
            mp[nums[i]]+=a;
            mp2[nums[i]]+=p;
        }
        
        
        // cout<<""*****""<<endl;
        return sum;
    }
};",1448244413
Aniket Saini,Ani_S,323,3612,java,"class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        for(int i = 0; i < nums.size() - (2 * k) + 1; i++) {
            int j = i + k;
            boolean possible = true;
            
            for(int z = 1; z < k; z++) {
                if(nums.get(i + z) <= nums.get(i + z - 1) || nums.get(j + z) <= nums.get(j + z - 1)) {
                    possible = false;
                    break;
                }
            }
            
            if(possible)
                return true;
        }
        
        return false;
    }
}",1448186091
Aniket Saini,Ani_S,323,3619,java,"class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        Stack<Integer> stack = new Stack<>();
        int lastPossible = 0;
        int ans = 0;
        
        for(int i = 0; i < nums.size(); i++) {
            if(stack.isEmpty() || stack.peek() < nums.get(i)) {
                stack.push(nums.get(i));
            } else {
                int size = stack.size();
                
                ans = Math.max(ans, size / 2);
                ans = Math.max(ans, Math.min(size, lastPossible));
                lastPossible = size;
                
                stack.clear();
                
                stack.push(nums.get(i));
            }
        }
        
        if(!stack.isEmpty()) {
            int size = stack.size();
                
            ans = Math.max(ans, size / 2);
            ans = Math.max(ans, Math.min(size, lastPossible));
            lastPossible = size;

            stack.clear();
        }
        
        return ans;
    }
}",1448200475
Aniket Saini,Ani_S,323,3631,java,"class Solution {
    static int mod = 1000000007;
    
    Boolean dp[][];
    Long memo[][][];
    
    public int countKReducibleNumbers(String s, int k) {
        
        dp = new Boolean[s.length() + 1][k + 1];
        memo = new Long[s.length()][s.length() + 1][2];
        
        for(int i = 1; i <= s.length(); i++) {
            isKReducible(i, k);
        }
        
        return (int)countPossible(s.toCharArray(), 0, 0, 0, k);
    }
    
    private long countPossible(char arr[], int i, int count, int smaller, int k) {
        if(i == arr.length)
        {
            if(smaller > 0 && isKReducible(count, k)) {
                // System.out.println(count);
                return 1l;
            } else {
                return 0l;
            }
        }
        
        if(memo[i][count][smaller] != null)
            return memo[i][count][smaller];
        
        long ans = 0;
        ans = (ans + countPossible(arr, i + 1, count + (arr[i] == '1' ? 1 : 0), smaller, k)) % mod;
        
        if(arr[i] == '0') {
            if(smaller > 0) {
                ans = (ans + countPossible(arr, i + 1, count + 1, smaller, k)) % mod;
            }
        } else {
            ans = (ans + countPossible(arr, i + 1, count, 1, k)) % mod;
        }
        
        return memo[i][count][smaller] = ans;
    } 
    
    private boolean isKReducible(int num, int k) {
        if(k == 0)
            return false;
        
        if(dp[num][k] != null)
            return dp[num][k];
        
        if(num == 1)
            return dp[num][k] = true;
        
        return dp[num][k] = isKReducible(Integer.bitCount(num), k - 1);
    }
}",1448279600
Aniket Saini,Ani_S,323,3646,java,"class Solution {
    static int mod = 1000000007;
    public int sumOfGoodSubsequences(int[] nums) {
        Map<Integer, Long> map = new HashMap<>();
        long left[] = new long[nums.length];
        
        long sum = 0;
        
        for(int i = 0; i < nums.length; i++) {
            int num = nums[i];
            
            // Case of num - 1
            long cntMinus1 = map.getOrDefault(num - 1, 0l);
            
            // Case of num + 1
            long cntPlus1 = map.getOrDefault(num + 1, 0l);
            
            left[i] = (cntPlus1 + cntMinus1 + 1) % mod;
            
            map.put(num, (map.getOrDefault(num, 0l) + left[i]) % mod);
            
            // System.out.print(left[i] + "" "");
        }
        
        // System.out.println();
        
        map = new HashMap<>();
        long right[] = new long[nums.length];
        
        for(int i = nums.length - 1; i >= 0; i--) {
            int num = nums[i];
            
            // Case of num - 1
            long cntMinus1 = map.getOrDefault(num - 1, 0l);
            
            // Case of num + 1
            long cntPlus1 = map.getOrDefault(num + 1, 0l);
            
            right[i] = (cntPlus1 + cntMinus1 + 1) % mod;
            
            map.put(num, (map.getOrDefault(num, 0l) + right[i]) % mod);
        }
        
//         for(int i = 0; i < nums.length; i++)
//             System.out.print(right[i] + "" "");
        
//         System.out.println();
        
        for(int i = 0; i < nums.length; i++) {
            long freq = (left[i] * right[i]) % mod;
            sum = (sum + (freq * nums[i]) % mod) % mod;
        }
        
        
        return (int)sum;
    }
}",1448250150
lihaicoder,lihaicoder,325,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        prevlen = 0
        prevnum = nums[0] + 1
        thislen = 0
        ans = 0
        maxlen = 0
        for i, num in enumerate(nums):
            if num > prevnum:
                thislen += 1
            else:
                prevlen = thislen
                thislen = 1
            ans = max(ans, min(prevlen, thislen))
            maxlen = max(maxlen, thislen)
            # print(i, num, prevnum, thislen, prevlen)
            prevnum = num
        ans = max(ans, maxlen // 2)
        return ans >= k
                ",1448190136
lihaicoder,lihaicoder,325,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        prevlen = 0
        prevnum = nums[0] + 1
        thislen = 0
        ans = 0
        maxlen = 0
        for i, num in enumerate(nums):
            if num > prevnum:
                thislen += 1
            else:
                prevlen = thislen
                thislen = 1
            ans = max(ans, min(prevlen, thislen))
            maxlen = max(maxlen, thislen)
            # print(i, num, prevnum, thislen, prevlen)
            prevnum = num
        return max(ans, maxlen // 2)
                ",1448189533
lihaicoder,lihaicoder,325,3631,python3,"from functools import cache

class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        mod = 1_000_000_007
        
        @cache
        def red(num):
            if num == 1:
                return 0
            return red(num.bit_count()) + 1
        n = len(s)
        f = [[0]*2 for _ in range(n+1)]
        f[1][0] = 1
        f[0][1] = 1
        for i in range(1, n):
            # print(f)
            newf = [[0]*2 for _ in range(n+1)]
            for used in range(n):
                for skipped in [0, 1]:
                    f[used][skipped] %= mod
                    if f[used][skipped] == 0:
                        continue
                    this = f[used][skipped]
                    if skipped:
                        newf[used+1][1] += this
                        newf[used][1] += this
                    else:
                        if s[i] == ""1"":
                            newf[used][1] += this
                            newf[used + 1][0] += this
                        else:
                            newf[used][0] += this
            f = newf
        # print(f)
        ans = 0
        for used in range(1, n + 1):
            if red(used) + 1 <= k:
                # print(""used"", used, red(used))
                for skipped in [0, 1]:
                    this = f[used][skipped] % mod
                    ans = (ans + this) % mod
        # print(""-""*10)
        # if ans == 0:
            # return 0
        if red(s.count(""1"")) + 1 <= k:
            ans -= 1
        return ans

        
#         @cache
#         def f(idx, used, skipped):
#             if idx == 0:
#                 if used == 1 and not skipped:
#                     return 1
#                 if used == 0 and skipped:
#                     return 1
#                 return 0
#             ans = 0
#             if s[idx] == ""0"":
                
                
#             ans %= mod
#             return ans


        
                
            
",1448280793
lihaicoder,lihaicoder,325,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        mod = 1_000_000_007
        f = defaultdict(int)
        s = defaultdict(int)
        # f[0] = 1
        for num in nums:
            adds = num + s[num-1] + num * f[num-1] + s[num + 1] + num * f[num + 1]
            adds %= mod
            s[num] = (s[num] + adds) % mod
            f[num] += (1 + f[num-1] + f[num+1])
            # print(num, dict(s), dict(f))
        return sum(s.values()) % mod",1448213129
Palash Agrawal,Golu-bhai,326,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        int dp[n];
        dp[0]=1;
        int ans =1;
        for(int i=1;i<n;i++){
            if(nums[i-1]<nums[i]) dp[i]=1+dp[i-1];
            else dp[i]=1;
            ans = max(ans, dp[i]/2);
            int p = i-dp[i];
            if(p>=0 and dp[p]>=dp[i])ans =max(ans, dp[i]);
        }
        return ans>=k;
    }
};",1448189901
Palash Agrawal,Golu-bhai,326,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        int dp[n];
        dp[0]=1;
        int ans =1;
        for(int i=1;i<n;i++){
            if(nums[i-1]<nums[i]) dp[i]=1+dp[i-1];
            else dp[i]=1;
            ans = max(ans, dp[i]/2);
            int p = i-dp[i];
            if(p>=0 and dp[p]>=dp[i])ans =max(ans, dp[i]);
        }
        return ans;
    }
};",1448188201
Palash Agrawal,Golu-bhai,326,3631,cpp,"#define ll long long
const int mx = 1000;
class Solution {
    
    const ll M = 1e9+7;
    
    ll facInv[mx + 1], natInv[mx + 1], fact[mx + 1];

    void invNum(ll p) {
        natInv[0] = natInv[1] = 1;
        for (int i = 2; i <= mx; i++)
            natInv[i] = natInv[p % i] * (p - p / i) % p;
    }

    void invFac(ll p) {
        facInv[0] = facInv[1] = 1;
        for (int i = 2; i <= mx; i++)
            facInv[i] = (natInv[i] * facInv[i - 1]) % p;
    }

    void factorial(ll p) {
        fact[0] = 1;
        for (int i = 1; i <= mx; i++) 
            fact[i] = (fact[i - 1] * i) % p;
    }

    ll comb(ll n, ll r, ll p) {
        return ((fact[n] * facInv[r]) % p * facInv[n - r]) % p;
    }
    
    int calc(int num){
        int k =0;
        while(num>1){
            int cnt =0;
            int temp = num;
            while(temp){
                if(temp%2) cnt++;
                temp/=2;
            }
            k++;
            num = cnt;
        }
        return k;
    }
    ll help(vector<int>&freq, int rem, int pr, int k){
        ll ans =0;
        ll p = 1000000007;
        for(int i=0;i<=rem;i++){
            if(pr ==0 and i==0) continue;
            if((freq[pr+i]+1)>k) continue;
            if(i==0) {ans++;continue;}
            (ans+=comb(rem, i, p))%=M;
        }
        return ans;
    }

public:
    int countKReducibleNumbers(string s, int k) {
        ll p = 1000000007;
        invNum(p);
        invFac(p);
        factorial(p);
        vector<int>freq(801);
        
        for(int i =1;i<=800;i++){
            freq[i]=calc(i);
        }
        int pr =0, n = s.size();
        ll ans =0;
        int i =0;
        while(i<n){
            while(i<n and s[i]=='0'){
                i++;
            }
            if(i==n) break;
            (ans+=help(freq, (n-i-1), pr, k))%=M;
            pr++;
            i++;
        }
        return ans;
    }
};",1448287724
Palash Agrawal,Golu-bhai,326,3646,cpp,"typedef long long ll;
class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int n = nums.size();
        const int M = 1e9+7;
        int mx = 1e5+3;
        vector<ll>dp(mx, 0), dpi(n, 0);
        ll ans =0;
        for(int i=0;i<n;i++){
            ll x = dp[nums[i]+1] + 1;
            if(nums[i]) x+=dp[nums[i]-1];
            dpi[i]=(x)%M;
            //cout<<i<<endl;
            dp[nums[i]]+=dpi[i];
            //cout<<nums[i]<<"" ""<<dp[nums[i]]<<endl;
            
        }
        dp.assign(dp.size(), 0);
        for(int i = n-1;i>=0;i--){
            ll x = dp[nums[i]+1] + 1;
            if(nums[i]) x+=dp[nums[i]-1];
            ll rt = (x)%M;
            //cout<<dpi[i]<<"" ""<<rt<<"" ""<<nums[i]<<endl;
            ll cadd=(dpi[i]*rt)%M;
            (cadd*=nums[i])%=M;
            (ans+=cadd)%=M;
            (dp[nums[i]]+=rt)%=M;
        }
        return ans;
    }
};",1448236497
Tim Lu,Casterkiller,328,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        N = len(nums)
        for i in range(N):
            if i + 2 * k <= N:
                start = nums[i]
                fail = False
                for j in range(1, k):
                    ni = i + j
                    if nums[ni] <= nums[ni - 1]:
                        fail = True
                        break
                if fail:
                    continue
                start = nums[i + k]
                for j in range(1, k):
                    ni = i + k + j
                    if nums[ni] <= nums[ni - 1]:
                        fail = True
                        break
                if not fail:
                    return True

        return False
                    ",1448184545
Tim Lu,Casterkiller,328,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        N = len(nums)
        ps = [1] * N

        for i in range(1, N):
            ps[i] = ps[i - 1] + 1 if nums[i] > nums[i - 1] else 1

        # print(ps)

        best = 0
        for i in range(1, N):
            r = ps[i]
            if i - r >= 0:
                best = max(best, min(ps[i - r], r))
            best = max(best, r // 2)

        return best",1448194321
Tim Lu,Casterkiller,328,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        M = 10 ** 9 + 7
        k -= 1

        count = sum(1 if c == '1' else 0 for c in s)

        @cache
        def go(cnt, step):
            if cnt == 1:
                return 1
            if step == 0 or cnt == 0:
                return 0

            return go(cnt.bit_count(), step - 1)
            
        # print('count', count)
        rs = list(reversed(s))
        total = 0
        # print('init total', total)
        ones = 0
        for i in range(len(rs)):
            if rs[i] == '1':
                ones += 1

                total += 1 if go(count - ones, k) else 0
                for j in range(1, i + 1):
                    total += comb(i, j) if go(count - ones + j, k) else 0
                    total %= M
                total %= M
                # print(i, total)

        # 1010100010100
        # 111
        
        return total",1448294549
Tim Lu,Casterkiller,328,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        M = 10 ** 9 + 7
        lookup = defaultdict(int)
        count = Counter()

        total = 0
        for n in nums:
            s = lookup[n - 1] + lookup[n + 1] + (1 + count[n - 1] + count[n + 1]) * n
            lookup[n] += s
            lookup[n] %= M
            total += s
            total %= M
            count[n] += count[n - 1] + count[n + 1] + 1
            # print(n, lookup, count)
            # print(total)

        # print(lookup)
        return total",1448238535
Saikat Ghosh,saikat93ify,330,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>&A, int k) {
    
        vector <int> increasing_subarray_from(A.size(), 1); 
        for(int i = A.size() - 2; i >= 0; i--)
        {
            increasing_subarray_from[i] = 1 + (A[i] < A[i + 1] ? increasing_subarray_from[i + 1] : 0);
        }
        
        for(int i = 0; i <= A.size() - 1 - k; i++)
        {
            int j = i + k; 
            //cout << ""i = "" << i << "" INcreasing = "" << increasing_subarray_from[i] <<"" j = "" << increasing_subarray_from[j] << ""\n"";//
            if(increasing_subarray_from[i] >= k && increasing_subarray_from[j] >= k)
            {
                return true;
            }
        }
        
        return false;
    }
};",1448274732
Saikat Ghosh,saikat93ify,330,3619,cpp,"class Solution {
public:
    int increasing_subarrays_exist(vector <int> &A, int k)
    {
        vector <int> increasing_subarray_from(A.size(), 1); 
        for(int i = A.size() - 2; i >= 0; i--)
        {
            increasing_subarray_from[i] = 1 + (A[i] < A[i + 1] ? increasing_subarray_from[i + 1] : 0);
        }
        
        for(int i = 0; i < A.size() - 1 - k; i++)
        {
            int j = i + k; 
            
            
            
            if(increasing_subarray_from[i] >= k && increasing_subarray_from[j] >= k)
            {
                //cout << ""Increasing from "" << i << "" = "" << increasing_subarray_from[i] << "" j = "" << j << "" = "" << increasing_subarray_from[j] << ""\n"";
                return true;
            }
        }
        
        return false;
    }
    
    int maxIncreasingSubarrays(vector<int>& nums) 
    {
        //Left <= answer < right
        int left = 1, right = nums.size(); 
        while(right - left > 1)
        {
            int mid = (left + right)/2; 
            
            if(increasing_subarrays_exist(nums, mid))
            {
                left = mid; 
            }
            else 
            {
                right = mid;
            }
        }
        
        return left; 
    }
};",1448269499
Saikat Ghosh,saikat93ify,330,3631,cpp,"class Solution 
{
    public:
    long long power_mod(long long x, long long power, int mod)
    {
        long long answer = 1; 
        while(power > 0)
        {
            if(power%2 == 1)
            {
                answer = (answer*x)%mod;
            }

            x = (x*x)%mod; 
            power = power/2;
        }

        return answer;
    }

    int bit_count(int n)
    {
        int bits = 0; 
        while(n > 0)
        {
            bits += (n%2 == 1);
            n /= 2;
        }

        return bits;
    }

    int reductions(int n)
    {
        if(n == 1)
        {
            return 0;
        }

        return 1 + reductions(bit_count(n));
    }

    int choose(int n, int r, vector <int> &factorial, vector <int> &inv_factorial, int mod)
    {
        int numerator = factorial[n]; 
        int inv_denominator = (inv_factorial[r]*1LL*inv_factorial[n - r])%mod;
        return (numerator*1LL*inv_denominator)%mod;
    }

    int countKReducibleNumbers(string S, int k) 
    {
        const int MAX_N = 1000, MOD = 1e9 + 7;
        vector <int> factorial(MAX_N, 1), inverse_factorial(MAX_N); 
        for(int i = 1; i < MAX_N; i++)
        {
            factorial[i] = (factorial[i - 1]*1LL*i)%MOD;
        }

        //i*(i - 1)! = i!
        inverse_factorial[MAX_N - 1] = power_mod(factorial[MAX_N - 1], MOD - 2, MOD);
        for(int i = MAX_N - 2; i >= 0; i--)
        {
            inverse_factorial[i] = ((i + 1)*1LL*inverse_factorial[i + 1])%MOD;
        }

        vector <int> is_good(MAX_N);
        vector <int> good_numbers_till(MAX_N);
        for(int i = 1; i < MAX_N; i++)
        {
            is_good[i] = (reductions(i) <= k - 1);
            good_numbers_till[i] = good_numbers_till[i - 1] + is_good[i];
        }
        
        int answer = 0; 
        int prefix_sum = 0; 
        for(int i = 0; i < S.size(); i++)
        {
            if(S[i] == '1')
            {
                int suffix = S.size() - i - 1; 
                int min_sum = prefix_sum, max_sum = prefix_sum + suffix; 

                for(int target_sum = prefix_sum; target_sum <= max_sum; target_sum++)
                {
                    if(!is_good[target_sum])
                    {
                        continue;
                    }
                    
                    int suffix_1s = target_sum - prefix_sum;
                    int no_of_ways = choose(suffix, suffix_1s, factorial, inverse_factorial, MOD); 
                    //cout << ""C("" << suffix << "","" << suffix_1s << "") = "" << no_of_ways << ""\n"";
                    answer += no_of_ways; 
                    answer %= MOD;

                    //cout << ""Prefix = "" << prefix_sum << "" T = "" << target_sum << "" Add "" << no_of_ways << ""\n"";
                }
            }
            
            prefix_sum += (S[i] - '0');
        }

        return answer; 
    }
};",1448238128
Saikat Ghosh,saikat93ify,330,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) 
    {
        const int MOD = 1e9 + 7;
        map <int, long long> sequences_with_last; 
        vector <long long> prefix_ending(nums.size()); 
        for(int i = 0; i < nums.size(); i++)
        {
            prefix_ending[i] += sequences_with_last[nums[i] - 1] + sequences_with_last[nums[i] + 1];
            prefix_ending[i] %= MOD;
            
            sequences_with_last[nums[i]] += 1 + prefix_ending[i];
            sequences_with_last[nums[i]] %= MOD;
        }
        
        map <int, long long> sequences_with_first; 
        vector <long long> suffix_ending(nums.size()); 
        for(int i = nums.size() - 1; i >= 0; i--)
        {
            suffix_ending[i] += sequences_with_first[nums[i] + 1] + sequences_with_first[nums[i] - 1];
            suffix_ending[i] %= MOD; 
            
            sequences_with_first[nums[i]] += 1 + suffix_ending[i];
            sequences_with_first[nums[i]] %= MOD;
        }
       
        long long sum = 0; 
        for(int i = 0; i < nums.size(); i++)
        {
            //cout << ""i = "" << i << "" Prefix Ending = "" << prefix_ending[i] <<""  Suffix ending = "" << suffix_ending[i] << ""\n"";
            long long contribution = prefix_ending[i] + suffix_ending[i] + prefix_ending[i]*1LL*suffix_ending[i] + 1;
            contribution %= MOD; 
            
            sum += contribution*nums[i]; 
            sum %= MOD;
        }
        
        return sum; 
    }
};",1448255231
EthanZyh,EthanZyh,331,3612,python,"class Solution(object):
    def hasIncreasingSubarrays(self, nums, k):
        """"""
        :type nums: List[int]
        :type k: int
        :rtype: bool
        """"""
        def is_inc(a):
            for i in range(1, len(a)):
                if a[i]<=a[i-1]:
                    return False
            return True

        n = len(nums)
        for i in range(n):
            if i>=k-1 and i+k<=n-1:
                if is_inc(nums[i-k+1:i+1]) and is_inc(nums[i+1:i+k+1]):
                    return True
        return False",1448183147
EthanZyh,EthanZyh,331,3619,python,"class Solution(object):
    def maxIncreasingSubarrays(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        n=len(nums)
        a = nums
        r = [0 for i in range(n)]
        l = [0 for i in range(n)]
        last = -1e18
        now = 0
        for i in range(n):
            if a[i]>last:
                now+=1
                l[i]=now
                last=a[i]
            else:
                now=1
                l[i]=1
                last=a[i]
        last = 1e18
        now = 0
        for i in range(n-1, -1, -1):
            if a[i]<last:
                now+=1
                r[i]=now
                last=a[i]
            else:
                now=1
                r[i]=1
                last=a[i]
        ans = 1
        for i in range(n-1):
            ans = max(ans, min(l[i],r[i+1]))
        # print(l)
        # print(r)
        return ans",1448191497
EthanZyh,EthanZyh,331,3631,python,"class Solution(object):
    def countKReducibleNumbers(self, s, k):
        """"""
        :type s: str
        :type k: int
        :rtype: int
        """"""
        K=k
        s = list(s)
        P = int(1e9+7)
        L = len(s)
        f = [[[0 for j in range(L+1)] for i in range(L+1)] for _ in range(2)]
        f[0][0][0] = 1
        for i in range(0,L):
            bit = int(s[i])
            for j in range(i+1):
                small = f[1][i][j]
                equal = f[0][i][j]
                for k in range(2):
                    newj = j + int(k==1)
                    f[1][i+1][newj] = (f[1][i+1][newj] + small) %P
                    if k<=bit:
                        newSE = int(k<bit)
                        f[newSE][i+1][newj] = (f[newSE][i+1][newj] + equal) %P
        bitc = [0 for i in range(900)]
        for i in range(1, 850):
            bitc[i] = bitc[i//2] + (i%2) 
        
        def valid(m,K):
            for i in range(K-1):
                m = bitc[m]
            return m==1
        
        ans = 0
        for j in range(1, L+1):
            # print(j,valid(j,K),f[1][L][j])
            ans = (ans + valid(j,K)*f[1][L][j]) %P
        return ans


                        ",1448260997
EthanZyh,EthanZyh,331,3646,python,"class Solution(object):
    def sumOfGoodSubsequences(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        M = 100000
        f = [0 for i in range(M+1)]
        g = [0 for i in range(M+1)]
        a = nums
        n = len(a)
        P = int(1e9+7)
        for i in range(n):
            g[a[i]] = (g[a[i]] + a[i]) %P
            if a[i]>=1:
                g[a[i]] = (g[a[i]] + g[a[i]-1] + a[i]*f[a[i]-1])%P
            if a[i]<M:
                g[a[i]] = (g[a[i]] + g[a[i]+1] + a[i]*f[a[i]+1])%P
            f[a[i]] = (f[a[i]] + 1) %P
            if a[i]>=1:
                f[a[i]] = (f[a[i]] + f[a[i]-1]) %P
            if a[i]<M:
                f[a[i]] = (f[a[i]] + f[a[i]+1]) %P
        ans = 0
        for i in range(M+1):
            ans = (ans + g[i])%P
        return ans",1448208424
Shuqi Shang,sshang,332,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        
        n = len(nums)
        
        dp = []
        for i, num in enumerate(nums):
            if i > 0 and nums[i] > nums[i-1]:
                dp.append(dp[-1] + 1)
            else:
                dp.append(1)
                
        rev = []
        for i in range(n-1, -1, -1):
            if i < n - 1 and nums[i+1] > nums[i]:
                rev.append(rev[-1] + 1)
            else:
                rev.append(1)
                
        rev.reverse()
        
        # print(dp)
        # print(rev)
        
        res = 1
        for i in range(n-1):
            res = max(res, min(dp[i], rev[i+1]))
        return res >= k",1448193786
Shuqi Shang,sshang,332,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        
        n = len(nums)
        
        dp = []
        for i, num in enumerate(nums):
            if i > 0 and nums[i] > nums[i-1]:
                dp.append(dp[-1] + 1)
            else:
                dp.append(1)
                
        rev = []
        for i in range(n-1, -1, -1):
            if i < n - 1 and nums[i+1] > nums[i]:
                rev.append(rev[-1] + 1)
            else:
                rev.append(1)
                
        rev.reverse()
        
        # print(dp)
        # print(rev)
        
        res = 1
        for i in range(n-1):
            res = max(res, min(dp[i], rev[i+1]))
        return res",1448192749
Shuqi Shang,sshang,332,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        
        mod = 10 ** 9 + 7
        
        if s == '0' or s == '1':
            return 0
        
        n = len(s)
        cnts = [float('inf')] * (n + 1)
        cnts[1] = 0
        
        for num in range(2, n + 1):
            cur, cnt = num, 1
            while cur != 1 and cnt < k:
                cur = bin(cur).count('1')
                cnt += 1
                
            if cur == 1:
                cnts[num] = cnt - 1
                
        @lru_cache(None)
        def count(i, need, equal):
            if need == 0:
                return 1
            if n - i < need:
                return 0
            
            if equal:
                if s[i] == '0':
                    return count(i + 1, need, True)
                else:
                    return (count(i + 1, need - 1, True) + count(i + 1, need, False)) % mod
            else:
                return (count(i + 1, need - 1, False) + count(i + 1, need, False)) % mod
                    
        res = 0
        for num, cnt in enumerate(cnts):
            if cnt != float('inf'):
                res = (res + count(0, num, True)) % mod
                
        ori = s.count('1')
        if cnts[ori] != float('inf'):
            res -= 1
        
        return res",1448275059
Shuqi Shang,sshang,332,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        
        mod = 10 ** 9 + 7
        
        d = defaultdict(int)
        d_cnt = defaultdict(int)
        for i, num in enumerate(nums):
            d[num] = d[num] + num + (d[num - 1] + num * d_cnt[num - 1]) + (d[num + 1] + num * d_cnt[num + 1])
            d[num] = d[num] % mod
            d_cnt[num] = d_cnt[num] + 1 + d_cnt[num - 1] + d_cnt[num + 1]
            
        return sum(d.values()) % mod ",1448204839
Ajay Maheshwari,unknown_ajay,333,3612,cpp,"/*
 
 File   : Leetcode.cpp
 -------------------
 |   Hello         |
 |   DSA !         |
 -------------------
 
 */

#define mii map<int,int>
#define vi vector<int>
#define vs vector<string>
#define vb vector<bool>
#define pii pair<int,int>
#define endl ""\n""
#define intmax INT_MAX
#define intmin INT_MIN
#define need_for_speed ios_base::sync_with_stdio(false); cin.tie(NULL);
#define ff(i,a,b) for(int i=a;i<b;i++)
#define rfor(i,a,b) for(int i=a;i>=b;i--)
#define all(x) x.begin(),x.end()
#define pt(x) { cout<<x<<""\n""; }
#define fs first.second
#define ss second.second
#define countofSet(x) __builtin_popcount(x)
#define pb push_back
#define fir first
#define sec second
#define sqrt(x) sqrtl(x)


class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& v, int k) {
        
        
        int n = (int)v.size();
        vi I;
        int i = 0;
        while(i<n)
        {
            int j = i;
            while(j+1<n && v[j+1] > v[j]) j++;
            I.pb(j-i+1);
            i = j+1;
        }
        
        auto poss = [&](int k) -> bool {
          
            bool ok = false;
            int m = (int)I.size();
            for(int i=0;i<m;i++)
            {
                ok |= ( I[i] >= 2 * k );
                ok|= ( i+1<m && I[i] >= k && I[i+1] >= k );
            }
            return ok;
        };
        
        return poss(k);
    }
};",1448199736
Ajay Maheshwari,unknown_ajay,333,3619,cpp,"
/*
 
 File   : Leetcode.cpp
 -------------------
 |   Hello         |
 |   DSA !         |
 -------------------
 
 */

#define mii map<int,int>
#define vi vector<int>
#define vs vector<string>
#define vb vector<bool>
#define pii pair<int,int>
#define endl ""\n""
#define intmax INT_MAX
#define intmin INT_MIN
#define need_for_speed ios_base::sync_with_stdio(false); cin.tie(NULL);
#define ff(i,a,b) for(int i=a;i<b;i++)
#define rfor(i,a,b) for(int i=a;i>=b;i--)
#define all(x) x.begin(),x.end()
#define pt(x) { cout<<x<<""\n""; }
#define fs first.second
#define ss second.second
#define countofSet(x) __builtin_popcount(x)
#define pb push_back
#define fir first
#define sec second
#define sqrt(x) sqrtl(x)

class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& v)
    {
        int n = (int)v.size();
        vi I;
        int i = 0;
        while(i<n)
        {
            int j = i;
            while(j+1<n && v[j+1] > v[j]) j++;
            I.pb(j-i+1);
            i = j+1;
        }
        
        auto poss = [&](int k) -> bool {
          
            bool ok = false;
            int m = (int)I.size();
            for(int i=0;i<m;i++)
            {
                ok |= ( I[i] >= 2 * k );
                ok|= ( i+1<m && I[i] >= k && I[i+1] >= k );
            }
            return ok;
        };
               
        int l = 1;
        int r = n/2;
        while(l+1<r)
        {
            int md = (l+r)/2;
            if( poss(md) ) l = md;
            else r = md;
        }
        
        int ans = l;
        if( poss(r) ) ans = r;
        return ans;
    }
};",1448198353
Ajay Maheshwari,unknown_ajay,333,3631,cpp,"using namespace std;

/*
 
 File   : Leetcode.cpp
 -------------------
 |   Hello         |
 |   DSA !         |
 -------------------
 
 */

#define mii map<int,int>
#define vi vector<int>
#define vs vector<string>
#define vb vector<bool>
#define pii pair<int,int>
#define endl ""\n""
#define intmax INT_MAX
#define intmin INT_MIN
#define need_for_speed ios_base::sync_with_stdio(false); cin.tie(NULL);
#define ff(i,a,b) for(int i=a;i<b;i++)
#define rfor(i,a,b) for(int i=a;i>=b;i--)
#define all(x) x.begin(),x.end()
#define pt(x) { cout<<x<<""\n""; }
#define fs first.second
#define ss second.second
#define countofSet(x) __builtin_popcount(x)
#define pb push_back
#define fir first
#define sec second
#define sqrt(x) sqrtl(x)
#define ll long long

const int M = 1e9+7;
const int N = 1000;
vector<int> red(N);
bool done = false;

void pre()
{
    if(done) return;
    for(int i=1;i<=800;i++)
    {
        int j = i;
        int op = 0;
        while(j!=1) {
            j = __builtin_popcount(j);
            op++;
        }
        red[i] = op;
    }
    done = 1;
}

class Solution {
public:
    int countKReducibleNumbers(string s, int k)
    {
        pre();
        int n = s.length();
        ll ans = 0;
        int st = 0;
        for(auto &x:s) st += (x == '1');
        
        vector< vector< vector<ll> > > dp(n+1, vector< vector<ll> > (n+1, vector<ll> (2,-1LL)));
        
        for(int i = 1 ; i <= n ;i++)
        {
            if( red[i] + 1 > k ) continue;
            
            // if og string has b bits set we can reduce it in red[i] + 1 steps
            // cout << ""Keeping "" << i << "" bits in og string ways = "" << ways(ways,0,b,true) << ""\n"";
            
            auto ways = [&](const auto &ways,int idx,int rem,bool cap) -> ll {
                
                if(rem == 0) return 1;
                if(idx == n) return (rem == 0);
                
                if( dp[idx][rem][cap] != -1 ) return dp[idx][rem][cap];
                
                ll cnt = 0;
                // place
                if( s[idx] == '0' && cap ) {}
                else cnt += ways(ways,idx+1,rem-1, cap && ( s[idx] == '1' ) );
                
                cnt %= M;
                    
                // not place
                cnt += ways(ways,idx+1,rem, cap && ( s[idx] == '0' ) );
                cnt %= M;
                
                return dp[idx][rem][cap] = cnt;
            };
            
            ans += ways(ways,0,i,true);
            ans %= M;

            if( i == st )
            {
                ans = (ans%M - 1) %M;
                ans += M;
                ans %= M;
            }
        }
        
        return (int)(ans %M);
    }
};",1448295408
Ajay Maheshwari,unknown_ajay,333,3646,cpp,"#include ""bits/stdc++.h""
using namespace std;

/*
 
 File   : Leetcode.cpp
 -------------------
 |   Hello         |
 |   DSA !         |
 -------------------
 
 */

#define mii map<int,int>
#define vi vector<int>
#define vs vector<string>
#define vb vector<bool>
#define pii pair<int,int>
#define endl ""\n""
#define intmax INT_MAX
#define intmin INT_MIN
#define need_for_speed ios_base::sync_with_stdio(false); cin.tie(NULL);
#define ff(i,a,b) for(int i=a;i<b;i++)
#define rfor(i,a,b) for(int i=a;i>=b;i--)
#define all(x) x.begin(),x.end()
#define pt(x) { cout<<x<<""\n""; }
#define fs first.second
#define ss second.second
#define countofSet(x) __builtin_popcount(x)
#define pb push_back
#define fir first
#define sec second
#define sqrt(x) sqrtl(x)
#define ll long long
const int M = 1e9 + 7;

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums)
    {
        int n = (int)nums.size();
        vector<ll> dpCnt(n,0);
        vector<ll> dpSum(n,0);
        map<int,ll> mpSum;
        map<int,ll> mpCnt;
        
        int ans = 0;
        dpCnt[0] = mpCnt[ nums[0] ] = 1;
        dpSum[0] = mpSum[ nums[0] ] = nums[0];
        
        ff(i,1,n)
        {
            ll cnt = 0;
            ll sm = 0;
            
            int prev = nums[i] - 1;
            if( mpCnt.find(prev) != mpCnt.end() )
            {
                cnt += mpCnt[ prev ];
                cnt %= M;
                
                sm += mpSum[ prev ];
                sm %= M;
            }
            
            prev = nums[i] + 1;
            if( mpCnt.find(prev) != mpCnt.end() )
            {
                cnt += mpCnt[ prev ];
                cnt %= M;
                
                sm += mpSum[ prev ];
                sm %= M;
            }
            
            dpCnt[i] = cnt + 1;
            dpSum[i] = ( (nums[i] %M * dpCnt[i] %M ) %M + sm %M ) %M;
            
            mpCnt[ nums[i] ] += dpCnt[i];
            mpCnt[ nums[i] ] %= M;
            
            mpSum[ nums[i] ] += dpSum[i];
            mpSum[ nums[i] ] %= M;
        }
        
        for(auto &x:dpSum)
        {
            ans += x;
            ans %= M;
        }
        return ans;
    }
};",1448242411
Priyabrata Das,Thunder_strom007,334,3612,cpp,"class Solution {
public:
    bool check(vector<int>&arr,int i,int j){
        for(int l=i+1;l<=j;l++){
            if(arr[l]<=arr[l-1]) return false;
        }
        return true;
    }
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        for(int a=0;a<n;a++){
            int idx1 = a;
            int idx2 = a + k - 1;
            int idx3 = a + k;
            int idx4 = idx3 + k - 1;
            if(idx2 < n && idx4 < n){
                if(check(nums,idx1,idx2) && check(nums,idx3,idx4)) return true;
            }
        }
        return false;
    }
};",1448183624
Priyabrata Das,Thunder_strom007,334,3619,cpp,"class Solution {
public:
    vector<int> pref;
    void f(vector<int>& arr){
        int n = arr.size();
        pref.assign(n-1,0);
        for(int i=1;i<n;i++){
            if(arr[i]>arr[i-1]){
                pref[i-1] = 1;
            }
            else{
                pref[i-1] = 0;
            }
            if(i-2>=0) pref[i-1] += pref[i-2];
        }
    }
    bool check(int i,int j){
        int len = j-i+1;
        int sum = pref[j];
        sum -= pref[i];
        return sum == len - 1;
    }
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        for(int a=0;a<n;a++){
            int idx1 = a;
            int idx2 = a + k - 1;
            int idx3 = a + k;
            int idx4 = idx3 + k - 1;
            if(idx2 < n && idx4 < n){
                if(check(idx1,idx2) && check(idx3,idx4)) return true;
            }
        }
        return false;
    }
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        
        vector<int> arr = {INT_MIN};
        for(auto &x : nums){
            arr.push_back(x);
        }

        f(arr);
        
        int ans = 1;
        int lo = 2, hi = n;
        while(lo<=hi){
            int mid = lo + (hi-lo)/2;
            if(hasIncreasingSubarrays(nums,mid)){
                ans = mid;
                lo = mid + 1;
            }
            else{
                hi = mid - 1;
            }
        }
        return ans;
    }
};",1448232277
Priyabrata Das,Thunder_strom007,334,3631,cpp,"class Solution {
public:
    int n;
    string str;
    int K;
    int mod = 1e9+7;
    
    long long dp[801][801][2];
   
    long long f(int i,int ones,bool flag){
        if(i==n){
            if(!flag) return 0;
            int op = 1;
            int val = ones;
            while(val!=1){
                op++;
                if(op>K) return 0;
                val = __builtin_popcount(val);
            }
            return op<=K;
        }
        if(dp[i][ones][flag]!=-1) return dp[i][ones][flag];
        long long ans = 0;
        if(flag){
            ans += f(i+1,ones,true);
            ans %= mod;
            ans += f(i+1,ones+1,true);
            ans %= mod;
        }
        else{
            if(str[i] == '1'){
                ans += f(i+1,ones+1,false);
                ans %= mod;
                ans += f(i+1,ones,true);
                ans %= mod;
            }
            else{
                ans += f(i+1,ones,false);
                ans %= mod;
            }
        }
        return dp[i][ones][flag] = ans;
    }
    int countKReducibleNumbers(string s, int k) {
        str = s;
        n = s.size();
        K = k;
        
        memset(dp,-1,sizeof(dp));
        
        return (int)f(0,0,false);
    }
};",1448288894
Priyabrata Das,Thunder_strom007,334,3646,cpp,"class Solution {
public:
    
    int sumOfGoodSubsequences(vector<int>& nums) {
        map<long long,long long> freq,sum;
        int n = nums.size();
        long long ans = 0;
        int mod = 1e9+7;
        
        for(int i=0;i<n;i++){
            long long val = nums[i];
            
            if(freq.count(val-1)){
                freq[val] += freq[val-1];
                freq[val] %= mod;
                sum[val] += ((sum[val-1] + (freq[val-1]*val)%mod)%mod);
                sum[val] %= mod;
            }
            if(freq.count(val+1)){
                freq[val] += freq[val+1];
                freq[val] %= mod;
                sum[val] += ((sum[val+1] + (freq[val+1]*val)%mod)%mod);
                sum[val] %= mod;
            }
            sum[val] += val;
            sum[val] %= mod;
            freq[val]++;
            freq[val] %= mod;
        }
        
        for(auto &x : sum){
            ans += x.second;
            ans %= mod;
        }
        
        return (int)ans;
    }
};",1448265592
BrutalKiller,BrutalKiller,335,3612,cpp,"#include ""bits/stdc++.h""
#define all(a) a.begin(), a.end()
#define pb push_back
#define vi vector <ll>
#define vvi vector <vector <ll>>
#define pll pair<ll, ll>

using namespace std;

typedef int ll;

class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& v, int k) {

        for(int i = 0; i + (2 * k) - 1 < v.size(); i++){
            int last = v[i];
            ll x = i + 1;
            bool flag = true;
            
            for(ll j = 1; j < k; j++){
                if(v[x] <= last){
                    flag = false;
                    break;
                }

                last = v[x];
                x++;
            }

            x = i + k;
            last = v[x];
            x++;
            for(ll j = 1; j < k; j++){
                if(v[x] <= last){
                    flag = false;
                    break;
                }

                last = v[x];
                x++;
            }

            if(flag)
                return true;
        }
        return false;
    }
};",1448188841
BrutalKiller,BrutalKiller,335,3619,cpp,"#include ""bits/stdc++.h""
#define all(a) a.begin(), a.end()
#define pb push_back
#define vi vector <ll>
#define vvi vector <vector <ll>>
#define pll pair<ll, ll>

using namespace std;

typedef int ll;

class Solution {

    vi help;
public:
    int maxIncreasingSubarrays(vector<int>& v) {

        ll n = v.size();
        ll l = 0, r = 0;
        ll ans = 0;
        ll cnt = 1;
        help = vi(n);
        
        while(l < n){
            r = max(l + 1, r);
            cnt = max(1, cnt);

            while(r < n && v[r] > v[r - 1]){
                r++;
                cnt++;
            }

            help[l] = cnt;
            l++;
            cnt--;
        }
        help.pb(1);
        
        for(ll i = 0; i < n; i++){
            ans = max(ans, help[i] / 2);

            ll x = min(help[i], help[i + help[i]]);
            ans = max(ans, x);
        }
        return ans;
    }
};",1448216578
BrutalKiller,BrutalKiller,335,3631,cpp,"#include ""bits/stdc++.h""
#define all(a) a.begin(), a.end()
#define pb push_back
#define vi vector <ll>
#define vvi vector <vector <ll>>
#define pll pair<ll, ll>

using namespace std;

typedef long long ll;

class Solution {

    vector <vvi> dp;
    string s;
    vi help;
    ll M = 1e9 + 7;
    ll n, k;

    ll cnt(ll x){
        for(int i = 1; i <= 7; i++){
            x = __builtin_popcount(x);

            if(x == 1)
                return i;
        }
        return 7;
    }

    ll dfs(ll x, ll y, ll z){
        if(x == n){
            if(z == 0 or (help[y] >= k and y != 1))
                return 0;
            return 1;
        }

        if(dp[x][y][z] != -1)
            return dp[x][y][z];

        ll ans = 0;
        if(z == 0){
            if(s[x] == '0')
                ans = (ans + dfs(x + 1, y, 0)) % M;
            else{
                ans = (ans + dfs(x + 1, y + 1, 0)) % M;
                ans = (ans + dfs(x + 1, y, 1)) % M;
            }
        }
        else{
            ans = (ans + dfs(x + 1, y + 1, 1)) % M;
            ans = (ans + dfs(x + 1, y, 1)) % M;
        }

        return dp[x][y][z] = ans;
    }
public:
    int countKReducibleNumbers(string ss, int kk) {
        ll ans = 0;
        s = ss;
        n = s.size();
        k = kk;
        help = vi(n + 1, -1);
        help[0] = 7;
        
        for(ll i = 1; i <= n; i++){
            help[i] = cnt(i);
        }

        dp = vector <vvi> (n, vvi(n + 1, vi(2, -1)));
        ans = dfs(0, 0, 0);
        return ans;
    }
};",1448282312
BrutalKiller,BrutalKiller,335,3646,cpp,"#include ""bits/stdc++.h""
#define all(a) a.begin(), a.end()
#define pb push_back
#define vi vector <ll>
#define vvi vector <vector <ll>>
#define pll pair<ll, ll>

using namespace std;

typedef long long ll;

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& v) {
        vi dp(1e5 + 5, 0);
        vi help(1e5 + 5, 0);
        ll M = 1e9 + 7;
        
        for(auto & e : v){
            
            help[e] = (help[e] + e) % M;
            
            ll x = 0;

            if(e != 0){
                x = dp[e - 1] * e % M;
                x = (x + help[e - 1]) % M;
                help[e] = (help[e] + x) % M;
            }
            
            x = dp[e + 1] * e % M;
            x = (x + help[e + 1]) % M;
            help[e] = (help[e] + x) % M;

            dp[e] = (dp[e] + 1) % M;
            dp[e] = (dp[e + 1] + dp[e]) % M;

            if(e != 0)
                dp[e] = (dp[e - 1] + dp[e]) % M;

        }
        
        ll ans = 0;
        for(auto & e : help){
            ans = (ans + e) % M;
        }

        return ans;
    }
};",1448240199
Mark33,mark233,338,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        if k == 1:
            return True
        lo, fa = 0, k
        count = 0
        while fa + 1 < len(nums):
            if nums[lo+1] > nums[lo] and nums[fa+1] > nums[fa]:
                count += 1
            else:
                count = 0
            if count == k - 1:
                return True
            lo += 1
            fa += 1
        return False",1448183960
Mark33,mark233,338,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        def if_k_valid(k):
            if k == 1:
                return True
            lo, fa = 0, k
            count = 0
            while fa + 1 < len(nums):
                if nums[lo+1] > nums[lo] and nums[fa+1] > nums[fa]:
                    count += 1
                else:
                    count = 0
                if count == k - 1:
                    return True
                lo += 1
                fa += 1
            return False
        res = 1
        l, r = 1, len(nums) // 2
        while l < r:
            mid = (l + r) // 2
            if if_k_valid(mid):
                res = mid
                l = mid + 1
            else:
                r = mid
        if if_k_valid(l):
            res = l
        return res",1448199282
Mark33,mark233,338,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        count_1 = s.count(""1"")
        @cache
        def is_count_1_valid(num, limit):
            if num == 1:
                return True
            if limit == 0:
                return False
            return is_count_1_valid(bin(num).count(""1""), limit - 1)
        res = 0 
        MOD = 10 ** 9 + 7
        count = count_1
        for i in range(len(s) - 1, -1, -1):
            if s[i] == '1':
                count -= 1
                length = len(s) - i - 1
                for j in range(length + 1):
                    if is_count_1_valid(count + j, k - 1):
                        res += math.comb(length, j)
                        # print(res, j, length, count)
                        res = res % MOD
        return res",1448282563
Mark33,mark233,338,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        dp = collections.defaultdict(lambda : [0, 0])
        res = 0
        MOD = 10 ** 9 + 7
        for num in nums:
            count1, all_sum1 = dp[num - 1]
            count2, all_sum2 = dp[num + 1]
            count = count1 + count2 + 1
            all_sum = all_sum1 + all_sum2 + count * num
            dp[num][0] += count
            dp[num][1] += all_sum
            res += all_sum
            res = res % MOD
        return res
    
    ## [10,10,1,9] 68",1448216048
Anupam Shah,user9218i,339,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        if(k == 1)  return 1;
        for(int i = 0; i <= nums.size() - k - k; i ++) {
            bool no = 0;
            //cout 
            for(int j = i+1; j < i + k; j ++) {
                if(nums[j] <= nums[j-1])    no = 1;
            }
            for(int j = i+k+1; j < i + k+k; j ++) {
                if(nums[j] <= nums[j-1])    no = 1;
            }
            if(!no)     return 1;
        }
        return 0;
    }
};",1448184654
Anupam Shah,user9218i,339,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> l(n);   vector<int> r(n);
        for(int i = 0; i < nums.size(); i ++) {
            if(!i)  l[i] = 1;
            else    l[i] = (nums[i] > nums[i-1] ? l[i-1] + 1 : 1);
        }
        for(int i = nums.size() - 1; i >= 0; i --) {
            if(i == nums.size() - 1)  r[i] = 1;
            else    r[i] = (nums[i] < nums[i+1] ? r[i+1] + 1 : 1);
        }
        int ans = 0;
        for(int i = 0; i < nums.size() - 1; i ++)
            ans = max(ans, min(l[i], r[i+1]));
        return ans;
    }
};",1448191251
Anupam Shah,user9218i,339,3631,cpp,"class Solution {
public:
    typedef long long int ll;
    ll MOD = 1000000007;
    
    ll digitDP(const string &n, int pos, int count, bool tight, int l, vector<vector<vector<ll>>>& dp) {
        if(count < 0)   return 0;
        
        if (pos == n.size()) {
            return count == 0 ? 1 : 0;
        }
        if (dp[pos][count][tight] != -1) {
            return dp[pos][count][tight];
        }
        int limit = tight ? n[pos] - '0' : 1;
        ll res = 0;
        res += digitDP(n, pos + 1, count, tight && (limit == 0), l, dp);
        if (limit == 1) {
            res += digitDP(n, pos + 1, count - 1, tight, l, dp);
        }
        res %= MOD;
        return dp[pos][count][tight] = res;
    }
    ll countNumbersWithLSetBits(string n, int l, vector<vector<vector<ll>>>& dp) {
        if(l == 0)  return 0;
        return digitDP(n, 0, l, true, l, dp);
    }
    
    int go(int n, int k, vector<vector<int>>& dp) {
        if(k < 0)   return 0;
        if(k == 0)  return n == 1;
        if(dp[n][k] != -1)  return dp[n][k];
        
        return dp[n][k] = go(__builtin_popcount(n), k-1, dp);
    }
    int countKReducibleNumbers(string s, int k) {
        int n = s.length();
        ll ans = 0;
        
        vector<vector<int>> dp(n+1, vector<int> (k+1, -1));
        vector<vector<vector<ll>>> dp2(n+1, vector<vector<ll>> (n+1, vector<ll> (2, -1)));
        
        for(int i = 1; i <= s.length(); i++) {
            if(go(i, k-1, dp)) {
                //cout << i << endl;
                ans += countNumbersWithLSetBits(s, i, dp2);
                ans %= MOD;
            }
        }
        
        int b = 0;
        for(int i = 0; i < s.length(); i ++)    b += (s[i] - '0');
        k --;
        while(k --) {
            b = __builtin_popcount(b);
        }
        if(b == 1)      ans = (ans - 1 + MOD)%MOD;
        
        return ans;
    }
};

/*
""10""
2

*/
    ",1448269070
Anupam Shah,user9218i,339,3646,cpp,"class Solution {
public:
    typedef long long ll;
    ll MOD = 1000000007;
    int sumOfGoodSubsequences(vector<int>& nums) {
        vector<pair<ll,ll>> dp;
        for(int i = 0; i <= 1e5 + 2; i ++)  dp.push_back({0, 0});
        
        ll ans = 0;
        for(int i = nums.size() - 1; i >= 0; i --) {
            
            ll l = nums[i] - 1, r = nums[i] + 1;
            ll s = 0, f = 0;
            
            s += (ll)dp[r].second + (ll)((ll)nums[i] * (ll)dp[r].first);
            f += (ll)dp[r].first;
            
            s %= MOD, f %= MOD;
            
            if(l >= 0) {
                s += (ll)dp[l].second + (ll)((ll)nums[i] * (ll)dp[l].first);
                f += (ll)dp[l].first;
            }
            s %= MOD, f %= MOD;
            s += (ll)nums[i];   f ++;
            s %= MOD, f %= MOD;
            
            dp[nums[i]].first +=  f, dp[nums[i]].second +=  s, 
            dp[nums[i]].first %= MOD, dp[nums[i]].second %= MOD;
            ans += s;
            ans %= MOD;
        }
        return (int)ans;
    }
};",1448237719
Kartik Garg,Kartik_garg163,340,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> idx(n,1);
        idx[n-1] = 1;
        for(int i=n-2; i>=0; i--){
            // int cnt = 1;
            // while(i >= 0 && nums[i] < nums[i+1]){
            //     cnt++;
            //     idx[i] = cnt;
            //     i--;
            // }
            // idx[i] = cnt;
            if(nums[i+1] > nums[i]){
                idx[i] += idx[i+1];
            }
        }
        int ans = 0;
        for(int i=0; i<n; i++){
            int val = idx[i]/2;
            if(val == k){
                return true;
            }
            if(i+idx[i] < n){
                if(idx[i+idx[i]] >= idx[i]){
                    if(idx[i] == k){
                        return true;
                    }
                }
            }
        }
        return false;
        
    }
};",1448202501
Kartik Garg,Kartik_garg163,340,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> idx(n,1);
        idx[n-1] = 1;
        for(int i=n-2; i>=0; i--){
            // int cnt = 1;
            // while(i >= 0 && nums[i] < nums[i+1]){
            //     cnt++;
            //     idx[i] = cnt;
            //     i--;
            // }
            // idx[i] = cnt;
            if(nums[i+1] > nums[i]){
                idx[i] += idx[i+1];
            }
        }
        int ans = 0;
        for(int i=0; i<n; i++){
            ans = max(ans,idx[i]/2);
            if(i+idx[i] < n){
                if(idx[i+idx[i]] >= idx[i]){
                    ans = max(ans, idx[i]);
                }
            }
        }
        return ans;
    }
};",1448198984
Kartik Garg,Kartik_garg163,340,3631,cpp,"class Solution {
public:
    const long long N = 802;
    long long mod_power(long long a, long long b, long long mod){
        if(b == 0){
            return 1;
        }
        long long x = mod_power(a, b/2, mod);
        if(b % 2 == 0){
            return (x * x) % mod;
        }
        else{
            long long y = (x * x) % mod;
            y = (y * a) % mod;
            return y;
        }
    }

    long long inverse(long long a, long long mod){
        return mod_power(a, mod - 2, mod);
    }
    vector<long long> factorial;
    void fac(long long mod){
        factorial.resize(N);
    	factorial[0] = 1;
    	for(long long i=1; i<N; i++){
    		factorial[i] = factorial[i-1] * i % mod;
    	}
    }
    long long combination(long long n, long long r, long long mod){
    	long long num1 = factorial[n];
    	long long num2 = factorial[r];
    	long long num3 = factorial[n-r];
    	long long num4 = num2 * num3 % mod;
    	long long ans = num1 * inverse(num4,mod) % mod;
    	return ans;
    }
    int countKReducibleNumbers(string s, int k) {
        int n = s.length();
        map<int,long long> cnt;
        for(int i=1; i<=n; i++){
            int num = i;
            long long count = 1;
            bool ok = true;
            while(num != 1){
                num = __builtin_popcount(num);
                count++;
                if(count > k){
                    ok = false;
                    break;
                }
            }
            if(ok){
                cnt[i] = count;
            }
            // cout<<cnt[i]<<endl;
        }
        long long mod = 1e9 + 7;
        fac(mod);
        long long ans = 0;
        for(int i=1; i<n; i++){
            for(int j=i-1; j>=0; j--){
                if(cnt[j+1] > 0){
                    long long val = combination(i-1,j,mod);
                    ans = (ans + val) % mod;
                    // cout<<i<<"" ""<<j<<"" ""<<ans<<endl;
                }
            }
        }
        long long h = 1;
        for(int f=1; f<n; f++){
            if(s[f] == '1'){
                int d = n - f - 1;
                // for(int i=1; i<n; i++){
                    for(int j=d; j>=0; j--){
                        if(cnt[j+h] > 0){
                            long long val = combination(d,j,mod);
                            ans = (ans + val) % mod;
                            // cout<<i<<"" ""<<j<<"" ""<<ans<<endl;
                        }
                    }
                // }
                h++;
            }
        }
        return ans;
    }
};",1448296043
Kartik Garg,Kartik_garg163,340,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        map<int,long long> mp;
        map<int,long long> sum;
        long long ans = 0;
        long long mod = 1e9 + 7;
        for(int i=0; i<nums.size(); i++){
            mp[nums[i]] += 1;
            sum[nums[i]] = (sum[nums[i]] + nums[i]) % mod;
            ans = (ans + nums[i]) % mod;
            int num1 = nums[i]-1;
            int num2 = nums[i] + 1;
            long long val1 = (sum[num1]+(mp[num1]*nums[i]%mod)%mod);
            long long val2 = (sum[num2]+(mp[num2]*nums[i]%mod)%mod);
            mp[nums[i]] = (mp[nums[i]] + mp[num1]) % mod;
            mp[nums[i]] = (mp[nums[i]] + mp[num2]) % mod;
            sum[nums[i]] = ((sum[nums[i]] + val1) % mod + val2) % mod;
            ans = ((ans + val1) % mod + val2) % mod;
        }
        return ans;
    }
};",1448232910
Chuan-Chih Chou,chuan-chih,344,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        def inc(i):
            return all(b > a for a, b in pairwise(nums[i:i+k]))
        n = len(nums)
        for i in range(n):
            if i + 2 * k <= n and inc(i) and inc(i + k):
                return True
        return False",1448183200
Chuan-Chih Chou,chuan-chih,344,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        longest = [1] * n
        l = 0
        prev = -inf
        for r, curr in enumerate(nums):
            if curr <= prev:
                longest[l:r] = reversed(range(1, 1 + r - l))
                l = r
            prev = curr
        r = n
        longest[l:r] = reversed(range(1, 1 + r - l))
        # print(longest)
        def check(k):
            for i in range(n - 2 * k + 1):
                if longest[i] >= k and longest[i + k] >= k:
                    return True
            return False
        low = 1
        high = n // 2
        while low < high:
            mid = (low + high + 1) // 2
            if check(mid):
                low = mid
            else:
                high = mid - 1
        return low
",1448210963
Chuan-Chih Chou,chuan-chih,344,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        mod = 10 ** 9 + 7
        @cache
        def dp(x):
            if not x:
                return math.inf
            if x == 1:
                return 0
            return 1 + dp(x.bit_count())
        l = [int(d) for d in s]
        n = len(l)
        fac = [1]
        for i in range(1, n + 1):
            fac.append(fac[-1] * i)
            fac[-1] %= mod
        # Count lower bit_length() numbers
        ans = 0
        for length in range(1, n):
            space = length - 1
            for x in range(space + 1):
                if 1 + dp(1 + x) <= k:
                    ans += fac[space] * pow(fac[x], -1, mod) * pow(fac[space - x], -1, mod)
                    ans %= mod
        # Scan left-right, count numbers with prefix
        acc = 1
        for i in range(1, n):
            bit = l[i]
            if bit:
                space = n - i - 1
                for x in range(space + 1):
                    if 1 + dp(acc + x) <= k:
                        ans += fac[space] * pow(fac[x], -1, mod) * pow(fac[space - x], -1, mod)
                        ans %= mod
                acc += 1
        return ans
            
        
            ",1448284083
Chuan-Chih Chou,chuan-chih,344,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        mod = 10 ** 9 + 7
        max_v = max(nums)
        count = [0] * (max_v + 1)
        total = [0] * (max_v + 1)
        for x in nums:
            new = x
            c = 1
            if x - 1 >= 0:
                new += total[x - 1] + x * count[x - 1]
                c += count[x - 1]
            if x + 1 < len(count):
                new += total[x + 1] + x * count[x + 1]
                c += count[x + 1]
            total[x] += new
            total[x] %= mod
            count[x] += c
            count[x] %= mod
        return sum(total) % mod",1448233384
Maruzensky,Maruzensky,346,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        
        for i in range(n - 2 * k + 1):
            left, right = nums[i: i + k], nums[i + k: i + 2 * k]
            if all(x < y for x, y in zip(left, left[1:])) and all(x < y for x, y in zip(right, right[1:])):
                return True
            
        return False",1448182090
Maruzensky,Maruzensky,346,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        
        is_increasing = [(x < y) for x, y in zip(nums, nums[1:])]
        is_false = [i for i in range(n - 1) if is_increasing[i] is False]
        
        gaps = [y - x for x, y in zip([-1] + is_false, is_false + [n - 1])]
        
        if len(gaps) == 1:
            return gaps[0] // 2
        
        return max(max(gaps) // 2, max(min(x, y) for x, y in zip(gaps, gaps[1:])))",1448190305
Maruzensky,Maruzensky,346,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        def power(p, x, e):
            base = x
            answer = 1
            while e:
                if e & 1:
                    answer = (answer * base) % p

                base = (base * base) % p
                e >>= 1

            return answer


        def inv(p, x):
            return power(p, x, p - 2)
        
        
        def hamming(x):
            answer = 0
            while x:
                b = x & (-x)
                x -= b
                answer += 1

            return answer
        

        times = [[] for _ in range(15)]

        for v in range(1, 901):
            temp = v
            i = 0
            while temp > 1:
                i += 1
                temp = hamming(temp)

            times[i].append(v)
            
        n = len(s)
        mod = 10**9 + 7
        want = []
        for t in times[:k]:
            want.extend(t)

        fact = [1]
        inv_fact = [1]
        for x in range(1, 1000):
            inv_x = inv(mod, x)
            fact.append((fact[-1] * x) % mod)
            inv_fact.append((inv_fact[-1] * inv_x) % mod)
            
            
        def choose(x, y):
            if y > x or y < 0:
                return 0
            return (fact[x] * inv_fact[y] * inv_fact[x - y]) % mod
        
        
        def count(b):
            answer = 0
            for i, c in enumerate(s):
                if c == '1':
                    answer += choose(n - 1 - i, b)
                    b -= 1
                    
            return answer % mod
        
        return sum(count(b) for b in want) % mod

",1448263425
Maruzensky,Maruzensky,346,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        # nums = [x + 2 for x in nums]
        mod = 10**9 + 7
        m = max(nums)
        
        assert m < 10**6
        
        left = [0]
        seen = [0] * (m + 3)
        seen[nums[0]] = 1
        
        for x in nums[1:]:
            how = seen[x - 1] + seen[x + 1]
            left.append(how)
            seen[x] += how + 1
            seen[x] %= mod
            
        right = [0]
        seen = [0] * (m + 3)
        seen[nums[-1]] = 1
        
        for x in nums[:-1][::-1]:
            how = seen[x - 1] + seen[x + 1]
            right.append(how)
            seen[x] += how + 1
            seen[x] %= mod
            
        right = right[::-1]
        
        answer = 0
        for l, r, x in zip(left, right, nums):
            answer += (l + 1) * (r + 1) * x
            answer %= mod
            
        return answer
",1448226707
Rishabh Tiwari,rishabhtwr07,347,3612,java,"class Solution {
    int n;
    
    int dp[];
    private boolean fnc(int x) {
        for(int i = 0; i < n; ++i) {
            if(i + x >= n)
                break;
            if(dp[i] >= x && dp[i + x] >= x)
                return true;
        }
        return false;
    }
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        n = nums.size();
        dp = new int[n];
        Arrays.fill(dp, 1);
        for(int i = n - 2; i >= 0; --i) {
            if(nums.get(i) < nums.get(i + 1)) 
                dp[i] = 1 + dp[i + 1];
        }
        return fnc(k);
    }
}

",1448191640
Rishabh Tiwari,rishabhtwr07,347,3619,java,"class Solution {
    int n;
    
    int dp[];

    private boolean fnc(int x) {
        for(int i = 0; i < n; ++i) {
            if(i + x >= n)
                break;
            if(dp[i] >= x && dp[i + x] >= x)
                return true;
        }
        return false;
    }
    public int maxIncreasingSubarrays(List<Integer> nums) {
        n = nums.size();
        
        int l = 1;
        int r = n / 2, mid;
        dp = new int[n];
        Arrays.fill(dp, 1);

        for(int i = n - 2; i >= 0; --i) {
            if(nums.get(i) < nums.get(i + 1)) 
                dp[i] = 1 + dp[i + 1];
        }

        while(r - l > 1) {
            mid = (l + r) / 2;
            //System.out.println(l + "" "" + r + "" "" + mid);
            if(fnc(mid)) {
                l = mid;
            } else {
                r = mid - 1;
            }
        }
        if(fnc(r)) {
            return r;
        }
        return l;
    }
}",1448188869
Rishabh Tiwari,rishabhtwr07,347,3631,java,"class Solution {
    boolean precom[][];
    int n;
    String str;
    int k;
    static final int MOD = 1000000007;
    private int bits(int x) {
        int ret = 0;
        while(x > 0) {
            if((x % 2) == 1)
                ret++;
            x /= 2;
        }
        return ret;
    }
    
    private void precompute(int x) {
        for(int i = 1; i <= x; ++i) {
            precom[0][i] = true;
            precom[1][i] = true;
        }

        precom[0][0] = true;
        precom[1][0] = false;
        for(int i = 2; i <= n; ++i) {
            for(int j = 0; j <= x; ++j) {
                if(j == 0)
                    precom[i][0] = false;
                else {
                    precom[i][j] = precom[bits(i)][j - 1];
                }
            }         
        }
        // for(int i = 0; i <= n; ++i) {
        //     System.out.println(i + "" "" + precom[i][k]);
        // }
    }

    long dp[][][];

    private long fnc(int x, int y, int z) {
        if(x == n) {
            if(z == 0)
                return 0L;
            return precom[y][k] ? 1L: 0L;
        }
        if(dp[x][y][z] != -1)
            return dp[x][y][z];
        dp[x][y][z] = 0L;
        int bitVal = (str.charAt(x) == '1' ? 1: 0);
       
        // Same bit
        dp[x][y][z] = fnc(x + 1, y + bitVal, z);
        dp[x][y][z] %= MOD;
        
        //flip
        if(bitVal == 1)
            dp[x][y][z] += fnc(x + 1, y, 1);
        else if(z == 1) {
            dp[x][y][z] += fnc(x + 1, y + 1, 1);
        }

        dp[x][y][z] %= MOD;
       // System.out.println(x + "" "" + y + "" "" + z + "" "" + dp[x][y][z]);
        return dp[x][y][z];
    }
    
    public int countKReducibleNumbers(String s, int k) {
        this.k = k;
        n = s.length();
        precom = new boolean[n + 1][k + 1];
        str = s;
        precompute(k);
        dp = new long[n + 1][n + 1][2];
        for(int i = 0; i < n; ++i) {
            for(int j = 0; j < n; ++j) {
                Arrays.fill(dp[i][j], -1);
            }
        }
        long ans = fnc(0, 0, 0) - 1 + MOD;
        ans %= MOD;
        return (int)ans;
    }
}",1448277391
Rishabh Tiwari,rishabhtwr07,347,3646,java,"class Solution {
    static final int MOD = 1000000007;
    public int sumOfGoodSubsequences(int[] nums) {
        int n = nums.length, x;

        long dp[] = new long[100005];
        Arrays.fill(dp, 0L);
        long subs[] = new long [100005];
        Arrays.fill(subs, 0L);

        long ret = 0L;
        long val, tmp;
        for(int i = n - 1; i >= 0; --i) {
            x = nums[i];
            tmp = 1L + subs[x + 1];
            tmp %= MOD;
            if(x != 0)
                tmp += subs[x - 1];
            tmp %= MOD;
            val = tmp * (long)x;
            val %= MOD;
            val += dp[x + 1];
            val %= MOD;
            if(x != 0)
                val += dp[x - 1];
            val %= MOD;
            
            //System.out.println(i + "" "" + x + "" "" + val);
            ret += val;
            ret %= MOD;
            dp[x] += val;
            dp[x] %= MOD;
            subs[x] += 1L;
            subs[x] %= MOD;
            subs[x] += subs[x + 1];
            subs[x] %= MOD;
            if(x != 0)
                subs[x] += subs[x - 1];
            subs[x] %= MOD;
        }

        return (int)ret;
    }
}",1448238980
Armaan,Armaan48,349,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        for (int i=0;i + 2*k<=n;i++){
            int tans = true;
            for (int j=i+1;j<i+k;j++){
                if (nums[j] <= nums[j - 1])
                    tans = false;
            }
            for (int j=i+k+1;j<i+2*k;j++){
                if (nums[j] <= nums[j-1])
                        tans = false;
            }
            if (tans)
                    return true;
        }
        return false;
    }
}; ",1448185125
Armaan,Armaan48,349,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        int i = 0;
        vector<int> ans;
        int val = 0;

        while (i<n){
            int j = i + 1;
            while(j<n and nums[j] > nums[j-1])
                j++;
            val = max(val , (j - i)/2);
            ans.push_back((j-i));
            i= j ;
        }
        for (int i=1;i<ans.size();i++)
            val = max(val ,min(ans[i],ans[i-1]));
        return val;
    }
};",1448198435
Armaan,Armaan48,349,3631,cpp,"class Solution {
public:
    vector<vector<vector<long long>>> dp;
    string s;
    int n,k;
    vector<long long> help;

    long long mod;
    Solution(){
        mod = 1000000007;
    }
    long long reduce(int a){
        if (help[a]!=-1)
                return help[a];
        if (a <= 1)
                return help[a] = 0;
        int cnt =0 ;
        for (int bit=30;bit>=0;bit--){
            cnt += ((a&(1ll<<bit))!=0);
        }
        return help[a] =  1+ reduce(cnt);
    }
    string path;
    long long solve(int i,int j,int f){
        if (i == n){
            return (j and   1+reduce(j)<=k and f);
        }
    long long  &ans = dp[i][j][f];
        if (ans!=-1)
                return ans;
        ans = 0;
        ans = solve(i + 1, j + (s[i] == '1') , f);
        if (s[i]=='1' or f == 1){
            ans = (ans + solve(i + 1 ,  j + (s[i] == '0') , f || (s[i] == '1')))%mod;
        }
        return ans;
    }
    int countKReducibleNumbers(string S, int K) {
        s = S;
        n = s.size();
        k = K;
        help = vector<long long> (801, -1);
        dp = vector<vector<vector<long long>>> ( n , vector<vector<long long>>( n  + 1,vector<long long> (2, -1)));
        return solve( 0 ,0 , 0);
    }
};",1448277503
Armaan,Armaan48,349,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int n = nums.size();
        map<int,pair<long long,long long>> dp;
        long long mod = 1000000007;
        for (int i=n-1;i>=0;i--){
            long long prv = dp[nums[i]].first;
            dp[nums[i]].first++;
            if (dp.count(nums[i] + 1)){
                dp[nums[i]].second = (dp[nums[i]].second +  dp[nums[i] + 1].second)%mod ; 
                dp[nums[i]].first = (dp[nums[i]].first  + dp[nums[i]+1].first)%mod;
            }
            if (dp.count(nums[i] - 1)){
                dp[nums[i]].second = (dp[nums[i]].second + dp[nums[i] - 1].second)%mod ;
                dp[nums[i]].first = (dp[nums[i]].first + dp[nums[i]-1].first)%mod;
                
            }
            dp[nums[i]].second = (dp[nums[i]].second + (dp[nums[i]].first - prv + mod) * nums[i]%mod)%mod;
        }
long long sum = 0;
        for (auto v: dp){
                sum = (sum + v.second.second)%mod;
        }
        return sum;
        
    }
};",1448230403
Peter Lin,inversionpeter,351,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        if (k == 1) {
            return true;
        }
        bool increasing;
        for (int i = 0; i <= nums.size() - (k << 1); ++i) {
            increasing = true;
            for (int j = i + 1; j < i + k; ++j) {
                if (nums[j - 1] >= nums[j]) {
                    increasing = false;
                    break;
                }
            }
            if (increasing) {
                for (int j = i + k + 1; j < i + (k << 1); ++j) {
                    if (nums[j - 1] >= nums[j]) {
                        increasing = false;
                        break;
                    }
                }
                if (increasing) {
                    return true;
                }
            }
        }
        return false;
    }
};",1448183887
Peter Lin,inversionpeter,351,3619,cpp,"int longests[200000];

class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int length = nums.size(), maximum = 0;
        longests[length - 1] = 1;
        for (int i = length - 2; i >= 0; --i) {
            if (nums[i] < nums[i + 1]) {
                longests[i] = longests[i + 1] + 1;
            }
            else {
                longests[i] = 1;
            }
        }
        for (int i = 0; i < length; ++i) {
            maximum = max(maximum, longests[i] >> 1);
            if (i + longests[i] < length) {
                maximum = max(maximum, min(longests[i], longests[i + longests[i]]));
            }
        }
        return maximum;
    }
};",1448192898
Peter Lin,inversionpeter,351,3631,cpp,"#define MOD 1000000007

int lookup[801], DP[801][801][2];

const static auto Initialize = []{
    ios::sync_with_stdio(false); cin.tie(nullptr);
    lookup[1] = 0;
    for (int i = 2, c; i <= 800; ++i) {
        c = 0;
        for (int j = 0; j < 10; ++j) {
            if (i & (1 << j)) {
                ++c;
            }
        }
        lookup[i] = lookup[c] + 1;
    }
    DP[1][0][0] = 1;
    DP[1][1][1] = 1;
    for (int i = 2; i <= 800; ++i) {
        DP[i][0][0] = 1;
        for (int j = 1; j <= i; ++j) {
            DP[i][j][0] = (DP[i - 1][j][0] + DP[i - 1][j][1]) % MOD;
            DP[i][j][1] = (DP[i - 1][j - 1][0] + DP[i - 1][j - 1][1]) % MOD;
        }
    }
    return nullptr;
}();

class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        int length = s.size(), counts = 0, ones = 1;
        for (int i = 1; i < length; ++i) {
            for (int j = 1; j <= i; ++j) {
                if (lookup[j] + (i > 1) <= k) {
                    counts += DP[i][j][1];
                    //cout << i << ' ' << j << ' ' << DP[i][j][1] << '\n';
                    if (counts >= MOD) {
                        counts -= MOD;
                    }
                }
            }
        }
        for (int i = 1; i < length; ++i) {
            if (s[i] == '1') {
                for (int j = 0; j <= length - i; ++j) {
                    if (lookup[j + ones] + 1 <= k) {
                        counts += DP[length - i][j][0];
                        if (counts >= MOD) {
                            counts -= MOD;
                        }
                    }
                }
                ++ones;
            }
        }
        return counts;
    }
};

// ""101011"" 3 -> 42?",1448285087
Peter Lin,inversionpeter,351,3646,cpp,"#define MOD 1000000007
int DP1[100005], DP2[100005];

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int total = 0, bound = 0;
        memset(DP1, 0, sizeof(DP1));
        memset(DP2, 0, sizeof(DP2));
        for (int i : nums) {
            if (!i) {
                DP1[0] = (DP1[0] + DP1[1] + 1) % MOD;
                DP2[0] = (DP2[0] + DP2[1]) % MOD;
            }
            else {
                DP1[i] = ((long long)DP1[i] + DP1[i + 1] + DP1[i - 1] + 1) % MOD;
                DP2[i] = ((long long)DP2[i] + (DP2[i + 1] + (long long)DP1[i + 1] * i) + (DP2[i - 1] + (long long)DP1[i - 1] * i) + i) % MOD;
            }
            bound = max(bound, i);
        }
        for (int i = 0; i <= bound; ++i) {
            total += DP2[i];
            if (total >= MOD) {
                total -= MOD;
            }
        }
        return total;
    }
};",1448216165
tranphuc8a,tranphuc8a,352,3612,cpp,"

class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> dp(n + 1, -1);
        for (int i = n - 1; i >= 0; i--){
            dp[i] = i;
            if (i + 1 < n && nums[i] < nums[i + 1]){
                dp[i] = dp[i + 1];
            } 
            if (dp[i] - i + 1 >= k){
                int next = i + k;
                if (dp[next] - next + 1 >= k) return 1;
            }
        }
        return 0;
    }
};",1448185756
tranphuc8a,tranphuc8a,352,3619,cpp,"

class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp(n + 1, -1);
        int res = 0;
        for (int i = n - 1; i >= 0; i--){
            dp[i] = i;
            if (i + 1 < n && nums[i] < nums[i + 1]){
                dp[i] = dp[i + 1];
            } 
            int next = dp[i] + 1;
            res = max(res, (dp[i] - i + 1)/2);
            if (next < n){
                res = max(res, min(dp[i] - i + 1, dp[next] - next + 1));
            }
        }
        // for (int i = 0; i < n; i++){
        //     cout << dp[i] << "" "";
        // }
        // cout << endl;
        return res;
    }
};
",1448216666
tranphuc8a,tranphuc8a,352,3631,cpp,"
const int mod = 1e9 + 7;
const int MAX = 800;

class Solution {
public:

	int cntBitOne(int n){
		int res = 0;
		while (n) {
			res += (n & 1);
			n >>= 1;
		}
		return res;
	}

    int countKReducibleNumbers(string s, int k) {
        int n = s.size();
        vector<int> red(n + 1, 1);
        for (int i = 2; i <= n; i++){
        	red[i] = 1 + red[cntBitOne(i)];
        }
        // for (int i = 0; i <= n; i++){
        // 	cout << red[i] << "" "";
        // }
        // cout << endl;
        if (s == ""1"") return 0;


        vector<int> acceptCntSetBit(n + 1, 0);
        for (int i = 1; i <= n; i++) {
        	if (red[i] <= k){
        		acceptCntSetBit[i] = 1;
        	}
        }


        vector<vector<vector<int>>> dp(n + 2, vector<vector<int>>(2, vector<int>(n + 1, 0)));
        dp[n][0][0] = 1;

        for (int i = n - 1; i >= 0; i--){
        	for (int tight = 0; tight < 2; tight++){
        		for (int cntBit = 0; cntBit <= n; cntBit++){
        			if (tight){
        				if (s[i] == '0'){
        					dp[i][tight][cntBit] = dp[i + 1][tight][cntBit];
        				} else {
        					dp[i][tight][cntBit] = dp[i + 1][0][cntBit];
        					if (cntBit > 0){
        						dp[i][tight][cntBit] = (dp[i][tight][cntBit] + 0ll + dp[i + 1][tight][cntBit - 1]) % mod;
        					}
        				}
        			} else {
        				dp[i][tight][cntBit] = dp[i + 1][tight][cntBit];
        				if (cntBit > 0){
        					dp[i][tight][cntBit] = (dp[i][tight][cntBit] + dp[i + 1][tight][cntBit - 1]) % mod;
        				}
        			}
        		}
        	}
        }

        int res = 0;
        for (int cntBit = 0; cntBit <= n; cntBit++){
        	if (acceptCntSetBit[cntBit]){
        		res = (res + 0ll + dp[0][1][cntBit]) % mod;
        	}
        }

        return res;
    }
};

",1448291938
tranphuc8a,tranphuc8a,352,3646,cpp,"
const int mod = 1e9 + 7;
const int MAX = 1e5;

int lft[MAX + 1] = {}, rgt[MAX + 1] = {};

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int n = nums.size();
        map<int, int> cntLeft, cntRight;
        fill(lft, lft + n, 0);
        fill(rgt, rgt + n, 0);
        for (int i = 0; i < n; i++){
            int add = (1ll + cntLeft[nums[i] - 1] + cntLeft[nums[i] + 1]) % mod;
            lft[i] = add;
            cntLeft[nums[i]] = (cntLeft[nums[i]] + add) % mod;
        }
        for (int i = n - 1; i >= 0; i--){
            int add = (1ll + cntRight[nums[i] - 1] + cntRight[nums[i] + 1]) % mod;
            rgt[i] = add;
            cntRight[nums[i]] = (cntRight[nums[i]] + add) % mod;
        }

        int res = 0;
        for (int i = 0; i < n; i++){
            int mult = lft[i] * 1ll * rgt[i] % mod;
            res = (res + nums[i] * 1ll * mult) % mod;
        }
        return res;
    }
};",1448246296
Akshayan M,AKXYN,353,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n=len(nums)
        for i in range(n-2*k+1):
            flag=False
            for j in range(i+1,i+k):
                if nums[j]<=nums[j-1]: 
                    flag=True
                    break
            for j in range(i+k+1,i+2*k):
                if nums[j]<=nums[j-1]: 
                    flag=True
                    break
            if not flag: return True
        return False",1448229193
Akshayan M,AKXYN,353,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        left=[]
        right=[]
        prev=-1
        streak=0
        for e in nums:
            if e>prev: streak+=1
            else: streak=1
            left.append(streak)
            prev=e
        prev=float('inf')
        streak=0
        for e in nums[::-1]:
            if e<prev: streak+=1
            else: streak=1
            right.append(streak)
            prev=e
        right.reverse()
        res=0
        n=len(nums)
        # print(left)
        # print(right)
        for i in range(n-1):
            res=max(res,min(left[i],right[i+1]))
        return res
                ",1448239999
Akshayan M,AKXYN,353,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        dp=[0]
        for i in range(1,801):
            j=i
            for _ in range(k-1):
                j=bin(j).count('1')
            dp.append(int(j==1))
        # print(dp[:10])
        n=len(s)
        mod=10**9+7
        @cache
        def solve(i,equal,tot):
            if i==n: return dp[tot] if not equal else 0
            res=solve(i+1,equal and s[i]=='0',tot)
            if not equal or s[i]=='1': res+=solve(i+1,equal and s[i]=='1',tot+1)
            return res%mod
        return solve(0,1,0)
            ",1448292592
Akshayan M,AKXYN,353,3646,python3,"from bisect import bisect_right
class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        data=defaultdict(list)
        for i,e in enumerate(nums):
            data[e].append(i)
        
        mod=10**9+7
        
        @cache
        def count(i):
            res=1
            ref=data[nums[i]]
            j=bisect_right(ref,i)
            if j<len(ref): res+=count(ref[j])
                
            ref=data[nums[i]+1]
            j=bisect_right(ref,i)
            if j<len(ref): res+=count(ref[j])
            
            ref=data[nums[i]-1]
            j=bisect_right(ref,i)
            if j<len(ref): res+=count(ref[j])
            
            return res
        
        @cache
        def solve(i):
            res=nums[i]
            ref=data[nums[i]]
            j=bisect_right(ref,i)
            if j<len(ref): res+=solve(ref[j])
                
            ref=data[nums[i]+1]
            j=bisect_right(ref,i)
            if j<len(ref): res+=count(ref[j])*nums[i]+solve(ref[j])
            
            ref=data[nums[i]-1]
            j=bisect_right(ref,i)
            if j<len(ref): res+=count(ref[j])*nums[i]+solve(ref[j])
            
            return res%mod
        
        s=set()
        res=0
        for i,e in enumerate(nums):
            if e not in s:
                res+=solve(i)
                s.add(e)
                res%=mod
        return res
            ",1448273615
Vladislav,timetoai,355,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        inc = [1] * len(nums)
        acc = 1
        for i in range(1, len(nums)):
            if nums[i] > nums[i - 1]:
                acc += 1
            else:
                acc = 1
            inc[i] = acc
        for i in range(k - 1, len(nums) - k):
            if inc[i] >= k and inc[i + k] >= k:
                return True
        return False
        ",1448183568
Vladislav,timetoai,355,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        inc = []
        acc = 1
        for i in range(1, len(nums)):
            if nums[i] > nums[i - 1]:
                acc += 1
            else:
                inc.append(acc)
                acc = 1
        inc.append(acc)
        ret = max(1, inc[0] // 2)
        for i in range(1, len(inc)):
            ret = max(ret, min(inc[i], inc[i - 1]), inc[i] // 2)
        return ret
        ",1448192356
Vladislav,timetoai,355,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        mod = 10 ** 9 + 7
        n = len(s)
        # 0op: 1
        # 1op: any 1-bit (excluding 1) [2, 4, 8, 16 ...]
        # 2op: any i-bit (excluding i = 1), where i in 1op res [3, 5, 6 ...]
        # 3op: any i1-bit (excluding i1 э i), where i1 in 2op res
        left_ones = [""1"" == s[i] for i in range(n)]
        for i in range(n - 2, - 1, - 1):
            left_ones[i] += left_ones[i + 1]

        def combn(bits):
            opts = {bits - 1: 1}  # left: cnt
            tot = 0
            for i in range(1, n):
                nxt = defaultdict(int)
                for left, cnt in opts.items():
                    if left == 0:
                        if left_ones[i] > 0:
                            tot = (tot + cnt) % mod
                        continue
                    if s[i] == ""0"":
                        nxt[left] += cnt
                    else:
                        nxt[left - 1] += cnt
                        tot = (tot + math.comb(n - i - 1, left)) % mod
                opts = nxt
            return tot

        # def combinationsn(bits):
        #     cur = {(n, bits - 1)}
        #     for i in range(1, n):
        #         nxt = set()
        #         for ss, left in cur:
        #             if left == 0:
        #                 yield ss + (n - i) * ""0""
        #                 continue
        #             if s[i] == ""0"":
        #                 nxt.add((ss + ""0"", left))
        #             else:
        #                 nxt.add((ss + ""1"", left - 1))
                        
        #         cur = nxt
        #     for ss, left in cur:
        #         if left == 0:
        #             yield ss
        
        used = {1}
        cur = [1]
        ret = 0
        for ki in range(k):
            nxt = []
            for i in cur:
                # print(i, comb(n - 1, i), combn(i))
                ret = (ret + math.comb(n - 1, i) % mod + combn(i) % mod) % mod
                for bit_poses in combinations(range(min(10, n - 1)), i):
                    ni = sum(1 << b for b in bit_poses)
                    if ni not in used:
                        nxt.append(ni)
                        used.add(ni)
                # for bit_poses in combinationsn(i):
                #     ni = sum(1 << b for b in bit_poses)
                #     if ni not in used:
                #         nxt.append(ni)
                #         used.add(ni)
            cur = nxt
        return ret
        ",1448286757
Vladislav,timetoai,355,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        mod = 10 ** 9 + 7
        end = defaultdict(int)
        cnt = defaultdict(int)
        ret = 0
        for num in nums:
            cur_cnt = cnt[num - 1] + cnt[num + 1] + 1
            cur = (end[num - 1] + num * cur_cnt + end[num + 1]) % mod
            ret = (ret + cur) % mod
            end[num] = (end[num] + cur) % mod
            cnt[num] += cur_cnt
        return ret
        ",1448200864
Rad0miR,Rad0miR,357,3612,csharp,"public class Solution {
    public bool HasIncreasingSubarrays(IList<int> nums, int k) {
        List<int> temp = new();
        int prev = Int32.MinValue, cnt = 0;
        foreach (int x in nums) 
        {
            if (x <= prev) 
            {
                temp.Add(cnt);
                prev = x;
                cnt = 1;
                continue;
            }

            prev = x;
            cnt++;
        }
        temp.Add(cnt);

        int ans = temp.Max() / 2;

        if (temp.Count > 1) 
            ans = Math.Max(ans, temp.Zip(temp.Skip(1), (f, s) => Math.Min(f, s)).Max());

        return ans >= k;
    }
}",1448190848
Rad0miR,Rad0miR,357,3619,csharp,"public class Solution {
    public int MaxIncreasingSubarrays(IList<int> nums) 
    {
        List<int> temp = new();
        int prev = Int32.MinValue, cnt = 0;
        foreach (int x in nums) 
        {
            if (x <= prev) 
            {
                temp.Add(cnt);
                prev = x;
                cnt = 1;
                continue;
            }

            prev = x;
            cnt++;
        }
        temp.Add(cnt);

        int ans = temp.Max() / 2;

        if (temp.Count > 1) 
            ans = Math.Max(ans, temp.Zip(temp.Skip(1), (f, s) => Math.Min(f, s)).Max());
        
        return ans;
    }
}",1448189493
Rad0miR,Rad0miR,357,3631,csharp,"public class Solution {
    public int CountKReducibleNumbers(string s, int k) 
    {
        int[] ops = new int[801];
        for (int i = 1; i <= 800; ++i) 
        {
            int x = i;
            while (x > 1) 
            {
                ops[i]++;
                x = BitOperations.PopCount((uint)x);
            }
        }

        //Console.WriteLine(String.Join(' ', ops));

        List<int> good = Enumerable.Range(1, 800).Where(i => ops[i] + 1 <= k).ToList();

        //Console.WriteLine(String.Join(' ', good));
        
        Dictionary<(int, int), long> dp = new();

        const int mod = 1_000_000_007;
        long ans = 0;

        int bits = 0;
        for(int i = 0; i < s.Length; ++i) 
        {
            if (s[i] == '0') continue;

            ++bits;
            foreach (int val in good) 
            {
                //Console.WriteLine($""{i} {val} {s.Length - i - 1} {val - bits + 1} {C(s.Length - i - 1, val - bits + 1)}"");
                ans += C(s.Length - i - 1, val - bits + 1);
                ans %= mod;
            }
        }
        
        return (int) ans;

        long C(int n, int k) 
        {
            if (k > n || k < 0) return 0;
            if (n == 0) return k == 0 ? 1 : 0;
            if (k == 0) return 1;
            var key = (n, k);
            if (!dp.ContainsKey(key)) 
            {
                dp[key] = (C(n - 1, k - 1) + C(n - 1, k)) % mod;
            }
            return dp[key];
        }
    }
}
/*
10
01
*/",1448276047
Rad0miR,Rad0miR,357,3646,csharp,"public class Solution 
{
    public int SumOfGoodSubsequences(int[] nums) 
    {
        const int mod = 1_000_000_007;
        long[] sums = new long[100_002];
        long[] cnts = new long[100_002];
        cnts[0] = 0;

        foreach (int x in nums) 
        {
            //if (x == 0) continue;

            sums[x] = Sum3(
                sums[x], 
                Sum(Mult((x == 0 ? 0 :cnts[x - 1]) + 1, x), x == 0 ? 0 :sums[x - 1]),
                Sum(Mult(cnts[x + 1], x), sums[x + 1])
                );
            
            cnts[x] = Sum3(
                cnts[x], 
                (x == 0 ? 0 :cnts[x - 1]) + 1, cnts[x + 1]
                );

            //Console.WriteLine(String.Join(' ', sums.Take(3)));
            //Console.WriteLine(String.Join(' ', cnts.Take(3)));
        }
        
        return (int) (sums.Sum() % mod);

        long Mult(long a, long b) => (a * b) % mod;
        long Sum(long a, long b) => (a + b) % mod;
        long Sum3(long a, long b, long c) => (a + b + c) % mod;
    }
}",1448287032
Skhirtladze,jskhirtladze,359,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int ans=0;
        int cnt=0;
        vector <int> a;
        for (int i=0;i<nums.size();i++)
            if (i==0 || nums[i]<=nums[i-1]) a.push_back(1);
                                       else a[a.size()-1]++;

        for (int i=0;i<a.size();i++) {
            ans=max(ans, a[i]/2);
            if (i) ans=max(ans, min(a[i],a[i-1]));
        }

        return (ans>=k);
    }
};",1448189711
Skhirtladze,jskhirtladze,359,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int ans=0;
        int cnt=0;
        vector <int> a;
        for (int i=0;i<nums.size();i++)
            if (i==0 || nums[i]<=nums[i-1]) a.push_back(1);
                                       else a[a.size()-1]++;

        for (int i=0;i<a.size();i++) {
            ans=max(ans, a[i]/2);
            if (i) ans=max(ans, min(a[i],a[i-1]));
        }
        return ans;
    }
};",1448187426
Skhirtladze,jskhirtladze,359,3631,cpp,"class Solution {
public:

    const static long long M = 1000*1000*1000+7;
    long long C[1000][1000];
    long long occ[1000];

    int bcnt(int x) {
        int cnt=0;
        while (x) {
            cnt+=(x%2);
            x/=2;
        }
        return cnt;
    }

    long long upd(int placed, int need, int space) {
        int ones=need-placed;
        if (ones<0) return 0;
        if (ones>space ) return 0;

        occ[need]+=C[space][ones];
        occ[need]%=M;
        return C[space][ones];
    }

    int countKReducibleNumbers(string s, int k) {

        vector <long long> need(801,0);
        for (int i=2;i<=800;i++)
            need[i]=1+need[bcnt(i)];

        for (int i=0;i<1000;i++)
            for (int j=0;j<=i;j++)
                if (j==0 || j==i)
                    C[i][j]=1;
                else C[i][j]=(C[i-1][j]+C[i-1][j-1])%M;

        int n=s.size();
        int original_cnt=0;
        for (int i=0;i<n;i++)
            if (s[i]=='1') {
                for (int j=1;j<=n;j++)
                    upd(original_cnt, j, n - i - 1);
                original_cnt++;
        }

        long long ans=0;
        for (int j=1;j<=n;j++) {
            if (need[j]+1LL > k) continue;
            ans=(ans+occ[j])%M;
        }
        return ans;
    }
};",1448293952
Skhirtladze,jskhirtladze,359,3646,cpp,"class Solution {
public:

    static const int N=100000+10;
    int sum[N],cnt[N];
    static const long long M=1000*1000*1000+7;
    
    int sumOfGoodSubsequences(vector<int>& nums) {
        long long ans=0;
        for (int i=0;i<nums.size();i++) {
            long long x = nums[i];
            long long a = x > 0 ? sum[x-1] : 0;
            long long acnt = x > 0 ? cnt[x-1] : 0;
            long long b = sum[x+1];
            long long bcnt = cnt[x+1];

            long long allcnt = (acnt+bcnt)%M;
            long long allsum = (a+b)%M;

            long long currcnt=(allcnt+1LL)%M;
            long long currsum=((x*currcnt)%M+allsum)%M;
            
            ans=(ans+currsum)%M;
            cnt[x]+=currcnt; cnt[x]%=M;
            sum[x]+=currsum; sum[x]%=M;
        }
        return ans;
    }
};",1448217853
varous,sourav_suku,360,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n=nums.size();
        for(int i=0;i+k*2<=n;++i){
            int flag=1;
            for(int j=i+1;j<i+k;++j){
                if(nums[j]<=nums[j-1])flag=0;
            }
            for(int j=i+k+1;j<i+k*2;++j){
                if(nums[j]<=nums[j-1])flag=0;
            }
            if(flag)return true;
        }
        return false;
    }
};",1448199996
varous,sourav_suku,360,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n=nums.size();
        vector<int> dp(n);
        int res=1;
        for(int i=n-1;i>=0;--i){
            dp[i]=1;
            if(i+1<n&&nums[i+1]>nums[i])dp[i]+=dp[i+1];
            int ind=i+dp[i];
            int cur=dp[i]/2;
            if(ind<n){
                int val=min(dp[i],dp[ind]);
                cur=max(cur,val);
            }
            res=max(res,cur);
            // cout<<i<<"" ""<<dp[i]<<endl;
        }
        return res;
    }
};",1448245033
varous,sourav_suku,360,3631,cpp,"const long long int M=(int)1e9+7;
#define popcount(x)     __builtin_popcount(x)
#define ll long long
ll dp[805][805][2];
ll dp2[805];
class Solution {
public:
    ll cal(string& s,int ind,int sum,int strict,int k){
        if(ind==s.size()){
            // cout<<sum<<"" ""<<dp2[sum]<<endl;
            if(1+dp2[sum]<=k){
                return dp[ind][sum][strict]=1;
            }else{
                return dp[ind][sum][strict]=0;
            }
        }else if(dp[ind][sum][strict]!=-1)return dp[ind][sum][strict];
        else{
            int st=0,end=(strict?s[ind]-'0':1);
            ll val=0;
            for(int i=st;i<=end;++i){
                val+=cal(s,ind+1,sum+i,strict&&(i==s[ind]-'0'),k);
                val%=M;
            }
            return dp[ind][sum][strict]=val;
        }
    }
    int countKReducibleNumbers(string s, int k) {
        int n=s.size();
        for(int i=0;i<=n;++i)for(int j=0;j<=n;++j){dp[i][j][0]=-1;   dp[i][j][1]=-1;}
        dp2[1]=0;       dp2[0]=k+1;
        int sum=0;
        for(int i=0;i<n;++i)sum+=s[i]-'0';
        for(int i=2;i<=n;++i){
            int val=popcount(i);
            dp2[i]=dp2[val]+1;
            // cout<<i<<"" ""<<dp2[i]<<endl;
        }
        ll val=cal(s,0,0,1,k);
        if(1+dp2[sum]<=k)--val;
        val+=M;     val%=M;
        return val;
    }
};",1448287535
varous,sourav_suku,360,3646,cpp,"const long long int M=(int)1e9+7;
#define ll long long
class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int n=nums.size();
        map<int,ll> dp1,dp2;
        ll res=0;
        for(int i=n-1;i>=0;--i){
            ll cnt=dp1[nums[i]+1];
            cnt+=dp1[nums[i]-1];
            cnt++;      cnt%=M;
            ll cur=(cnt)*nums[i]; 
            cur%=M;
            cur+=dp2[nums[i]+1];
            cur%=M;
            cur+=dp2[nums[i]-1];
            cur%=M;
            res+=cur;       res%=M;
            dp2[nums[i]]+=cur;      dp2[nums[i]]%=M;
            dp1[nums[i]]+=cnt;      dp1[nums[i]]%=M;
        }
        return res;
    }
};",1448228110
ez95088,ez95088,362,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        if (k == 1) {
            return true;
        }
        for (int s1 = 0, s2 = k; s2 + k - 1 < nums.size(); s1++, s2++) {
            bool first = true;
            bool second = true;
            for (int i = s1 + 1; i < s1 + k; i++) {
                if (nums[i] <= nums[i - 1]) {
                    first = false;
                    break;
                }
            }
            for (int i = s2 + 1; i < s2 + k; i++) {
                if (nums[i] <= nums[i - 1]) {
                    second = false;
                    break;
                }
            }
            if (first && second) {
                return true;
            }
        }
        return false;
    }
};",1448185921
ez95088,ez95088,362,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> res(n, 0);
        int increasing = 0;
        int prev = INT_MIN;
        for (int end = 0; end < n; end++) {
            if (nums[end] > prev) {
                increasing++;
            } else {
                increasing = 1;
            }
            res[end] = increasing;
            prev = nums[end];
        }
        int result = 1;
        for (int i = 0; i < n; i++) {
            result = max(result, res[i] / 2);
            if (i - res[i] >= 0 && res[i - res[i]] >= res[i]) {
                result = max(result, res[i]);
            }
        }
        return result;
    }
};",1448202049
ez95088,ez95088,362,3631,cpp,"class Solution {
private:
    int power2[801];
    int mod = 1e9 + 7;
    int memo[801][801][2];
public:
    int countKReducibleNumbers(string s, int k) {
        int n = s.size();
        int steps[801];
        steps[0] = 0;
        int rr = 0;
        for (int i = 1; i <= 800; i++) {
            steps[i] = __builtin_popcount(i);
            rr = max(rr, steps[i]);
        }
        int p2 = 1;
        power2[0] = 1;
        for (int i = 1; i <= 800; i++) {
            p2 = (p2 * 2) % mod;
            power2[i] = p2;
        }
        steps[1] = 0;
        for (int i = 2; i <= 800; i++) {
            steps[i] = steps[steps[i]] + 1;
        }
        memset(memo, -1, sizeof(memo));
        for (int i = 1; i <= n; i++) {
            dp(0, i, s, true);
        }
        int res = 0;
        for (int i = 1; i <= n; i++) {
            if (steps[i] + 1 <= k) {
                res = (res + dp(0, i, s, true)) % mod;
            }
        }
        int s_bits = 0;
        for (int i = 0; i < n; i++) {
            s_bits += s[i] == '1';
        }
        if (steps[s_bits] + 1 <= k) {
            res--;
        }
        return res;
    }
    // need to fill k bits from s[i] to s[-1]
    int dp(int i, int k, string &s, bool constrained) {
        int n = s.size();
        int bit_left = n - i;
        if (bit_left < k) {
            return 0;
        }
        if (k == 0) {
            return 1;
        }
        if (i == n) {
            return k == 0? 1: 0;
        }
        if (memo[i][k][constrained? 1: 0] != -1) {
            return memo[i][k][constrained? 1: 0];
        }
        long long res = 0;
        if (not constrained) {
            res = dp(i + 1, k, s, constrained);
            res = (res + dp(i + 1, k - 1, s, constrained)) % mod;
        } else {
            int bit = s[i] - '0';
            if (bit == 1) {
                res = dp(i + 1, k, s, not constrained);
                res = (res + dp(i + 1, k - 1, s, constrained)) % mod;
            } else {
                res = dp(i + 1, k, s, constrained);
            }
        }
        memo[i][k][constrained? 1: 0] = res;
        return res;
    }
};",1448300991
ez95088,ez95088,362,3646,cpp,"class Solution {
private:
    int mod = 1e9 + 7;
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        map<int, pair<long long, long long>> mp; // num -> sum, ways
        for (int num: nums) {
            pair<long long, long long> cur = mp[num];
            cur.first = (cur.first + num) % mod;
            cur.second = (cur.second + 1) % mod;
            auto next = mp[num + 1];
            long long nn = (next.first + next.second * num % mod) % mod;
            cur.first = (cur.first + nn) % mod;
            cur.second = cur.second + next.second % mod;
            auto prev = mp[num - 1];
            long long pp = (prev.first + prev.second * num % mod) % mod;
            cur.first = (cur.first + pp) % mod;
            cur.second = cur.second + prev.second % mod;
            mp[num] = cur;
        }
        long long res = 0;
        for (auto it = mp.begin(); it != mp.end(); it++) {
            res = (res + it->second.first) % mod;
        }
        return res;
    }
};",1448232721
Atul,coderchamp07,363,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();

        vector<int> incLen(n, 1);
        for(int r = 1; r < n; r++) {
            if(nums[r - 1] < nums[r])
                incLen[r] += incLen[r - 1];
        }

        for(int i = 0; i + k < n; i++) {
            if(incLen[i] >= k && incLen[i + k] >= k)
                return true;
        }
        return false;
    }
};",1448183244
Atul,coderchamp07,363,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();

        vector<int> incLen(n, 1);
        for(int r = 1; r < n; r++) {
            if(nums[r - 1] < nums[r])
                incLen[r] += incLen[r - 1];
        }

        auto poss = [&](int k) -> bool {
            for(int i = 0; i + k < n; i++) {
                if(incLen[i] >= k && incLen[i + k] >= k)
                    return true;
            }
            return false;
        };

        int l = 0, r = n - 1;
        while(l <= r) {
            int m = (l + r) / 2;
            if(poss(m))
                l = m + 1;
            else
                r = m - 1;
        }
        return r;
    }
};",1448186110
Atul,coderchamp07,363,3631,cpp,"class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        const int mod = 1e9 + 7;
        int n = s.size();

        auto setBitsIn = [&](int v) -> int {
            int ans = 0;
            for(int bit = 0; bit < 32; bit++) {
                if((v >> bit) & 1)
                    ans++;
            }
            return ans;
        };
        
        set<int> canHaveSetBits;

        map<int, int> t;
        for(int i = 1; i <= n; i++) {
            t[i] = 1 + t[setBitsIn(i)];
            if(t[i] <= k)
                canHaveSetBits.insert(i);
        }

        map<int, int> dp[n][2];

        auto recur = [&](auto&& recur, int pos, bool tight, int setBits) -> int {
            if(pos == n)
                return !tight && canHaveSetBits.count(setBits);
            if(setBits > *canHaveSetBits.rbegin())
                return 0;

            if(dp[pos][tight].count(setBits))
                return dp[pos][tight][setBits];

            // add 0 here
            int ans = recur(recur, pos + 1, tight && (s[pos] == '0'), setBits);

            // add 1 here
            if(!tight || s[pos] == '1')
                ans = (1ll * ans + recur(recur, pos + 1, tight && (s[pos] == '1'), setBits + 1)) % mod;
            return dp[pos][tight][setBits] = ans;
        };

        
        return recur(recur, 0, true, 0);
    }
};",1448274192
Atul,coderchamp07,363,3646,python3,"class Solution:
    MOD = int(1e9 + 7)

    def modMul(self, a, b):
        result = 0
        a %= self.MOD
        
        while b > 0:
            if b % 2 == 1:
                result = (result + a) % self.MOD
            a = (a * 2) % self.MOD
            b //= 2
        
        return result % self.MOD

    def sumOfGoodSubsequences(self, nums):
        n = len(nums)
        sumEnding = {}
        cntEnding = {}

        for cur in nums:
            sumEnding[cur] = (sumEnding.get(cur, 0) + cur) % self.MOD
            cntEnding[cur] = cntEnding.get(cur, 0) + 1

            if (cur - 1) in sumEnding:
                cntEnding[cur] += cntEnding[cur - 1]
                sumEnding[cur] = (
                    (sumEnding[cur] + sumEnding[cur - 1]) % self.MOD +
                    self.modMul(cntEnding[cur - 1], cur)
                ) % self.MOD

            if (cur + 1) in sumEnding:
                cntEnding[cur] += cntEnding[cur + 1]
                sumEnding[cur] = (
                    (sumEnding[cur] + sumEnding[cur + 1]) % self.MOD +
                    self.modMul(cntEnding[cur + 1], cur)
                ) % self.MOD

        ans = sum(sumEnding.values()) % self.MOD
        return ans
",1448223679
Halsey Walker,HalseyWalker,364,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int N = nums.size();
        vector<int> startList(N,0);
        int prev = nums[0];
        int left = 0;
        for(int i = 1;i < N;++i){
            int cur = nums[i];
            if(cur > prev){
                startList[i] = left;
            }
            else{
                startList[i] = i;
                left = i;
            }

            prev = cur;
        }
        for(int i = 0;i < N; ++i){
            if(i+1-startList[i] >= k){
                if(i + 1 - startList[i] >= k*2) return true;
                int prevEnd = startList[i] - 1;
                if(prevEnd >= 0){
                    int prevStart = startList[prevEnd];
                    if(prevEnd + 1 - prevStart >= k) return true;
                }

            }
        }
        return false;
    }
};",1448191414
Halsey Walker,HalseyWalker,364,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int N = nums.size();
        vector<int> startList(N,0);
        int prev = nums[0];
        int left = 0;
        for(int i = 1;i < N;++i){
            int cur = nums[i];
            if(cur > prev){
                startList[i] = left;
            }
            else{
                startList[i] = i;
                left = i;
            }

            prev = cur;
        }
        int ans = 1;
        for(int i = 0;i < N; ++i){
            if(i > startList[i]  ){
                int len = i + 1 - startList[i];
                ans = max(ans , len/2);
                int prevEnd = startList[i] - 1;
                if(prevEnd >= 0){
                    int prevStart = startList[prevEnd];
                    int minLen = min(prevEnd + 1 - prevStart, len);
                    ans = max(ans,minLen);
                }

            }
        }
        return ans;
    }
};",1448198799
Halsey Walker,HalseyWalker,364,3631,cpp,"const int mod = 1e9+7;
class Solution {
public:
    int ok(int n,int step){
        if(n <= 1) return 1;
        while(step--){
            if(n == 1) return 1;
            n = __builtin_popcount(n);
        }
        return 0;
    }
    long long jx(int x){
        static bool init = false;
        static vector<long long> list;
        if(!init){
            init = 1;
            list.resize(801,1);
            for(int i = 1;i <= 800;++i){
                list[i] = i * list[i-1];
                list[i] %= mod;
            }
        }
        return list[x];
    }
    long long exp(long long x,int e){
        long long ans = 1;
        long long base = x;
        while(e){
            if(e % 2){
                ans *= base;
                ans %= mod;
            }
            base *= base;
            base %= mod;
            e >>= 1;
        }
        return ans;
    }
    int C(int tot,int take){
        long long res = jx(tot);
        long long a = jx(take);
        long long b = jx(tot - take);
        res *= exp(a,mod-2);
        res %= mod;
        res *= exp(b,mod-2);
        res %= mod;
        return res;
    }
    vector<char> has1List;
    int f(string& s,int one){
        int N = s.length();
        int prev = 0;
        long long ret = 0;
        for(int i = 0;i < N;++i){
            if(s[i] == '1'){
                int back = one - prev;
                prev++;
                if(N-1-i < back){
                    break;
                }
                if(back == 1){
                    if(has1List[i]){
                        ret++;
                    }
                }
                if(back == 0){
                    break;
                }
                else{
                    ret += C(N-1-i , back);
                    ret %= mod;
                }
            }
        }
        return ret%mod;
    }
    int countKReducibleNumbers(string s, int k) {
        int N = s.length();
        has1List.resize(N,0);
        int has = 0;
        for(int i = N-1;i >=0;i--){
            has1List[i] = has;
            if(s[i] == '1'){
                has = 1;
            }
        }
        vector<int> okList(N+1,1);
        for(int i = 1;i <=N;++i){
            okList[i] = ok(i,k);
        }
        long long ans = 0;
        for(int one = 1;one <= N;++one){
            if(okList[one] == 0) continue;
            ans += f(s,one);
            ans %= mod;
        }

        return ans;
    }
};",1448294429
Halsey Walker,HalseyWalker,364,3646,cpp,"const int mod = 1e9+7;
class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int N = nums.size();
        vector<long long> sumList(N,0);
        map<int,long long> cntMap;
        map<int,long long> m;
        for(int i = 0;i < N;++i){
            long long cur = nums[i];
            int a = cur-1;
            int b = cur+1;
            long long sum = cur;
            long long meCnt = 1;
            if(m.find(a) != m.end()){
                long long suma = m[a];
                long long cnt = cntMap[a];
                meCnt += cnt;
                sum += suma + cnt*cur;
                sum %= mod;
            }
            if(m.find(b) != m.end()){
                long long sumb = m[b];
                long long cnt = cntMap[b];
                meCnt += cnt;
                sum += sumb + cnt* cur;
                sum %= mod;
            }
            meCnt%=mod;
            cntMap[cur] += meCnt;
            m[cur] += sum;
            sumList[i] = sum;
        }
        long long ans = 0;
        for(auto sum:sumList) ans += sum;
        return ans % mod;
    }
};",1448226239
Conrad_123,Conrad_123,368,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(std::vector<int>& nums, int k) {

        std::vector<int> counts(nums.size(), 1);

        for(int i = 1; i < nums.size(); i++){
            if(nums[i-1] < nums[i]){
                counts[i] = counts[i-1]+1;
            }
        }

        for(int i = k; i < counts.size(); i++){
            std::cout<<counts[i]<<"" "";
            if(counts[i] < k) continue;

            if(counts[i-k] >= k) return true;
        }

        return false;
    }
};",1448185566
Conrad_123,Conrad_123,368,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(std::vector<int>& nums) {

        std::vector<int> counts(nums.size(), 1);
        int k = 1;
        
        for(int i = 1; i < nums.size(); i++){
            if(nums[i-1] < nums[i]){
                counts[i] = counts[i-1]+1;
            }
            
            while(i - k >= 0 && counts[i] >= k && counts[i-k] >= k){
                k++;
            }        
        }


        return k - 1;
    }
};",1448192380
Conrad_123,Conrad_123,368,3631,cpp,"class Solution {
public:

    int Get_Reduction_Count(int num, int k, std::vector<std::vector<int>>& cache){

        if(num == 1){
            return 0;
        }

        if(k == 0) return 1e9;

        if(cache[num][k] != -1){
            return cache[num][k];
        }

        int idx = 0;
        int bit_counts = 0;
        while((1 << idx) <= num){
            if(num & (1 << idx)) bit_counts++;
            idx++;
        }

        return cache[num][k] = 1+Get_Reduction_Count(bit_counts, k-1, cache);
    }

    int Count_Nums(std::string& s, int idx, int bit_counts, bool is_smaller, std::vector<std::vector<int>>& cache, std::vector<bool>& is_valid){

        if(idx >= s.size() && is_valid[bit_counts] && is_smaller){
            return 1;
        }else if(idx >= s.size()){
            return 0;
        }

        if(cache[idx*2 + is_smaller][bit_counts] != -1){
            return cache[idx*2 + is_smaller][bit_counts];
        }

        int mod = 1e9+7;
        int result = 0;
        if(s[idx] == '1'){
            result += Count_Nums(s, idx+1, bit_counts+1, is_smaller, cache, is_valid);
            result %= mod;
            result += Count_Nums(s, idx+1, bit_counts, true, cache, is_valid);
            result %= mod;
        }else{
            if(is_smaller){
                result += Count_Nums(s, idx+1, bit_counts+1, is_smaller, cache, is_valid);
                result %= mod;
            }
            result += Count_Nums(s, idx+1, bit_counts, is_smaller, cache, is_valid);
            result %= mod;
        }

        return cache[idx*2 + is_smaller][bit_counts] = result;
    }

    int countKReducibleNumbers(std::string s, int k) {

        std::vector<std::vector<int>> reduction_cache(s.size()+1, std::vector<int>(k+1, -1));
        std::vector<bool> is_valid(s.size()+1, false);
    
        for(int i = 1; i <= s.size(); i++){
            int count = Get_Reduction_Count(i, k, reduction_cache);
            if(count < k){  
                is_valid[i] = true;  
            } 
            
        }

        std::vector<std::vector<int>> cache(s.size()*2, std::vector<int>(s.size()+1, -1));

        return Count_Nums(s, 0, 0, false, cache, is_valid);
    }
};",1448230995
Conrad_123,Conrad_123,368,3646,cpp,"class Solution {
public:

    int Count_Sum(std::vector<std::vector<int>>& dag, int idx, std::vector<int>& cache, std::vector<int>& counts){

        if(idx >= dag.size()){
            return 0;
        }

        if(cache[idx] != -1){
            return cache[idx];
        }
        
        int mod = 1e9+7;
        counts[idx] = 1;
        counts[idx] += Count_Sum(dag, dag[idx][0], cache, counts);
        counts[idx] %= mod;
        counts[idx] += Count_Sum(dag, dag[idx][1], cache, counts);
        counts[idx] %= mod;
        
        int skip = Count_Sum(dag, dag[idx][2], cache, counts);
            
        return cache[idx] = (skip + counts[idx])%mod;
    }

    void Get_Count(std::vector<int>& nums, std::vector<int>& counts){
        std::unordered_map<int, int> last_seen;
        std::vector<std::vector<int>> dag(nums.size(), std::vector<int>(3, nums.size()));
        
        for(int i = (int)nums.size()-1; i >= 0; i--){

            if(last_seen.find(nums[i] + 1) != last_seen.end()){
                dag[i][0] = last_seen[nums[i]+1];
            }
            if(last_seen.find(nums[i] - 1) != last_seen.end()){
                dag[i][1] = last_seen[nums[i]-1];
            }
            if(last_seen.find(nums[i]) != last_seen.end()){
                dag[i][2] = last_seen[nums[i]];
            }
            last_seen[nums[i]] = i;
        }

        std::vector<int> cache(nums.size(), -1);

        for(int i = 0; i < nums.size(); i++){
            Count_Sum(dag, i, cache, counts);
        }
    }

    int sumOfGoodSubsequences(std::vector<int>& nums) {

        std::vector<int> counts1(nums.size(), 0);

        Get_Count(nums, counts1);
        std::reverse(nums.begin(), nums.end());
        std::vector<int> counts2(nums.size(), 0);

        Get_Count(nums, counts2);
        std::reverse(nums.begin(), nums.end());
        std::reverse(counts2.begin(), counts2.end());

        long long sum = 0;
        int mod = 1e9 + 7;
        for(int i = 0; i < nums.size(); i++){
            //std::cout<<counts1[i]<<"" ""<<counts2[i]<<'\n';
            long long subarrays = (long long)counts1[i] * (long long)(counts2[i]);
            subarrays %= mod;
            //subarrays += counts1[i] + counts2[i];
            subarrays %= mod;

            sum += subarrays * (long long)nums[i];
            sum %= mod;
        }
    
        return sum;
    }
};",1448295464
kailam11223,kailam11223,369,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        vector<int> lens(nums.size(), 0);
        lens[0] = 1;
        for(int i = 1; i < nums.size(); ++i){
            if(nums[i] <= nums[i-1]){
                lens[i] = 1;
            } else {
                lens[i] = lens[i-1]+1;
            }
            if( i>=k && lens[i] >= k && lens[i-k] >= k) return true;
        }
        
        return false;
    }
};",1448194372
kailam11223,kailam11223,369,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        vector<int> lens(nums.size(), 0);
        lens[0] = 1;
        int ret = 1;
        for(int i = 1; i < nums.size(); ++i){
            if(nums[i] <= nums[i-1]){
                lens[i] = 1;
            } else {
                lens[i] = lens[i-1]+1;
            }
            ret = max(ret, (i >= lens[i] && lens[i-lens[i]] >= lens[i]) ? lens[i] : lens[i]/2);
        }
        
        return ret;
    }
};",1448191799
kailam11223,kailam11223,369,3631,cpp,"class Solution {
private:
    int bit_count(int x){
        int c = 0;
        while(x){
            c += (x%2);
            x >>= 1;
        }
        return c;
    }
    long long pow_mod(long long x, int n){
        if(n==0) return 1;
        x%=MOD;
        long long p = pow_mod(x, n/2);
        p = (p*p)%MOD;
        return (p*((n%2)?x:1LL))%MOD;
    }
    long long nCr(long long n, long long r){
        if(r > n) return 0;
        if(r==0) return 1;
        return (((n * invs[r]) % MOD) * nCr(n-1, r-1)) % MOD;
    }
    void construct(){
        invs = vector<long long>(801, 0);
        for(int i = 1; i < invs.size(); ++i) invs[i] = pow_mod(i, MOD-2);
    }
public:
    int countKReducibleNumbers(string s, int k) {
        // s = std::string(800,'1');
        int n = s.length();
        int b = 0;
        construct();
        for(int i = 0; i < n; ++i){
            b+=(s[i]-'0');
        }
        
        vector<int> v(n+1, 0);
        long long ret = 0;
        // cout<<""s=""<<s<<endl;
        for(int x = 1; x <= n; ++x){
            auto bc = bit_count(x);
            v[x] = v[bc]+1;
            // cout<<""x=""<<x<<"", v=""<<v[x]<<"", bc=""<<bc<<endl;
            if(v[x] > k) continue;
            long long off = (x < b)? 1 : 0;
            // cout<<""off=""<<off<<"", b=""<<b<<endl;
            int c = 0;
            for(int i = 0; i < n && x > c; ++i){
                if(s[i]=='0') continue;
                // cout<<""adding ""<<(n-i-1)<<""C""<<(x - c)<<endl;
                off = (off + nCr(n-i-1, x - c)) % MOD;
                c++;
            }
            ret = (ret + off) % MOD;
        }
        return ret;
        
    }
private:
long long MOD = 1e9+7;
vector<long long> invs;
};",1448288941
kailam11223,kailam11223,369,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        map<int, long long> S;
        map<int, long long> C;
        long long ret = 0;
        for(auto x : nums){
            long long c = C[x-1] + C[x+1] + 1;
            long long s = (S[x-1] + S[x+1] + ((c * x) % MOD)) % MOD;
            S[x] = (S[x] + s) % MOD;
            C[x] = (C[x] + c) % MOD;
            ret = (ret + s) % MOD;
        }
        return ret;
    }
private:
    long long MOD = 1e9+7;
};",1448210686
HarshaNP,NastyWaterEspresso,370,3612,cpp,"#include <vector>
using namespace std;

class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        if (n < 2 * k) return false; 
        auto isStrictlyIncreasing = [&](int start) -> bool {
            for (int i = start; i < start + k - 1; i++) {
                if (nums[i] >= nums[i + 1]) {
                    return false;
                }
            }
            return true;
        };

        for (int i = 0; i <= n - 2 * k; i++) {
 
            if (isStrictlyIncreasing(i) && isStrictlyIncreasing(i + k)) {
                return true;
            }
        }

        return false;
    }
};
",1448181561
HarshaNP,NastyWaterEspresso,370,3619,cpp,"#include <vector>
using namespace std;

class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        if (n < 2 * k) return false;

        vector<int> inc(n, 1);
        for(int i = n - 2; i >= 0; --i){
            if(nums[i] < nums[i+1]) inc[i] = inc[i+1] + 1;
            else inc[i] = 1;
        }

        for(int i = 0; i + 2 * k <= n; ++i){
            if(inc[i] >= k && inc[i + k] >= k){
                return true;
            }
        }
        return false;
    }

    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        int left = 1, right = n / 2, result = 0;
        while(left <= right){
            int mid = left + (right - left) / 2;
            if(hasIncreasingSubarrays(nums, mid)){
                result = mid;
                left = mid + 1;
            }
            else{
                right = mid - 1;
            }
        }
        return result;
    }
};
",1448191832
HarshaNP,NastyWaterEspresso,370,3631,python3,"from math import comb

class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        MOD = 10**9 + 7

        def precompute_f(max_l):
            f = [0] * (max_l + 2)
            f[1] = 0
            for l in range(2, max_l + 1):
                pop = bin(l).count('1')
                f[l] = 1 + f[pop]
            return f

        n = int(s, 2)
        max_l = len(s)
        f = precompute_f(max_l)

        def count_less_than(n, m):
            total = 0
            binary_n = bin(n)[2:]
            num_bits = len(binary_n)
            
            for i, bit in enumerate(binary_n):
                if bit == '1':
                    bits_to_right = num_bits - i - 1
                    if m >= 0 and bits_to_right >= m:
                        total += comb(bits_to_right, m)
                    m -= 1
                
                if m < 0:
                    break
        
            return total

        total = 0

        if n > 1 and k >= 0:
            total += 1
            total %= MOD

        if k >= 1:
            count_l1 = count_less_than(n, 1)
            if n > 1:
                count_l1 -= 1
            total += count_l1
            total %= MOD

        for l in range(2, max_l + 1):
            if f[l] <= (k-1):
                count_l = count_less_than(n, l)
                total += count_l
                total %= MOD

        return total
",1448289206
HarshaNP,NastyWaterEspresso,370,3646,cpp,"#include <vector>
#include <unordered_map>
using namespace std;

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        const int MOD = 1'000'000'007;
 
        unordered_map<int, long> dp;  
        unordered_map<int, long> cnt; 
        
        for(auto num : nums){
            long temp_sum = num; 
            long temp_cnt = 1;   
            
    
            if(cnt.find(num-1) != cnt.end()){
                temp_sum = (temp_sum + dp[num-1] + ((long)cnt[num-1] * num)) % MOD;
                temp_cnt = (temp_cnt + cnt[num-1]) % MOD;
            }
 
            if(cnt.find(num+1) != cnt.end()){
                temp_sum = (temp_sum + dp[num+1] + ((long)cnt[num+1] * num)) % MOD;
                temp_cnt = (temp_cnt + cnt[num+1]) % MOD;
            }
    
            dp[num] = (dp[num] + temp_sum) % MOD;
            cnt[num] = (cnt[num] + temp_cnt) % MOD;
        }
        
    
        long total = 0;
        for(auto &[key, val] : dp){
            total = (total + val) % MOD;
        }
        
        return (int)total;
    }
};
",1448202145
virinci,virinci,371,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        dp = [0] * n
        dp[0] = 1
        for i in range(1, n):
            dp[i] = dp[i - 1] + 1 if nums[i] > nums[i - 1] else 1
        # print(dp)
        for i in range(n):
            ik = i + k - 1
            j = i + k
            jk = i + k + k - 1
            if jk >= n:
                break
            if dp[ik] >= k and dp[jk] == k or dp[jk] >= 2 * k:
                return True
        return False",1448188228
virinci,virinci,371,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        p, s = [0] * n, [0] * n
        p[0], s[n - 1] = 1, 1
        for i in range(1, n):
            p[i] = p[i - 1] + 1 if nums[i] > nums[i - 1] else 1
        for i in range(n - 2, -1, -1):
            s[i] = s[i + 1] + 1 if nums[i] < nums[i + 1] else 1
        ans = max(p) // 2
        for i in range(1, n):
            if p[i] != 1:
                continue
            ans = max(ans, min(p[i - 1], s[i]))
        return ans",1448198062
virinci,virinci,371,3631,cpp,"#ifndef dbg
#define dbg(...)
#endif

auto _fastio = [] { return std::cin.tie(nullptr)->sync_with_stdio(false); }();

class Solution {
public:
	int countKReducibleNumbers(string s, int k) {
		constexpr int L = 800;
		vector z(L + 1, 0LL);
		vector d(2, z);
		d[0][0] = 1;
		dbg(d);

		constexpr long long M = 1e9 + 7;

		for (int c : s) {
			c -= '0';
			vector nd(2, z);

			for (int x = 0; x <= 1; ++x) {
				for (int i = x; i <= L; ++i) {
					nd[1][i] = (nd[1][i] + d[1][i - x]) % M;
				}
			}

			for (int x = 0; x < c; ++x) {
				for (int i = x; i <= L; ++i) {
					nd[1][i] = (nd[1][i] + d[0][i - x]) % M;
				}
			}

			for (int i = c; i <= L; ++i) {
				nd[0][i] = (nd[0][i] + d[0][i - c]) % M;
			}

			d = nd;
			dbg(d);
		}

		auto count = d[1];

		vector k_reducible(k + 1, vector(L + 1, false));
		k_reducible[0][1] = true;

		for (int i = 1; i <= k; ++i) {
			for (int j = 1; j <= L; ++j) {
				auto c = __builtin_popcount(j);
				k_reducible[i][j] = k_reducible[i - 1][c];
			}
		}
		auto ans = 0LL;

		dbg(count);
		dbg(k_reducible);

		for (int i = 1; i <= L; ++i) {
			if (!k_reducible[k - 1][i]) continue;
			ans = (ans + count[i]) % M;
		}

		return ans;
	}
};",1448275776
virinci,virinci,371,3646,cpp,"auto _fastio = [] { return std::cin.tie(nullptr)->sync_with_stdio(false); }();

class Solution {
public:
	int sumOfGoodSubsequences(vector<int>& nums) {
		auto m = ranges::max(nums);

		using i64 = long long;
		constexpr i64 M = 1e9 + 7;
		vector<i64> d(m + 3, 0), c(m + 3, 0);

		for (auto x : nums) {
			d[x + 1] = (d[x + 1] + d[x] + c[x] * x) % M;
			d[x + 1] = (d[x + 1] + d[x + 2] + c[x + 2] * x) % M;
			d[x + 1] = (d[x + 1] + x) % M;
			c[x + 1] = (c[x + 1] + c[x]) % M;
			c[x + 1] = (c[x + 1] + c[x + 2]) % M;
			c[x + 1] = (c[x + 1] + 1) % M;
		}

		return accumulate(d.cbegin(), d.cend(), 0LL) % M;
	}
};",1448218886
Manojkumar Sirvi,sirvi_26,372,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        
         int len1 = 1 , len2 = 0 ; 
        int ans = 0 ; 
        for(int i = 1 ; i<nums.size() ; ++i)
        {
            if(nums[i] > nums[i-1])
            {
                if(len2==0)
                    len1++ ; 
                else 
                {
                    len2++ ; 
                     
                }
            }
            else 
            {
                if(len2==0)
                {
                    len2 = 1 ;
                }
                else
                {
                    len1 = len2 , len2 = 1 ; 
                }
                
            }
            
                // cout<<""len1 : ""<<len1<<"" len2 : ""<<len2<<""\n""  ;
            
            ans = max(ans , min(len1,len2)) ;
            ans = max(ans,len1/2) ; 
            ans = max(ans,len2/2) ; 
        }
        
        return k<=ans ; 
        
    }
};",1448203184
Manojkumar Sirvi,sirvi_26,372,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int len1 = 1 , len2 = 0 ; 
        int ans = 0 ; 
        for(int i = 1 ; i<nums.size() ; ++i)
        {
            if(nums[i] > nums[i-1])
            {
                if(len2==0)
                    len1++ ; 
                else 
                {
                    len2++ ; 
                     
                }
            }
            else 
            {
                if(len2==0)
                {
                    len2 = 1 ;
                }
                else
                {
                    len1 = len2 , len2 = 1 ; 
                }
                
            }
            
                // cout<<""len1 : ""<<len1<<"" len2 : ""<<len2<<""\n""  ;
            
            ans = max(ans , min(len1,len2)) ;
            ans = max(ans,len1/2) ; 
            ans = max(ans,len2/2) ; 
        }
        
        return ans ; 
    }
};",1448202395
Manojkumar Sirvi,sirvi_26,372,3631,cpp,"typedef long long ll ; 
ll mod = 1e9 + 7 ; 

class Solution {
public:
    
    ll op[801] ; 
    
    vector<vector<vector<ll>>> dp ; 
    
    ll get(ll ind , string &s , ll one , ll is_small , int &k)
    {
        if(ind == s.size())
        {
           // cout<<""one : ""<<one<<""\n"" ; 
            if(op[one]<=k and is_small)
                return 1 ; 
            else return 0 ; 
            // return op[one] <= k  ; 
        }
        if(dp[is_small][one][ind]!=-1)
            return dp[is_small][one][ind] ; 
        ll ans = 0 ; 
        
        if(is_small)
        {
            ans = get(ind+1,s,one+1,1,k);
            ans = (ans + get(ind+1,s,one,1,k))%mod ; 
        }
        else 
        {
            if(s[ind]=='0')
                ans = get(ind+1,s,one,0,k) ; 
            else 
            {
                ans = get(ind+1,s,one+1,0,k);
                // cout<<""after one : ""<<ans<<""\n""  ;
                // cout<<""one : ""<<one<<""\n"" ; 
                // cout<<""get : ""<<get(ind+1,s,one,1,k)<<""\n"" ;
                ans = (ans + get(ind+1,s,one,1,k))%mod ; 
                // cout<<""after zero : ""<<ans<<""\n"" ; 
            }
        }
        
        
        return dp[is_small][one][ind] = ans ; 
    }
    
    
    
    
    int countKReducibleNumbers(string s, int k) {
        dp.clear();
         dp.resize(2, vector<vector<ll>>(s.size() + 1, vector<ll>(s.size() + 1, -1)));

       for(int i = 1 ; i<=s.size() ; ++i)
       {
           ll n = i ;
           ll ops = 1 ; 
           while(n>1 and ops<k)
           {
               ops++; 
               n = __builtin_popcount(n);
           }
           if(n==1)
               op[i] = ops ; 
           else op[i] = 10 ; 
       }
        op[0] = 10 ; 
        
       
        return get(0,s,0,0,k);
    }
};",1448289913
Manojkumar Sirvi,sirvi_26,372,3646,cpp,"typedef long long ll ; 
ll mod = 1e9+7 ; 
class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        
        ll ans = 0 ; 
        
        
        map<ll,ll> dp2 , cnt2 ; 
        
        for(ll i = 0  ;i<nums.size() ; ++i)
        {
            ll ncnt = (cnt2[nums[i]-1]+cnt2[nums[i]+1])%mod , sum = (dp2[nums[i]-1]+dp2[nums[i]+1])%mod ; 
            ncnt = (ncnt+1)%mod ; 
            
            ll ex = ( ncnt * nums[i] ) %mod ; 
            
            ll anss = (sum + ex) % mod ; 
            
            ans = (ans + anss) % mod ; 
            
            ll currSum = dp2[nums[i]];
            currSum = (currSum + anss) % mod ; 
            
            ll currCnt = cnt2[nums[i]] ; 
            currCnt = (currCnt + ncnt ) % mod ; 
            
            dp2[nums[i]] = currSum ; 
            cnt2[nums[i]] = currCnt ; 
            
        }
        
        return ans ; 
        
    }
};",1448231166
agix,agix,373,3612,cpp,"class Solution {
public:
    bool ok(vector<int>& nums, int l, int k)
    {
        for (int i = l + 1; i < l + k; i++)
        {
            if (nums[i] <= nums[i - 1])
            {
                return false;
            }
        }
        return true;
    }
    
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        
        for (int i = 0; i + 2 * k - 1 < n; i++)
        {
            if (ok(nums, i, k) && ok(nums, i + k, k))
            {
                return true;
            }
        }
        return false;
    }
};",1448182593
agix,agix,373,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        
        vector<int> l(n);
        l[0] = 1;
        
        for (int i = 1; i < n; i++)
        {
            if (nums[i] > nums[i - 1])
            {
                l[i] = l[i - 1] + 1;
            }
            else
            {
                l[i] = 1;
            }
        }
        
        vector<int> r(n);
        r[n - 1] = 1;
        
        for (int i = n - 2; i >= 0; i--)
        {
            if (nums[i] < nums[i + 1])
            {
                r[i] = r[i + 1] + 1;
            }
            else
            {
                r[i] = 1;
            }
        }
        
        int ans = 1;
        for (int i = 0; i < n - 1; i++)
        {
            int a = l[i];
            int b = r[i + 1];
            ans = max(ans, min(a, b));
        }
        
        return ans;
    }
};",1448198563
agix,agix,373,3631,cpp,"#define LL long long

LL comb[1000][1000];

LL mod = 1e9 + 7;

class Solution {
public:
    int reduce(int num)
    {
        int step = 0;
        while (num > 1)
        {
            int cnt = __builtin_popcount(num);
            num = cnt;
            step++;
        }
        return step;
    }
    
    int countKReducibleNumbers(string s, int k) {
        int x = 800;
        
        unordered_map<int, vector<int>> mp;
        
        for (int i = 1; i <= 800; i++)
        {
            int cnt = reduce(i);
            mp[cnt].push_back(i);
        }
        
        memset(comb, 0, sizeof(comb));
        
        comb[0][0] = 1;
        for (int i = 1; i <= 800; i++)
        {
            comb[i][0] = 1;
            
            for (int j = 1; j <= i; j++)
            {
                comb[i][j] = comb[i - 1][j] + comb[i - 1][j - 1];
                comb[i][j] = comb[i][j] % mod;
            }
        }
        
        int n = s.size();
        int used = 0;
        LL ans = 0;
        
        for (int i = 0; i < n; i++)
        {
            if (s[i] == '1')
            {
                int r = n - i - 1;
                
                for (int j = k - 1; j >= 0; j--)
                {
                    for (auto& value : mp[j])
                    {
                        int bits = value - used;

                        if (bits >= 0 && bits <= r)
                        {
                            ans += comb[r][bits];
                            ans = ans % mod;
                        }
                    }
                }
                
                used += 1;
            }
        }
        
        return ans;
    }
};",1448297086
agix,agix,373,3646,cpp,"#define LL long long 

LL mod = 1e9 + 7;

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int n = nums.size();
        
        unordered_map<int, LL> cnt;
        unordered_map<int, LL> sum;
        
        cnt[nums[0]] = 1;
        sum[nums[0]] = nums[0];
        
        for (int i = 1; i < n; i++)
        {
            int val = nums[i];
            
            LL c = 1;
            LL s = val;
            
            c += cnt[val - 1];
            s += sum[val - 1] + cnt[val - 1] * val;
            
            c += cnt[val + 1];
            s += sum[val + 1] + cnt[val + 1] * val;
            
            //cout << i << endl;
            //cout << c << "" "" << s << endl;
            
            c = c % mod;
            s = s % mod;
            
            cnt[val] += c;
            sum[val] += s;
            cnt[val] = cnt[val] % mod;
            sum[val] = sum[val] % mod;
        }
        
        LL ans = 0;
        
        for (auto& [k, v] : sum)
        {
            ans += v;
            ans = ans % mod;
        }
        
        return ans;
    }
};",1448230852
xjc,kaddie,374,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        last = 0
        cur = 0
        for i, x in enumerate(nums):
            if i == 0 or x > nums[i - 1]:
                cur += 1
            else:
                last, cur = cur, 1

            if (last >= k and cur >= k) or (cur >= 2 * k):
                return True

        return False",1448190383
xjc,kaddie,374,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        last = cur = 0
        k = 0
        for i, x in enumerate(nums):
            if i == 0 or x > nums[i - 1]:
                cur += 1
            else:
                last, cur = cur, 1
            k = max(k, min(last, cur), cur // 2)

        return k",1448194095
xjc,kaddie,374,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        MOD = 10**9 + 7
        N = len(s)

        def ones(x):
            res = 0
            while x:
                res += x & 1
                x >>= 1
            return res

        @cache
        def k_reducible(x, k):
            while x != 1 and k > 0:
                x = ones(x)
                k -= 1
            return x == 1

        res = 0
        left_ones = sum(x == '1' for x in s)
        for i in range(N - 1, -1, -1):
            if s[i] == '0':
                continue
            left_ones -= 1
            bits = N - 1 - i
            for right_ones in range(bits + 1):
                x = left_ones + right_ones
                if k_reducible(x, k - 1):
                    res = (res + comb(bits, right_ones)) % MOD

        return res",1448283998
xjc,kaddie,374,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        MOD = 10**9 + 7
        N = len(nums)

        m = {} # begin: (count, sum)
        for x in nums[::-1]:
            count0, sum0 = m.get(x, (0, 0))
            count0 += 1
            sum0 += x
            for y in (x - 1, x + 1):
                if y in m:
                    count1, sum1 = m[y]
                    count0 += count1
                    sum0 = (sum0 + sum1 + x * count1) % MOD
            m[x] = (count0, sum0)

        return sum(sum0 for _, sum0 in m.values()) % MOD

        @cache
        def dp(i, prev):
            if prev is None:
                if i == N:
                    return 0, 0                    
                count1, sum1 = dp(i + 1, None)
                count2, sum2 = dp(i + 1, nums[i])
                return count1 + count2, (sum1 + sum2 + nums[i] * count2) % MOD
            else:
                if i == N:
                    return 1, 0
                count, sum = dp(i + 1, prev)
                if (nums[i] - prev) in (-1, 1):
                    count2, sum2 = dp(i + 1, nums[i])
                    count += count2
                    sum += (sum2 + nums[i] * count2) % MOD
                return count, sum

        return dp(0, None)[1]",1448246293
bramar2,bramar2,377,3612,cpp,"//#pragma GCC optimize(""O3,unroll-loops"")
//#pragma GCC target(""avx2,bmi,bmi2,lzcnt,popcnt"")
#include <bits/stdc++.h>
using namespace std;
// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// using namespace __gnu_pbds;
// template<typename T>
// using ordered_map = tree<T, T, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// template<typename T>
// using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define ll long long
#define ld long double
#define fastio ios::sync_with_stdio(false); cin.tie(nullptr);

#define dbg_stream cout
void __print(int x) {dbg_stream << x;}
void __print(long x) {dbg_stream << x;}
void __print(long long x) {dbg_stream << x;}
void __print(unsigned x) {dbg_stream << x;}
void __print(unsigned long x) {dbg_stream << x;}
void __print(unsigned long long x) {dbg_stream << x;}
void __print(float x) {dbg_stream << x;}
void __print(double x) {dbg_stream << x;}
void __print(long double x) {dbg_stream << x;}
void __print(char x) {dbg_stream << '\'' << x << '\'';}
void __print(const char *x) {dbg_stream << '\""' << x << '\""';}
void __print(const string &x) {dbg_stream << '\""' << x << '\""';}
void __print(bool x) {dbg_stream << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {dbg_stream << '{'; __print(x.first); dbg_stream << ','; __print(x.second); dbg_stream << '}';}
template<typename T>
void __print(const T &x) {int f = 0; dbg_stream << '{'; for (auto &i: x) dbg_stream << (f++ ? "","" : """"), __print(i); dbg_stream << ""}"";}
void _print() {dbg_stream << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) dbg_stream << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define dbg(x...) dbg_stream << ""["" << #x << ""] = [""; _print(x)
#else
#define dbg(x...)
#endif

template <typename T>
void print(T t) { int f = 0; for(const auto& b : t) cout << (f++ ? "" "" : """") << b; cout << '\n'; }
template <typename T>
void print2d(T t) { for(const auto& b : t) { print(b); } }

inline long long mod_exp(long long base, long long exp, long long modd) { unsigned long long ans = 1; base %= modd; while(exp > 0) { if(exp%2==1) ans = (base*ans)%modd; exp /= 2; base = (base*base)%modd; } return ans; }
inline long long factorial(long long n) { long long ans = 1; for(long long i = 2; i <= n; i++) ans *= n; return ans; }
inline long long memo_factorial(long long n) { static vector<int> memo {1,1,2}; if(static_cast<size_t>(n) >= memo.size()) { memo.resize(n+1); for(long long i = memo.size(); i <= n; i++) memo[i] = i*memo[i-1]; } return memo[n]; }
inline long long nCk(int N, int K) { if(K > N) return 0; if(K > N-K) K = N-K; long long ans = 1; for(long long i = 1; i <= K; i++) ans = (ans * (N - (K-i))) / i; return ans; }

const ll MOD = 1e9 + 7;
const ll MOD99 = 998244353;
const ll BIGMOD = pow(2,31)-1;

class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        bool y = false;
        for(int i = 0; i < n; i++) {
            bool yes = true;

            int lastIdx = i + 2*k - 1;
            if(lastIdx >= n) break;


            for(int j = i + 1; j < i + k; j++) {
                if(nums[j] <= nums[j - 1]) {
                    yes = false;
                    break;
                }
            }
            for(int j = i + k + 1; j <= lastIdx; j++) {
                if(nums[j] <= nums[j - 1]) {
                    yes = false;
                    break;
                }
            }

            y |= yes;
        }
        return y;
    }
};

int main1() {
    fastio;
    return 0;
}",1448185122
bramar2,bramar2,377,3619,cpp,"//#pragma GCC optimize(""O3,unroll-loops"")
//#pragma GCC target(""avx2,bmi,bmi2,lzcnt,popcnt"")
#include <bits/stdc++.h>
using namespace std;
// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// using namespace __gnu_pbds;
// template<typename T>
// using ordered_map = tree<T, T, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// template<typename T>
// using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define ll long long
#define ld long double
#define fastio ios::sync_with_stdio(false); cin.tie(nullptr);

#define dbg_stream cout
void __print(int x) {dbg_stream << x;}
void __print(long x) {dbg_stream << x;}
void __print(long long x) {dbg_stream << x;}
void __print(unsigned x) {dbg_stream << x;}
void __print(unsigned long x) {dbg_stream << x;}
void __print(unsigned long long x) {dbg_stream << x;}
void __print(float x) {dbg_stream << x;}
void __print(double x) {dbg_stream << x;}
void __print(long double x) {dbg_stream << x;}
void __print(char x) {dbg_stream << '\'' << x << '\'';}
void __print(const char *x) {dbg_stream << '\""' << x << '\""';}
void __print(const string &x) {dbg_stream << '\""' << x << '\""';}
void __print(bool x) {dbg_stream << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {dbg_stream << '{'; __print(x.first); dbg_stream << ','; __print(x.second); dbg_stream << '}';}
template<typename T>
void __print(const T &x) {int f = 0; dbg_stream << '{'; for (auto &i: x) dbg_stream << (f++ ? "","" : """"), __print(i); dbg_stream << ""}"";}
void _print() {dbg_stream << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) dbg_stream << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define dbg(x...) dbg_stream << ""["" << #x << ""] = [""; _print(x)
#else
#define dbg(x...)
#endif

template <typename T>
void print(T t) { int f = 0; for(const auto& b : t) cout << (f++ ? "" "" : """") << b; cout << '\n'; }
template <typename T>
void print2d(T t) { for(const auto& b : t) { print(b); } }

inline long long mod_exp(long long base, long long exp, long long modd) { unsigned long long ans = 1; base %= modd; while(exp > 0) { if(exp%2==1) ans = (base*ans)%modd; exp /= 2; base = (base*base)%modd; } return ans; }
inline long long factorial(long long n) { long long ans = 1; for(long long i = 2; i <= n; i++) ans *= n; return ans; }
inline long long memo_factorial(long long n) { static vector<int> memo {1,1,2}; if(static_cast<size_t>(n) >= memo.size()) { memo.resize(n+1); for(long long i = memo.size(); i <= n; i++) memo[i] = i*memo[i-1]; } return memo[n]; }
inline long long nCk(int N, int K) { if(K > N) return 0; if(K > N-K) K = N-K; long long ans = 1; for(long long i = 1; i <= K; i++) ans = (ans * (N - (K-i))) / i; return ans; }

const ll MOD = 1e9 + 7;
const ll MOD99 = 998244353;
const ll BIGMOD = pow(2,31)-1;

class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> strict; strict.reserve(nums.size());
        strict.push_back(1);
        for(int i = 1; i < n; i++) {
            if(nums[i] > nums[i - 1]) {
                strict.back()++;
            }else {
                strict.push_back(1);
            }
        }
        ll ans = *max_element(all(strict)) / 2;

        for(ll i = 1; i < strict.size(); i++) {
            ans = max(ans, (ll)min(strict[i - 1], strict[i]));
        }
        return ans;
    }
};

int main1() {
    fastio;
    return 0;
}",1448192185
bramar2,bramar2,377,3631,cpp,"//#pragma GCC optimize(""O3,unroll-loops"")
//#pragma GCC target(""avx2,bmi,bmi2,lzcnt,popcnt"")
#include <bits/stdc++.h>
using namespace std;
// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// using namespace __gnu_pbds;
// template<typename T>
// using ordered_map = tree<T, T, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// template<typename T>
// using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define ll long long
#define ld long double
#define fastio ios::sync_with_stdio(false); cin.tie(nullptr);

#define dbg_stream cout
void __print(int x) {dbg_stream << x;}
void __print(long x) {dbg_stream << x;}
void __print(long long x) {dbg_stream << x;}
void __print(unsigned x) {dbg_stream << x;}
void __print(unsigned long x) {dbg_stream << x;}
void __print(unsigned long long x) {dbg_stream << x;}
void __print(float x) {dbg_stream << x;}
void __print(double x) {dbg_stream << x;}
void __print(long double x) {dbg_stream << x;}
void __print(char x) {dbg_stream << '\'' << x << '\'';}
void __print(const char *x) {dbg_stream << '\""' << x << '\""';}
void __print(const string &x) {dbg_stream << '\""' << x << '\""';}
void __print(bool x) {dbg_stream << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {dbg_stream << '{'; __print(x.first); dbg_stream << ','; __print(x.second); dbg_stream << '}';}
template<typename T>
void __print(const T &x) {int f = 0; dbg_stream << '{'; for (auto &i: x) dbg_stream << (f++ ? "","" : """"), __print(i); dbg_stream << ""}"";}
void _print() {dbg_stream << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) dbg_stream << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define dbg(x...) dbg_stream << ""["" << #x << ""] = [""; _print(x)
#else
#define dbg(x...)
#endif

template <typename T>
void print(T t) { int f = 0; for(const auto& b : t) cout << (f++ ? "" "" : """") << b; cout << '\n'; }
template <typename T>
void print2d(T t) { for(const auto& b : t) { print(b); } }

inline long long mod_exp(long long base, long long exp, long long modd) { unsigned long long ans = 1; base %= modd; while(exp > 0) { if(exp%2==1) ans = (base*ans)%modd; exp /= 2; base = (base*base)%modd; } return ans; }
inline long long factorial(long long n) { long long ans = 1; for(long long i = 2; i <= n; i++) ans *= n; return ans; }
inline long long memo_factorial(long long n) { static vector<int> memo {1,1,2}; if(static_cast<size_t>(n) >= memo.size()) { memo.resize(n+1); for(long long i = memo.size(); i <= n; i++) memo[i] = i*memo[i-1]; } return memo[n]; }
inline long long nCk(int N, int K) { if(K > N) return 0; if(K > N-K) K = N-K; long long ans = 1; for(long long i = 1; i <= K; i++) ans = (ans * (N - (K-i))) / i; return ans; }

const ll MOD = 1e9 + 7;
const ll MOD99 = 998244353;
const ll BIGMOD = pow(2,31)-1;

class Solution {
public:
    int countKReducibleNumbers(const string& s, int k) {
        int n = s.size();
        if(n == 1) return 0;

        vector valid(n+1, vector<int>(2, -1));
        valid[0][0] = valid[0][1] = 0;
        valid[1][0] = valid[1][1] = 1;

        function<int(int,bool)> dfs = [&](int setBits, bool isOne) -> int {
            if(setBits == 1 && isOne) return 0;
            if(valid[setBits][isOne] >= 0) return valid[setBits][isOne];
            // dbg(setBits, isOne, __builtin_popcount(setBits));
            return valid[setBits][isOne] = (1 + dfs(__builtin_popcount(setBits), setBits == 1));
        };

        for(int i = 2; i <= n; ++i) {
            dfs(i, false);
        }

        // dbg(valid);

        for(int i = 1; i <= n; i++) {
            valid[i][0] = (0 <= valid[i][0] && valid[i][0] <= k);
            valid[i][1] = (0 <= valid[i][1] && valid[i][1] <= k);
        }

        // dbg(valid);


        vector memo(n, vector(n, vector<ll>(2, -1)));
        function<ll(int,int,bool)> go = [&](int i, int bitCnt, bool sameS) -> ll {
            if(i >= n) return (!sameS && valid[bitCnt][false] ? 1LL : 0LL);
            if(memo[i][bitCnt][sameS] >= 0) return memo[i][bitCnt][sameS];
            if(!sameS) {
                return memo[i][bitCnt][sameS] = (go(i + 1, bitCnt + 1, false) + go(i + 1, bitCnt, false)) % MOD;
            }else {
                if(s[i] == '0') {
                    return memo[i][bitCnt][sameS] = go(i + 1, bitCnt, true);
                }else {
                    return memo[i][bitCnt][sameS] = (go(i + 1, bitCnt, false) + go(i + 1, bitCnt + 1, true)) % MOD;
                }
            }
        };


        return int(go(0, 0, true) % MOD);
    }
};

int main1() {
    fastio;
    return 0;
}",1448284740
bramar2,bramar2,377,3646,cpp,"//#pragma GCC optimize(""O3,unroll-loops"")
//#pragma GCC target(""avx2,bmi,bmi2,lzcnt,popcnt"")
#include <bits/stdc++.h>
using namespace std;
// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// using namespace __gnu_pbds;
// template<typename T>
// using ordered_map = tree<T, T, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// template<typename T>
// using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define ll long long
#define ld long double
#define fastio ios::sync_with_stdio(false); cin.tie(nullptr);

#define dbg_stream cout
void __print(int x) {dbg_stream << x;}
void __print(long x) {dbg_stream << x;}
void __print(long long x) {dbg_stream << x;}
void __print(unsigned x) {dbg_stream << x;}
void __print(unsigned long x) {dbg_stream << x;}
void __print(unsigned long long x) {dbg_stream << x;}
void __print(float x) {dbg_stream << x;}
void __print(double x) {dbg_stream << x;}
void __print(long double x) {dbg_stream << x;}
void __print(char x) {dbg_stream << '\'' << x << '\'';}
void __print(const char *x) {dbg_stream << '\""' << x << '\""';}
void __print(const string &x) {dbg_stream << '\""' << x << '\""';}
void __print(bool x) {dbg_stream << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {dbg_stream << '{'; __print(x.first); dbg_stream << ','; __print(x.second); dbg_stream << '}';}
template<typename T>
void __print(const T &x) {int f = 0; dbg_stream << '{'; for (auto &i: x) dbg_stream << (f++ ? "","" : """"), __print(i); dbg_stream << ""}"";}
void _print() {dbg_stream << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) dbg_stream << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define dbg(x...) dbg_stream << ""["" << #x << ""] = [""; _print(x)
#else
#define dbg(x...)
#endif

template <typename T>
void print(T t) { int f = 0; for(const auto& b : t) cout << (f++ ? "" "" : """") << b; cout << '\n'; }
template <typename T>
void print2d(T t) { for(const auto& b : t) { print(b); } }

inline long long mod_exp(long long base, long long exp, long long modd) { unsigned long long ans = 1; base %= modd; while(exp > 0) { if(exp%2==1) ans = (base*ans)%modd; exp /= 2; base = (base*base)%modd; } return ans; }
inline long long factorial(long long n) { long long ans = 1; for(long long i = 2; i <= n; i++) ans *= n; return ans; }
inline long long memo_factorial(long long n) { static vector<int> memo {1,1,2}; if(static_cast<size_t>(n) >= memo.size()) { memo.resize(n+1); for(long long i = memo.size(); i <= n; i++) memo[i] = i*memo[i-1]; } return memo[n]; }
inline long long nCk(int N, int K) { if(K > N) return 0; if(K > N-K) K = N-K; long long ans = 1; for(long long i = 1; i <= K; i++) ans = (ans * (N - (K-i))) / i; return ans; }

const ll MOD = 1e9 + 7;
const ll MOD99 = 998244353;
const ll BIGMOD = pow(2,31)-1;

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        const ll NEUTRAL = -1;

        int n = nums.size(); ll ans = 0;
        map<ll, ll> mp, mp2;
        for(ll i = 0; i < n; i++) {
            ll x = nums[i];
            ans = (ans + x) % MOD;
            if(mp.count(x + 1)) ans = (ans + mp[x + 1]*x) % MOD;
            if(mp.count(x - 1)) ans = (ans + mp[x - 1]*x) % MOD;

            mp[x] = (mp[x] + 1) % MOD;
            if(mp.count(x + 1)) mp[x] = (mp[x] + mp[x + 1]) % MOD;
            if(mp.count(x - 1)) mp[x] = (mp[x] + mp[x - 1]) % MOD;
        }

        for(ll i = n; i --> 0;) {
            ll x = nums[i];
            ans = (ans + x) % MOD;
            if(mp2.count(x + 1)) ans = (ans + mp2[x + 1]*x) % MOD;
            if(mp2.count(x - 1)) ans = (ans + mp2[x - 1]*x) % MOD;

            mp2[x] = (mp2[x] + 1) % MOD;
            if(mp2.count(x + 1)) mp2[x] = (mp2[x] + mp2[x + 1]) % MOD;
            if(mp2.count(x - 1)) mp2[x] = (mp2[x] + mp2[x - 1]) % MOD;
        }
        mp.clear();

        auto rev = [&](ll x) {
            if(mp2.count(x + 1)) mp2[x] = (mp2[x] - mp2[x + 1] + MOD) % MOD;
            if(mp2.count(x - 1)) mp2[x] = (mp2[x] - mp2[x - 1] + MOD) % MOD;
            mp2[x] = (mp2[x] - 1 + MOD) % MOD;
        };
        ++mp[nums[0]];
        rev(nums[0]);
        // dbg(ans);

        for(ll i = 1; i < n; i++) {
            ll x = nums[i];
            // act x as the middle element
            // dbg(mp, mp2);
            for(ll a = -1; a <= 1; a += 2) {
                for(ll b = -1; b <= 1; b += 2) {
                    if(mp.count(x + a) && mp2.count(x + b)) {
                        ll tmp = x * mp[x + a];
                        tmp %= MOD;
                        tmp *= mp2[x + b];
                        tmp %= MOD;
                        // ans += x * mp[x + a] * mp2[x + b];
                        ans = (ans + tmp) % MOD;
                    }
                }
            }
            rev(x);

            mp[x] = (mp[x] + 1) % MOD;
            if(mp.count(x + 1)) mp[x] = (mp[x] + mp[x + 1]) % MOD;
            if(mp.count(x - 1)) mp[x] = (mp[x] + mp[x - 1]) % MOD;
        }

        for(ll i = 0; i < n; i++) {
            ans = (ans - nums[i]) % MOD;
        }
        ans %= MOD; ans += MOD; ans %= MOD;

        return ans;
    }
};

int main1() {
    fastio;
    return 0;
}",1448235002
Mridul Pandey,mridul_cr7,380,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n=nums.size();
        vector<int> st(n,1),en(n,1);
        for(int i=n-2;i>=0;i--)
        {
            if(nums[i]<nums[i+1])
                st[i]=st[i+1]+1;
            
        }
        for(int i=1;i<n;i++)
        {
            if(nums[i]>nums[i-1])
                en[i]=en[i-1]+1;
        }
        int ans=0;
       
        for(int i=1;i<n;i++)
        {
            int mn=min(en[i-1],st[i]);
            ans=max(ans,mn);
        }
        
        return (ans>=k);
    }
};",1448188728
Mridul Pandey,mridul_cr7,380,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n=nums.size();
        vector<int> st(n,1),en(n,1);
        for(int i=n-2;i>=0;i--)
        {
            if(nums[i]<nums[i+1])
                st[i]=st[i+1]+1;
            
        }
        for(int i=1;i<n;i++)
        {
            if(nums[i]>nums[i-1])
                en[i]=en[i-1]+1;
        }
        int ans=0;
       
        for(int i=1;i<n;i++)
        {
            int mn=min(en[i-1],st[i]);
            ans=max(ans,mn);
        }
        return ans;
    }
};",1448186967
Mridul Pandey,mridul_cr7,380,3631,cpp,"int count_setbits(int N)
{ 
   int cnt=0;

   while(N>0)
   {
       cnt+=(N&1);
       N=N>>1;
   }

   return cnt;
}

int cc=0;


class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        
    
        int mod=1e9+7;
        int n=s.size();
        string t=s;
        reverse(t.begin(),t.end());
        vector<vector<vector<int>>> dp(n+1,vector<vector<int>>(n+1,vector<int> (2,0)));
        dp[0][0][1]=1;
        int val=1;
        for(int i=1;i<=n;i++)
        {
            if(t[i-1]=='1')
                val=0;
            dp[i][0][val]=1;
            for(int j=1;j<=i;j++)
            {
                if(t[i-1]=='0')
                {
                    dp[i][j][0]=(dp[i][j][0]+dp[i-1][j][0])%mod;
                    dp[i][j][1]=(dp[i][j][1]+dp[i-1][j][1])%mod;
                }
                else
                {
                    dp[i][j][0]=(dp[i][j][0]+dp[i-1][j][0])%mod;
                    dp[i][j][0]=(dp[i][j][0]+dp[i-1][j][1])%mod;
                }
                if(t[i-1]=='1')
                {
                    dp[i][j][0]=(dp[i][j][0]+dp[i-1][j-1][0])%mod;
                    dp[i][j][1]=(dp[i][j][1]+dp[i-1][j-1][1])%mod;
                }
                else
                {
                    dp[i][j][1]=(dp[i][j][1]+dp[i-1][j-1][0])%mod;
                    dp[i][j][1]=(dp[i][j][1]+dp[i-1][j-1][1])%mod;
                }
                // if(i==n && j==1)
                // {
                //     cout<<dp[i-1][j][0]<<"" ""<<dp[i-1][j][1]<<""\n"";
                // }
            }
        }
        vector<int> st(n+1,0);
      
            st[1]=1;
            for(int i=2;i<=n;i++)
            {
                int num=i;
                int c=1;
                while(num!=1)
                {
                    c++;
                    num=count_setbits(num);
                }
                if(c<=k)
                    st[i]=1;
            }
        int ans=0;
        for(int i=1;i<=n;i++)
        {
            int cnt=dp[n][i][0];
            //cout<<i<<"" ""<<cnt<<""\n"";
            if(st[i]==1)
            {
                ans=(ans+cnt)%mod;
            }
            
        }
        return ans;
    }
};",1448299257
Mridul Pandey,mridul_cr7,380,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int mx=0,mod=1e9+7,ans=0;
        for(auto x:nums)
        {
            mx=max(mx,x);
        }
        vector<int> sum(mx+2,0),count(mx+2,0);
        for(auto x:nums)
        {
            int prev=x-1;
            int nxt=x+1;
            int mn=sum[x];
            int val=(1ll*count[nxt]*1ll*x)%mod;
            sum[x]=(sum[x]+(sum[nxt]+val)%mod)%mod;
            count[x]=(count[x]+count[nxt])%mod;
            if(prev>=0)
            {
                int val=(1ll*count[prev]*1ll*x)%mod;
                sum[x]=(sum[x]+(sum[prev]+val)%mod)%mod;
                count[x]=(count[x]+count[prev])%mod;
            }
            sum[x] = (sum[x] + x)%mod;
            count[x] = (count[x] + 1)%mod;
            ans=(ans+sum[x])%mod;
            ans=((ans-mn)+mod)%mod;
        }
        return ans;
    }
};",1448222575
Ashutosh Singh,AshutoshSingh10,382,3612,cpp,"

	#include <bits/stdc++.h>
	using namespace std;
	using std::cout;
	using std::cin;
	#define endl '\n'    
	#define Endl '\n'    
	#define ll long long
	#define loop(i,a,b) for(long long i=a;i<b;i++)
	#define roop(i,a,b) for(long long i=a-1;i>=b;i--)
	#define all(p) p.begin(),p.end()
	#define pb(p) push_back(p);
	long long pop_count(long long a){int res=0;while(a){res+=(a&1),a>>=1;}return res;}
	template<class T> using _pq = priority_queue<T>;
	template<class T> using _pqr = priority_queue<T, vector<T>, greater<T>>;
	template<class T> void So(vector<T> &v) {sort(v.begin(),v.end());}
	template<class T> void Sore(vector<T> &v) {sort(v.begin(),v.end(),[](T x,T y){return x>y;});}
	#include <ext/pb_ds/assoc_container.hpp>
	#include <ext/pb_ds/tree_policy.hpp>
	using namespace __gnu_pbds;
	#include<iostream>
	template <class T> using OrderSet = tree<T, null_type, 
	less<T>, rb_tree_tag,tree_order_statistics_node_update>;
	ll lcm(ll a, ll b){return (a/__gcd(a,b)*b);}
	const ll INF= LONG_LONG_MAX;
	int mod=1e9+7;


	class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
		int cnt=1;;
		int n=nums.size();
		vector<int> vec;
		for(int i=1;i<n;i++)
		{
			if(nums[i]>nums[i-1])
			{
				cnt++;
			}
			else 
			{
				vec.push_back(cnt);
				cnt=1;
			}

		}
        vec.push_back(cnt);
		int ans=vec[0]/2;
		for(int i=1;i<vec.size();i++)
		{
			ans=max(ans,vec[i]/2);
			ans=max(ans,min(vec[i],vec[i-1]));
		}
		return ans>=k;
	
        
    }
};
",1448198789
Ashutosh Singh,AshutoshSingh10,382,3619,cpp,"	#include <bits/stdc++.h>
	using namespace std;
	using std::cout;
	using std::cin;
	#define endl '\n'    
	#define Endl '\n'    
	#define ll long long
	#define loop(i,a,b) for(long long i=a;i<b;i++)
	#define roop(i,a,b) for(long long i=a-1;i>=b;i--)
	#define all(p) p.begin(),p.end()
	#define pb(p) push_back(p);
	long long pop_count(long long a){int res=0;while(a){res+=(a&1),a>>=1;}return res;}
	template<class T> using _pq = priority_queue<T>;
	template<class T> using _pqr = priority_queue<T, vector<T>, greater<T>>;
	template<class T> void So(vector<T> &v) {sort(v.begin(),v.end());}
	template<class T> void Sore(vector<T> &v) {sort(v.begin(),v.end(),[](T x,T y){return x>y;});}
	#include <ext/pb_ds/assoc_container.hpp>
	#include <ext/pb_ds/tree_policy.hpp>
	using namespace __gnu_pbds;
	#include<iostream>
	template <class T> using OrderSet = tree<T, null_type, 
	less<T>, rb_tree_tag,tree_order_statistics_node_update>;
	ll lcm(ll a, ll b){return (a/__gcd(a,b)*b);}
	const ll INF= LONG_LONG_MAX;
	int mod=1e9+7;


	class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
		int cnt=1;;
		int n=nums.size();
		vector<int> vec;
		for(int i=1;i<n;i++)
		{
			if(nums[i]>nums[i-1])
			{
				cnt++;
			}
			else 
			{
				vec.push_back(cnt);
				cnt=1;
			}

		}
        vec.push_back(cnt);
		int ans=vec[0]/2;
		for(int i=1;i<vec.size();i++)
		{
			ans=max(ans,vec[i]/2);
			ans=max(ans,min(vec[i],vec[i-1]));
		}
		return ans;
	
        
    }
};
",1448196965
Ashutosh Singh,AshutoshSingh10,382,3631,cpp,"		#include <bits/stdc++.h>
		using namespace std;
		using std::cout;
		using std::cin;
		#define endl '\n'    
		#define Endl '\n'    
		#define ll long long
		#define loop(i,a,b) for(long long i=a;i<b;i++)
		#define roop(i,a,b) for(long long i=a-1;i>=b;i--)
		#define all(p) p.begin(),p.end()
		#define pb(p) push_back(p);
		long long pop_count(long long a){int res=0;while(a){res+=(a&1),a>>=1;}return res;}
		template<class T> using _pq = priority_queue<T>;
		template<class T> using _pqr = priority_queue<T, vector<T>, greater<T>>;
		template<class T> void So(vector<T> &v) {sort(v.begin(),v.end());}
		template<class T> void Sore(vector<T> &v) {sort(v.begin(),v.end(),[](T x,T y){return x>y;});}
		#include <ext/pb_ds/assoc_container.hpp>
		#include <ext/pb_ds/tree_policy.hpp>
		using namespace __gnu_pbds;
		#include<iostream>
		template <class T> using OrderSet = tree<T, null_type, 
		less<T>, rb_tree_tag,tree_order_statistics_node_update>;
		ll lcm(ll a, ll b){return (a/__gcd(a,b)*b);}
		const ll INF= LONG_LONG_MAX;
		int mod=1e9+7;



int ca(ll x,ll k)
{
    while(k>0 && x>1)
    {
        ll temp=0;
        while(x>0)
        {
            if(x&1) temp++;
            x>>=1;
        }
        x=temp;
        k--;
    }
    return x==1;
}
class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
		ll sz=s.length();
		
		ll bitsfound=0;
		map<ll,ll> mp;
        ll x=sz+10;
    vector<vector<ll>> vec(x+1,vector<ll> (x+1,0));
    vec[0][0]=1;
	for(ll i=1;i<=x;i++)
	{
		for(ll j=0;j<=x;j++)
		{
			vec[i][j]=vec[i-1][j];
		}
		for(ll j=1;j<=x;j++)
		{
			vec[i][j]=(vec[i-1][j-1]+vec[i][j])%mod;
		}
	}

        
		for(int i=0;i<sz;i++)
		{
			if(s[i]=='1')
			{
                for(ll j=0;j<=sz-i-1;j++)
            	{
            		mp[j+bitsfound]=(mp[j+bitsfound]+vec[sz-i-1][j])%mod;
            	}
				bitsfound++;
			}
		}
        ll ans=0;
        for(auto &[a,b]:mp)
            {
                // cout<<a<<"" ""<<b;
                if(ca(a,k-1)) 
                {
                    // cout<<"" YES"";
                    ans=(ans+b)%mod;
                }
                // cout<<endl;
            }
		
		return ans;
        
    }
};",1448279834
Ashutosh Singh,AshutoshSingh10,382,3646,cpp,"		#include <bits/stdc++.h>
		using namespace std;
		using std::cout;
		using std::cin;
		#define endl '\n'    
		#define Endl '\n'    
		#define ll long long
		#define loop(i,a,b) for(long long i=a;i<b;i++)
		#define roop(i,a,b) for(long long i=a-1;i>=b;i--)
		#define all(p) p.begin(),p.end()
		#define pb(p) push_back(p);
		long long pop_count(long long a){int res=0;while(a){res+=(a&1),a>>=1;}return res;}
		template<class T> using _pq = priority_queue<T>;
		template<class T> using _pqr = priority_queue<T, vector<T>, greater<T>>;
		template<class T> void So(vector<T> &v) {sort(v.begin(),v.end());}
		template<class T> void Sore(vector<T> &v) {sort(v.begin(),v.end(),[](T x,T y){return x>y;});}
		#include <ext/pb_ds/assoc_container.hpp>
		#include <ext/pb_ds/tree_policy.hpp>
		using namespace __gnu_pbds;
		#include<iostream>
		template <class T> using OrderSet = tree<T, null_type, 
		less<T>, rb_tree_tag,tree_order_statistics_node_update>;
		ll lcm(ll a, ll b){return (a/__gcd(a,b)*b);}
		const ll INF= LONG_LONG_MAX;
		int mod=1e9+7;
class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
		map<ll,ll> cnt;
		map<ll,ll> sum;
		ll ans=0;
		for(auto &i:nums)
		{
			ll el=i;
			ll cursum=el;
			ll end=1;
			if(cnt.count(el-1))
			{
				cursum=(cursum+sum[el-1])%mod;
                ll temp=(el*cnt[el-1])%mod;
                cursum=(cursum+temp)%mod;
				end=(end+cnt[el-1])%mod;
				
			}
			if(cnt.count(el+1))
			{
				cursum=(cursum+sum[el+1])%mod;
                ll temp=(el*cnt[el+1])%mod;
                cursum=(cursum+temp)%mod;
				end=(end+cnt[el+1])%mod;
				
			}
		
			cnt[el]=(cnt[el]+end)%mod;
			sum[el]=(sum[el]+cursum)%mod;
			ans=(ans+cursum)%mod;
		}
		return ans;
        
    }
};",1448219604
ssk4988,ssk4988,385,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        for i in range(len(nums)):
            if i + k + k > len(nums): break
            a = True
            b = True
            for j in range(k-1):
                if nums[i + j] >= nums[i + j + 1]: a = False
                if nums[i + j + k] >= nums[i + j + k + 1]: b = False
            if a and b: return True
        return False",1448273190
ssk4988,ssk4988,385,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        dp = [0] * len(nums)
        ans = 1
        n = len(nums)
        for i in range(n)[::-1]:
            if i + 1 >= n: continue
            if nums[i] < nums[i+1]: dp[i] = 1 + dp[i+1]
            v = dp[i]
            ans = max(ans, (v+1) // 2)
            if i + v + 1 < n:
                u = dp[i + v + 1]
                ans = max(ans, 1+min(u, v))
        return ans",1448280513
ssk4988,ssk4988,385,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        if len(s) == 1:
            return 0
        s = list(map(int, s))
        n = len(s)
        # print(s)
        @cache
        def conv(v):
            if v <= 1: return 0
            return 1 + conv(Counter(bin(v))[""1""])
        mod = 1000000007
        @cache
        def dp(idx, pref, c1):
            if idx == n:
                if pref: return 0
                req = conv(c1)
                # if c1 > 1: req += 1
                return req < k
            ans = 0
            for i in range(1 + (s[idx] if pref else 1)):
                ans += dp(idx+1, pref and i == s[idx], c1 + i)
            # print(idx, pref, c1, ans % mod)
            return ans % mod
        return (dp(0, True, 0)-1) % mod",1448300296
ssk4988,ssk4988,385,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        N = 100100
        ways = [0] * N
        sm = [0] * N
        mod = 1000000007
        for v in nums:
            ways[v] += 1
            sm[v] += v
            for d in [-1, 1]:
                if v+d<0: continue
                ways[v] += ways[v+d]
                sm[v] += ways[v+d] * v
                sm[v] += sm[v+d]
                ways[v] %= mod
                sm[v] %= mod
        ans = 0
        # print(sm[:5], ways[:5])
        for i in range(len(sm)):
            ans += sm[i]
            ans %= mod
        return ans",1448290227
Haksell,Haksell,390,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        f = lambda a: all(y>x for x,y in zip(a, a[1:]))
        return any(f(nums[i:i+k]) and f(nums[i+k:i+k+k]) for i in range(len(nums) - 2*k + 1))",1448182049
Haksell,Haksell,390,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        last = [0] * len(nums)
        j = 0
        m = -(1<<30)
        for i, n in enumerate(nums):
            if n <= m:
                j=i
            m=n
            last[i] = j
        groups = [sum(1 for _ in v) for _, v in groupby(last)]
        res=[g//2 for g in groups]+[min(g1,g2) for g1,g2 in zip(groups, groups[1:])]
        # print(last, groups, res)
        return max(res)",1448189254
Haksell,Haksell,390,3631,python3,"MOD=1_000_000_007

# def naive(n, k):
#     def valid(n, k):
#         if k==0:
#             return n==1
#         return valid(bin(n).count(""1""), k-1)
        
#     return sum(valid(i, k) for i in range(1, n))

# for n in [1<<1, 1<<2, 1<<4, 1<<8, 1<<16]:
#     print([naive(n, k) for k in range(1, 6)])

""""""
[1, 1, 1, 1, 1]
[2, 3, 3, 3, 3]
[4, 11, 15, 15, 15]
[8, 107, 247, 255, 255]
[16, 14827, 49047, 65535, 65535]
""""""

def f(s, n):
    if n==0: return 1
    if s==""1"": return 0
    res = comb(len(s)-1, n)
    for i in range(1, len(s)):
        if s[i]==""1"":
            res += f(s[i:], n-1)
            break
    return res % MOD

class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        if len(s)==1:
            return 0
        queue={1}
        for _ in range(k-1):
            queue={i for i in range(1, 801) if bin(i).count(""1"") in queue}
        queue=sorted(queue)
        # print([(i, f(s, i)) for i in queue])
        return sum(f(s, i) for i in queue)%MOD

# smod=0
# for c in s:
#     smod*=2
#     smod+=c==""1""
#     smod%=MOD
""""""

1*127
1111111
111
11
10
1
""""""",1448294672
Haksell,Haksell,390,3646,python3,"MOD=1_000_000_007

class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        cnt=defaultdict(int)
        dp=defaultdict(int)
        for i, n in enumerate(nums):
            dp[n]+=n*(1+cnt[n+1]+cnt[n-1])+dp[n+1]+dp[n-1]
            cnt[n]+=1+cnt[n+1]+cnt[n-1]
            dp[n]%=MOD
            cnt[n]%=MOD
        return sum(dp.values())%MOD",1448210455
i_will_beat_my_iq,i_will_beat_my_iq,391,3612,cpp,"class Solution {
public:
 vector<int> f2_precompute_inc(vector<int>& a, int n) {
        vector<int> inc(n, 1);
        for (int i = n - 2; i >= 0; --i) {
            inc[i] = (a[i] < a[i + 1]) ? inc[i + 1] + 1 : 1;
        }
        return inc;
    }

    bool f3_check_adjacent(vector<int>& inc, int b, int n) {
        for (int i = 0; i + 2 * b <= n; ++i) {
            if (inc[i] >= b && inc[i + b] >= b) {
                return true;
            }
        }
        return false;
    }
    bool hasIncreasingSubarrays(vector<int>& a, int b) {
        int n = a.size();
        
        if (2 * b > n) return false;
        
        vector<int> inc = f2_precompute_inc(a, n);
        
        return f3_check_adjacent(inc, b, n);
    }
};",1448287348
i_will_beat_my_iq,i_will_beat_my_iq,391,3619,cpp,"class Solution {
public:
vector<int> f2_inc_lengths(vector<int>& a, int n) {
        vector<int> inc(n, 1);
        for (int i = n - 2; i >= 0; --i) {
            if (a[i] < a[i + 1]) {
                inc[i] = inc[i + 1] + 1;
            } else {
                inc[i] = 1;
            }
        }
        return inc;
    }

    int f3_max_k(vector<int>& inc, int n) {
        int l = 1, r = n / 2, mx_k = 0;

        while (l <= r) {
            int m = l + (r - l) / 2;
            bool found = false;

            for (int i = 0; i + 2 * m <= n; ++i) {
                if (inc[i] >= m && inc[i + m] >= m) {
                    found = true;
                    break;
                }
            }
            
            if (found) {
                mx_k = m;
                l = m + 1;
            } else {
                r = m - 1;
            }
        }

        return mx_k;
    }
    int maxIncreasingSubarrays(vector<int>& a) {
        int n = a.size();
        if (n < 2) return 0;

        vector<int> inc = f2_inc_lengths(a, n);
        
        return f3_max_k(inc, n);
    }
};",1448278203
i_will_beat_my_iq,i_will_beat_my_iq,391,3631,cpp,"class Solution {
public:
vector<int> f2_compute_steps(int MX) {
        vector<int> steps(MX + 1, -1);
        steps[1] = 0;

        for (int x = 1; x <= MX; ++x) {
            if (steps[x] == -1) {
                int cnt = 0, cur = x;
                vector<int> path;

                while (cur != 1 && (cur > MX || steps[cur] == -1)) {
                    path.push_back(cur);
                    cur = __builtin_popcount(cur);
                    cnt++;
                }
                if (cur <= MX) cnt += steps[cur];

                f7_assign_steps(steps, path, cnt);
            }
        }
        return steps;
    }

    vector<vector<vector<long>>> f3_init_memo(int n) {
        return vector<vector<vector<long>>>(n + 1, vector<vector<long>>(n + 1, vector<long>(2, -1)));
    }

    long f4_dp(int p, int sb, int t, int n, const string& a, int b, const vector<int>& steps, vector<vector<vector<long>>>& memo) {
        const int MOD = 1e9 + 7;
        if (p == n) return (sb >= 1 && sb <= 1000 && steps[sb] <= b - 1) ? 1 : 0;

        if (memo[p][sb][t] != -1) return memo[p][sb][t];

        int limit = t ? (a[p] - '0') : 1;
        long res = 0;

        for (int bit = 0; bit <= limit; ++bit) {
            int nt = t && (bit == limit);
            int nsb = sb + bit;
            res = (res + f4_dp(p + 1, nsb, nt, n, a, b, steps, memo)) % MOD;
        }

        return memo[p][sb][t] = res;
    }

    int f5_count_set_bits(const string& a) {
        return count(a.begin(), a.end(), '1');
    }

    bool f6_is_reducible(int sb, int k, const vector<int>& steps, int MX) {
        int steps_n = (sb <= MX) ? 1 + steps[sb] : 2;
        return (sb >= 1 && steps_n <= k);
    }

    void f7_assign_steps(vector<int>& steps, vector<int>& path, int cnt) {
        for (auto it = path.rbegin(); it != path.rend(); ++it) {
            if (*it < steps.size()) steps[*it] = cnt;
            cnt--;
        }
    }
    int countKReducibleNumbers(string a, int b) {
        const int MX = 1000, MOD = 1e9 + 7;

        vector<int> steps = f2_compute_steps(MX);
        int n = a.size();

        vector<vector<vector<long>>> memo = f3_init_memo(n);

        long total = f4_dp(0, 0, 1, n, a, b, steps, memo);

        int sb = f5_count_set_bits(a);
        bool is_reducible = f6_is_reducible(sb, b, steps, MX);

        if (is_reducible) {
            total = (total - 1 + MOD) % MOD;
        }

        return (total % MOD);
    }
};",1448301396
i_will_beat_my_iq,i_will_beat_my_iq,391,3646,cpp,"class Solution {
public:
using ll = long long;
int f2(vector<int>& a) {
        int mx = 0;
        for (auto x : a) {
            if (x > mx) mx = x;
        }
        return mx;
    }
    
    ll f3(vector<ll>& c, int i) {
        return (i >= 0 ? c[i] : 0);
    }

    ll f4(vector<ll>& s, vector<ll>& c, int i, int x) {
        ll ls = (i >= 0 ? s[i] : 0);
        ll lc = (i >= 0 ? c[i] : 0);
        return ls + (lc * (ll)x) % 1000000007;
    }
    
    int f5(vector<ll>& s) {
        const int M = 1000000007;
        ll ans = 0;
        for (auto v : s) {
            ans = (ans + v) % M;
        }
        return ans;
    }
    int sumOfGoodSubsequences(vector<int>& a) {
        const int M = 1000000007;
        int mx = f2(a);
        
        vector<ll> c(mx + 2, 0);
        vector<ll> s(mx + 2, 0);

        for (auto x : a) {
            ll nc = (f3(c, x - 1) + c[x + 1] + 1) % M;
            ll ns = (f4(s, c, x - 1, x) + s[x + 1] + (c[x + 1] * (ll)x) % M + x) % M;

            c[x] = (c[x] + nc) % M;
            s[x] = (s[x] + ns) % M;
        }

        return f5(s);
    }
};",1448275554
amez,amezzz,394,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        valid = True
        for i in range(n - 2 * k + 1):
            valid = True
            for j in range(i, i + k - 1):
                if not nums[j] < nums[j + 1]:
                    valid = False
            for j in range(i + k, i + 2 * k - 1):
                if not nums[j] < nums[j + 1]:
                    valid = False
            if valid:
                return True
        return valid",1448194086
amez,amezzz,394,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        vals = []
        n = len(nums)
        p = 0
        while p < n:
            start = p
            p += 1
            while p < n and nums[p] > nums[p - 1]:
                p += 1
            vals.append(p - start)
        ans = max(a // 2 for a in vals)
        for a, b in pairwise(vals):
            ans = max(ans, min(a, b))
        return ans
            
        ",1448200256
amez,amezzz,394,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:

        def check(num, t):
            while num > 1 and t > 0:
                num = bin(num).count('1')
                t -= 1
            return num <= 1

        @cache
        def dfs(p, cnt, free, start):
            if p == n:
                return 1 if check(cnt, k - 1) and free else 0
            ans = 0
            if not start:
                ans = dfs(p + 1, cnt, True, False)
            if free:
                if start:
                    ans += dfs(p + 1, cnt, True, True)
                    ans %= mod
                ans += dfs(p + 1, cnt + 1, True, True)
            else:
                if start:
                    if int(s[p]) == 1:
                        ans += dfs(p + 1, cnt, True, True)
                        ans %= mod
                    else:
                        ans += dfs(p + 1, cnt, False, True)
                        ans %= mod
                if int(s[p]) == 1:
                    ans += dfs(p + 1, cnt + 1, False, True)
                    ans %= mod
            return ans

        n = len(s)
        mod = 10 ** 9 + 7
        return dfs(0, 0, False, False) - 1

        
        ",1448289322
amez,amezzz,394,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        mod = 10 ** 9 + 7
        count_dp = defaultdict(int)
        sum_dp = defaultdict(int)
        total_sum = 0

        for num in nums:
            count = 1 
            total = num  

            for diff in [-1, 1]:
                prev_num = num - diff
                if prev_num in count_dp:
                    count += count_dp[prev_num]
                    total += sum_dp[prev_num] + count_dp[prev_num] * num
                    total %= mod 

            count_dp[num] = (count_dp[num] + count) % mod
            sum_dp[num] = (sum_dp[num] + total) % mod
            total_sum = (total_sum + total) % mod

        return total_sum
",1448260889
Sarthak Mathur,WORTH_IT,395,3612,java,"// import java.util.*;
// import java.util.function.*;

// public class Main {
//     public static void main(String[] args) throws Exception {
//         System.out.println(new Solution().solve());
//     }
// }

class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        if (k == 1)
            return true;

        int n = nums.size();

        IntPredicate check = new IntPredicate() {
            @Override
            public boolean test(int i) {
                for (int j = 0; j < k - 1; j++) {
                    if (i + j + 1 >= n)
                        return false;

                    if (nums.get(i + j + 1) <= nums.get(i + j))
                        return false;
                }
                return true;
            }
        };

        for (int i = 0; i < n; i++) {
            if (check.test(i) && check.test(i + k))
                return true;
        }
        return false;
    }
}",1448188085
Sarthak Mathur,WORTH_IT,395,3619,java,"// import java.util.*;
// import java.util.function.*;

// public class Main {
//     public static void main(String[] args) throws Exception {
//         System.out.println(new Solution().solve());
//     }
// }

class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        ArrayList<Integer> sizes = new ArrayList<>();
        int n = nums.size(), l = 0, r;
        while (l < n) {
            r = l + 1;
            while (r < n && nums.get(r) > nums.get(r - 1))
                r++;

            sizes.add(r - l);
            l = r;
        }

        int k = Math.max(1, sizes.get(sizes.size() - 1) >> 1);
        for (int i = 0; i < sizes.size() - 1; i++) {
            k = Math.max(k, sizes.get(i) >> 1);
            k = Math.max(k, Math.min(sizes.get(i), sizes.get(i + 1)));
        }

        return k;
    }
}",1448194093
Sarthak Mathur,WORTH_IT,395,3631,java,"// import java.util.*;
// import java.util.function.*;

// public class Main {
//     public static void main(String[] args) throws Exception {
//         System.out.println(new Solution().countKReducibleNumbers(""111"", 1));
//         System.out.println(new Solution().countKReducibleNumbers(""1000"", 2));
//     }
// }

class Solution {
    static int N = 801;
    static int[] ops = new int[N];

    static {
        for (int i = 2; i < N; i++)
            ops[i] = ops[Integer.bitCount(i)] + 1;
    }

    public int countKReducibleNumbers(String s, int k) {
        int n = s.length();

        // dp[i][set][tight] = Number of suffixes of length i
        Mint[][][] dp = new Mint[n + 1][N][2];
        TriFunction<Integer, Integer, Integer, Mint> solve = new TriFunction<Integer, Integer, Integer, Mint>() {
            @Override
            public Mint apply(Integer i, Integer set, Integer tight) {
                if (set < 0)
                    return Mint.ZERO;

                if (dp[i][set][tight] != null)
                    return dp[i][set][tight];

                if (i == 0) {
                    if (set == 0)
                        return dp[i][set][tight] = Mint.ONE;
                    return dp[i][set][tight] = Mint.ZERO;
                }

                Mint ans = Mint.ZERO;
                if (s.charAt(n - i) == '0' && tight == 1) {
                    ans = ans.add(apply(i - 1, set, tight));
                } else {
                    ans = ans.add(apply(i - 1, set - 1, tight));
                    ans = ans.add(apply(i - 1, set, 0));
                }

                return dp[i][set][tight] = ans;
            }
        };

        Mint ans = Mint.ZERO;
        for (int i = 1; i <= n; i++) {
            if (ops[i] + 1 <= k)
                ans = ans.add(solve.apply(n, i, 1));
        }

        int count = 0;
        for (int i = 0; i < n; i++)
            count += s.charAt(i) - '0';
        if (ops[count] + 1 <= k)
            ans = ans.sub(1);
        return (int) ans.get();
    }
}

@FunctionalInterface
interface TriFunction<One, Two, Three, Return> {
    public Return apply(One one, Two two, Three three);
}

@FunctionalInterface
interface TetraFunction<One, Two, Three, Four, Return> {
    public Return apply(One one, Two two, Three three, Four four);
}

@FunctionalInterface
interface PentaFunction<One, Two, Three, Four, Five, Return> {
    public Return apply(One one, Two two, Three three, Four four, Five five);
}

final class Mint { // 1000000007 998244353
    public static long mod = 1000000007;
    public static boolean modIsPrime = true;
    private final long val;

    public static final Mint ZERO = new Mint(0L);
    public static final Mint ONE = new Mint(1L);

    public static long norm(long val) {
        return (val %= mod) < 0 ? val + mod : val;
    }

    public static long norm(Integer val) {
        return norm(val.longValue());
    }

    public Mint(long val) {
        this.val = norm(val);
    }

    public Mint() {
        this(0);
    }

    public Mint(Mint arg) {
        this(arg.val);
    }

    public Mint(Integer arg) {
        this(arg.longValue());
    }

    public long get() {
        return val;
    }

    public Mint add(long arg) {
        return new Mint(this.val + norm(arg));
    }

    public Mint add(Mint arg) {
        return add(arg.val);
    }

    public Mint add(Integer arg) {
        return add(arg.longValue());
    }

    public Mint add(long... args) {
        Mint sum = this;
        for (long a : args)
            sum = sum.add(a);
        return sum;
    }

    public Mint add(Mint... args) {
        Mint sum = this;
        for (Mint a : args)
            sum = sum.add(a);
        return sum;
    }

    public Mint add(Integer... args) {
        Mint sum = this;
        for (Integer a : args)
            sum = sum.add(a);
        return sum;
    }

    public Mint sub(long arg) {
        return new Mint(val - norm(arg));
    }

    public Mint sub(Mint arg) {
        return sub(arg.val);
    }

    public Mint sub(Integer arg) {
        return sub(arg.longValue());
    }

    public Mint mul(long arg) {
        return new Mint(this.val * norm(arg));
    }

    public Mint mul(Mint arg) {
        return mul(arg.val);
    }

    public Mint mul(Integer arg) {
        return mul(arg.longValue());
    }

    public Mint mul(long... args) {
        Mint product = this;
        for (long a : args)
            product = product.mul(norm(a));
        return product;
    }

    public Mint mul(Mint... args) {
        Mint product = this;
        for (Mint a : args)
            product = product.mul(a);
        return product;
    }

    public Mint mul(Integer... args) {
        Mint product = this;
        for (Integer a : args)
            product = product.mul(norm(a));
        return product;
    }

    public Mint div(Mint arg) {
        return mul(arg.inv());
    }

    public Mint div(long arg) {
        return div(new Mint(arg));
    }

    public Mint div(Integer arg) {
        return div(new Mint(arg));
    }

    public Mint inv() {
        if (!modIsPrime)
            throw new ArithmeticException(val + "" cannot have inverse with mod "" + mod + ""!"");
        return pow(mod - 2);
    }

    public Mint pow(long arg) {
        if (arg < 0)
            return pow(-arg).inv();
        Mint pow = Mint.ONE;
        Mint temp = this;
        while (arg > 0) {
            if ((arg & 1) == 1)
                pow = pow.mul(temp);
            temp = temp.mul(temp);
            arg = arg >> 1;
        }
        return pow;
    }

    public Mint pow(Mint arg) {
        return pow(arg.val);
    }

    public Mint pow(Integer arg) {
        return pow(arg.longValue());
    }

    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;
        Mint mint = (Mint) o;
        return val == mint.val;
    }

    @Override
    public String toString() {
        return Long.toString(val);
    }
}",1448302838
Sarthak Mathur,WORTH_IT,395,3646,java,"// import java.util.*;
// import java.util.function.*;

// public class Main {
//     public static void main(String[] args) throws Exception {
//         System.out.println(new Solution().sumOfGoodSubsequences(new int[]{1, 2, 1}));
//         System.out.println(new Solution().sumOfGoodSubsequences(new int[]{3, 4, 5}));
//     }
// }

class Solution {
    public int sumOfGoodSubsequences(int[] nums) {
        int n = nums.length;

        HashMap<Integer, Mint> sum = new HashMap<>();
        HashMap<Integer, Mint> count = new HashMap<>();
        for (int x : nums) {
            Mint s = Mint.ZERO;
            s = s.add(sum.getOrDefault(x - 1, Mint.ZERO));
            s = s.add(sum.getOrDefault(x + 1, Mint.ZERO));

            Mint c = Mint.ONE;
            c = c.add(count.getOrDefault(x - 1, Mint.ZERO));
            c = c.add(count.getOrDefault(x + 1, Mint.ZERO));

            s = s.add(new Mint(x).mul(c));
            sum.put(x, sum.getOrDefault(x, Mint.ZERO).add(s));
            count.put(x, count.getOrDefault(x, Mint.ZERO).add(c));
        }

        Mint ans = Mint.ZERO;
        for (var asd : sum.values())
            ans = ans.add(asd);

        return (int) ans.get();
    }
}

final class Mint { // 1000000007 998244353
    public static long mod = 1000000007;
    public static boolean modIsPrime = true;
    private final long val;

    public static final Mint ZERO = new Mint(0L);
    public static final Mint ONE = new Mint(1L);

    public static long norm(long val) {
        return (val %= mod) < 0 ? val + mod : val;
    }

    public static long norm(Integer val) {
        return norm(val.longValue());
    }

    public Mint(long val) {
        this.val = norm(val);
    }

    public Mint() {
        this(0);
    }

    public Mint(Mint arg) {
        this(arg.val);
    }

    public Mint(Integer arg) {
        this(arg.longValue());
    }

    public long get() {
        return val;
    }

    public Mint add(long arg) {
        return new Mint(this.val + norm(arg));
    }

    public Mint add(Mint arg) {
        return add(arg.val);
    }

    public Mint add(Integer arg) {
        return add(arg.longValue());
    }

    public Mint add(long... args) {
        Mint sum = this;
        for (long a : args)
            sum = sum.add(a);
        return sum;
    }

    public Mint add(Mint... args) {
        Mint sum = this;
        for (Mint a : args)
            sum = sum.add(a);
        return sum;
    }

    public Mint add(Integer... args) {
        Mint sum = this;
        for (Integer a : args)
            sum = sum.add(a);
        return sum;
    }

    public Mint sub(long arg) {
        return new Mint(val - norm(arg));
    }

    public Mint sub(Mint arg) {
        return sub(arg.val);
    }

    public Mint sub(Integer arg) {
        return sub(arg.longValue());
    }

    public Mint mul(long arg) {
        return new Mint(this.val * norm(arg));
    }

    public Mint mul(Mint arg) {
        return mul(arg.val);
    }

    public Mint mul(Integer arg) {
        return mul(arg.longValue());
    }

    public Mint mul(long... args) {
        Mint product = this;
        for (long a : args)
            product = product.mul(norm(a));
        return product;
    }

    public Mint mul(Mint... args) {
        Mint product = this;
        for (Mint a : args)
            product = product.mul(a);
        return product;
    }

    public Mint mul(Integer... args) {
        Mint product = this;
        for (Integer a : args)
            product = product.mul(norm(a));
        return product;
    }

    public Mint div(Mint arg) {
        return mul(arg.inv());
    }

    public Mint div(long arg) {
        return div(new Mint(arg));
    }

    public Mint div(Integer arg) {
        return div(new Mint(arg));
    }

    public Mint inv() {
        if (!modIsPrime)
            throw new ArithmeticException(val + "" cannot have inverse with mod "" + mod + ""!"");
        return pow(mod - 2);
    }

    public Mint pow(long arg) {
        if (arg < 0)
            return pow(-arg).inv();
        Mint pow = Mint.ONE;
        Mint temp = this;
        while (arg > 0) {
            if ((arg & 1) == 1)
                pow = pow.mul(temp);
            temp = temp.mul(temp);
            arg = arg >> 1;
        }
        return pow;
    }

    public Mint pow(Mint arg) {
        return pow(arg.val);
    }

    public Mint pow(Integer arg) {
        return pow(arg.longValue());
    }

    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;
        Mint mint = (Mint) o;
        return val == mint.val;
    }

    @Override
    public String toString() {
        return Long.toString(val);
    }
}",1448243383
DestinyGod,DestinyGod,397,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        d=[0]*len(nums)
        for i in range(len(nums)-1):
            if nums[i+1]>nums[i]:
                d[i]=1
        c=0
        for i in range(len(nums)-1,-1,-1):
            if d[i]:
                c+=1
                d[i]=c
            else:
                c=0
        for i in range(0,len(nums)-k):
            if d[i]>=k-1 and d[i+k]>=k-1:
                return True
        return False",1448194440
DestinyGod,DestinyGod,397,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        l=0
        r=10**6
        def check(k:int):
            d=[0]*len(nums)
            for i in range(len(nums)-1):
                if nums[i+1]>nums[i]:
                    d[i]=1
            c=0
            for i in range(len(nums)-1,-1,-1):
                if d[i]:
                    c+=1
                    d[i]=c
                else:
                    c=0
            for i in range(0,len(nums)-k):
                if d[i]>=k-1 and d[i+k]>=k-1:
                    return True
            return False
        while l<r:
            mid=(l+r+1)//2
            if check(mid):
                l=mid
            else:
                r=mid-1
        return l",1448197829
DestinyGod,DestinyGod,397,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        mod=10**9+7
        dp=[0]*801
        for i in range(1,801):
            c=0
            x=i
            while i>0:
                c+=(i&1)
                i>>=1
            dp[x]=dp[c]+1
        @cache
        def dfs(cnt:int,limit:int,i:int):
            if i==len(s):
                return (dp[cnt]<=k)&(cnt!=0)&(limit==0)
            if limit:
                if s[i]=='0':
                    return dfs(cnt,1,i+1)
                else:
                    return (dfs(cnt,0,i+1)+dfs(cnt+1,1,i+1))%mod
            else:
                return (dfs(cnt,0,i+1)+dfs(cnt+1,0,i+1))%mod
        return dfs(0,1,0)",1448290110
DestinyGod,DestinyGod,397,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        dp={}
        cnt={}
        res=0
        mod=10**9+7
        for i in nums:
            if i not in dp:
                dp[i]=0
                cnt[i]=0
            c=1
            sum=0
            if i-1 in dp:
                sum+=dp[i-1]
                c+=cnt[i-1]
            if i+1 in dp:
                sum+=dp[i+1]
                c+=cnt[i+1]
            sum=(sum+(c*i)%mod)%mod
            cnt[i]+=c
            cnt[i]%=mod
            res+=sum
            res%=mod
            dp[i]+=sum
            dp[i]%=mod
        return res",1448227609
lovesbumblebees,lovesbumblebees,398,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        if(k == 1) {
            return true;
        }
        // search forward
        vector<bool> forward(nums.size(), false);
        int count = 1;
        for(int i = 1; i < nums.size(); i++) {
            if(nums[i] > nums[i - 1]) {
                count++;
                if(count >= k) {
                    forward[i] = true;
                }
            } else {
                // reset the count
                count = 1;
            }
        }
        // search backward
        // vector<bool> backward(nums.size(), false);
        count = 1;
        for(int i = nums.size() - 2; i >= 0; i--) {
            if(nums[i] < nums[i + 1]) {
                count++;
                if(count >= k) {
                    //backward[i] = true;
                    if(i > 0 && forward[i - 1]) {
                        return true;
                    }
                }
            } else {
                // reset the count
                count = 1;
            }
        }
        return false;
        
    }
};",1448195169
lovesbumblebees,lovesbumblebees,398,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        // search forward
        vector<int> forward(nums.size(), 1);
        int count = 1;
        for(int i = 1; i < nums.size(); i++) {
            if(nums[i] > nums[i - 1]) {
                count++;
            } else {
                // reset the count
                count = 1;
            }
            forward[i] = count;
        }
        // search backward
        count = 1;
        int max_k = 1;
        for(int i = nums.size() - 2; i >= 0; i--) {
            if(nums[i] < nums[i + 1]) {
                count++;
                if(i > 0) {
                    max_k = max(max_k, min(count, forward[i - 1])); 
                }
            } else {
                // reset the count
                count = 1;
            }
        }
        return max_k;
    }
};

",1448201849
lovesbumblebees,lovesbumblebees,398,3631,cpp,"const int MOD = 1000000007;
class Solution {
public:
    int combination[801][801]= {};
    int k_score[801] = {};

    Solution() {
        memset(k_score,  -1, sizeof(k_score)); 
    }

    int kScore(int n) {
        if(k_score[n] >= 0) {
            return k_score[n];
        }
        if(n == 0) {
            return 1000;
        }
        // no operations are necessary
        if(n == 1) {
            return 0;
        }
        // count bits,
        int current = n;
        int bits = 0;
        for(int i = 0; i < 10; i++) {
            if(current & 1) {
                bits++;
            }
            current >>= 1;
        }
        k_score[n] = 1 + kScore(bits); 
        return k_score[n]; 
    }
    // we have SET bits determined
    // we have FREE bits available to be either 0 or 1
    int countLessThan(int free, int set, int k) {
        int count = 0;
        for(int i = 0; i <= free; i++) {
            if(kScore(i + set) < k) {
                count = (count + comb(free, i)) % MOD; 
            }
        }
        return count;
    }

    int comb(int n, int k) {
        if(combination[n + 1][k + 1] >0) {
            return combination[n + 1][k + 1];
        }
        if(k ==0 || k == n) {
            return 1;
        }
        combination[n + 1][k + 1] = (comb(n-1, k) + comb(n-1, k-1)) % MOD;
        return combination[n + 1][k + 1];
    }

    int countKReducibleNumbers(string s, int k) {
        int set = 0;
        int count = 0;
        for(int i = 0; i < s.size(); i++) {
            if(s[i] == '1') {
                count = (count + countLessThan(s.size() - i - 1, set, k)) % MOD;
                set++;
            }
        }
        return count;
    }
};",1448290779
lovesbumblebees,lovesbumblebees,398,3646,cpp,"constexpr int MOD = 1000000007;
class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        vector<long long> dp_count(100003, 0ll); 
        vector<long long> dp_sum(100003, 0ll); 
        dp_count[nums[0] + 1] = 1; 
        dp_sum[nums[0] + 1] = nums[0];
        for(int i = 1; i < nums.size(); i++) {
            dp_count[nums[i] + 1] = (dp_count[nums[i] + 1] + dp_count[nums[i]] + dp_count[nums[i] + 2] + 1) % MOD;
            dp_sum[nums[i] + 1] = (dp_sum[nums[i] + 1] + dp_sum[nums[i]] + dp_sum[nums[i] + 2] + (dp_count[nums[i]] + dp_count[nums[i] + 2] + 1) * nums[i]) % MOD; 
        }
        long long total = 0;
        for(const int num: dp_sum) {
            total = (total + num) % MOD;
        }
        return total;
    }
};",1448238173
Ivan Li,liivan256,400,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n=len(nums)
        for i in range(n - k + 1):
            j = i + k
            if j + k <= n:
                s1 = nums[i:i+k]
                s2 = nums[j:j+k]
                if all(s1[k-1] < s1[k] for k in range(1, len(s1))) and all(s2[k-1] < s2[k] for k in range(1, len(s2))):
                    return True
        return False",1448187343
Ivan Li,liivan256,400,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        def works(m):
            for i in range(n - 2 * m + 1):
                l = i
                r = i + m - 1
                l2 = r + 1
                r2 = l2 + m - 1
                if 0 == query(l,r) == query(l2, r2):
                    return True
            return False
    
        inf = 1 << 30
        n = len(nums)
        dec = [nums[i] >= nums[i + 1] for i in range(n - 1)] + [0]
        psa = [0] + list(accumulate(dec))
        query = lambda l,r: psa[r]-psa[l]
    
        low = 0
        high = n // 2
        while low <= high:
            mid = (low + high) // 2
            if works(mid):
                low = mid + 1
            else:
                high = mid - 1
        return low - 1
",1448217566
Ivan Li,liivan256,400,3631,python3,"from functools import cache

@cache
def get_min_reduction(cur):
    if cur == 1:
        return 0
    return 1 + get_min_reduction(cur.bit_count())


MN = 1000
reductions = [-1] * MN
for i in range(1, MN):
    reductions[i] = get_min_reduction(i)
# print(reductions)

class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        le = len(s)
        MOD = 10 ** 9 + 7
        s = list(map(int, s))
    
        cache = [[[-1] * (le + 1) for _ in range(le)] for _ in range(2)]
        def solve(touch_r, idx, bits):
            nonlocal cache
            if idx == le:
                return bits in fine and not touch_r
            if cache[touch_r][idx][bits] != -1:
                return cache[touch_r][idx][bits]
    
            t = 0
            upper = s[idx] if touch_r else 1
            for dig in range(upper + 1):
                t += solve(touch_r and s[idx] == dig, idx + 1, bits + dig)
            cache[touch_r][idx][bits] = t % MOD
            return cache[touch_r][idx][bits]
    
        fine = set()
        for i in range(1, MN):
            if reductions[i] + 1 <= k:
                fine.add(i)
        return solve(True, 0, 0) % MOD",1448291537
Ivan Li,liivan256,400,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        MOD = 10 ** 9 + 7
        cnt = defaultdict(int)
        total = defaultdict(int)
        n = len(nums)
    
        cnt[nums[0]] = 1  # base case
        total[nums[0]] = nums[0]
    
        for num in nums[1:]:
            # consider subsequence building on top of previous ones
            cnt[num] += cnt[num - 1]
            total[num] += total[num - 1] + num * (cnt[num - 1])
    
            cnt[num] += cnt[num + 1]
            total[num] += total[num + 1] + num * cnt[num + 1]
    
            # consider subsequence start here
            total[num] += num
            cnt[num] += 1
            
            total[num] %= MOD
            cnt[num] %= MOD
    
        return sum(total.values()) % MOD
",1448237527
parth162,parth162,402,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        dp = [1 for i in range(len(nums))]
        dp2 = [1 for i in range(len(nums))]
        
        for i in range(1, len(nums)):
            if nums[i]>nums[i-1]:
                dp[i] = dp[i-1]+1
                
        for i in range(len(nums)-2, -1, -1):
            if nums[i]<nums[i+1]:
                dp2[i]= dp2[i+1]+1
                
        for i in range(1, len(nums)):
            if dp[i-1]>=k and dp2[i]>=k:
                return True
            
        # print(dp, dp2)
                
        return False",1448185054
parth162,parth162,402,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        dp = [1 for i in range(len(nums))]
        dp2 = [1 for i in range(len(nums))]
        
        for i in range(1, len(nums)):
            if nums[i]>nums[i-1]:
                dp[i] = dp[i-1]+1
                
        for i in range(len(nums)-2, -1, -1):
            if nums[i]<nums[i+1]:
                dp2[i]= dp2[i+1]+1
        res = 0
        for i in range(1, len(nums)):
            res = max(res, min(dp[i-1], dp2[i]))
            
        # print(dp, dp2)
                
        return res",1448187015
parth162,parth162,402,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        mx = len(s)
        if mx <= 1:
            return 0
        
        nt = {}
        
        @cache
        def opt2(i):
            if bin(i).count(""1"") == 1:
                return 1
            return opt2(bin(i).count(""1""))+1
        
        want = set([1])
        
        for j in range(2, mx+1):
            nt[j] = opt2(j)
            if nt[j]<=k-1:
                want.add(j)
                
        # print(want)
        
        @cache
        def opt(n, l):
            if n<0:
                return 0
            if n == 0:
                return 1
            if n > l:
                return 0
            if n == l:
                return 1
            return (opt(n,l-1) + opt(n-1,l-1))%(10**9+7)
        
        res = 0
        for n in want: 
            f = 0
            for i,x in enumerate(s):
                if x == ""0"":
                    continue
                l = len(s)-i-1
                res += opt(n-f, l)
                res %= (10**9+7)
                f+=1
        
        return res",1448278416
parth162,parth162,402,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        mp = defaultdict(list)
            
        till_now = {}
        
        for i,x in enumerate(nums):
            mp[x].append(i)
            till_now[nums[i]] = (0,0)
        
        @cache
        def opt(i):
            ele = nums[i]
            need = nums[i]-1
            need2 = nums[i]+1
            
            res = ele
            l = 1
            # print(mp[need], need)
            # for j in mp[need]:
            #     if j>i:
            #         break
            #     s,n = opt(j)
            #     # print(s,n,j)
            #     res += n*nums[i] + s
            #     res%= (10**9+7)
            #     l+=n
            # # print(mp[need2], need2)
            # for j in mp[need2]:
            #     if j>i:
            #         break
            #     s,n = opt(j)
            #     res += n*nums[i] + s
            #     res%= (10**9+7)
            #     l+=n
            if need in till_now:
                s,n = till_now[need]
                res += n*nums[i] + s
                res%= (10**9+7)
                l+=n
            if need2 in till_now:
                s,n = till_now[need2]
                res += n*nums[i] + s
                res%= (10**9+7)
                l+=n
            x,y = till_now[ele]
            till_now[ele] = (res+x, l+y)
                
            return res,l
        ans = 0
        for i in range(len(nums)):
            ans += (opt(i)[0])
            # print(opt(i))
            ans%= (10**9+7)
            
        return ans",1448232609
jianstanleya,jianstanleya,405,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int i = 0;
        vector<int> segs;
        while(i < nums.size()) {
            int j = i + 1;
            while(j < nums.size() && nums[j] > nums[j - 1]) j++;
            segs.push_back(j - i);
            i = j;
        }
        int result = 0;
        for(int i : segs) result = max(result, i / 2);
        for(int i = 0; i < segs.size() - 1; i++) result = max(result, min(segs[i], segs[i + 1]));
        return result >= k;
    }
};",1448188356
jianstanleya,jianstanleya,405,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int i = 0;
        vector<int> segs;
        while(i < nums.size()) {
            int j = i + 1;
            while(j < nums.size() && nums[j] > nums[j - 1]) j++;
            segs.push_back(j - i);
            i = j;
        }
        int result = 0;
        for(int i : segs) result = max(result, i / 2);
        for(int i = 0; i < segs.size() - 1; i++) result = max(result, min(segs[i], segs[i + 1]));
        return result;
    }
};",1448187586
jianstanleya,jianstanleya,405,3631,cpp,"#define LL long long

const static LL MOD = 1000000007;

class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        int w = s.size();
        vector<vector<int>> binom(w + 1, vector<int>(w + 1, 0));
        binom[0][0] = 1;
        for(int i = 1; i <= w; i++) {
            for(int j = 0; j <= i; j++){
                binom[i][j] = j > 0 ? binom[i - 1][j - 1] + binom[i - 1][j] : 1;
                binom[i][j] %= MOD;
            }
        }
        k--;
        vector<int> evo(w + 1, 0);
        for(int i = 0; i <= w; i++) {
            evo[i] = __builtin_popcount(i);
            if(i == 1) evo[i] = -1;
        }
        vector<int> kevo(w + 1, 0);
        for(int i = 0; i <= w; i++) {
            kevo[i] = evo[i];
            for(int j = 0; kevo[i] > -1 && j < k; j++) kevo[i] = evo[kevo[i]];
        }
        vector<LL> freq(w + 1, 0);
        int prefix = 0;
        for(int i = 0; i < w; i++) {
            if(s[i] == '1') {
                for(int j = 0; j < w - i; j++) {
                    freq[j + prefix] += binom[w - i - 1][j];
                    freq[j + prefix] %= MOD;
                }
                prefix++;
            }
        }
        LL result = 0;
        for(int i = 0; i <= w; i++) {
            if(kevo[i] == -1) {
                result += freq[i];
                result %= MOD;
            }
        }
        return result;
    }
};",1448299784
jianstanleya,jianstanleya,405,3646,cpp,"#define LL long long

const LL MOD = 1000000007;

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int cap = 0;
        for(int i : nums) cap = max(cap, i);
        vector<LL> counts(cap + 1, 0);
        vector<LL> evalues(cap + 1, 0);
        vector<LL> values(nums.size(), 0);
        for(int i = 0; i < nums.size(); i++) {
            values[i] += nums[i];
            values[i] %= MOD;
            counts[nums[i]]++;
            counts[nums[i]] %= MOD;
            if(nums[i] > 0) {
                values[i] += evalues[nums[i] - 1];
                values[i] %= MOD;
                values[i] += (counts[nums[i] - 1] * nums[i]) % MOD;
                values[i] %= MOD;
                counts[nums[i]] += counts[nums[i] - 1];
                counts[nums[i]] %= MOD;
            }
            if(nums[i] < cap) {
                values[i] += evalues[nums[i] + 1];
                values[i] %= MOD;
                values[i] += (counts[nums[i] + 1] * nums[i]) % MOD;
                values[i] %= MOD;
                counts[nums[i]] += counts[nums[i] + 1];
                counts[nums[i]] %= MOD;
            }
            evalues[nums[i]] += values[i];
            evalues[nums[i]] %= MOD;
            if(i > 0) {
                values[i] += values[i - 1];
                values[i] %= MOD;
            }
        }
        return values.back();
    }
};",1448242546
leetgoat_dot_dev,leetgoat_dot_dev,406,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        incs = set()
        for start in range(len(nums) - k + 1):
            failSeen = False
            for right in range(start + 1, start + k):
                if nums[right] <= nums[right - 1]:
                    failSeen = True
                    break
            if not failSeen:
                incs.add(start)
        
        
        for leftStart in range(len(nums)):
            rightStart = leftStart + k
            if leftStart in incs and rightStart in incs:
                return True
        
        return False",1448182322
leetgoat_dot_dev,leetgoat_dot_dev,406,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        @cache
        def descent(i):
            if i == 0:
                return 1
            if nums[i - 1] >= nums[i]:
                return 1
            return 1 + descent(i - 1)
        
        @cache
        def ascent(i):
            if i == len(nums) - 1:
                return 1
            if nums[i + 1] <= nums[i]:
                return 1
            return 1 + ascent(i + 1)
        
        res = 0
        
        for rightEdge in range(len(nums) - 1):
            res = max(res, min(descent(rightEdge), ascent(rightEdge + 1)))
            
        descent.cache_clear()
        ascent.cache_clear()
            
        return res",1448185273
leetgoat_dot_dev,leetgoat_dot_dev,406,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        @cache
        def isReducible(numberOfSetBitsFromLastNumber, transformsMade):
            if numberOfSetBitsFromLastNumber == 1:
                return True
            if transformsMade == k:
                return False
            newNum = numberOfSetBitsFromLastNumber
            newCount = newNum.bit_count()
            return isReducible(newCount, transformsMade + 1)
        
        M = 10**9 + 7
        
        # returns (# of ways to make valid subsequence)
        @cache
        def dp(i, isTight, setBits):
            if i == len(s):
                if setBits == 0:
                    return 0
                if isReducible(setBits, 1):
                    return 1
                return 0
            
            anyWaysHere = 0
            # validWaysHere = 0
            
            upperBoundary = int(s[i]) if isTight else 1
            for nextDigit in range(upperBoundary + 1):
                newIsTight = isTight and nextDigit == upperBoundary
                anyWays = dp(i + 1, newIsTight, setBits + nextDigit)
                anyWaysHere += anyWays
                # validWaysHere += validWays
            
            return anyWaysHere % M
        
        
        ans = dp(0, True, 0)
        
        # print(f'inint ans: {ans}')
                
        # dont include n if it is reducible
        num = int(s, 2)
        if num == 1:
            ans -= 1
        else:
            setBits = num.bit_count()
            # print(f'set bits: {setBits}')
            if isReducible(setBits, 1):
                ans -= 1
        
        dp.cache_clear()
        
        return ans
                ",1448269801
leetgoat_dot_dev,leetgoat_dot_dev,406,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        n = len(nums)
        ends = [0] * (max(nums) + 1) # how many subsequences end with x, for ...i as we go, where we must take the `ith`
        # print(ends)
        
        endSaved = [None] * len(nums) # maps an i to how many subsequences end with nums[i] for ...i, where we must take the `ith`
        M = 10**9 + 7
        
        for i in range(len(nums)):
            # print(f'iter on i={i}')
            down = nums[i] - 1
            up = nums[i] + 1
            # print('up down', up, down)
            newWays = 0
            if down >= 0:
                newWays += ends[down]
            if up < len(ends):
                newWays += ends[up]
            # print(f'new ways from prior constructions: {newWays}')
            finalWays = newWays + 1
            # print(f'final ways: {finalWays}')
            endSaved[i] = finalWays % M
            actualFinal = finalWays + ends[nums[i]]
            ends[nums[i]] = actualFinal % M
            # print(f'ends now: {ends}')
        
        # print(endSaved)
        
        starts = [0] * (max(nums) + 1) # how many subsequences start with X, for i... as we go backwards, DONT NEED TO TAKE ITH
        
        startsSaved = [None] * len(nums) # maps an i to how many subsequences start with nums[i] for i..., where we must take the `ith`
        
        for i in range(len(nums) - 1, -1, -1):
            up = nums[i] + 1
            down = nums[i] - 1
            newWays = 0
            if down >= 0:
                newWays += starts[down]
            if up < len(starts):
                newWays += starts[up]
            finalWays = newWays + 1
            startsSaved[i] = finalWays % M
            actualFinal = finalWays + starts[nums[i]]
            starts[nums[i]] = actualFinal % M
        
        res = 0
        
        for i in range(len(nums)):
            res += startsSaved[i] * endSaved[i] * nums[i]
            res %= (10**9 + 7)
        
        return res % (10**9 + 7)
                
            ",1448293133
Lokesh Rajput,lokeshrajput5473,407,3612,cpp,"class Solution {
public:
bool hasIncreasingSubarrays(const vector<int>& nums, int k) {
    int n = nums.size();
    bool prevIncreasing = false;
    vector<bool>arr(n, false);
    for (int i = 0; i <= n - k; ++i) {
        bool isIncreasing = true;
        for (int j = i; j < i + k - 1; ++j) {
            if (nums[j] >= nums[j + 1]) {
                isIncreasing = false;
                break;
            }
        }
        if(i-k>=0) prevIncreasing = arr[i-k];
        else prevIncreasing = false;
        
        if (isIncreasing && prevIncreasing) {
            return true;
        }
        arr[i] = isIncreasing;
    }
    
    return false;
}
};",1448187509
Lokesh Rajput,lokeshrajput5473,407,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        vector<pair<int, int>> increasingSubarrays;
        int n = nums.size();
        
        int start = 0;
        
        for (int i = 1; i < n; ++i) {
            if (nums[i] <= nums[i - 1]) {
                increasingSubarrays.push_back({start, i - 1});
                start = i;
            }
        }
        
        increasingSubarrays.push_back({start, n - 1});

        int ans = 0;

        for(int i=1;i<increasingSubarrays.size();i++) {
            int len1 = increasingSubarrays[i].second - increasingSubarrays[i].first + 1;
            int len2 = increasingSubarrays[i-1].second - increasingSubarrays[i-1].first + 1;
            ans = max(ans, min(len1, len2));
        }

        for(auto i:increasingSubarrays) {
            ans = max(ans, (i.second - i.first + 1)/2);
        }
        
        return ans;
    }
};",1448197486
Lokesh Rajput,lokeshrajput5473,407,3631,cpp,"

class Solution {
public:
    int mod = 1e9 + 7;
    long long fact[801];

    int modInverse(int A, int M) {
        return power(A, M - 2, M);
    }

    int power(int x, int y, int M) {
        if (y == 0)
            return 1;

        long long p = power(x, y / 2, M) % M;
        p = (p * p) % M;

        return (y % 2 == 0) ? p : (x * p) % M;
    }

    int countSetBits(int n) {
        return bitset<32>(n).count();
    }

    int stepsToOne(int n) {
        int steps = 0;
        while (n != 1) {
            n = countSetBits(n);
            steps++;
        }
        return steps;
    }

    int ncr(int n, int r) {
        long long num = fact[n];
        long long den = (fact[r] * fact[n - r]) % mod;
        den = modInverse(den, mod);

        return (num * den) % mod;
    }

    int solve(int currSetBits, map<int, int>& mp, int n, int r, int k) {
        if (mp[currSetBits + r] > k) return 0;
        int cases = ncr(n, r);
        // cout << cases << "" "";
        return cases;
    }

    int countKReducibleNumbers(string s, int k) {
        map<int, int> mp;
        mp[0] = INT_MAX;
        fact[0] = 1;
        
        for (int i = 1; i <= 800; i++) {
            mp[i] = stepsToOne(i);
            fact[i] = (fact[i - 1] * (long long)i) % mod;
        }

        int currSetBits = 0;
        int ans = 0;
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == '1') {
                int left = s.size() - i - 1;
                for (int j = 0; j <= left; j++) {
                    ans = (ans + (long long)solve(currSetBits, mp, left, j, k-1)) % mod; 
                }
                // cout << endl;
                currSetBits++;
            }
        }
        return ans;
    }
};
",1448293336
Lokesh Rajput,lokeshrajput5473,407,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        map<int, vector<int>> indexes;
        for(int i=0;i<nums.size();i++) {
            indexes[nums[i]].push_back(i);
        }
        int n = nums.size(), mod = 1e9 + 7;
        vector<int> dp(n+1, 1);
        vector<int> sum(n+1, 0), inclSum(n+1, 0);

        map<int, int> forDp, forInclSum;
        sum[n-1] = inclSum[n-1] = nums[n-1];
        dp[n-1] = 1;
        forDp[nums[n-1]] += 1;
        forInclSum[nums[n-1]] += nums[n-1];
        for(int i=n-2;i>=0;i--) {
            inclSum[i] = (inclSum[i] + 0ll + nums[i]) % mod;
            int lower = nums[i]-1;
            if(indexes.find(lower) != indexes.end()) {
                dp[i] = (dp[i] + 0ll + forDp[lower]) % mod;
                inclSum[i] = (inclSum[i] + 0ll + forInclSum[lower]) % mod;
                inclSum[i] = (inclSum[i] + 0ll + (nums[i] * 1ll * forDp[lower]) % mod) % mod;
            }

            int upper = nums[i]+1;
            if(indexes.find(upper) != indexes.end()) {
                dp[i] = (dp[i] + 0ll + forDp[upper]) % mod;
                inclSum[i] = (inclSum[i] + 0ll + forInclSum[upper]) % mod;
                inclSum[i] = (inclSum[i] + 0ll + (nums[i] * 1ll * forDp[upper]) % mod) % mod;
            }
            forDp[nums[i]] = (forDp[nums[i]] +0ll + dp[i]) % mod;
            forInclSum[nums[i]] = (forInclSum[nums[i]] + 0ll + inclSum[i]) % mod;
            sum[i] = sum[i+1];
            sum[i] = (sum[i] + 0ll + inclSum[i]) % mod;

            // cout << sum[i] << "" "";
        }
        return sum[0];
    }
};",1448257425
Arnav Goyal,Pikachu0123,408,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        for(int i=0; i<=n-2*k; i++){
            bool flag = true;
            for(int j=i+1; j<i+k; j++){
                if (nums[j] > nums[j-1]) {}
                else flag = false;
            }
            if (flag){
                for(int j=i+k+1; j<i+2*k; j++){
                    if (nums[j] > nums[j-1]) {}
                    else flag = false;
                }
                if (flag) return true;
            }
        }

        return false;
    }
};",1448183195
Arnav Goyal,Pikachu0123,408,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        int ans = 0, low = 0, high = n / 2 + 1;
        while (low <= high) {
            int mid = (low + high) / 2;
            deque<int> dq;
            for (int i = 0; i < mid; i++) {
                while (!dq.empty() and nums[dq.back()] >= nums[i])
                    dq.pop_back();
                dq.push_back(i);
            }

            vector<int> vis(n, 0);
            for (int i = 0; i <= n - mid; i++) {
                if (dq.size() == mid)
                    vis[i] = 1;
                while (!dq.empty() and dq.front() <= i)
                    dq.pop_front();
                if (i + mid >= n)
                    break;
                while (!dq.empty() and nums[dq.back()] >= nums[i + mid])
                    dq.pop_back();
                dq.push_back(i + mid);
            }
            bool flag = false;
            for (int i = 0; i <= n - 2 * mid; i++) {
                if (i + mid < n and vis[i] and vis[i + mid])
                    flag = true;
            }
            if (flag) {
                ans = mid;
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }

        return ans;
    }
};",1448194523
Arnav Goyal,Pikachu0123,408,3631,cpp,"class Solution {
const int mod = 1e9 + 7;
long long dp[801][801][2];
int dfs(string &str, int tight, int i, int k, int one){
    if (i == str.size()){
        int temp = k;
        int cnt = 0;
        int p = k - 1;
        int temp2 = one;
        while(p--){
            if (temp2 == 1) break;
            temp2 = __builtin_popcount(temp2);
        }
        if (temp2 == 1) return 1;
        return 0;
    }
    if (dp[i][one][tight] != -1) return dp[i][one][tight];
    int end = (tight ? str[i] - '0' : 1);
    long long ans = 0;
    for(int st=0; st<=end; st++){
        (ans += dfs(str, tight&(st==end), i+1, k, one + (st == 1))) %= mod;
    }
    return dp[i][one][tight] = ans;
}

public:
    int countKReducibleNumbers(string s, int k) {
        memset(dp, -1, sizeof dp);
        int flag = 0;
        int p = k -1;
        int temp2 = 0;
        for(int j=0; j<s.size(); j++) temp2 += (s[j] == '1');
        while(p--){
            temp2 = __builtin_popcount(temp2);
        }
        if (temp2 == 1) flag = 1;
        return (dfs(s, 1, 0, k, 0) - flag + mod) % mod;
    }
};",1448272484
Arnav Goyal,Pikachu0123,408,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        const int mod = 1e9 + 7;
        int n = nums.size();
        map<int, long long> dp;
        map<int, long long> sum;

        long long ans = 0;
        for(int &x : nums){
            int left = dp[x-1]+dp[x+1]+1;
            (dp[x] += left) %= mod;
            long long nsum = (sum[x-1]+sum[x+1]+(1LL*left*x)%mod) % mod;
            (sum[x] += nsum) %= mod;
            (ans += nsum) %= mod;
        }

        return ans;
    }
};",1448300193
CoolManGame,CoolManGame,409,3612,cpp,"class Solution {
public:
    bool f(vector<int>& nums, int a, int k) {
        for (int i = a; i+1 < a+k; i++) {
            if (nums[i] >= nums[i+1]) return false;
        }   
        return true;
    }

    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        for (int a = 0; a + 2*k - 1 < n; a++) {
            int b = a + k;
            if (f(nums, a, k) && f(nums, b, k)) return true;
        }
        return false;
    }
};",1448181897
CoolManGame,CoolManGame,409,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> a(n); // a[i] = max j such that nums[i..j] is inc

        for (int i = 0; i < n; ) {
            int j = i;
            while (j < n && (j == i || nums[j] > nums[j-1])) {
                j++;
            }

            for (int k = i; k < j; k++) {
                a[k] = j-1;
            }

            i = j;
        }

        

        int ans = 1;
        for (int i = 0; i < n; i++) {
            int j = a[i];

            int evl1 = (j + 1 - i) / 2;

            int i2 = j + 1;
            int evl2 = 0;
            if (i2 < n) {
                int j2 = a[i2];
                evl2 = min(j - i + 1, j2 - i2 + 1);
            }
        
            ans = max({ans, evl1, evl2});
        }

        return ans;
    }
};",1448198699
CoolManGame,CoolManGame,409,3631,cpp,"#include <bits/stdc++.h>
using namespace std;
#define fi first
#define se second
#define all(v) v.begin(),v.end()
#define fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define len(v) (ll((v).size()))
#define mp(a,b) (make_pair((a),(b)))
using ll = long long;
using pii = pair<int,int>;
using ld = long double;
#define x() real()
#define y() imag()

class Solution {
public:
    int M = 1e9 + 7;
    
    int stepReduce2(const string& s) {
        if (s == ""1"") return 0;
        return 1 + stepReduce(count(all(s), '1'));
    }

    int stepReduce(int x) {
        if (x == 1) return 0;
        if (x == __builtin_popcount(x)) return 1e7;
        return 1 + stepReduce(__builtin_popcount(x));
    }

    vector<vector<int>> A = {
        {1},
        {2, 4, 8, 16, 32, 64, 128, 256, 512}, // A[1]
        
        {3, 5, 6, 9, 10, 12, 15, 17, 18, 20, 23, 24, 27, 29, 30, 33, 34, 36, 39, 40, 43, 45, 46, 48, 51, 53, 54, 57, 58, 60, 65, 66, 68, 71, 72, 75, 77, 78, 80, 83, 85, 86, 89, 90, 92, 96, 99, 101, 102, 105, 106, 108, 113, 114, 116, 120, 129, 130, 132, 135, 136, 139, 141, 142, 144, 147, 149, 150, 153, 154, 156, 160, 163, 165, 166, 169, 170, 172, 177, 178, 180, 184, 192, 195, 197, 198, 201, 202, 204, 209, 210, 212, 216, 225, 226, 228, 232, 240, 255, 257, 258, 260, 263, 264, 267, 269, 270, 272, 275, 277, 278, 281, 282, 284, 288, 291, 293, 294, 297, 298, 300, 305, 306, 308, 312, 320, 323, 325, 326, 329, 330, 332, 337, 338, 340, 344, 353, 354, 356, 360, 368, 383, 384, 387, 389, 390, 393, 394, 396, 401, 402, 404, 408, 417, 418, 420, 424, 432, 447, 449, 450, 452, 456, 464, 479, 480, 495, 503, 507, 509, 510, 513, 514, 516, 519, 520, 523, 525, 526, 528, 531, 533, 534, 537, 538, 540, 544, 547, 549, 550, 553, 554, 556, 561, 562, 564, 568, 576, 579, 581, 582, 585, 586, 588, 593, 594, 596, 600, 609, 610, 612, 616, 624, 639, 640, 643, 645, 646, 649, 650, 652, 657, 658, 660, 664, 673, 674, 676, 680, 688, 703, 705, 706, 708, 712, 720, 735, 736, 751, 759, 763, 765, 766, 768, 771, 773, 774, 777, 778, 780, 785, 786, 788, 792},
        
        {7, 11, 13, 14, 19, 21, 22, 25, 26, 28, 31, 35, 37, 38, 41, 42, 44, 47, 49, 50, 52, 55, 56, 59, 61, 62, 63, 67, 69, 70, 73, 74, 76, 79, 81, 82, 84, 87, 88, 91, 93, 94, 95, 97, 98, 100, 103, 104, 107, 109, 110, 111, 112, 115, 117, 118, 119, 121, 122, 123, 124, 125, 126, 131, 133, 134, 137, 138, 140, 143, 145, 146, 148, 151, 152, 155, 157, 158, 159, 161, 162, 164, 167, 168, 171, 173, 174, 175, 176, 179, 181, 182, 183, 185, 186, 187, 188, 189, 190, 193, 194, 196, 199, 200, 203, 205, 206, 207, 208, 211, 213, 214, 215, 217, 218, 219, 220, 221, 222, 224, 227, 229, 230, 231, 233, 234, 235, 236, 237, 238, 241, 242, 243, 244, 245, 246, 248, 249, 250, 252, 259, 261, 262, 265, 266, 268, 271, 273, 274, 276, 279, 280, 283, 285, 286, 287, 289, 290, 292, 295, 296, 299, 301, 302, 303, 304, 307, 309, 310, 311, 313, 314, 315, 316, 317, 318, 321, 322, 324, 327, 328, 331, 333, 334, 335, 336, 339, 341, 342, 343, 345, 346, 347, 348, 349, 350, 352, 355, 357, 358, 359, 361, 362, 363, 364, 365, 366, 369, 370, 371, 372, 373, 374, 376, 377, 378, 380, 385, 386, 388, 391, 392, 395, 397, 398, 399, 400, 403, 405, 406, 407, 409, 410, 411, 412, 413, 414, 416, 419, 421, 422, 423, 425, 426, 427, 428, 429, 430, 433, 434, 435, 436, 437, 438, 440, 441, 442, 444, 448, 451, 453, 454, 455, 457, 458, 459, 460, 461, 462, 465, 466, 467, 468, 469, 470, 472, 473, 474, 476, 481, 482, 483, 484, 485, 486, 488, 489, 490, 492, 496, 497, 498, 500, 504, 511, 515, 517, 518, 521, 522, 524, 527, 529, 530, 532, 535, 536, 539, 541, 542, 543, 545, 546, 548, 551, 552, 555, 557, 558, 559, 560, 563, 565, 566, 567, 569, 570, 571, 572, 573, 574, 577, 578, 580, 583, 584, 587, 589, 590, 591, 592, 595, 597, 598, 599, 601, 602, 603, 604, 605, 606, 608, 611, 613, 614, 615, 617, 618, 619, 620, 621, 622, 625, 626, 627, 628, 629, 630, 632, 633, 634, 636, 641, 642, 644, 647, 648, 651, 653, 654, 655, 656, 659, 661, 662, 663, 665, 666, 667, 668, 669, 670, 672, 675, 677, 678, 679, 681, 682, 683, 684, 685, 686, 689, 690, 691, 692, 693, 694, 696, 697, 698, 700, 704, 707, 709, 710, 711, 713, 714, 715, 716, 717, 718, 721, 722, 723, 724, 725, 726, 728, 729, 730, 732, 737, 738, 739, 740, 741, 742, 744, 745, 746, 748, 752, 753, 754, 756, 760, 767, 769, 770, 772, 775, 776, 779, 781, 782, 783, 784, 787, 789, 790, 791, 793, 794, 795, 796, 797, 798, 800}, // A[3]
        
        {127, 191, 223, 239, 247, 251, 253, 254, 319, 351, 367, 375, 379, 381, 382, 415, 431, 439, 443, 445, 446, 463, 471, 475, 477, 478, 487, 491, 493, 494, 499, 501, 502, 505, 506, 508, 575, 607, 623, 631, 635, 637, 638, 671, 687, 695, 699, 701, 702, 719, 727, 731, 733, 734, 743, 747, 749, 750, 755, 757, 758, 761, 762, 764, 799}
    };
    
    int modadd(int a, int b) {
        return (a + b) % M;
    }

    int countKReducibleNumbers(string s, int k) {
        if (s == ""0"") return 0;

        int n = s.size();
        int maxBit = 800;
        vector<vector<vector<int>>> dp(n+1, vector<vector<int>>(2, vector<int>(maxBit+1, 0)));

        for (int i = n; i >= 0; i--) {
            for (int j = 0; j < 2; j++) {
                for (int k = 0; k <= maxBit; k++) {
                    if (i == n) {
                        dp[i][j][k] = k == 0 ? 1 : 0;
                        continue;
                    }

                    int evl = 0;

                    if (j == 1) {
                        evl = modadd(dp[i+1][j][k], k > 0 ? dp[i+1][j][k-1] : 0);
                    }
                    else {
                        if (s[i] == '0') {
                            evl = dp[i+1][j][k];
                        } else {
                            evl = modadd(k > 0 ? dp[i+1][j][k-1] : 0, dp[i+1][1][k]);
                        }
                    }

                    dp[i][j][k] = evl;
                }
            }
        }

        int ans = 0;
        for (int j = 0; j < k; j++) {
            for (int i : A[j]) {
                (ans += dp[0][0][i]) %= M;
            }
        }

        if (stepReduce2(s) <= k) {
            ans--;
        }
        
        return ans;
    }
};",1448300414
CoolManGame,CoolManGame,409,3646,cpp,"#include <bits/stdc++.h>
using namespace std;
#define fi first
#define se second
#define all(v) v.begin(),v.end()
#define fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define len(v) (ll((v).size()))
#define mp(a,b) (make_pair((a),(b)))
using ll = long long;
using pii = pair<int,int>;
using ld = long double;
#define x() real()
#define y() imag()

class Solution {
public:
    const int M = 1e9 + 7;
    int modmul(vector<ll> a) {
        ll ans = 1;
        for (ll i : a) {
            i %= M;
            (ans *= i) %= M;
        }
        return ans;
    }

    int sumOfGoodSubsequences(vector<int>& a) {
        int m = *max_element(a.begin(), a.end());
        int n = a.size();
        vector<ll> F(m+1), f(n); // f[i] = count how many end at i

        auto betw = [](int l, int x, int r) {
            return l <= x && x <= r;
        };

        for (int i = 0; i < n; i++) {
            f[i] = 1;
            (f[i] += betw(0, a[i]+1, m) ? F[a[i]+1] : 0) %= M;
            (f[i] += betw(0, a[i]-1, m) ? F[a[i]-1] : 0) %= M;
            (F[a[i]] += f[i]) %= M;
        }

        vector<ll> G(m+1), g(n); // g[i] = count how many start at i

        for (int i = n-1; i >= 0; i--) {
            g[i] = 1;
            (g[i] += betw(0, a[i]+1, m) ? G[a[i]+1] : 0) %= M;
            (g[i] += betw(0, a[i]-1, m) ? G[a[i]-1] : 0) %= M;
            (G[a[i]] += g[i]) %= M;
        }

        ll ans = 0;
        for (int i = 0; i < n; i++) {
            ll evl = modmul({a[i], f[i], g[i]});
            (ans += evl) %= M;
        }

        return ans;
    }
};",1448224852
Ratnakar Gautam,ratnakarg,411,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int>pre(n,0);
        pre[0]=1;
        for(int i=1;i<n;i++){
            if(nums[i]> nums[i-1]) pre[i] = pre[i-1]+1;
            else pre[i]=1;
        }
        
        vector<int>suf(n);
        suf[n-1]=1;
        for(int i=n-2;i>=0;i--){
            if(nums[i]<nums[i+1]) suf[i]=1+suf[i+1];
            else suf[i]= 1;
        }
        int ans = 0;
        for(int i=0;i<n-1;i++){
            ans = max(ans,min(pre[i],suf[i+1]));
        }
        return ans >= k;
    }
};",1448196693
Ratnakar Gautam,ratnakarg,411,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int>pre(n,0);
        pre[0]=1;
        for(int i=1;i<n;i++){
            if(nums[i]> nums[i-1]) pre[i] = pre[i-1]+1;
            else pre[i]=1;
        }
        
        vector<int>suf(n);
        suf[n-1]=1;
        for(int i=n-2;i>=0;i--){
            if(nums[i]<nums[i+1]) suf[i]=1+suf[i+1];
            else suf[i]= 1;
        }
        int ans = 0;
        for(int i=0;i<n-1;i++){
            ans = max(ans,min(pre[i],suf[i+1]));
        }
        return ans;
    }
};",1448194973
Ratnakar Gautam,ratnakarg,411,3631,cpp,"#define ll long long
#define mod ((int)1e9+7)
class Solution {
public:
    vector<vector<int>> dp2;
    bool is_valid(int cnt,int k){
        if(cnt==1)return true;
        if(k==0)return false;
        if(dp2[cnt][k]!=-1)return dp2[cnt][k];
        return dp2[cnt][k]=is_valid(__builtin_popcount(cnt),k-1);
    }

    vector<vector<vector<int>>> dp1;
    int rec(string &s,int i,int cnt,int k,int f){
        if(i==s.size()){
            if(cnt==1)return 1;
            return is_valid(cnt,k-1);
        }
        if(dp1[i][cnt][f]!=-1)return dp1[i][cnt][f];
        ll ans = 0;
        if(f){
            for(int j=0;j<=s[i]-'0';j++){
                if(j==s[i]-'0'){
                    ans+=rec(s,i+1,cnt+(j==1),k,1);
                    ans%=mod;
                }else{
                    ans+=rec(s,i+1,cnt+(j==1),k,0);
                    ans%=mod;
                }
            }
        }else{
            for(int j=0;j<2;j++){
                ans+=rec(s,i+1,cnt+(j==1),k,0);
                ans%=mod;
            }
        }
        return dp1[i][cnt][f]=ans;
    }

    bool check(string &s,int k){
        int cnt = 0;
        for(int i=0;i<s.size();i++)cnt+=(s[i]=='1');
        return is_valid(cnt,k-1);
    }

    int countKReducibleNumbers(string s, int k) {
        int n = s.size();
        dp1.resize(n+1,vector<vector<int>> (n+1,vector<int> (2,-1)));
        dp2.resize(n+1,vector<int> (k+1,-1));
        return rec(s,0,0,k,1) - check(s,k);
    }
};",1448300792
Ratnakar Gautam,ratnakarg,411,3646,cpp,"#define ll long long
#define mod ((int)1e9+7)
class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& arr){
        int n = arr.size();
        map<int,ll> mp;
        int mx = *max_element(arr.begin(),arr.end());
        vector<ll> dp1(n+1);
        for(int i=0;i<n;i++){
            dp1[i] = 1;
            if(mp.count(arr[i]-1)==1){
                dp1[i]+= mp[arr[i]-1];
                dp1[i]%=mod;
            }
            if(mp.count(arr[i]+1)==1){
                dp1[i]+= mp[arr[i]+1];
                dp1[i]%=mod;            
            }
            dp1[i]%=mod;
            mp[arr[i]]+=dp1[i];
            mp[arr[i]]%=mod;
        }

        mp.clear();

        vector<ll> dp2(n+1);

        for(int i=n-1;i>=0;i--){
            dp2[i] = 1;
            if(mp.count(arr[i]-1)==1){
                  dp2[i]+= mp[arr[i]-1];
                dp2[i]%=mod;
            }
              
            if(mp.count(arr[i]+1)==1){
                dp2[i]+= mp[arr[i]+1];
                dp2[i]%=mod;
            }
            dp2[i]%=mod;
            mp[arr[i]]+=dp2[i];
            mp[arr[i]]%=mod;
        }

        // for(auto x:dp1){
        //     cout<<x<<"" "";
        // }

        // cout<<endl;

        // for(auto x:dp2){
        //     cout<<x<<"" "";
        // }

        ll ans = 0;

        for(int i=0;i<n;i++){
            ll val = (dp1[i]*dp2[i])%mod;
            ans+=((arr[i]*val)%mod);
            ans%=mod;
        }
        
        return ans;
    }
};",1448233316
Mohit_is_back,Mohit_2k_kukreja,413,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        // 2 1
        for(int i=0; i+2*k<=n; i++){
            bool left = true, right = true;
            
            for(int j = i+1; j < i+k; j++){
                if(nums[j] <= nums[j-1]){
                    left = false;
                    break;
                }
            }
            
            for(int j = i + k + 1; j < i + 2*k; j++){
                if(nums[j] <= nums[j-1]){
                    right = false;
                    break;
                }
            }
            
            if(left && right) return true;
        }
        return false;
    }
};",1448188520
Mohit_is_back,Mohit_2k_kukreja,413,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        int curr = 1;
        vector<int> res = {1};
        for(int i=1; i<n; i++){
            if(nums[i] > nums[i-1]) res.back()++;
            else res.push_back(1);
            
        }
        int ans = 0;
        for(int i=0; i<res.size(); i++){
            ans = max(ans, res[i]/2);
            if(i > 0){
                ans = max(ans, min(res[i], res[i-1]));
            }
        }
        return ans;
    }
};",1448199879
Mohit_is_back,Mohit_2k_kukreja,413,3631,cpp,"class Solution {
    vector<int> cnt;
    int k;
    const int mod = 1e9 + 7;
    int dp[801][2][801];

public:
    int solve(const string& s, int i, bool tight, int setBits) {
        if (i == s.size()) return (tight || setBits == 0) ? 0 : cnt[setBits] < k;
        if(dp[i][tight][setBits] != -1) return dp[i][tight][setBits];
        
        if (tight) {
            if (s[i] == '0') return solve(s, i + 1, true, setBits);
            
            int res = solve(s, i + 1, true, setBits + 1);
            res = (res + solve(s, i + 1, false, setBits)) % mod;
            return dp[i][tight][setBits] = res;
        }
        
        int res = solve(s, i + 1, false, setBits + 1);
        res = (res + solve(s, i + 1, false, setBits)) % mod;
        return dp[i][tight][setBits] = res;
    }

    int countKReducibleNumbers(std::string s, int k) {
        this->k = k;
        this->cnt = std::vector<int>(801, 0);
        memset(dp, -1, sizeof(dp));
        for (int i = 2; i <= 800; i++) {
            int setBits = __builtin_popcount(i);
            cnt[i] = 1 + cnt[setBits];
            // cout << cnt[i] << "" "" ;
        }
        // cout << endl;
        
        return solve(s, 0, true, 0);        
    }
};
",1448294258
Mohit_is_back,Mohit_2k_kukreja,413,3646,cpp,"class Solution {
    const int mod = 1e9 + 7;
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        long long res = 0;
        int n = nums.size();
        map<int, long long> sum, count;
        
        for(int i = 0; i < n; i++) {
            res = (res + nums[i]) % mod;
            int toFind1 = nums[i] + 1;
            int toFind2 = nums[i] - 1;
            
            long long cnt1 = count[toFind1];
            long long sum1 = sum[toFind1];
            res = (res + (cnt1 * nums[i] % mod + sum1) % mod) % mod;
            
            long long cnt2 = count[toFind2];
            long long sum2 = sum[toFind2];
            res = (res + (cnt2 * nums[i] % mod + sum2) % mod) % mod;
            
            count[nums[i]] = (count[nums[i]] + cnt1 + cnt2 + 1) % mod;
            long long curr = ((nums[i]) * (cnt1 + cnt2 + 1)) % mod;
            sum[nums[i]] = (sum[nums[i]] + sum1 + sum2 + curr) % mod;
        }
        return res;
    }
};
",1448239923
h_bugw7,h_bugw7,414,3612,cpp,"class Solution2 {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        int U[200000];
        int D[200000];
        U[0] = 1;
        for(int i = 1; i < n; i++) {
            if(nums[i] > nums[i-1]) U[i] = U[i-1] + 1;
            else U[i] = 1;
        }
        D[n-1] = 1;
        for(int i = n-2; i >= 0; i--) {
            if(nums[i] < nums[i+1]) D[i] = D[i+1] + 1;
            else D[i] = 1;
        }
        int res = 0;
        for(int i = 1; i < n; i++) {
            res = max(res, min(U[i-1], D[i]));
        }
        return res;
    }
};

class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        return Solution2().maxIncreasingSubarrays(nums) >= k;
    }
};",1448188074
h_bugw7,h_bugw7,414,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        int U[200000];
        int D[200000];
        U[0] = 1;
        for(int i = 1; i < n; i++) {
            if(nums[i] > nums[i-1]) U[i] = U[i-1] + 1;
            else U[i] = 1;
        }
        D[n-1] = 1;
        for(int i = n-2; i >= 0; i--) {
            if(nums[i] < nums[i+1]) D[i] = D[i+1] + 1;
            else D[i] = 1;
        }
        int res = 0;
        for(int i = 1; i < n; i++) {
            res = max(res, min(U[i-1], D[i]));
        }
        return res;
    }
};",1448185700
h_bugw7,h_bugw7,414,3631,cpp,"const int MOD = 1e9+7;

// C(n, k) % MOD
class Combination { 
    vector<long long> fact;
    vector<long long> invFact;
    long long power(long long a, long long b, long long mod) {
        long long res = 1;
        while (b > 0) {
            if (b & 1) res = res * a % mod;
            a = a * a % mod;
            b >>= 1;
        }
        return res;
    }
public:
    Combination(int n): fact(n+1), invFact(n+1) {
        fact[0] = 1;
        for(int i = 1; i <= n; i++) {
            fact[i] = fact[i-1] * i % MOD;
        }
        invFact[n] = power(fact[n], MOD-2, MOD);
        for(int i = n-1; i >= 0; i--) {
            invFact[i] = invFact[i+1] * (i+1) % MOD;
        }
    }
    long long operator()(int n, int k) const {
        if (k < 0 || k > n) return 0;
        return fact[n] * invFact[k] % MOD * invFact[n-k] % MOD;
    }
};


class Solution {
    Combination C;
public:
    Solution(): C(801) { }
    int countKReducibleNumbers(string s, int k) {
        int dp[801];
        dp[0] = dp[1] = 0;
        for(int i = 2; i <= 800; i++) {
            dp[i] = dp[bitcnt(i)] + 1;
        }
        int res = 0;
        vector<int> ones;
        for(int i = 0; i < s.length(); i++) {
            if(s[i] == '1') ones.push_back(i);
        }
        // for(int o: ones) cout << o << ' ';
        // cout << endl;
        for(int i = 1; i <= 800; i++) {
            if(dp[i] < k) {
                int r = solve(ones, s.length(), i);
                res = (res + r) % MOD;
            }
        }
        return res;
    }
    int bitcnt(int x) {
        int res = 0;
        while(x) {
            if(x & 1) res++;
            x >>= 1;
        }
        return res;
    }
    int solve(const vector<int>& v, int len, int k) {
        int res = 0;
        for(int i = 0; i < v.size(); i++) {
            // cout << ""C("" << (len-v[i]-1) << "", "" << (k-i) << "")"" << endl;
            res = (res + C(len-v[i]-1, k-i)) % MOD;
        }
        // cout << ""solve "" << k << "" = "" << res << endl;
        return res;
    }
};",1448287875
h_bugw7,h_bugw7,414,3646,cpp,"const int MOD = 1e9+7;

int cnt[100001];
int sum[100001];

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        memset(cnt, 0, sizeof(cnt));
        memset(sum, 0, sizeof(sum));
        int n = nums.size();
        for(int i = 0; i < n; i++) {
            int& c = cnt[nums[i]];
            int& s = sum[nums[i]];
            c = (c + 1) % MOD;
            s = (s + nums[i]) % MOD;
            for(int x = nums[i]-1; x <= nums[i]+1; x += 2) {
                if(x < 0 || x > 100000) continue;
                c = (c + cnt[x]) % MOD;
                s = (s + sum[x]) % MOD;
                s = (s + (long long)cnt[x] * nums[i] % MOD) % MOD;
            }
            // s = (s + (long long)c * nums[i] % MOD) % MOD;
            // cout << i << "": "" << s << endl;
        }
        int res = 0;
        for(int i = 0; i <= 100000; i++) res = (res + sum[i]) % MOD;
        return res;
    }
};",1448243315
Lisa Shi,yinxiashi,416,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        for a in range(n - 2 * k + 1):
            flag = True
            for i in range(a + 1, a + k):
                if nums[i] <= nums[i - 1]:
                    flag = False
                    break
            if flag:
                for i in range(a + k + 1, a + k + k):
                    if nums[i] <= nums[i - 1]:
                        flag = False
                        break
            if flag:
                return True
        return False
                    ",1448273687
Lisa Shi,yinxiashi,416,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        size = []
        n = len(nums)
        count = 1
        pre = nums[0]
        for i in range(1, n):
            if nums[i] > pre:
                count += 1
            else:
                size.append(count)
                count = 1
            pre = nums[i]
        size.append(count)
        ans = 1
        for c in size:
            ans = max(ans, c // 2)
        for i in range(1, len(size)):
            ans = max(ans, min(size[i], size[i - 1]))
        return ans",1448277863
Lisa Shi,yinxiashi,416,3631,python3,"@cache
def getCount(num):
    ans = 0
    while num > 0:
        if num & 1:
            ans += 1
        num >>= 1
    return ans

@cache
def isReducible(num, k):
    if k == 0:
        return num == 1
    if num == 1:
        return True
    return isReducible(getCount(num), k - 1)

class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        n = len(s)
        MOD = 10**9 + 7
        @cache
        def dfs(index, flag, acc):
            if index == n:
                if flag and acc > 0 and isReducible(acc, k - 1):
                    return 1
                else:
                    return 0
            up = int(s[index])
            if flag:
                up = 1
            ans = 0
            for i in range(up + 1):
                newFlag = flag or i < up
                ans += dfs(index + 1, newFlag, acc + i)
            ans %= MOD
            return ans

        return dfs(0, False, 0)",1448307911
Lisa Shi,yinxiashi,416,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        d = {}
        ans = 0
        MOD = 10**9 + 7
        for num in nums:
            curCount = 1
            curSum = num
            diffs = [-1, 1]
            for diff in diffs:
                pre = num + diff
                if pre in d:
                    c, s = d[pre]
                    curCount += c
                    curSum += s + c * num
            curCount %= MOD
            curSum %= MOD
            ans += curSum
            ans = ans % MOD
            cc, cs = 0, 0
            if num in d:
                cc, cs = d[num]
            cc += curCount
            cs += curSum
            cc %= MOD
            cs %= MOD
            d[num] = (cc, cs)
        return ans",1448288979
jachetheboss,jachetheboss,417,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        
        if k == 1:
            return True
        
        # sliding window
        bound = len(nums) - 2 * k
        for L in range(bound + 1):
        
            ok = True
            for i in range(L + 1, L + k):
                if nums[i] <= nums[i - 1]:
                    ok = False
                    break

            if ok:
                for i in range(L + k + 1, L + 2 * k):
                    if nums[i] <= nums[i - 1]:
                        ok = False
                        break
            if ok:
                return True
                        
        return False
                    ",1448196120
jachetheboss,jachetheboss,417,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        
        # binary search + sliding window subroutine?
        # how about RLE, O(n)
        RLE = []
        prev = -10**9 - 1
        streak = 0
        for num in nums:
            if num > prev:
                streak += 1
            else:
                RLE.append(streak)
                streak = 1
            prev = num
            
        RLE.append(streak)
        
        # print(""RLE"", RLE)
        
        ans = 1
        if len(RLE) == 1: # entire array is strictly increasing
            return RLE[0] // 2
        
        for i in range(len(RLE) - 1):
            ans = max(ans, min(RLE[i], RLE[i + 1]))
        for i in range(len(RLE)):
            ans = max(ans, RLE[i] // 2)
        return ans
        ",1448206106
jachetheboss,jachetheboss,417,3631,python3,"class Solution:
    def getSetBits(num):
            b = bin(num)[2 : ]
            set_bits = 0
            for c in b:
                if c == ""1"":
                    set_bits += 1
            return set_bits
        
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        
        # graph, cycle detection, shortest path from each number to 1?
        # then DP on each binary string rep length to get number of strings having that length that are k-reducible,
        # the tough part will be finding # of k-reducible numbers with binary string rep same length as s
        # akin to a Project Euler problem \U0001f5ff
        
        # O(n^3) won't cut it, have to find O(n^2) DP
        
        MOD = 10**9 + 7
        
        reduce_map = dict()
        reduce_map.update( {1 : 0} ) # 1 is k-reducible, guaranteed
        for ori_num in range(2, len(s) + 1):
            iters = 1
            num = ori_num # original number
            while num != 1 and iters < k:
                num = Solution.getSetBits(num)
                if num == 1:
                    reduce_map.update( {ori_num : iters} )
                    break
                iters += 1
        
        # print(""k_reducible:"", k_reducible)
        # print(""reduce_map"", reduce_map)
        
        DP = [[0 for _ in range(len(s) + 1)] for _ in range(len(s))]
        # DP[i][j] is # of unique k-reducible numbers having binary string repr of length (i + 1) and j set_bits
        # we want positive integers LESS than n, >= 1. [1, n)
        DP[0][1] = 1
        for i in range(1, len(DP)):
            for j in range(1, len(s) + 1):
                # appending a ""0""
                DP[i][j] += DP[i - 1][j]
                # appending a ""1""
                DP[i][j] += DP[i - 1][j - 1]
        
        ans = 0
        for i in range(len(DP) - 1): # account for all nums having binary repr length < len(s)
            for j in range(len(DP[i])):
                if j in reduce_map:
                    ans += DP[i][j]
                    ans %= MOD
                    
        # account for all nums having binary repr length == len(s)
        # s[0] == ""1""
        rolling_set_bits = 0
        for i in range(1, len(s)):
            if s[i] == ""1"":
                # try all binary strings having prefix s[0 : i], s[i] = ""0"", then all possible suffixes
                arr = DP[len(s) - i - 1]
                shifted = [0 for _ in range(len(arr))]
                for j in range(len(arr)):
                    if j + rolling_set_bits >= len(shifted):
                        break
                    shifted[j + rolling_set_bits] = arr[j]
                
                for j in range(len(shifted)):
                    if j in reduce_map:
                        ans += shifted[j]
                        ans %= MOD
                
                rolling_set_bits += 1
            else: # s[i] == ""0""
                # must append ""0"" to our constructed strings
                continue
        
        return ans
            
            ",1448280560
jachetheboss,jachetheboss,417,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        
        # DP?
        ans = 0
        MOD = 10**9 + 7
        di = dict() # unique number mapped to [total_sum, count of subseqs]
        for num in nums:
            to_update = []
            cands = [num - 1, num + 1]
            for cand in cands:
                if cand in di:
                    total = di[cand][0]
                    subseqs = di[cand][1]
                    new_total = total + subseqs * num
                    new_total %= MOD
                    to_update.append([new_total, subseqs])
                    
                    ans += new_total
                    ans %= MOD
                
            if num not in di:
                di.update( {num : [0, 0]} )
                
            for update_pair in to_update:
                di[num][0] += update_pair[0]
                di[num][1] += update_pair[1]
                
            di[num][0] += num # consider just the singleton subseq consitsing of num itself, [num]
            di[num][1] += 1
            
            ans += num
            
        return ans
                
        ",1448307966
Xuanxuan Wang,wxxlouisa,418,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        auto n = nums.size();
        
        auto isIncreasing = [&](int start) -> bool {
            for (int i = start; i < start + k - 1; ++i) {
                if (nums[i] >= nums[i+1]) {
                    return false;
                }
            }
            return true;
        };
        
        for (int i = 0; i <= n - 2 * k; ++i) {
            if (isIncreasing(i) && isIncreasing(i + k)) {
                return true;
            }
        }
        return false;
    }
};",1448182964
Xuanxuan Wang,wxxlouisa,418,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        
        auto canFind = [&](int k) {
            int count = 0;
            vector<int> start = {1};
            
            for (int i = 1; i < n; ++i) {
                if (nums[i] > nums[i - 1]) {
                    start.emplace_back( start[i - 1] + 1);
                } else {
                    start.emplace_back(1);
                }
            }
            for (int i = 0; i <= n - 2 * k; ++i) {
                int x1 = i, y1 = i + k - 1;
                int x2 = i + k, y2 = i + 2 * k - 1;
                if (start[y1] - start[x1] == k - 1 && start[y2] - start[x2] == k-1) {
                    return true;
                }
            }
            return false;
        };
        
        int left = 1, right = n / 2;
        int answer = 0;
        
        while (left <= right) {
            int mid = (left + right) / 2;
            
            if (canFind(mid)) {
                answer = mid;  
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return answer;
    }
};",1448219058
Xuanxuan Wang,wxxlouisa,418,3631,cpp,"class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        const int MOD = 1e9 + 7;
        int n = s.size();
        vector<int> steps(900, -1);

        function<int(int)> calc_steps = [&](int cnt) {
            if (steps[cnt] != -1) return steps[cnt];
            if (cnt <= 1) return steps[cnt] = 0;
            int next_cnt = __builtin_popcount(cnt);
            return steps[cnt] = calc_steps(next_cnt) + 1;
        };

        for (int i = 1; i <= 801; ++i) {
            calc_steps(i);
        }

        vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(n + 10, vector<int>(2, 0)));
        dp[0][0][1] = 1;  // pos, cnt, tight
        
        for (int pos = 0; pos < n; ++pos) {
            for (int cnt = 0; cnt <= n; ++cnt) {
                for (int tight = 0; tight <= 1; ++tight) {
                    int limit = tight ? s[pos] - '0' : 1;
                    for (int digit = 0; digit <= limit; ++digit) {
                        int new_cnt = cnt + digit;
                        int new_tight = tight && (digit == limit);
                        dp[pos+1][new_cnt][new_tight] = (dp[pos+1][new_cnt][new_tight] + dp[pos][cnt][tight]) % MOD;
                    }
                }
            }
        }

        int ans = 0;
        for (int cnt = 1; cnt <= n; ++cnt) {
            if (steps[cnt] < k) {
                //cout << cnt << "" "" << steps[cnt] << endl;
                ans = (ans + dp[n][cnt][0]) % MOD;
            }
        }
        return ans;
    }
};",1448308257
Xuanxuan Wang,wxxlouisa,418,3646,cpp,"#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        const int MOD = 1e9 + 7;
        int n = nums.size();
        
        unordered_map<int, long long> cnt;
        unordered_map<int, long long> cc;
        vector<long long> dp(n, 0);
        vector<long long> c(n, 0);
        long long ans = 0;
        
        for (int i = 0; i < n; ++i) {
            c[i] = 1;
            c[i] = (c[i] + cc[nums[i]-1] + cc[nums[i]+1]) % MOD;
            
            dp[i] = c[i] * nums[i] % MOD;
            dp[i] = (dp[i] + cnt[nums[i] - 1]) % MOD;
            dp[i] = (dp[i] + cnt[nums[i] + 1]) % MOD;
            
            cnt[nums[i]] = (cnt[nums[i]] + dp[i]) % MOD;
            cc[nums[i]] = (cc[nums[i]] + c[i]) % MOD;
            ans = (ans + dp[i]) % MOD;
        }
        return ans;
    }
};",1448245962
lcz12345,lcz12345,419,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int p = 0;
        int t = 1;
        int n = nums.size();
        for (int i = 1; i <= n; i++) {
            if (i < n && nums[i] > nums[i - 1]) {
                t++;
            }
            else {
                if (t >= (k << 1) || !(p < k || t < k)) {
                    return true;
                }
                
                p = t;
                t = 1;
            }
        }
        
        return false;
    }
};",1448202910
lcz12345,lcz12345,419,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int p = 0;
        int t = 1;
        int n = nums.size();
        int res = 0;
        for (int i = 1; i <= n; i++) {
            if (i < n && nums[i] > nums[i - 1]) {
                t++;
            }
            else {
                res = max(
                    max((t >> 1), min(p, t)),
                    res
                );
                p = t;
                t = 1;
            }
        }
        
        return res;
    }
};",1448206885
lcz12345,lcz12345,419,3631,cpp,"class Solution {
public:
    long nCr(int n, int r, vector<vector<int>>& c) {
        if (r == 0 || n == r) {
            return 1;
        }
        
        if (c[n][r] > -1) {
            return c[n][r];
        }
        
        long t = (nCr(n - 1, r - 1, c) + nCr(n - 1, r, c)) % M;
        
        c[n][r] = t;
        
        return t;
    }
    
    int countKReducibleNumbers(string s, int k) {
        int n = s.size();
        vector<vector<int>> c(n + 1, vector<int>(n + 1, -1));
        
        vector<int> t(n + 1);
        t[0] = k + 1;
        t[1] = 0;
        
        auto f = [](int v) {
            int w = 0;
            while (v > 0) {
                w += (v & 1);
                v >>= 1;
            }
            
            return w;
        };
        
        for (int i = 2; i <= n; i++) {
            t[i] = t[f(i)] + 1;
        }
        
        int o = 0;
        for (int i = 0; i < n; i++) {
            o += s[i] - '0';
        }
        
        long res = 0;
        int z = 0;
        for (int i = n - 1; i > -1; i--) {
            if (s[i] == '1') {
                o--;
                for (int j = 0; j <= z; j++) {
                    if (t[o + j] < k) {
                        res = (res + nCr(z, j, c)) % M;
                    }
                }
            }
            
            z++;
        }
        
        return res;
    }
private:
    const int M = 1E9 + 7;
};",1448301803
lcz12345,lcz12345,419,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        unordered_map<int, long> m;
        unordered_map<int, long> s;
        int res = 0;
        for (int n: nums) {
            long t = 1;
            t = (t + m[n - 1]) % M;
            t = (t + m[n + 1]) % M;
            
            m[n] = (m[n] + t) % M;
            
            long w = (t * n) % M;
            w = (w + s[n - 1]) % M;
            w = (w + s[n + 1]) % M;
            
            s[n] = (s[n] + w) % M;
            
            res = (w + res) % M;
        }
        
        return res;
    }
    
private:
    const int M = 1E9 + 7;
};",1448226480
Sambhav Jain,Sambhav-Jain,420,3612,cpp,"class Solution {
    bool isIncreasing(const vector<int> &nums, int l, int r)
    {
        for (int i = l + 1; i <= r; i++)
        {
            if (nums[i] <= nums[i - 1])
            {
                return false;
            }
        }
        return true;
    }
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) 
    {
        for (int i = 0; i + 2 * k - 1 < nums.size(); i++)
        {
            if (isIncreasing(nums, i, i + k - 1) && isIncreasing(nums, i + k, i + 2 * k - 1))
            {
                return true;
            }
        }
        return false;
    }
};",1448185146
Sambhav Jain,Sambhav-Jain,420,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) 
    {
        vector<int> max_len(nums.size(), 1);
        for (int i = 0; i < nums.size();)
        {
            int j = i + 1;
            while (j < nums.size() && nums[j] > nums[j - 1])
            {
                j++;
            }
            for (int k = i; k < j; k++)
            {
                max_len[k] = j - k;
            }
            i = j;
        }
        int ans = 1;
        for (int start = 0, end = nums.size(), mid; start <= end;)
        {
            mid = (start + end) / 2;
            bool flag = false;
            for (int i = 0; i + 2 * mid - 1 < nums.size(); i++)
            {
                if (max_len[i] >= mid && max_len[i + mid] >= mid)
                {
                    flag = true;
                    break;
                }
            }
            if (flag)
            {
                ans = mid; start = mid + 1;
            }
            else
            {
                end = mid - 1;
            }
        }
        return ans;
    }
};",1448193402
SR3mix,SR3mix,2,3612,cpp,"class Solution {
public:
    vector<int>dp;
    int n;
    bool check(int m) {
        for (int i = 0; i < n - m; i++) {
            if (dp[i] >= m && dp[i+m] >= m) return true;
        }
        return false;
    }
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        n = nums.size();
        dp = vector<int>(n);
        dp[n-1] = 1;
        for (int i = n-2; i >= 0; i--) {
            if (nums[i] < nums[i+1]) dp[i] = dp[i+1] + 1;
            else dp[i] = 1;
        }
        return check(k);
    }
};",1448188802
SR3mix,SR3mix,2,3619,cpp,"class Solution {
public:
    vector<int>dp;
    int n;
    bool check(int m) {
        for (int i = 0; i < n - m; i++) {
            if (dp[i] >= m && dp[i+m] >= m) return true;
        }
        return false;
    }
    int maxIncreasingSubarrays(vector<int>& nums) {
        n = nums.size();
        dp = vector<int>(n);
        dp[n-1] = 1;
        for (int i = n-2; i >= 0; i--) {
            if (nums[i] < nums[i+1]) dp[i] = dp[i+1] + 1;
            else dp[i] = 1;
        }
        int l = 1, r = n;
        while (l < r) {
            int m = l + (r - l)/2 + (r-l)%2;
            if (check(m)) l =m;
            else r = m-1;
        }
        return l;
    }
};",1448188115
SR3mix,SR3mix,2,3631,cpp,"typedef long long ll;
ll M = 1e9 + 7;
vector<ll>key;
class Solution {
public:
    int reduce(int x) {
        int cnt = 0;
        while (x > 1) {
            x = __builtin_popcount(x);
            cnt++;
        }
        return cnt;
    }
    string r;
    int k;
    ll dp[805][2][805];
    ll compute(int done, bool t2, int cnt) {
        if (done == r.size()) {
            if (cnt == 0) return 0;
            int ops = key[cnt] + 1;
            if (ops <= k) return 1;
            return 0;
        }
        if (dp[done][t2][cnt] != -1) return dp[done][t2][cnt];
        int s = 0;
        int e = 1; if (t2) e = r[done] - '0';
        ll res = 0;
        for (int i = s; i <= e; i++) {
            bool nt2 = (t2 && (r[done] - '0') == i);
            res = (res + compute(done + 1, nt2, cnt + i))%M;
        }
        
        dp[done][t2][cnt] = res;
        return res;
    }
    int countKReducibleNumbers(string s, int kk) {
        r = s; k = kk;
        if (key.size() == 0) {
            key = vector<ll>(805);
            for (int i = 1; i <= 804; i++) key[i] = reduce(i);
        }
        //return 0;
        memset(dp, -1, sizeof(dp));
        ll ans = compute(0, true, 0);
        int cnt = 0; for (auto i : s) cnt += i - '0';
        if (key[cnt]+ 1 <= k) ans--;
        return ans;
    }
};",1448203811
SR3mix,SR3mix,2,3646,cpp,"typedef long long ll;
ll M = 1e9 + 7;
// Z Mod Long Long
const long long PrimeMod = M;
struct MLL
{
    long long x;
    MLL(long long init_val = 0)
    {
        assert(init_val >= 0);
        x = init_val % PrimeMod;
    }
    long long val() {
        return x;
    }
    MLL power(long long exponent) {
        MLL res = 1, a = x; 
        long long b = exponent;
        for (; b; b /= 2, a *= a) {
            if (b % 2) {
                res *= a;
            }
        }
        return res;
    }
    MLL inv() {
        return power(PrimeMod - 2);
    }
    long long norm(long long v) {
        if (v < 0) v += PrimeMod;
        else if (v >= PrimeMod) v -= PrimeMod;
        assert(v >= 0 && v < PrimeMod);
        return v;
    } 
    MLL &operator+=(MLL rhs) &{
        x = norm(x + rhs.x);
        return *this;
    }
    MLL &operator-=(MLL rhs) &{
        x = norm(x - rhs.x);
        return *this;
    }
    MLL &operator*=(MLL rhs) &{
        x = (x * rhs.x)%PrimeMod;
        return *this;
    }
    MLL &operator/=(MLL rhs) &{
        x = (x * rhs.inv().x)%PrimeMod;
        return *this;
    }
    friend MLL operator+(MLL lhs, MLL rhs)
    {
        MLL res = lhs; res += rhs;
        return res;
    }
    friend MLL operator-(MLL lhs, MLL rhs)
    {
        MLL res = lhs; res -= rhs;
        return res;
    }
    friend MLL operator*(MLL lhs, MLL rhs)
    {
        MLL res = lhs; res *= rhs;
        return res;
    }
    friend MLL operator/(MLL lhs, MLL rhs) {
        MLL res = lhs; res /= rhs;
        return res;
    }
    friend bool operator==(MLL lhs, MLL rhs) {
        return lhs.x == rhs.x;
    }
    friend bool operator!=(MLL lhs, MLL rhs) {
        return lhs.x != rhs.x;
    }
    friend std::istream &operator>>(std::istream &is, MLL &a) {
        long long v; is >> v;
        a = MLL(v);
        return is;
    }
    friend std::ostream &operator<<(std::ostream &os, MLL &a) {
        return os << a.val();
    }
};
using Z = MLL;
Z Zpowxy(long long a, long long b) {
    Z x = a;
    return x.power(b);
}
long long int powxy(long long int x, long long int y, long long M) {
    if (y == 0) return 1;
    if (y%2 == 1) return (x*powxy(x, y-1, M))%M;
    long long int t = powxy(x, y/2, M);
    return (t*t)%M;
}
// CREDIT TO JIANGLY FOR THIS TEMPLATE -> https://codeforces.com/profile/jiangly
class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int ma = *max_element(nums.begin(), nums.end());
        vector<Z>dp(ma + 3);
        vector<Z>cnt(ma + 3);
        for (auto x : nums) {
            Z cx = x;
            dp[x + 1] += cx;
            cnt[x + 1] += (Z)1;
            dp[x + 1] += dp[x] + cnt[x] * cx;
            cnt[x + 1] += cnt[x];
            dp[x + 1] += dp[x + 2] + cnt[x + 2] * cx;
            cnt[x + 1] += cnt[x + 2];
        }
        Z ans = 0;
        for (Z t : dp) ans += t;
        return ans.x;
    }
};",1448183572
Ethan,ethanrao,5,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        for (int i = 0; i <= nums.size() - 2 * k; ++i) {
            bool flag1 = true;
            bool flag2 = true;

            for (int j = i; j < i + k - 1; ++j) {
                if (nums[j] >= nums[j + 1]) {
                    flag1 = false;
                    break;
                }
            }

            for (int j = i + k; j < i + 2 * k - 1; ++j) {
                if (nums[j] >= nums[j + 1]) {
                    flag2 = false;
                    break;
                }
            }


            if(flag1 && flag2) return true;
        }

        return false;
    }
};",1448196885
Ethan,ethanrao,5,3619,cpp,"class Solution {
public:
    bool check(vector<int>& nums,vector<int>& lc, int k) {
        int n = nums.size();
        for (int i = 0; i <= n - 2 * k; ++i) {
            if (lc[i] >= k && lc[i + k] >= k) {
                return true;
            }
        }
        return false;
    }
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> lc(n);
        for(int i=0;i<n;i++){
            lc[i] = 0;
        }
        lc[n - 1] = 1;

        for (int i = n - 2; i >= 0; --i) {
            if (nums[i + 1] > nums[i]) {
                lc[i] = lc[i + 1] + 1;
            } else {
                lc[i] = 1;
            }
        }

        int low = 1, high = n / 2, ans = 0;

        while (low <= high) {
            int mid = (low + high) / 2;
            if (check(nums, lc, mid)) {
                ans = mid;
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }

        return ans;
    }


};
",1448204730
Ethan,ethanrao,5,3631,cpp,"class Solution {
public:
    int n, f[805], dp[805][805][2];
    const int mod = 1e9 + 7;
    inline int add(int x, int y){
        return x + y >= mod ? x + y - mod : x + y;
    }
    inline int popcnt(int x){
        int r = 0;
        while(x){
            if(x & 1) r += 1;
            x >>= 1;
        }
        return r;
    }
    int countKReducibleNumbers(string s, int u) {
        n = s.size();
        f[1] = 0;
        for(int i = 2; i <= 800; ++i) f[i] = f[popcnt(i)] + 1;
        dp[0][1][0] = 1;
        dp[0][0][1] = 1;
        for(int i = 1; i < n; ++i){
            int z = s[i] - '0';
            for(int j = 0; j <= i; ++j){
                for(int k = 0; k <= 1; ++k){
                    for(int t = 0; t <= 1; ++t){
                        if(k == 0 && t > z) continue;
                        int nk = k;
                        if(t < z) nk = 1;
                        dp[i][j + t][nk] = add(dp[i][j + t][nk], dp[i - 1][j][k]);
                    }
                }
            }
        }
        int ans = 0;
        for(int i = 1; i <= n; ++i) if(f[i] <= u - 1) ans = add(ans, dp[n - 1][i][1]);
        return ans;
    }
};",1448196025
Ethan,ethanrao,5,3646,cpp,"class Solution {
public:
    int f[100005], g[100005], n, a[100005], h[100005];
    const int mod = 1e9 + 7;
    inline int add(int x, int y){
        return x + y >= mod ? x + y - mod : x + y;
    }
    inline int mul(int x, int y){
        return 1ll * x * y % mod;
    }
    int sumOfGoodSubsequences(vector<int>& nums) {
        n = nums.size();
        for(int i = 1; i <= n; ++i) a[i] = nums[i - 1];
        memset(f, 0, sizeof f);
        for(int i = 1; i <= n; ++i){
            g[i] = add(1, f[a[i] + 1]);
            if(a[i] >= 1) g[i] = add(g[i], f[a[i] - 1]);
            f[a[i]] = add(f[a[i]], g[i]);
        }
        memset(f, 0, sizeof f);
        for(int i = n; i >= 1; --i){
            h[i] = add(1, f[a[i] + 1]);
            if(a[i] >= 1) h[i] = add(h[i], f[a[i] - 1]);
            f[a[i]] = add(f[a[i]], h[i]);
        }
        int ans = 0;
        for(int i = 1; i <= n; ++i){
            
            ans = add(ans, mul(a[i], mul(g[i], h[i])));
        }
        return ans;
    }
};",1448204935
Dylan Smith,DylanSmith,6,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        vector<int> right(nums.size());
        for (int i = (int)nums.size() - 1; i >= 0; i--) {
            right[i] = 1;
            if (i + 1 < (int)nums.size() && nums[i + 1] > nums[i]) right[i] = right[i + 1] + 1;
        }
        int cur = 0;
        int res = 0;
        for (int i = 0; i + 1 < (int)nums.size(); i++) {
            if (i > 0 && nums[i] > nums[i - 1]) cur++;
            else cur = 1;
            if (cur >= k && right[i + 1] >= k) return 1;
        }
        return 0;
    }
};",1448183801
Dylan Smith,DylanSmith,6,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        vector<int> right(nums.size());
        for (int i = (int)nums.size() - 1; i >= 0; i--) {
            right[i] = 1;
            if (i + 1 < (int)nums.size() && nums[i + 1] > nums[i]) right[i] = right[i + 1] + 1;
        }
        int cur = 0;
        int res = 0;
        for (int i = 0; i + 1 < (int)nums.size(); i++) {
            if (i > 0 && nums[i] > nums[i - 1]) cur++;
            else cur = 1;
            res = max(res, min(cur, right[i + 1]));
        }
        return res;
    }
};",1448183121
Dylan Smith,DylanSmith,6,3631,cpp,"typedef long long ll;

#define pb push_back
#define sz(x) (int)x.size()
#define all(x) begin(x),end(x)
#define lb(x,y) lower_bound(all(x),y)-begin(x)
class Solution {
public:
    int mod = 1000000007;
    int countKReducibleNumbers(string s, int k) {
        vector<int> dp(sz(s) + 1, 0);
        dp[0] = 1;
        vector<int> freq(sz(s) + 1, 0);
        for (int i = sz(s) - 1; i >= 0; i--) {
            if (s[i] == '1') {
                int cnt = 0;
                for (int j = 0; j < i; j++) {
                    cnt += s[j] == '1';
                }
                for (int j = 0; j + cnt <= sz(s); j++) {
                    freq[cnt + j] += dp[j];
                    if (freq[cnt + j] >= mod) freq[cnt + j] -= mod;
                }
            }
            for (int j = sz(s); j > 0; j--) {
                dp[j] += dp[j - 1];
                if (dp[j] >= mod) dp[j] -= mod;
            }
        }
        int res = 0;
        for (int i = 1; i <= sz(s); i++) {
            int cur = i;
            for (int j = 0; j < k - 1; j++) {
                int nxt = 0;
                while (cur) {
                    nxt += cur & 1;
                    cur >>= 1;
                }
                cur = nxt;
            }
            if (cur == 1) {
                res += freq[i];
                if (res >= mod) res -= mod;
            }
        }
        return res;
    }
};",1448206247
Dylan Smith,DylanSmith,6,3646,cpp,"class Solution {
public:
    int mod = 1000000007;
    int sumOfGoodSubsequences(vector<int>& nums) {
        map<int, int> cnt, sum;
        for (int i : nums) {
            cnt[i] += (cnt[i - 1] + cnt[i + 1] + 1) % mod;
            cnt[i] %= mod;
            sum[i] += (sum[i - 1] + sum[i + 1]) % mod;
            sum[i] %= mod;
            sum[i] += (long long)(cnt[i - 1] + cnt[i + 1] + 1) % mod * i % mod;
            sum[i] %= mod;
        }
        int res = 0;
        for (auto &p : sum) {
            res += p.second;
            res %= mod;
        }
        return res;
    }
};",1448189947
Nutty Professor,varkatkl,11,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        N = len(nums)
        incr = [1] * N
        for i in range(N - 2, -1, -1):
            if nums[i] < nums[i + 1]:
                incr[i] = 1 + incr[i + 1]

        for i in range(N - 2 * k + 1):
            if incr[i] >= k and incr[i + k] >= k:
                return True
        return False
",1448181997
Nutty Professor,varkatkl,11,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        N = len(nums)
        r_incr = [1] * N
        l_incr = [1] * N
        for i in range(1, N):
            if nums[i] > nums[i - 1]:
                l_incr[i] = l_incr[i - 1] + 1

        for i in range(N - 2, -1, -1):
            if nums[i] < nums[i + 1]:
                r_incr[i] = 1 + r_incr[i + 1]

        ret = 1
        for i in range(N - 1):
            ret = max(ret, min(l_incr[i], r_incr[i + 1]))

        return ret
",1448185336
Nutty Professor,varkatkl,11,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        MOD = (10 ** 9) + 7
        N = len(s)

        def reduce(x):
            ret = 0
            while x > 0:
                ret += x % 2
                x //= 2
            return ret

        min_ops = [0] * 801
        min_ops[0] = 10
        for i in range(1, 801):
            c, x = 0, i
            while x > 1:
                x = reduce(x)
                c += 1
            min_ops[i] = c

        @functools.lru_cache(maxsize=None)
        def f(i, lesser, bits):
            if i == N:
                return 1 if (lesser and min_ops[bits] < k) else 0
            ret = f(i + 1, lesser or s[i] == '1', bits)
            if lesser or s[i] == '1':
                ret += f(i + 1, lesser, bits + 1)
            ret %= MOD
            return ret

        return f(0, False, 0)
",1448213368
Nutty Professor,varkatkl,11,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        N = len(nums)
        MOD = (10 ** 9) + 7
        MAX = 100010
        total = [0] * MAX
        count = [0] * MAX

        for i in range(N - 1, -1, -1):
            a = nums[i]
            count[a] += 1
            count[a] += count[a + 1]
            if a - 1 >= 0:
                count[a] += count[a - 1]
            count[a] %= MOD

            total[a] += a
            total[a] += total[a + 1] + count[a + 1] * a
            if a - 1 >= 0:
                total[a] += total[a - 1] + count[a - 1] * a
            total[a] %= MOD

        return sum(total) % MOD
",1448195442
LayCurse,LayCurse,12,3612,cpp,"#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")
#include<bits/stdc++.h>
using namespace std;
template<class T> struct cLtraits_identity{
  using type = T;
}
;
template<class T> using cLtraits_try_make_signed =
  typename conditional<
    is_integral<T>::value,
    make_signed<T>,
    cLtraits_identity<T>
    >::type;
template <class S, class T> struct cLtraits_common_type{
  using tS = typename cLtraits_try_make_signed<S>::type;
  using tT = typename cLtraits_try_make_signed<T>::type;
  using type = typename common_type<tS,tT>::type;
}
;
template<class S, class T> inline auto min_L(S a, T b)
-> typename cLtraits_common_type<S,T>::type{
  return (typename cLtraits_common_type<S,T>::type) a <= (typename cLtraits_common_type<S,T>::type) b ? a : b;
}
template<class S, class T> inline S chmax(S &a, T b){
  if(a<b){
    a=b;
  }
  return a;
}
#define main dummy_main
int main(){
  return 0;
}
#undef main
class Solution{
  public:
  bool hasIncreasingSubarrays(vector<int>& A, int k){
    int i;
    int N = A.size();
    int res = 0;
    static int dp1[1000000];
    static int dp2[1000000];
    dp1[0] = 1;
    for(i=(1);i<(N);i++){
      if(A[i] > A[i-1]){
        dp1[i] =dp1[i-1]+1;
      }
      else{
        dp1[i] =1;
      }
    }
    dp2[N-1] = 1;
    for(i=(N-1)-1;i>=(0);i--){
      if(A[i] < A[i+1]){
        dp2[i] =dp2[i+1]+1;
      }
      else{
        dp2[i] =1;
      }
    }
    for(i=(1);i<(N);i++){
      chmax(res, min_L(dp1[i-1], dp2[i]));
    }
    return res >= k;
  }
}
;
// cLay version 20241019-1

// --- original code ---
// #define main dummy_main
// {}
// #undef main
// 
// class Solution {
// public:
//   bool hasIncreasingSubarrays(vector<int>& A, int k) {
//     int N = A.size();
//     int res = 0;
//     static int dp1[1d6], dp2[1d6];
// 
//     dp1[0] = 1;
//     rep(i,1,N) dp1[i] = if[A[i] > A[i-1], dp1[i-1]+1, 1];
// 
//     dp2[N-1] = 1;
//     rrep(i,N-1) dp2[i] = if[A[i] < A[i+1], dp2[i+1]+1, 1];
// 
//     rep(i,1,N) res >?= min(dp1[i-1], dp2[i]);
// 
//     return res >= k;
//   }
// };
",1448194012
LayCurse,LayCurse,12,3619,cpp,"#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")
#include<bits/stdc++.h>
using namespace std;
template<class T> struct cLtraits_identity{
  using type = T;
}
;
template<class T> using cLtraits_try_make_signed =
  typename conditional<
    is_integral<T>::value,
    make_signed<T>,
    cLtraits_identity<T>
    >::type;
template <class S, class T> struct cLtraits_common_type{
  using tS = typename cLtraits_try_make_signed<S>::type;
  using tT = typename cLtraits_try_make_signed<T>::type;
  using type = typename common_type<tS,tT>::type;
}
;
template<class S, class T> inline auto min_L(S a, T b)
-> typename cLtraits_common_type<S,T>::type{
  return (typename cLtraits_common_type<S,T>::type) a <= (typename cLtraits_common_type<S,T>::type) b ? a : b;
}
template<class S, class T> inline S chmax(S &a, T b){
  if(a<b){
    a=b;
  }
  return a;
}
#define main dummy_main
int main(){
  return 0;
}
#undef main
class Solution{
  public:
  int maxIncreasingSubarrays(vector<int>& A){
    int i;
    int N = A.size();
    int res = 0;
    static int dp1[1000000];
    static int dp2[1000000];
    dp1[0] = 1;
    for(i=(1);i<(N);i++){
      if(A[i] > A[i-1]){
        dp1[i] =dp1[i-1]+1;
      }
      else{
        dp1[i] =1;
      }
    }
    dp2[N-1] = 1;
    for(i=(N-1)-1;i>=(0);i--){
      if(A[i] < A[i+1]){
        dp2[i] =dp2[i+1]+1;
      }
      else{
        dp2[i] =1;
      }
    }
    for(i=(1);i<(N);i++){
      chmax(res, min_L(dp1[i-1], dp2[i]));
    }
    return res;
  }
}
;
// cLay version 20241019-1

// --- original code ---
// #define main dummy_main
// {}
// #undef main
// 
// class Solution {
// public:
//   int maxIncreasingSubarrays(vector<int>& A) {
//     int N = A.size();
//     int res = 0;
//     static int dp1[1d6], dp2[1d6];
// 
//     dp1[0] = 1;
//     rep(i,1,N) dp1[i] = if[A[i] > A[i-1], dp1[i-1]+1, 1];
// 
//     dp2[N-1] = 1;
//     rrep(i,N-1) dp2[i] = if[A[i] < A[i+1], dp2[i+1]+1, 1];
// 
//     rep(i,1,N) res >?= min(dp1[i-1], dp2[i]);
// 
//     return res;
//   }
// };
",1448192601
LayCurse,LayCurse,12,3631,cpp,"#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")
#include<bits/stdc++.h>
using namespace std;
#define MD (1000000007U)
struct Modint{
  unsigned val;
  Modint(){
    val=0;
  }
  Modint(int a){
    val = ord(a);
  }
  Modint(unsigned a){
    val = ord(a);
  }
  Modint(long long a){
    val = ord(a);
  }
  Modint(unsigned long long a){
    val = ord(a);
  }
  inline unsigned ord(unsigned a){
    return a%MD;
  }
  inline unsigned ord(int a){
    a %= (int)MD;
    if(a < 0){
      a += MD;
    }
    return a;
  }
  inline unsigned ord(unsigned long long a){
    return a%MD;
  }
  inline unsigned ord(long long a){
    a %= (int)MD;
    if(a < 0){
      a += MD;
    }
    return a;
  }
  inline unsigned get(){
    return val;
  }
  inline Modint &operator++(){
    val++;
    if(val >= MD){
      val -= MD;
    }
    return *this;
  }
  inline Modint &operator--(){
    if(val == 0){
      val = MD - 1;
    }
    else{
      --val;
    }
    return *this;
  }
  inline Modint operator++(int a){
    Modint res(*this);
    val++;
    if(val >= MD){
      val -= MD;
    }
    return res;
  }
  inline Modint operator--(int a){
    Modint res(*this);
    if(val == 0){
      val = MD - 1;
    }
    else{
      --val;
    }
    return res;
  }
  inline Modint &operator+=(Modint a){
    val += a.val;
    if(val >= MD){
      val -= MD;
    }
    return *this;
  }
  inline Modint &operator-=(Modint a){
    if(val < a.val){
      val = val + MD - a.val;
    }
    else{
      val -= a.val;
    }
    return *this;
  }
  inline Modint &operator*=(Modint a){
    val = ((unsigned long long)val*a.val)%MD;
    return *this;
  }
  inline Modint &operator/=(Modint a){
    return *this *= a.inverse();
  }
  inline Modint operator+(Modint a){
    return Modint(*this)+=a;
  }
  inline Modint operator-(Modint a){
    return Modint(*this)-=a;
  }
  inline Modint operator*(Modint a){
    return Modint(*this)*=a;
  }
  inline Modint operator/(Modint a){
    return Modint(*this)/=a;
  }
  inline Modint operator+(int a){
    return Modint(*this)+=Modint(a);
  }
  inline Modint operator-(int a){
    return Modint(*this)-=Modint(a);
  }
  inline Modint operator*(int a){
    return Modint(*this)*=Modint(a);
  }
  inline Modint operator/(int a){
    return Modint(*this)/=Modint(a);
  }
  inline Modint operator+(long long a){
    return Modint(*this)+=Modint(a);
  }
  inline Modint operator-(long long a){
    return Modint(*this)-=Modint(a);
  }
  inline Modint operator*(long long a){
    return Modint(*this)*=Modint(a);
  }
  inline Modint operator/(long long a){
    return Modint(*this)/=Modint(a);
  }
  inline Modint operator-(void){
    Modint res;
    if(val){
      res.val=MD-val;
    }
    else{
      res.val=0;
    }
    return res;
  }
  inline operator bool(void){
    return val!=0;
  }
  inline operator int(void){
    return get();
  }
  inline operator long long(void){
    return get();
  }
  inline Modint inverse(){
    int a = val;
    int b = MD;
    int u = 1;
    int v = 0;
    int t;
    Modint res;
    while(b){
      t = a / b;
      a -= t * b;
      swap(a, b);
      u -= t * v;
      swap(u, v);
    }
    if(u < 0){
      u += MD;
    }
    res.val = u;
    return res;
  }
  inline Modint pw(unsigned long long b){
    Modint a(*this);
    Modint res;
    res.val = 1;
    while(b){
      if(b&1){
        res *= a;
      }
      b >>= 1;
      a *= a;
    }
    return res;
  }
  inline bool operator==(int a){
    return ord(a)==val;
  }
  inline bool operator!=(int a){
    return ord(a)!=val;
  }
}
;
inline Modint operator+(int a, Modint b){
  return Modint(a)+=b;
}
inline Modint operator-(int a, Modint b){
  return Modint(a)-=b;
}
inline Modint operator*(int a, Modint b){
  return Modint(a)*=b;
}
inline Modint operator/(int a, Modint b){
  return Modint(a)/=b;
}
inline Modint operator+(long long a, Modint b){
  return Modint(a)+=b;
}
inline Modint operator-(long long a, Modint b){
  return Modint(a)-=b;
}
inline Modint operator*(long long a, Modint b){
  return Modint(a)*=b;
}
inline Modint operator/(long long a, Modint b){
  return Modint(a)/=b;
}
inline int BIT_popcount_L(const int x){
  return __builtin_popcount(x);
}
inline int BIT_popcount_L(const long long x){
  return __builtin_popcountll(x);
}
#define main dummy_main
int main(){
  return 0;
}
#undef main
class Solution{
  public:
  int countKReducibleNumbers(string s, int k){
    int i, j, m;
    int N = s.size();
    static int go[1000][6];
    static int gof;
    static Modint dp[2][1000];
    static Modint nx[2][1000];
    Modint res = 0;
    if(gof==0){
      int i, j;
      gof = 1;
      for(i=(0);i<(1000);i++){
        go[i][0] = i;
      }
      for(j=(0);j<(5);j++){
        for(i=(0);i<(1000);i++){
          go[i][j+1] =BIT_popcount_L(go[i][j]);
        }
      }
    }
    for(i=(0);i<(2);i++){
      int j;
      for(j=(0);j<(N+1);j++){
        dp[i][j] = 0;
      }
    }
    dp[0][0] = 1;
    for(m=(0);m<(N);m++){
      int j;
      for(i=(0);i<(2);i++){
        int j;
        for(j=(0);j<(N+1);j++){
          nx[i][j] = 0;
        }
      }
      for(j=(0);j<(N+1);j++){
        if(dp[0][j] || dp[1][j]){
          int x;
          for(x=(0);x<(2);x++){
            nx[1][j+x] += dp[1][j];
          }
          if(s[m]=='0'){
            nx[0][j] += dp[0][j];
          }
          else{
            nx[1][j] += dp[0][j];
            nx[0][j+1] += dp[0][j];
          }
        }
      }
      for(i=(0);i<(2);i++){
        for(j=(0);j<(N+1);j++){
          dp[i][j] = nx[i][j];
        }
      }
    }
    for(j=(0);j<(N+1);j++){
      if(go[j][k-1]==1){
        res += dp[1][j];
      }
    }
    return res;
  }
}
;
// cLay version 20241019-1

// --- original code ---
// #define main dummy_main
// {}
// #undef main
// 
// class Solution {
// public:
//   int countKReducibleNumbers(string s, int k) {
//     int N = s.size();
//     static int go[1000][6], gof;
//     static Modint dp[2][1000], nx[2][1000];
//     Modint res = 0;
// 
//     if(gof==0){
//       gof = 1;
//       rep(i,1000) go[i][0] = i;
//       rep(j,5) rep(i,1000){
//         go[i][j+1] = BIT_popcount(go[i][j]);
//       }
//     }
// 
//     rep(i,2) rep(j,N+1) dp[i][j] = 0;
//     dp[0][0] = 1;
// 
//     rep(m,N){
//       rep(i,2) rep(j,N+1) nx[i][j] = 0;
//       rep(j,N+1) if(dp[0][j] || dp[1][j]){
//         rep(x,2) nx[1][j+x] += dp[1][j];
//         if(s[m]=='0'){
//           nx[0][j] += dp[0][j];
//         } else {
//           nx[1][j] += dp[0][j];
//           nx[0][j+1] += dp[0][j];
//         }
//       }
//       rep(i,2) rep(j,N+1) dp[i][j] = nx[i][j];
//     }
// 
//     rep(j,N+1) if(go[j][k-1]==1) res += dp[1][j];
//     return res;
//   }
// };
",1448213752
LayCurse,LayCurse,12,3646,cpp,"#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")
#include<bits/stdc++.h>
using namespace std;
#define MD (1000000007U)
struct Modint{
  unsigned val;
  Modint(){
    val=0;
  }
  Modint(int a){
    val = ord(a);
  }
  Modint(unsigned a){
    val = ord(a);
  }
  Modint(long long a){
    val = ord(a);
  }
  Modint(unsigned long long a){
    val = ord(a);
  }
  inline unsigned ord(unsigned a){
    return a%MD;
  }
  inline unsigned ord(int a){
    a %= (int)MD;
    if(a < 0){
      a += MD;
    }
    return a;
  }
  inline unsigned ord(unsigned long long a){
    return a%MD;
  }
  inline unsigned ord(long long a){
    a %= (int)MD;
    if(a < 0){
      a += MD;
    }
    return a;
  }
  inline unsigned get(){
    return val;
  }
  inline Modint &operator++(){
    val++;
    if(val >= MD){
      val -= MD;
    }
    return *this;
  }
  inline Modint &operator--(){
    if(val == 0){
      val = MD - 1;
    }
    else{
      --val;
    }
    return *this;
  }
  inline Modint operator++(int a){
    Modint res(*this);
    val++;
    if(val >= MD){
      val -= MD;
    }
    return res;
  }
  inline Modint operator--(int a){
    Modint res(*this);
    if(val == 0){
      val = MD - 1;
    }
    else{
      --val;
    }
    return res;
  }
  inline Modint &operator+=(Modint a){
    val += a.val;
    if(val >= MD){
      val -= MD;
    }
    return *this;
  }
  inline Modint &operator-=(Modint a){
    if(val < a.val){
      val = val + MD - a.val;
    }
    else{
      val -= a.val;
    }
    return *this;
  }
  inline Modint &operator*=(Modint a){
    val = ((unsigned long long)val*a.val)%MD;
    return *this;
  }
  inline Modint &operator/=(Modint a){
    return *this *= a.inverse();
  }
  inline Modint operator+(Modint a){
    return Modint(*this)+=a;
  }
  inline Modint operator-(Modint a){
    return Modint(*this)-=a;
  }
  inline Modint operator*(Modint a){
    return Modint(*this)*=a;
  }
  inline Modint operator/(Modint a){
    return Modint(*this)/=a;
  }
  inline Modint operator+(int a){
    return Modint(*this)+=Modint(a);
  }
  inline Modint operator-(int a){
    return Modint(*this)-=Modint(a);
  }
  inline Modint operator*(int a){
    return Modint(*this)*=Modint(a);
  }
  inline Modint operator/(int a){
    return Modint(*this)/=Modint(a);
  }
  inline Modint operator+(long long a){
    return Modint(*this)+=Modint(a);
  }
  inline Modint operator-(long long a){
    return Modint(*this)-=Modint(a);
  }
  inline Modint operator*(long long a){
    return Modint(*this)*=Modint(a);
  }
  inline Modint operator/(long long a){
    return Modint(*this)/=Modint(a);
  }
  inline Modint operator-(void){
    Modint res;
    if(val){
      res.val=MD-val;
    }
    else{
      res.val=0;
    }
    return res;
  }
  inline operator bool(void){
    return val!=0;
  }
  inline operator int(void){
    return get();
  }
  inline operator long long(void){
    return get();
  }
  inline Modint inverse(){
    int a = val;
    int b = MD;
    int u = 1;
    int v = 0;
    int t;
    Modint res;
    while(b){
      t = a / b;
      a -= t * b;
      swap(a, b);
      u -= t * v;
      swap(u, v);
    }
    if(u < 0){
      u += MD;
    }
    res.val = u;
    return res;
  }
  inline Modint pw(unsigned long long b){
    Modint a(*this);
    Modint res;
    res.val = 1;
    while(b){
      if(b&1){
        res *= a;
      }
      b >>= 1;
      a *= a;
    }
    return res;
  }
  inline bool operator==(int a){
    return ord(a)==val;
  }
  inline bool operator!=(int a){
    return ord(a)!=val;
  }
}
;
inline Modint operator+(int a, Modint b){
  return Modint(a)+=b;
}
inline Modint operator-(int a, Modint b){
  return Modint(a)-=b;
}
inline Modint operator*(int a, Modint b){
  return Modint(a)*=b;
}
inline Modint operator/(int a, Modint b){
  return Modint(a)/=b;
}
inline Modint operator+(long long a, Modint b){
  return Modint(a)+=b;
}
inline Modint operator-(long long a, Modint b){
  return Modint(a)-=b;
}
inline Modint operator*(long long a, Modint b){
  return Modint(a)*=b;
}
inline Modint operator/(long long a, Modint b){
  return Modint(a)/=b;
}
#define main dummy_main
int main(){
  return 0;
}
#undef main
class Solution{
  public:
  int sumOfGoodSubsequences(vector<int>& A){
    int i;
    int N = A.size();
    map<int,Modint> c;
    map<int,Modint> s;
    Modint res = 0;
    Modint tc;
    Modint ts;
    for(i=(0);i<(N);i++){
      tc = ts = 0;
      if(c.count(A[i]-1)){
        tc += c[A[i]-1];
        ts += s[A[i]-1];
      }
      if(c.count(A[i]+1)){
        tc += c[A[i]+1];
        ts += s[A[i]+1];
      }
      tc++;
      ts += tc * A[i];
      res += ts;
      c[A[i]] += tc;
      s[A[i]] += ts;
    }
    return res;
  }
}
;
// cLay version 20241019-1

// --- original code ---
// #define main dummy_main
// {}
// #undef main
// 
// class Solution {
// public:
//   int sumOfGoodSubsequences(vector<int>& A) {
//     int N = A.size();
//     map<int,Modint> c, s;
//     Modint res = 0, tc, ts;
// 
//     rep(i,N){
//       tc = ts = 0;
//       if(c.count(A[i]-1)){
//         tc += c[A[i]-1];
//         ts += s[A[i]-1];
//       }
//       if(c.count(A[i]+1)){
//         tc += c[A[i]+1];
//         ts += s[A[i]+1];
//       }
//       tc++;
//       ts += tc * A[i];
//       res += ts;
//       c[A[i]] += tc;
//       s[A[i]] += ts;
//     }
// 
//     return res;
//   }
// };
",1448184044
Ma Lin,Ma_Lin,13,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& a, int K) {
        int i, j, k, n = a.size();
        for (i = 0; i + K + K - 1 < n; ++i){
            bool ky = true;
            for (j = i + 1; j < i + K; ++j)
                if (a[j] <= a[j - 1]) ky = false;
            for (j = i + K + 1; j < i + K + K; ++j)
                if (a[j] <= a[j - 1]) ky = false;
            if (ky) return true;
        }
            
        return false;
    }
};",1448181616
Ma Lin,Ma_Lin,13,3619,cpp,"class Solution {
public:
    int f[200005], sum[200005];
    int maxIncreasingSubarrays(vector<int>& a) {
        int st = 2, ed, K, i, j, res = 1, n = a.size();
        ed = n / 2;
        while (st <= ed){
            K = (st + ed) / 2;
            sum[0] = f[0] = 0;
            for (i = 1; i < n; ++i){
                f[i] = 0;
                if (a[i] > a[i - 1]) f[i] = 1;
                sum[i] = sum[i - 1] + f[i];
            }
            
            bool yes = false;
            for (i = 0; i + K + K - 1 < n; ++i)
                if (sum[i + K - 1] - sum[i] == K - 1 && sum[i + K + K - 1] - sum[i + K] == K - 1){
                    yes = true;
                    break;
                }
                
            if (yes){
                res = K;
                st = K + 1;
            }
            else ed = K - 1;
        }
        
        return res;
    }
};",1448187198
Ma Lin,Ma_Lin,13,3631,cpp,"class Solution {
public:
    int n, C[805][805], f[805], mo = 1000000007;
    
    void calc_C(){
        int i, j;
        C[0][0] = 1; 
        for (i = 1; i <= n; ++i){
            C[i][0] = C[i][i] = 1;
            for (j = 1; j < i; ++j) C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mo;
        }
    }
    
    void calc_f(){
        int i, ge;
        f[1] = 0;
        for (i = 2; i <= n; ++i){
            ge = __builtin_popcount(i);
            f[i] = f[ge] + 1;
        }
    }
    
    int countKReducibleNumbers(string s, int K) {
        int i, j, k, L, yj = 0, res = 0;
        if (s == ""1"" || s == ""0"") return 0;
        n = s.size();
        calc_C();
        calc_f();
        for (i = 0; i < n; ++i)
            if (s[i] == '1'){
                L = n - 1 - i;
                for (j = 0; j <= L; ++j)
                    if ((yj + j) > 0 && f[yj + j] + 1 <= K)
                        res = (res + 1LL * C[L][j]) % mo;
                ++yj;
            }
        
        return res;
    }
};",1448214080
Ma Lin,Ma_Lin,13,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& a) {
        int mo = 1000000007;
        int n = a.size(), i, j, k, res = 0, t;
        map<int, int> ge, sum;
        for (auto x : a){
            ge[x] = (0LL + ge[x - 1] + ge[x + 1] + 1LL + ge[x]) % mo;
            sum[x] = (0LL + sum[x] + sum[x - 1] + 1LL * x * ge[x - 1] + sum[x + 1] + 1LL * x * ge[x + 1] + x) % mo;
        }
        
        for (auto p : sum) res = (res + p.second) % mo;
        return res;
    }
};",1448194288
Yiming Li,lympanda,14,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& a, int k) {
        int i,j,n,b1;
        n=a.size();
        for (i=0;i+k+k<=n;i++)
        {
            b1=1;
            for (j=0;j+1<k;j++)
                if (a[i+j]>=a[i+j+1]) b1=0;
            for (j=0;j+1<k;j++)
                if (a[i+k+j]>=a[i+k+j+1]) b1=0;
            if (b1==1) return true;
            
        }
        return false;
    }
};",1448181990
Yiming Li,lympanda,14,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& a) {
        int i,j,k,n,prev,cnt,ans;
        n=a.size();
        prev=0;
        cnt=0;
        ans=0;
        for (i=0;i+1<n;i++)
        {
            if (a[i+1]>a[i]) cnt++;
            else
            {
                ans=max(ans,min(cnt+1,prev+1));
                ans=max(ans,(cnt+1)/2);
                prev=cnt;
                cnt=0;
            }
        }
        ans=max(ans,min(cnt+1,prev+1));
        ans=max(ans,(cnt+1)/2);
        return ans;        
    }
};",1448184454
Yiming Li,lympanda,14,3631,cpp,"#define _int64 long long
#define mo 1000000007


#define faclim 110000

_int64 fac[faclim];
_int64 invfac[faclim];

_int64 pow1(int x,int y)
{
	int i;
	_int64 ret;
	ret=1;
	for (i=30;i>=0;i--)
	{
		ret=ret*ret%mo;
		if (((1<<i)&y)!=0) ret=ret*x%mo;
	}
	return ret;
}
_int64 inv(int x)
{
	return pow1(x,mo-2);
}
_int64 c(int x,int y)
{
	return fac[x]*invfac[y]%mo*invfac[x-y]%mo;
}
void init()
{
	int i;
	fac[0]=1;
	for (i=1;i<faclim;i++)
		fac[i]=fac[i-1]*i%mo;
	invfac[faclim-1]=inv(fac[faclim-1]);
	for (i=faclim-1;i>0;i--)
		invfac[i-1]=invfac[i]*i%mo;
}

int inited=0;
int d[1000];

class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        int i,j,n,cnt,o,tmp,rem;
        _int64 ans;
        if (inited==0)
        {
            init();
            inited=1;
        }
        n=s.length();
        for (i=1;i<=n;i++)
        {
            tmp=i;
            for (o=0;o+1<k;o++)
                tmp=__builtin_popcount(tmp);
            if (tmp==1) d[i]=1;
            else d[i]=0;
        }
        ans=0;
        cnt=0;
        for (i=0;i<n;i++)
        {
            if (s[i]=='1')
            {
                rem=n-1-i;
                for (j=0;j<=rem;j++)
                {
                    if (d[cnt+j]==1)
                    {
                        ans+=c(rem,j);
                        ans%=mo;
                    }
                }
                cnt++;
            }
        }
        return ans;
        
    }
};",1448209606
Yiming Li,lympanda,14,3646,cpp,"#define _int64 long long
#define mo 1000000007

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& a) {
        int i,j,k,n;
        _int64 ans,tmp1,tmp2;
        map<int,pair<_int64,_int64> > mp;
        pair<_int64,_int64> tmp,v;
        n=a.size();
        mp.clear();
        ans=0;
        for (i=0;i<n;i++)
        {
            tmp=make_pair(0,0);
            if (mp.find(a[i]-1)!=mp.end())
            {
                v=mp[a[i]-1];
                tmp.first+=v.first;
                tmp.first%=mo;
                tmp.second+=v.second;
                tmp.second%=mo;
            }
            if (mp.find(a[i]+1)!=mp.end())
            {
                v=mp[a[i]+1];
                tmp.first+=v.first;
                tmp.first%=mo;
                tmp.second+=v.second;
                tmp.second%=mo;
            }
            tmp.second+=tmp.first*a[i];
            tmp.second+=a[i];
            tmp.second%=mo;
            tmp.first++;
            tmp.first%=mo;
            ans+=tmp.second;
            ans%=mo;
            mp[a[i]].first+=tmp.first;
            mp[a[i]].first%=mo;
            mp[a[i]].second+=tmp.second;
            mp[a[i]].second%=mo;
        }
        return ans;
    }
};",1448194209
PyIsTheBestLang,PyIsTheBestLang,15,3612,python3,"
class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        post = [0]*n
        post[n-1] = 1
        for i in range(n-2, -1 ,-1):
            if nums[i] < nums[i+1]:
                post[i] = post[i+1]+1
            else:
                post[i] = 1
            if post[i] >= k and i+2*k<=n and post[i+k] >= k:
                return True
        return False",1448210092
PyIsTheBestLang,PyIsTheBestLang,15,3619,python3,"class BinarySearch:
    def __init__(self):
        return

    @staticmethod
    def find_int_left(low: int, high: int, check) -> int:
        """"""find the minimum int x which make check true""""""
        while low < high:
            mid = low + (high - low) // 2
            if check(mid):
                high = mid
            else:
                low = mid + 1
        return low

    @staticmethod
    def find_int_right(low: int, high: int, check) -> int:
        """"""find the maximum int x which make check true""""""
        while low < high:
            mid = low + (high - low + 1) // 2
            if check(mid):
                low = mid
            else:
                high = mid - 1
        return high

    @staticmethod
    def find_float_left(low: float, high: float, check, error=1e-6) -> float:
        """"""find the minimum float x which make check true""""""
        while low < high - error:
            mid = low + (high - low) / 2
            if check(mid):
                high = mid
            else:
                low = mid
        return low if check(low) else high

    @staticmethod
    def find_float_right(low: float, high: float, check, error=1e-6) -> float:
        """"""find the maximum float x which make check true""""""
        while low < high - error:
            mid = low + (high - low) / 2
            if check(mid):
                low = mid
            else:
                high = mid
        return high if check(high) else low


class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        
    
        n = len(nums)
        def check(k):
            post = [0]*n
            post[n-1] = 1
            for i in range(n-2, -1 ,-1):
                if nums[i] < nums[i+1]:
                    post[i] = post[i+1]+1
                else:
                    post[i] = 1
                if post[i] >= k and i+2*k<=n and post[i+k] >= k:
                    return True
            return False
        ans = BinarySearch().find_int_right(0, n//2, check)
        return ans",1448209854
PyIsTheBestLang,PyIsTheBestLang,15,3631,python3,"
@lru_cache(None)
def check(num):
    if num == 1:
        return 0
    return check(num.bit_count()) + 1


mod = 10**9 + 7
class Solution:

    def countKReducibleNumbers2(self, s: str, k: int) -> int:
        n = int(""0b""+s, 2)
        n -= 1
        s = bin(n)[2:]
        m = len(s)
        ans2 = sum(check(x)<=k for x in range(1, n+1))
        return ans2

    def countKReducibleNumbers(self, s: str, k: int) -> int:
        n = int(""0b""+s, 2)
        n -= 1
        s = bin(n)[2:]
        m = len(s)

        @lru_cache(None)
        def dfs(i, is_limit, is_num, cnt):
            if i == m:
                return check(cnt) + 1 <= k if is_num and cnt else 0
            res = 0
            if not is_num:
                res += dfs(i + 1, False, False, cnt)
            low = 0 if is_num else 1
            high = int(s[i]) if is_limit else 1
            for x in range(low, high + 1):
                res += dfs(i + 1, is_limit and high == x, True, cnt + int(x == 1))
            return res % mod


        ans2 = dfs(0, True, False, 0)
        dfs.cache_clear()
        ans2 %= mod
        return ans2
",1448211034
PyIsTheBestLang,PyIsTheBestLang,15,3646,python3,"mod = 10**9 + 7
class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:

        ans = 0
        cnt = defaultdict(int)
        ss = defaultdict(int)
        for num in nums:
            pre = cnt[num-1]+cnt[num+1]
            pre_ss = ss[num-1] + ss[num+1]
            pre += 1
            pre_ss += pre*num
            pre_ss %= mod
            cnt[num] += pre
            cnt[num] %= mod
            ss[num] += pre_ss
            ss[num] %= mod
        return sum(ss.values()) % mod",1448209536
nguyen31hoang08minh2003,nguyen31hoang08minh2003,16,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& a, int k) {
        int n = a.size();
        auto f = [&](int l, int r) -> bool {
            for (int i = l + 1; i <= r; ++i)
                if (a[i - 1] >= a[i])
                    return false;
            return true;
        };
        for (int l = 0, m = k - 1, r = m + k; r < n; ++l, ++m, ++r)
            if (f(l, m) && f(m + 1, r))
                return true;
        return false;
    }
};",1448181823
nguyen31hoang08minh2003,nguyen31hoang08minh2003,16,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& a) {
        int n = a.size();
        vector<int> p(n);

        auto s = [&](int l, int r) -> int {
            return p[r] - p[l];
        };

        auto f = [&](int l, int r) -> bool {
            return s(l, r) == r - l;  
        };

        auto check = [&](int k) -> bool {
            for (int l = 0, m = k - 1, r = m + k; r < n; ++l, ++m, ++r)
                if (f(l, m) && f(m + 1, r))
                    return true;
            return false;
        };
        
        for (int i = 1; i < n; ++i) {
            p[i] = p[i - 1];
            if (a[i - 1] < a[i])
                ++p[i];
        }

        int low = 1, high = n + 1, middle;

        for (; low + 1 < high;) {
            middle = low + high >> 1;
            if (check(middle))
                low = middle;
            else
                high = middle;
        }
        
        return low;
    }
};",1448185422
nguyen31hoang08minh2003,nguyen31hoang08minh2003,16,3631,cpp,"class Solution {
protected:

    const int MOD = 1E9 + 7;

private:

    int n, k;
    string u;
    vector<int> d;
    vector<vector<vector<int> > > f;

    int add(int x, int y) {
        if ((x += y) >= MOD)
            x -= MOD;
        return x;
    }

    int mul(long long x, long long y) {
        return x * y % MOD;
    }

    int F(int i, int j, bool r) {
        if (i >= n)
            return r && j && (1 + d[j] <= k);
        if (f[i][j][r] < 0) {
            const int t = r ? 1 : (u[i] - '0');
            f[i][j][r] = 0;
            for (int d = 0; d <= t; ++d)
                f[i][j][r] = add(f[i][j][r], F(i + 1, j + d, r || (d < t)));
        }
        return f[i][j][r];
    }

public:

    int countKReducibleNumbers(string s, int k) {
        n = s.size();
        d.resize(n + 1);
        for (int i = 2, j, x; i <= n; ++i) {
            for (j = 0, x = i; x; x -= x & -x)
                ++j;
            d[i] = d[j] + 1;
        }
        u = s;
        this -> k = k;
        f.resize(n + 1, vector<vector<int> >(n + 1, vector<int>(2, -1)));
        return F(0, 0, false);
    }
};",1448219518
nguyen31hoang08minh2003,nguyen31hoang08minh2003,16,3646,cpp,"class Solution {
protected:

    const int MOD = 1E9 + 7;

private:

    int add(int x, int y) {
        if ((x += y) >= MOD)
            x -= MOD;
        return x;
    }

    int mul(long long x, long long y) {
        return x * y % MOD;
    }

public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        map<int, int> f;
        int n = nums.size();
        map<int, int>::iterator e;
        vector<int> l(n), r(n);
        int result = 0;
        
        for (int i = 0; i < n; ++i) {
            const auto &x = nums[i];
            l[i] = 1;
            e = f.find(x - 1);
            if (e != f.end())
                l[i] = add(l[i], e -> second);
            e = f.find(x + 1);
            if (e != f.end())
                l[i] = add(l[i], e -> second);
            f[x] = add(f[x], l[i]);
        }

        f.clear();

        for (int i = n - 1; i >= 0; --i) {
            const auto &x = nums[i];
            r[i] = 1;
            e = f.find(x - 1);
            if (e != f.end())
                r[i] = add(r[i], e -> second);
            e = f.find(x + 1);
            if (e != f.end())
                r[i] = add(r[i], e -> second);
            f[x] = add(f[x], r[i]);
            result = add(result, mul(mul(l[i], r[i]), x));
        } 

        return result;
    }
};",1448202234
Yang Xiao,sheepforever,17,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        for (int i = 0; i + 2 * k - 1 < nums.size(); ++i) {
            bool ok = true;
            for (int j = 0; j + 1 < k; ++j) {
                if (nums[i + j] >= nums[i + j + 1]) {
                    ok = false;
                    break;
                }
                if (nums[i + k + j] >= nums[i + k + j + 1]) {
                    ok = false;
                    break;
                }
            }
            if (ok) {
                return true;
            }
        }
        return false;
    }
};",1448182341
Yang Xiao,sheepforever,17,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> len(n, 0), to(n, -1);
        int ans = 0;
        for (int i = n - 1; i >= 0; --i) {
            to[i] = i;
            len[i] = 1;
            if (i + 1 < n && nums[i] < nums[i + 1]) {
                len[i] = len[i + 1] + 1;
                to[i] = to[i + 1];
            }
            
            ans = max(ans, len[i] / 2);
            if (to[i] != -1 && to[i] + 1 < n) {
                ans = max(ans, min(len[i], len[to[i] + 1]));
            }
        }
        return ans;
    }
};",1448185060
Yang Xiao,sheepforever,17,3631,cpp,"const int N = 807;
const int MOD = 1000000007;

int steps[N];
bool inited = false;

int dp[N][2][N];

class Solution {
public:
    int countKReducibleNumbers(string s, int kk) {
        if (!inited) {
            inited = true;
            for (int i = 2; i < N; ++i) {
                steps[i] = steps[__builtin_popcount(i)] + 1;
            }
        }
        
        int n = s.size();
        for (int i = 0; i <= n; ++i) {
            for (int j = 0; j < 2; ++j) {
                for (int k = 0; k <= n; ++k) {
                    dp[i][j][k] = 0;
                }
            }
        }
        
        dp[0][0][0] = 1;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < 2; ++j) {
                for (int k = 0; k < n; ++k) {
                    if (dp[i][j][k] == 0) continue;
                    for (int p = 0; p < 2; ++p) {
                        if (p == 1 && j == 0 && s[i] == '0') continue;
                        
                        int nj = j;
                        if (s[i] == '1' && p == 0) nj = 1;
                        
                        dp[i + 1][nj][k + p] = (dp[i + 1][nj][k + p] + dp[i][j][k]) % MOD;
                    }
                }
            }
        }
        
        int ans = 0;
        for (int k = 1; k <= n; ++k) {
            if (steps[k] + 1 <= kk) {
                ans = (ans + dp[n][1][k]) % MOD;
            }
        }
        
        
        return ans;
    }
};",1448212295
Yang Xiao,sheepforever,17,3646,cpp,"const int MOD = 1000000007;

void add(int& x, int y) {
    x += y;
    if (x >= MOD) x -= MOD;
}

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        unordered_map<int, int> count;
        unordered_map<int, int> sum;
        for (int val : nums) {
            int& res = count[val];
            int& s = sum[val];
            add(res, 1);
            add(s, val);
            
            auto it = count.find(val - 1);
            if (it != count.end()) {
                add(res, it->second);
                add(s, (sum[val - 1] + it->second * 1LL * val % MOD) % MOD);
            }
            it = count.find(val + 1);
            if (it != count.end()) {
                add(res, it->second);
                add(s, (sum[val + 1] + it->second * 1LL * val % MOD) % MOD);
            }
        }
        
        int ans = 0;
        for (auto it : sum) {
            add(ans, it.second);
        }
        return ans;
    }
};",1448195832
Abhishek Choudhary,theabbie,20,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        dp = [1] * n
        for i in range(n - 2, -1, -1):
            if nums[i] < nums[i + 1]:
                dp[i] = 1 + dp[i + 1]
        for i in range(n - 2 * k + 1):
            if dp[i] >= k and dp[i + k] >= k:
                return True
        return False",1448206225
Abhishek Choudhary,theabbie,20,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        dp = [1] * n
        for i in range(n - 2, -1, -1):
            if nums[i] < nums[i + 1]:
                dp[i] = 1 + dp[i + 1]
        beg = 1
        end = n // 2
        while beg <= end:
            mid = (beg + end) // 2
            pos = False
            for i in range(n - 2 * mid + 1):
                if dp[i] >= mid and dp[i + mid] >= mid:
                    pos = True
                    break
            if pos:
                beg = mid + 1
            else:
                end = mid - 1
        return beg - 1",1448204688
Abhishek Choudhary,theabbie,20,3631,python3,"M = 10 ** 9 + 7

class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        @lru_cache(maxsize = None)
        def count(x):
            if x <= 1:
                return 0
            return 1 + count(x.bit_count())
        cache = {}
        def dp(i, ctr, tight):
            if i >= len(s):
                return int(1 + count(ctr) <= k and not tight)
            key = (i, ctr, tight)
            if key in cache:
                return cache[key]
            up = 1
            if tight:
                up = int(s[i])
            res = 0
            for d in range(0, up + 1):
                res += dp(i + 1, ctr + d, tight and d == up)
                res %= M
            cache[key] = res
            return res
        return (dp(0, 0, True) - 1) % M",1448222527
Abhishek Choudhary,theabbie,20,3646,python3,"M = 10 ** 9 + 7

class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        n = len(nums)
        s = [0] * (n + 1)
        ctr = [0] * (n + 1)
        ssum = Counter()
        csum = Counter()
        for j in range(n):
            ctr[j] = 1 + csum[nums[j] - 1] + csum[nums[j] + 1]
            s[j] = ssum[nums[j] - 1] + ssum[nums[j] + 1] + nums[j] * ctr[j]
            s[j] %= M
            ctr[j] %= M
            ssum[nums[j]] += s[j]
            csum[nums[j]] += ctr[j]
            ssum[nums[j]] %= M
            csum[nums[j]] %= M
        return sum(s) % M",1448195869
scanhex,scanhex,22,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
                int n = nums.size();
        vector<int> pref(n);
        for (int i = 0; i < n - 1; ++i) 
            pref[i + 1] = pref[i] + (nums[i + 1] <= nums[i]);
        int maxk = 1;
        for (int c = 0; c < n - 1; ++c) {
            int L = 0, R = n - 1;
            while (R - L > 1){
                int M = (L + R ) / 2;
                bool ok = true;
                if (c - M < 0 || c + M + 1 >= n) {
                    ok = false;
                } else {
                    ok &= pref[c] - pref[c - M] == 0 && pref[c + M + 1] - pref[c + 1] == 0;
                }
                if (ok) L = M;
                else
                    R = M;
            }
            maxk = max(maxk, L + 1);
        }
        return maxk >= k;

    }
};",1448214937
scanhex,scanhex,22,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> pref(n);
        for (int i = 0; i < n - 1; ++i) 
            pref[i + 1] = pref[i] + (nums[i + 1] <= nums[i]);
        int maxk = 1;
        for (int c = 0; c < n - 1; ++c) {
            int L = 0, R = n - 1;
            while (R - L > 1){
                int M = (L + R ) / 2;
                bool ok = true;
                if (c - M < 0 || c + M + 1 >= n) {
                    ok = false;
                } else {
                    ok &= pref[c] - pref[c - M] == 0 && pref[c + M + 1] - pref[c + 1] == 0;
                }
                if (ok) L = M;
                else
                    R = M;
            }
            maxk = max(maxk, L + 1);
        }
        return maxk;
    }
};
",1448214366
scanhex,scanhex,22,3631,cpp,"class Solution {
public:
  const int mod = 1e9 + 7;
  int countKReducibleNumbers(string s, int k) {
    vector<vector<vector<int>>> dp(
        s.size() + 1, vector<vector<int>>(s.size() + 1, vector<int>(2)));
    int n = s.size();
    dp[0][0][0] = 1;
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j <= i; ++j) {
            for (int k = 0; k < 2; ++k) {
                if (dp[i][j][k] == 0) {
                    continue;
                }
                for (int d = 0; d <= (k ? 1 : s[i] - '0'); ++d) {
                    int nk = k || (d < s[i] - '0');
                    int nj = j + (d == 1);
                    dp[i + 1][nj][nk] += dp[i][j][k];
                    if (dp[i + 1][nj][nk] >= mod) {
                        dp[i + 1][nj][nk] -= mod;
                    }
                }
            }
        }
    }
    vector<int> c(s.size() + 1);
    c[1] = 0;
    for (int i = 2; i <= s.size(); ++i) {
        c[i] = c[__builtin_popcount(i)] + 1;
    }
    int ans = 0;
    for (int i = 1; i <= s.size(); ++i) {
        if (c[i] <= k - 1) {
            ans += dp[s.size()][i][1];
            if (ans >= mod) {
                ans -= mod;
            }
        }
    }
    return ans;
  }
};
",1448194370
scanhex,scanhex,22,3646,cpp,"class Solution {
public:
  const int mod = 1e9 + 7;
  int mu(int a, int b) { return (a * 1LL * b) % mod; }
  void ad(int &x, int y) {
    x += y;
    if (x >= mod)
      x -= mod;
  }
  int sumOfGoodSubsequences(vector<int> &nums) {
    int n = nums.size();
    map<int, int> cnt, sm;
    for (int x : nums) {
      int c = 1, su = 0;
      ad(c, cnt[x - 1]);
      ad(c, cnt[x + 1]);
      ad(su, sm[x - 1]);
      ad(su, sm[x + 1]);
      ad(su, mu(c, x));
      ad(cnt[x], c);
      ad(sm[x], su);
    }
    int ans = 0;
    for (auto p : sm)
      ad(ans, p.second);
    return ans;
  }
};
",1448205732
aqxa2k,aqxa2k,26,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& a, int k) {
        int n = a.size(); 
        vector<int> g(n, 1); 
        for (int i = 1; i < n; ++i) {
            if (a[i] > a[i - 1]) g[i] += g[i - 1]; 
        }
        for (int i = 0; i + k < n; ++i) {
            if (g[i + k]>= k && g[i] >= k) {
                return true; 
            }
        }
        return false; 
    }
};",1448182391
aqxa2k,aqxa2k,26,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& a) {
        int n = a.size(); 
        vector<int> g(n, 1); 
        for (int i = 1; i < n; ++i) {
            if (a[i] > a[i - 1]) g[i] += g[i - 1]; 
        }
        int lo = 1, hi = n / 2; 
        while (lo < hi) {
            int md = (lo + hi + 1) / 2; 
            int ok = 0; 
            for (int i = 0; i + md < n; ++i) {
                if (g[i] >= md && g[i + md] >= md) {
                    ok = 1; 
                }
            }
            if (ok) lo = md; 
            else hi = md - 1; 
        }
        return lo; 
    }
};",1448183666
aqxa2k,aqxa2k,26,3631,cpp,"template <typename T>
T inverse(T a, T m) {
	T u = 0, v = 1;
	while (a != 0) {
		T t = m / a;
		m -= t * a; swap(a, m);
		u -= t * v; swap(u, v);
	}
	assert(m == 1);
	return u;
}

template<class T>
T power(T a, long long b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}

template <typename T>
class Modular {
    public:
    using Type = typename decay<decltype(T::value)>::type;

    constexpr Modular() : value() {}
    template <typename U>
    Modular(const U& x) {
        value = normalize(x);
    }

    template <typename U>
    static Type normalize(const U& x) {
        Type v;
        if (-mod() <= x && x < mod()) v = static_cast<Type>(x);
        else v = static_cast<Type>(x % mod());
        if (v < 0) v += mod();
        return v;
    }

    const Type& operator()() const { return value; }
    template <typename U>
    explicit operator U() const { return static_cast<U>(value); }
    constexpr static Type mod() { return T::value; }

    Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }
    Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }
    template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }
    template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }
    Modular& operator++() { return *this += 1; }
    Modular& operator--() { return *this -= 1; }
    Modular operator++(int) { Modular result(*this); *this += 1; return result; }
    Modular operator--(int) { Modular result(*this); *this -= 1; return result; }
    Modular operator-() const { return Modular(-value); }

    template <typename U = T>
    typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {

    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));

        return *this;
    }
    template <typename U = T>
    typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {
            long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());
            value = normalize(value * rhs.value - q * mod());
            return *this;
    }
    template <typename U = T>
    typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {
            value = normalize(value * rhs.value);
            return *this;
    }

    Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }

    friend const Type& abs(const Modular& x) { return x.value; }

    template <typename U>
    friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);

    template <typename U>
    friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);

    template <typename V, typename U>
    friend V& operator>>(V& stream, Modular<U>& number);

    private:
    Type value;
};
template <typename T> bool operator>(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value > rhs.value; }
template <typename T, typename U> bool operator>(const Modular<T>& lhs, U rhs) { return lhs > Modular<T>(rhs); }
template <typename T, typename U> bool operator>(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) > rhs; }

template <typename T> bool operator>=(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value >= rhs.value; }
template <typename T, typename U> bool operator>=(const Modular<T>& lhs, U rhs) { return lhs >= Modular<T>(rhs); }
template <typename T, typename U> bool operator>=(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) >= rhs; }
 
template <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }
template <typename T, typename U> bool operator<(const Modular<T>& lhs, U rhs) { return lhs < Modular<T>(rhs); }
template <typename T, typename U> bool operator<(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) < rhs; }

template <typename T> bool operator<=(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value <= rhs.value; }
template <typename T, typename U> bool operator<=(const Modular<T>& lhs, U rhs) { return lhs <= Modular<T>(rhs); }
template <typename T, typename U> bool operator<=(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) <= rhs; }

template <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }
template <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }
template <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }
 
template <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }
template <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }
template <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }
 
template <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }
template <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }
template <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }
 
template <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }
template <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }
template <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }
 
template <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }
template <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }
template <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }
 
template <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }
template <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }
template <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }

template <typename T>
bool IsZero(const Modular<T>& number) {
    return number() == 0;
}
 
template <typename T>
string to_string(const Modular<T>& number) {
    return to_string(number());
}
 
// U == std::ostream? but done this way because of fastoutput
template <typename U, typename T>
U& operator<<(U& stream, const Modular<T>& number) {
    return stream << number();
}
 
// U == std::istream? but done this way because of fastinput
template <typename U, typename T>
U& operator>>(U& stream, Modular<T>& number) {
    typename common_type<typename Modular<T>::Type, long long>::type x;
    stream >> x;
    number.value = Modular<T>::normalize(x);
    return stream;
}
 
/*
using ModType = int;
 
struct VarMod { static ModType value; };
ModType VarMod::value;
ModType& md = VarMod::value;
using Mint = Modular<VarMod>;
*/

constexpr int md = 1000000007;
using Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;
 
vector<Mint> fact(1, 1);
vector<Mint> inv_fact(1, 1);

void R(int n) {
    while ((int) fact.size() < n + 1) {
        fact.push_back(fact.back() * (int) fact.size());
        inv_fact.push_back(0); 
    }
    inv_fact[n] = 1 / fact[n]; 
    for (int i = n; i >= 1; --i) {
        inv_fact[i-1] = inv_fact[i] * i; 
    }
}


Mint C(int n, int k) {
    if (k < 0 || k > n) {
        return 0;
    }
    while ((int) fact.size() < n + 1) {
        fact.push_back(fact.back() * (int) fact.size());
        inv_fact.push_back(1 / fact.back());
    }
    return fact[n] * inv_fact[k] * inv_fact[n - k];
}

class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        int n = s.size(); 
        // if (k == 1) {
        //     int ans = 0; 
        //     for (int i = 1; i < n; ++i) {
        //         if (s[i] == '1') ans = 1; 
        //     }
        //     ans += s.size() - 1; 
        //     return ans; 
        // }

        vector<vector<Mint>> dp(n + 1, vector<Mint>(2, 0));
        dp[0][0] = 1; 
        // 0 -> cur equal 
        // 1 -> less than 
        
        for (int i = 0; i < n; ++i) {
            vector<vector<Mint>> dp2(n + 1, vector<Mint>(2, 0)); 
            for (int j = 0; j < n; ++j) {
                dp2[j + 1][1] += dp[j][1]; 
                dp2[j][1] += dp[j][1]; 
                // include the bit 
                if (s[i] == '1') {
                    dp2[j + 1][0] += dp[j][0]; 
                    dp2[j][1] += dp[j][0]; 
                } else {
                    dp2[j][0] += dp[j][0]; 
                }
            }
            dp = dp2; 
        }
        vector<Mint> c(n + 1); 
        for (int i = 1; i <= n; ++i) {
            c[i] = dp[i][1]; 
            // cout << c[i] << "" \n""[i == n];
        }

        k--; 
        while (k--) {
            vector<Mint> c2(n + 1); 
            for (int i = 1; i <= n; ++i) {
                int b = 0; 
                for (int j = 0; j < 15; ++j) {
                    if ((1 << j) & i) b++; 
                }
                c2[b] += c[i]; 
            }
            c = c2; 
        }
        return (int)c[1]; 
    }
};",1448224176
aqxa2k,aqxa2k,26,3646,cpp,"using ll = long long; 
const int md = 1000000007; 

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& a) {
        ll ans = 0; 
        map<int, ll> s; 
        map<int, ll> f; 
        
        for (auto & x: a) {
            for (int i = -1; i <= 1; i += 2) {
                // cout << f[x + i] << ' ' << s[x + i] << '\n';
                f[x] += f[x + i]; 
                ans += f[x + i] * (ll) x; 
                f[x] %= md; 
                ans += s[x + i]; 
                ans %= md; 
                s[x] += s[x + i]; 
                s[x] += f[x + i] * (ll) x; 
                s[x] %= md; 
            }
            // cout << ans << '\n'; 
            ans += x; 
            ans %= md; 
            f[x]++; 
            f[x] %= md; 
            s[x] += x; 
            s[x] %= md;

            cout << ans << '\n'; 
        }
        return ans; 
    }
};",1448198977
Naruto,Naruto_x,27,3612,python3,"class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret

class Solution:
    def maxIncreasingSubarrays(self, arr: List[int]) -> int:
        n = len(arr)
        if n < 2:
            return 0 
        inc = [1] * n
        for i in range(n - 2, -1, -1):
            if arr[i] < arr[i + 1]:
                inc[i] = 1 + inc[i + 1]
            else:
                inc[i] = 1

        low, high = 1, n // 2
        ans = 0

        while low <= high:
            mid = low + (high - low) // 2
            flag = False

            for a in range(n - 2 * mid + 1):
                if inc[a] >= mid and inc[a + mid] >= mid:
                    flag = True
                    break

            if flag:
                ans = mid
                low = mid + 1  
            else:
                high = mid - 1  

        return ans

class Solution:
    def hasIncreasingSubarrays(self, arr: List[int], k: int) -> bool:
        n = len(arr)
        if 2 * k > n:
            return False
        inc = [1] * n 
        
        for i in range(n - 2, -1, -1):
            if arr[i] < arr[i + 1]:
                inc[i] = 1 + inc[i + 1]
            else:
                inc[i] = 1
        for i in range(n):
            pass
        for j in range(n - 2 * k + 1):
            if inc[j] >= k:
                if inc[j + k] >= k:
                    return True  
        return False
",1448216942
Naruto,Naruto_x,27,3619,python3,"class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret

class Solution:
    def maxIncreasingSubarrays(self, arr: List[int]) -> int:
        n = len(arr)
        if n < 2:
            return 0 
        inc = [1] * n
        for i in range(n - 2, -1, -1):
            if arr[i] < arr[i + 1]:
                inc[i] = 1 + inc[i + 1]
            else:
                inc[i] = 1

        low, high = 1, n // 2
        ans = 0

        while low <= high:
            mid = low + (high - low) // 2
            flag = False

            for a in range(n - 2 * mid + 1):
                if inc[a] >= mid and inc[a + mid] >= mid:
                    flag = True
                    break

            if flag:
                ans = mid
                low = mid + 1  
            else:
                high = mid - 1  

        return ans
",1448214894
Naruto,Naruto_x,27,3631,python3,"class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret

class Solution:
    mod = 10**9 + 7
    maxs = 800
    infx = 10**9

    def __init__(self):
        self.stps = [0] * (self.maxs + 1)
        self.dp = {}
        self.k = 0
        self.precompute()

    def precompute(self):
        self.stps[0] = self.infx 
        self.stps[1] = 0   
        for i in range(10):
            pass
        for s in range(2, self.maxs + 1):
            temp = s
            steps = 0
            while temp != 1:
                temp = bin(temp).count('1')
                steps += 1
            self.stps[s] = steps

    def dfs(self, n, pos, t1, count, start1):
        if pos == len(n):
            return 1 if start1 and (1 + self.stps[count]) <= self.k else 0

        if (pos, t1, count, start1) in self.dp:
            return self.dp[(pos, t1, count, start1)]

        res = 0
        maxd = int(n[pos]) if t1 else 1
        for i in range(maxd + 1):
            pass
        for z in range(maxd + 1):
            tnext = t1 and (z == maxd)
            snext = start1 or (z != 0)
            cnext = count + z if snext else 0

            res = (res + self.dfs(n, pos + 1, tnext, cnext, snext)) % self.mod

        self.dp[(pos, t1, count, start1)] = res
        return res

    def countKReducibleNumbers(self, s: str, x: int) -> int:
        self.k = x
        self.dp = {}
        res = self.dfs(s, 0, 1, 0, 0)
        scnt = s.count('1')
        tot = 1 + self.stps[scnt]
        if tot <= self.k:
            res = (res - 1 + self.mod) % self.mod
        return res % self.mod
",1448224249
Naruto,Naruto_x,27,3646,python3,"class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret

class Solution:
    def sumOfGoodSubsequences(self, arr: List[int]) -> int:
        mod = 10**9+7
        maxn = max(arr) if arr else 0
        dpc = [0] * (maxn + 2) 
        dps = [0] * (maxn + 2)   

        ans = 0

        for p in arr:
            cnt1 = 1
            sumx = p

            if p > 0:
                cnt1 = (cnt1 + dpc[p - 1]) % mod
                sumx = (sumx + dps[p - 1] + dpc[p - 1] * p) % mod

            if p < maxn:
                cnt1 = (cnt1 + dpc[p + 1]) % mod
                sumx = (sumx + dps[p + 1] + dpc[p + 1] * p) % mod

            dpc[p] = (dpc[p] + cnt1) % mod
            dps[p] = (dps[p] + sumx) % mod

            ans = (ans + sumx) % mod

        return ans
",1448212511
res,Res1StAnce7,28,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n=len(nums)
        inc=[1]*n
        for i in range(n-2,-1,-1):
            inc[i]=inc[i+1]+1 if nums[i]<nums[i+1] else 1
        return any(inc[a]>=k and inc[a+k]>=k for a in range(n-2*k+1))",1448181398
res,Res1StAnce7,28,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n=len(nums)
        inc=[1]*n
        for i in range(n-2,-1,-1):
            inc[i]=inc[i+1]+1 if nums[i]<nums[i+1] else 1
        l=1
        h=n//2
        res=0
        while l<=h:
            m=(l+h)//2
            if any(inc[a]>=m and a+m<n and inc[a+m]>=m for a in range(n-2*m+1)):
                res=m
                l=m+1
            else:
                h=m-1
        return res",1448183602
res,Res1StAnce7,28,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        mod=10**9+7
        memo={}
    
        def f(x):
            if x==1:
                memo[x]=0
                return 0
            if x in memo:
                return memo[x]
            memo[x]=1+f(bin(x).count('1'))
            return memo[x]
    
        for x in range(1,2049):
            f(x)
    
        cs=[c for c in range(1,2049) if memo.get(c,2048)<=k-1]
        n_val=int(s,2)
        if n_val==0:
            return 0
        n_val-=1
        s=bin(n_val)[2:].zfill(len(s))
        n=len(s)
        dp={}
    
        def count_bits(i,cnt,tight):
            if i==n:
                return 1 if cnt in cs else 0
            key=(i,cnt,tight)
            if key in dp:
                return dp[key]
            res=0
            limit=int(s[i]) if tight else 1
            for bit in range(0,limit+1):
                new_tight=tight and (bit==limit)
                new_cnt=cnt+bit
                if new_cnt>2048:
                    continue
                res+=count_bits(i+1,new_cnt,new_tight)
                res%=mod
            dp[key]=res
            return res
    
        return count_bits(0,0,True)%mod",1448216260
res,Res1StAnce7,28,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        mod=10**9+7
        cnt=defaultdict(int)
        sm=defaultdict(int)
        total=0
        for x in nums:
            c1=cnt[x-1]
            c2=cnt[x+1]
            s1=sm[x-1]
            s2=sm[x+1]
            ns=(s1+s2+x*(c1+c2+1))%mod
            nc=(c1+c2+1)%mod
            cnt[x]=(cnt[x]+nc)%mod
            sm[x]=(sm[x]+ns)%mod
            total=(total+ns)%mod
        return total",1448186905
physics0523,physics0523,29,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n=nums.size();
        vector<int> sgn(n+5,0);
        for(int i=1;i<n;i++){
            if(nums[i-1]<nums[i]){sgn[i]++;}
        }
        for(int i=1;i<n;i++){
            sgn[i]+=sgn[i-1];
        }
        for(int i=0;i+2*k<=n;i++){
            int j=i+k;
            bool ok=true;
            if(sgn[i+k-1]-sgn[i] != (k-1)){ok=false;}
            if(sgn[j+k-1]-sgn[j] != (k-1)){ok=false;}
            if(ok){return true;}
        }
        return false;
    }
};",1448184834
physics0523,physics0523,29,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n=nums.size();
        vector<int> sgn(n+5,0);
        for(int i=1;i<n;i++){
            if(nums[i-1]<nums[i]){sgn[i]++;}
        }
        for(int i=1;i<n;i++){
            sgn[i]+=sgn[i-1];
        }
        int res=1;
        for(int i=1;i<n;i++){
            int l=1,r=min(i,n-i);
            while(l<=r){
                int te=(l+r)/2;
                if(((sgn[i-1]-sgn[i-1-(te-1)])==(te-1)) && (sgn[i+(te-1)]-sgn[i]==(te-1))){l=te+1;}
                else{r=te-1;}
            }
            res=max(res,r);
        }
        return res;
    }
};",1448196325
physics0523,physics0523,29,3631,cpp,"#define mod 1000000007

int f(int x){
    return __builtin_popcount(x);
}

class Solution {
public:
    int countKReducibleNumbers(string s, int k){
        // cout << f(6) << ""\n"";
        // cout << f(2) << ""\n"";
        // cout << f(7) << ""\n"";
        
        int n=s.size();
        vector<long long> dp(2*n+6,0);
        dp[1]=1;
        for(int pos=0;pos<n;pos++){
            vector<long long> ndp(2*n+6,0);
            for(int i=0;i<dp.size();i++){
                if(dp[i]==0){continue;}
                int c=(i/2);
                int f=(i%2);
                for(int ap=0;ap<=1;ap++){
                    int nc=c+ap;
                    int nf=f;
                    if(f==1){
                        if((s[pos]-'0')==0 && ap==1){continue;}
                        if((s[pos]-'0')==1 && ap==0){nf=0;}
                    }
                    int tg=(nc*2)+nf;
                    ndp[tg]+=dp[i];
                    ndp[tg]%=mod;
                }
            }
            dp=ndp;
        }
        
        long long res=0;
        for(int i=2;i<dp.size();i+=2){
            int x=(i/2);
            for(int tr=2;tr<=k;tr++){x=f(x);}
            if(x==1){res+=dp[i]; res%=mod;}
        }
        return (res%mod);
    }
};",1448224939
physics0523,physics0523,29,3646,cpp,"#define mod 1000000007

using pl=pair<long long,long long>;

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums){
        unordered_map<long long,pl> mp;
        for(auto &ix : nums){
            long long x=ix;
            if(mp.find(x-1)==mp.end()){mp[x-1]={0,0};}
            if(mp.find(x)==mp.end()){mp[x]={0,0};}
            if(mp.find(x+1)==mp.end()){mp[x+1]={0,0};}

            pl del={1,x};
            pl ml=mp[x-1];
            pl mr=mp[x+1];
            ml.first+=mr.first; ml.first%=mod;
            ml.second+=mr.second; ml.second%=mod;
            del.first+=ml.first; del.first%=mod;
            del.second+=ml.second; del.second%=mod;
            del.second+=(x*ml.first); del.second%=mod;
            mp[x].first+=del.first;
            mp[x].second+=del.second;
        }
        long long res=0;
        for(auto &nx : mp){
            res+=nx.second.second; res%=mod;
        }
        return res;
    }
};",1448208838
Anuj Anand,coleworld223,31,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
      int n = nums.size();
      vector <int> dpf (n), dpb (n);
      for (int i = 0; i < n; ++i) {
        dpf[i] = 1;
        if (i and nums[i] > nums[i - 1]) { dpf[i] += dpf[i - 1]; } 
      }
      for (int i = n - 1; i >= 0; i--) {
        dpb[i] = 1;
        if (i + 1 < n and nums[i + 1] > nums[i]) { dpb[i] += dpb[i + 1]; }
      }
      bool ok = 0;
      for (int i = 0; i < n; ++i) {
        if (i + 1 < n and dpf[i] >= k and dpb[i + 1] >= k) { ok = 1; }
      }
      return ok;
    }
};",1448189361
Anuj Anand,coleworld223,31,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
      int n = nums.size();
      vector <int> dpf (n), dpb (n);
      for (int i = 0; i < n; ++i) {
        dpf[i] = 1;
        if (i and nums[i] > nums[i - 1]) { dpf[i] += dpf[i - 1]; } 
      }
      for (int i = n - 1; i >= 0; i--) {
        dpb[i] = 1;
        if (i + 1 < n and nums[i + 1] > nums[i]) { dpb[i] += dpb[i + 1]; }
      }
      int ans = 0;
      for (int i = 0; i < n; ++i) {
        if (i + 1 < n) {
          ans = max(ans, min(dpf[i], dpb[i + 1]));
        }
      }
      return ans;
    }
};",1448187598
Anuj Anand,coleworld223,31,3631,cpp,"const int MOD = 1e9 + 7;
long long dp[801][2][801];
class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
      using i64 = long long;
      int siz = s.size();
      memset(dp, -1, sizeof(dp));
      auto F = [&] (auto &&F, int idx, int f, int cnt, string&s) -> i64 {
        int siz = s.size();
        if (cnt < 0) { return 0; }
        if (idx == s.size()) {
          if (cnt == 0) { return 1; }
          return 0;
        }
        if (dp[idx][f][cnt] != -1) { return dp[idx][f][cnt]; }
        i64 res = 0;
        int till = (f ? 1 : s[idx] - '0');
        for (int take = 0; take <= till; take++) {
          bool nf = (f or (take < (s[idx] - '0')));
          res += F(F, idx + 1, nf, cnt - take, s);
          res %= MOD;
        }
        return dp[idx][f][cnt] = res;
      };
      
      auto op = [&] (int x) -> int {
        int lft = k - 1;
        while (lft > 0 and x != 1) {
          lft--;
          int c = 0;
          while (x) {
            if (x & 1) c += 1;
            x >>= 1;
          }
          x = c;
        }
        return x == 1;
      };
      
      i64 ans = 0;
      for (int cnt = 1; cnt <= siz; cnt++) {
        i64 num = F(F, 0, 0, cnt, s);
        if (op(cnt)) { ans += num; ans %= MOD; }
      }
      int c_n = count(s.begin(), s.end(), '1');
      if (op(c_n)) ans--;
      ans += MOD;
      ans %= MOD;
      return ans;
    }
};",1448225554
Anuj Anand,coleworld223,31,3646,cpp,"// dp[s] = ending with s , all posssubseq sum
// dp[s] = s + dp[s - 1] + cnt[s - 1] * s + s * cnt[s + 1]

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
      using i64 = long long;
      const int MOD = 1e9 + 7;
      const int siz = 1e5;
      vector <i64> dp (siz + 5), cnt (siz + 5);
      int n = nums.size();
      for (int i = 0; i < n; ++i) {
        int s = nums[i];
        dp[s] += s;
        if (s > 0) dp[s] += dp[s - 1];
        dp[s] += dp[s + 1];
        dp[s] %= MOD;
        if (s > 0) dp[s] += s * cnt[s - 1];
        dp[s] += s * cnt[s + 1];
        cnt[s] += 1 + (s - 1 >= 0 ? cnt[s - 1] : 0) + cnt[s + 1];
        cnt[s] %= MOD;
      }
      i64 res = 0;
      for (int i = 0; i <= siz; ++i) {
        res += dp[i];
        res %= MOD;
      }
      return res;
    }
};",1448201458
user5860c,user5860c,35,3612,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;
const char en = '\n';

class Solution {
public:
    int hasIncreasingSubarrays(vector<int>& v, int k) {
        vi bl(sz(v));
        vi br(sz(v));
        FOR(i, sz(v)) {
            if (i == 0) {
                bl[i] = 1;
            } else {
                if (v[i] > v[i-1]) {
                    bl[i] = bl[i-1] + 1;
                } else {
                    bl[i] = 1;
                }
            }
        }
        for (int i=sz(v)-1;i>=0;--i) {
            if (i == sz(v) - 1) {
                br[i] = 1;
            } else {
                if (v[i] < v[i+1]) {
                    br[i] = br[i+1] + 1;
                } else {
                    br[i] = 1;
                }
            }
        }
        int ret = 0;
        for (int i=0;i<sz(v)-1;++i) {
            ret = max(ret, min(bl[i], br[i+1]));
        }
        return ret >= k;
    }
};
",1448219921
user5860c,user5860c,35,3619,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;
const char en = '\n';

class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& v) {
        vi bl(sz(v));
        vi br(sz(v));
        FOR(i, sz(v)) {
            if (i == 0) {
                bl[i] = 1;
            } else {
                if (v[i] > v[i-1]) {
                    bl[i] = bl[i-1] + 1;
                } else {
                    bl[i] = 1;
                }
            }
        }
        for (int i=sz(v)-1;i>=0;--i) {
            if (i == sz(v) - 1) {
                br[i] = 1;
            } else {
                if (v[i] < v[i+1]) {
                    br[i] = br[i+1] + 1;
                } else {
                    br[i] = 1;
                }
            }
        }
        int ret = 0;
        for (int i=0;i<sz(v)-1;++i) {
            ret = max(ret, min(bl[i], br[i+1]));
        }
        return ret;
    }
};",1448218731
user5860c,user5860c,35,3631,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;
const char en = '\n';
#define MOD 1000000007
template<int MODX>
struct ModInt {
  unsigned x;
  ModInt() : x(0) { }
  ModInt(signed sig) : x(((sig%MODX)+MODX)%MODX) {  }
  ModInt(signed long long sig) : x(((sig%MODX)+MODX)%MODX) { }
  int get() const { return (int)x; }
  ModInt pow(ll p) { ModInt res = 1, a = *this; while (p) { if (p & 1) res *= a; a *= a; p >>= 1; } return res; }
 
  ModInt &operator+=(ModInt that) { if ((x += that.x) >= MODX) x -= MODX; return *this; }
  ModInt &operator-=(ModInt that) { if ((x += MODX - that.x) >= MODX) x -= MODX; return *this; }
  ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MODX; if (x < 0) x += MODX; return *this; }
  ModInt &operator/=(ModInt that) { return (*this) *= that.pow(MODX - 2); }
 
  ModInt operator+(ModInt that) const { return ModInt(*this) += that; }
  ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }
  ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }
  ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }
  bool operator<(ModInt that) const { return x < that.x; }
  friend ostream& operator<<(ostream &os, ModInt a) { os << a.x; return os; }
};
typedef ModInt<MOD> mint; 

string s;

mint best[808][808][2];

int calc(int d) {
    if (d == 1) return 1;
    return 1 + calc(__popcount(d));
}

class Solution {
public:
    int countKReducibleNumbers(string sx, int k) {
        
        s = sx;
        int N = sz(sx);
        FOR(i, N+2) {
            FOR(j, N+2) {
                FOR(b,2) {
                    best[i][j][b] = 0;
                }
            }
        }
        best[0][0][1] = 1;
        for (int i=0;i<sz(sx);++i) {
            for (int j=0;j<=i;++j) {
                for (int b=0;b<2;++b) {
                    //if (best[i][j][b].x == 0) continue;
                    if (b == 0) {
                        best[i+1][j+1][b] += best[i][j][b];
                        best[i+1][j][b] += best[i][j][b];
                    } else if (b == 1) {
                        if (s[i] == '1') {
                            best[i+1][j+1][1] += best[i][j][b];
                            best[i+1][j][0] += best[i][j][b];
                        } else {
                            best[i+1][j][1] += best[i][j][b];
                        }
                    }
                }
            }
        }        
        mint ret = 0;
        for (int i=1;i<=sz(sx);++i) {
            if (calc(i) <= k) {
                ret += best[sz(sx)][i][0];
            }
        }
        return ret.x;
    }
};",1448203247
user5860c,user5860c,35,3646,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;
const char en = '\n';

#define MOD 1000000007
template<int MODX>
struct ModInt {
  unsigned x;
  ModInt() : x(0) { }
  ModInt(signed sig) : x(((sig%MODX)+MODX)%MODX) {  }
  ModInt(signed long long sig) : x(((sig%MODX)+MODX)%MODX) { }
  int get() const { return (int)x; }
  ModInt pow(ll p) { ModInt res = 1, a = *this; while (p) { if (p & 1) res *= a; a *= a; p >>= 1; } return res; }
 
  ModInt &operator+=(ModInt that) { if ((x += that.x) >= MODX) x -= MODX; return *this; }
  ModInt &operator-=(ModInt that) { if ((x += MODX - that.x) >= MODX) x -= MODX; return *this; }
  ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MODX; if (x < 0) x += MODX; return *this; }
  ModInt &operator/=(ModInt that) { return (*this) *= that.pow(MODX - 2); }
 
  ModInt operator+(ModInt that) const { return ModInt(*this) += that; }
  ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }
  ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }
  ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }
  bool operator<(ModInt that) const { return x < that.x; }
  friend ostream& operator<<(ostream &os, ModInt a) { os << a.x; return os; }
};
typedef ModInt<MOD> mint;

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& v) {
        map<int,pair<mint,mint>> h;
        for (auto x : v) {
            auto cnt = h[x];
            
            cnt.fs += 1;
            cnt.fs += h[x-1].fs;
            cnt.fs += h[x+1].fs;
            cnt.sc += x;
            cnt.sc += h[x+1].sc + h[x+1].fs * x;
            cnt.sc += h[x-1].sc + h[x-1].fs * x;
            h[x] = cnt;
            //cout << cnt.fs << "" "" << cnt.sc << endl;
        }
        
        mint ret = 0;
        for (auto x : h) {
            ret += x.sc.sc;
        }
        return ret.x;
    }
};",1448215188
washedup,rejudge_thiz,37,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> pref(n);
        for(int i=0;i+1<n;i++) pref[i+1]=pref[i]+(nums[i+1]>nums[i]);
        for(int i=0;i+2*k<=n;i++){
            if(pref[i+k-1]-pref[i]==k-1 && pref[i+2*k-1]-pref[i+k]==k-1) return true;
        }
        return false;
    }
};",1448184221
washedup,rejudge_thiz,37,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> pref(n);
        for(int i=0;i+1<n;i++) pref[i+1]=pref[i]+(nums[i+1]>nums[i]);
        int l=1,r=n/2;
        while(l<r){
            int m=(l+r+1)/2;
            bool good=false;
            for(int i=0;i+2*m<=n;i++){
                if(pref[i+m-1]-pref[i]==m-1 && pref[i+2*m-1]-pref[i+m]==m-1) good=true;
            }
            if(good) l=m;
            else r=m-1;
        }
        return l;
    }
};",1448186424
washedup,rejudge_thiz,37,3631,cpp,"template <typename T> T mod_inv_in_range(T a, T m) {
  // assert(0 <= a && a < m);
  T x = a, y = m;
  // coeff of a in x and y
  T vx = 1, vy = 0;
  while (x) {
    T k = y / x;
    y %= x;
    vy -= k * vx;
    std::swap(x, y);
    std::swap(vx, vy);
  }
  assert(y == 1);
  return vy < 0 ? m + vy : vy;
}
template <int MOD_> struct modnum {
    static constexpr int MOD = MOD_;
    static_assert(MOD_ > 0, ""MOD must be positive"");

private:
    int v;

public:

    modnum() : v(0) {}
    modnum(int64_t v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }
    explicit operator int() const { return v; }
    friend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }
    friend std::istream& operator >> (std::istream& in, modnum& n) { int64_t v_; in >> v_; n = modnum(v_); return in; }

    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }
    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }

    modnum inv() const {
        modnum res;
        res.v = mod_inv_in_range(v, MOD);
        return res;
    }
    friend modnum inv(const modnum& m) { return m.inv(); }
    modnum neg() const {
        modnum res;
        res.v = v ? MOD-v : 0;
        return res;
    }
    friend modnum neg(const modnum& m) { return m.neg(); }

    modnum operator- () const {
        return neg();
    }
    modnum operator+ () const {
        return modnum(*this);
    }

    modnum& operator ++ () {
        v ++;
        if (v == MOD) v = 0;
        return *this;
    }
    modnum& operator -- () {
        if (v == 0) v = MOD;
        v --;
        return *this;
    }
    modnum& operator += (const modnum& o) {
        v -= MOD-o.v;
        v = (v < 0) ? v + MOD : v;
        return *this;
    }
    modnum& operator -= (const modnum& o) {
        v -= o.v;
        v = (v < 0) ? v + MOD : v;
        return *this;
    }
    modnum& operator *= (const modnum& o) {
        v = int(int64_t(v) * int64_t(o.v) % MOD);
        return *this;
    }
    modnum& operator /= (const modnum& o) {
        return *this *= o.inv();
    }

    friend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }
    friend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }
    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }
    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }
    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }
    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }
};
class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        const int mx=801;
        vector<int> tok(mx);
        for(int i=1;i<mx;i++){
            int temp=i;
            for(int _=0;_+1<k;_++) temp=__builtin_popcount(temp);
            tok[i]=temp==1;
        }
        using num=modnum<1'000'000'007>;
        int n=s.size();
        vector<array<num,mx>> d(n);
        d[0][0]+=1;
        for(int i=1;i<n;i++){
            d[i]=d[i-1];
            for(int j=0;j<=i;j++) d[i][j+1]+=d[i-1][j];
        }
        int s1=0;num re{};
        for(int i=0;i<n;i++){
            if(s[i]=='1'){
                for(int j=s1;j<mx;j++) if(tok[j]) re+=d[n-1-i][j-s1];
                s1++;
            }
        }
        return (int)re;
    }
};",1448229216
washedup,rejudge_thiz,37,3646,cpp,"template <typename T> T mod_inv_in_range(T a, T m) {
  // assert(0 <= a && a < m);
  T x = a, y = m;
  // coeff of a in x and y
  T vx = 1, vy = 0;
  while (x) {
    T k = y / x;
    y %= x;
    vy -= k * vx;
    std::swap(x, y);
    std::swap(vx, vy);
  }
  assert(y == 1);
  return vy < 0 ? m + vy : vy;
}
template <int MOD_> struct modnum {
    static constexpr int MOD = MOD_;
    static_assert(MOD_ > 0, ""MOD must be positive"");

private:
    int v;

public:

    modnum() : v(0) {}
    modnum(int64_t v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }
    explicit operator int() const { return v; }
    friend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }
    friend std::istream& operator >> (std::istream& in, modnum& n) { int64_t v_; in >> v_; n = modnum(v_); return in; }

    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }
    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }

    modnum inv() const {
        modnum res;
        res.v = mod_inv_in_range(v, MOD);
        return res;
    }
    friend modnum inv(const modnum& m) { return m.inv(); }
    modnum neg() const {
        modnum res;
        res.v = v ? MOD-v : 0;
        return res;
    }
    friend modnum neg(const modnum& m) { return m.neg(); }

    modnum operator- () const {
        return neg();
    }
    modnum operator+ () const {
        return modnum(*this);
    }

    modnum& operator ++ () {
        v ++;
        if (v == MOD) v = 0;
        return *this;
    }
    modnum& operator -- () {
        if (v == 0) v = MOD;
        v --;
        return *this;
    }
    modnum& operator += (const modnum& o) {
        v -= MOD-o.v;
        v = (v < 0) ? v + MOD : v;
        return *this;
    }
    modnum& operator -= (const modnum& o) {
        v -= o.v;
        v = (v < 0) ? v + MOD : v;
        return *this;
    }
    modnum& operator *= (const modnum& o) {
        v = int(int64_t(v) * int64_t(o.v) % MOD);
        return *this;
    }
    modnum& operator /= (const modnum& o) {
        return *this *= o.inv();
    }

    friend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }
    friend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }
    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }
    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }
    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }
    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }
};
class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        using num=modnum<1'000'000'007>;
        const int mx=100'001;
        array<num,mx> cnt{},su{};
        for(int i:nums){
            su[i]+=i,cnt[i]+=1;
            if(i>0) su[i]+=su[i-1]+i*cnt[i-1],cnt[i]+=cnt[i-1];
            if(i+1<mx) su[i]+=su[i+1]+i*cnt[i+1],cnt[i]+=cnt[i+1];
        }
        num re{};
        for(auto i:su) re+=i;
        return (int)re;
    }
};",1448200112
Dhruv Pasricha,pasricha_dhruv,39,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> pre(n, 1), suf(n, 1);
        for(int i = 1; i < n; ++i)
        {
            if(nums[i] > nums[i - 1])
            {
                pre[i] += pre[i - 1];
            }
        }
        for(int i = n - 2; i >= 0; --i)
        {
            if(nums[i + 1] > nums[i])
            {
                suf[i] += suf[i + 1];
            }
        }
        int ans = 1;
        for(int i = 0; i + 1 < n; ++i)
        {
            int cur = min(pre[i], suf[i + 1]);
            ans = max(ans, cur);
        }
        return ans >= k;
    }
};",1448229720
Dhruv Pasricha,pasricha_dhruv,39,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> pre(n, 1), suf(n, 1);
        for(int i = 1; i < n; ++i)
        {
            if(nums[i] > nums[i - 1])
            {
                pre[i] += pre[i - 1];
            }
        }
        for(int i = n - 2; i >= 0; --i)
        {
            if(nums[i + 1] > nums[i])
            {
                suf[i] += suf[i + 1];
            }
        }
        int ans = 1;
        for(int i = 0; i + 1 < n; ++i)
        {
            int cur = min(pre[i], suf[i + 1]);
            ans = max(ans, cur);
        }
        return ans;
    }
};",1448228632
Dhruv Pasricha,pasricha_dhruv,39,3631,cpp,"int cnt[810], dp[810][2][810];
string s;
int k;

const int mod = 1e9 + 7;

int f(int pos, bool tight, int setBits)
{
    if(pos == s.size())
    {
        if(tight or setBits == 0) return false;
        return cnt[setBits] < k;
    }

    if(dp[pos][tight][setBits] != -1) return dp[pos][tight][setBits];

    int lb = 0;
    int ub = tight ? s[pos] - '0' : 1;

    int ans = 0;
    for(int i = lb; i <= ub; ++i)
    {
        ans += f(pos + 1, tight and i == ub, setBits + (i == 1));
        ans %= mod;
    }

    return dp[pos][tight][setBits] = ans;
}

class Solution 
{
public:
    int countKReducibleNumbers(string S, int K) 
    {
        for(int i = 2; i <= 800; ++i)
        {
            cnt[i] = 1 + cnt[__builtin_popcount(i)];
        }

        memset(dp, -1, sizeof dp);
        
        s = S;
        k = K;

        return f(0, true, 0);
    }
};",1448220455
Dhruv Pasricha,pasricha_dhruv,39,3646,cpp,"const int N = 1e5 + 10, mod = 1e9 + 7;
long long dp[N + 1], dp2[N + 1];
class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        #define int long long

        int n = nums.size();
        memset(dp, 0, sizeof dp);
        memset(dp2, 0, sizeof dp2);

        int ans = 0;
        for(int i = 0; i < n; ++i)
        {
            int num = nums[i];
        
            dp[num] += num;
            dp2[num] += 1;
            
            if(num - 1 >= 0)
            {
                dp[num] += dp[num - 1];
                dp[num] += (dp2[num - 1] * num) % mod;
                dp[num] %= mod;
            
                dp2[num] += dp2[num - 1];
                dp2[num] %= mod;
            }
        
            dp[num] += dp[num + 1];
            dp[num] += (dp2[num + 1] * num) % mod;
            dp[num] %= mod;
        
            dp2[num] += dp2[num + 1];
            dp2[num] %= mod;
        }

        for(int i = 0; i <= N; ++i)
        {
            ans += dp[i];
            ans %= mod;
        }

        #undef int

        return ans;
    }
};",1448199994
BERNARD BRAHIMCHA,BERNARB01,42,3612,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

class Solution {
 public:
  bool hasIncreasingSubarrays(vector<int>& a, int k) {
    int n = int(a.size());
    vector<int> v;
    int beg = 0;
    while (beg < n) {
      int end = beg;
      while (end + 1 < n && a[end + 1] > a[end]) {
        end += 1;
      }
      v.push_back(end - beg + 1);
      beg = end + 1;
    }
    int ans = 0;
    for (int i = 0; i < int(v.size()); i++) {
      ans = max(ans, v[i] / 2);
    }
    for (int i = 1; i < int(v.size()); i++) {
      ans = max(ans, min(v[i - 1], v[i]));
    }
    return (ans >= k);
  }
};

#ifdef B01
int main() {
  Solution sl;
}
#endif
",1448230687
BERNARD BRAHIMCHA,BERNARB01,42,3619,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

class Solution {
 public:
  int maxIncreasingSubarrays(vector<int>& a) {
    int n = int(a.size());
    vector<int> v;
    int beg = 0;
    while (beg < n) {
      int end = beg;
      while (end + 1 < n && a[end + 1] > a[end]) {
        end += 1;
      }
      v.push_back(end - beg + 1);
      beg = end + 1;
    }
    int ans = 0;
    for (int i = 0; i < int(v.size()); i++) {
      ans = max(ans, v[i] / 2);
    }
    for (int i = 1; i < int(v.size()); i++) {
      ans = max(ans, min(v[i - 1], v[i]));
    }
    return ans;
  }
};

#ifdef B01
int main() {
  Solution sl;
}
#endif
",1448229414
BERNARD BRAHIMCHA,BERNARB01,42,3631,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

const int md = int(1e9) + 7;

inline void add(int& a, int b) {
  a += b;
  if (a >= md) a -= md;
}

inline void sub(int& a, int b) {
  a -= b;
  if (a < 0) a += md;
}

inline int mul(int a, int b) {
  return int(int64_t(a) * b % md);
}

int n, k;
string s;
int dp[801][801][2];
int dp2[801][5];

int sol2(int i, int j) {
  int& ret = dp2[i][j];
  if (ret != -1) {
    return ret;
  }
  if (j == 0) {
    ret = (i == 1);
  } else {
    ret = sol2(__builtin_popcount(i), j - 1);
  }
  return ret;
}

int sol(int i, int j, int e) {
  if (i == n) {
    return (e == 0 && j > 0 ? sol2(j, k - 1) : 0);
  }
  int& ret = dp[i][j][e];
  if (ret != -1) {
    return ret;
  }
  ret = 0;
  if (e) {
    if (s[i] == '1') {
      add(ret, sol(i + 1, j, 0));
      add(ret, sol(i + 1, j + 1, e));
    } else {
      add(ret, sol(i + 1, j, e));
    }
  } else {
    add(ret, sol(i + 1, j, 0));
    add(ret, sol(i + 1, j + 1, 0));
  }
  return ret;
}

class Solution {
 public:
  int countKReducibleNumbers(string s_, int k_) {
    s = s_;
    k = k_;
    n = int(s.length());
    memset(dp, -1, sizeof dp);
    memset(dp2, -1, sizeof dp2);
    return sol(0, 0, 1);
  }
};

#ifdef B01
int main() {
  Solution sl;
  deb(sl.countKReducibleNumbers(""1000"", 2));
}
#endif
",1448212713
BERNARD BRAHIMCHA,BERNARB01,42,3646,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

const int md = int(1e9) + 7;

inline void add(int& a, int b) {
  a += b;
  if (a >= md) a -= md;
}

inline void sub(int& a, int b) {
  a -= b;
  if (a < 0) a += md;
}

inline int mul(int a, int b) {
  return int(int64_t(a) * b % md);
}

class Solution {
 public:
  int sumOfGoodSubsequences(vector<int>& a) {
    int n = int(a.size());
    const int N = int(1e5) + 1;
    vector<int> cnt(N);
    vector<int> sum(N);
    for (int i = 0; i < n; i++) {
      int z = 1;
      int x = 0;
      if (a[i] > 0) {
        add(z, cnt[a[i] - 1]);
        add(x, sum[a[i] - 1]);
      }
      if (a[i] + 1 < N) {
        add(z, cnt[a[i] + 1]);
        add(x, sum[a[i] + 1]);
      }
      add(x, mul(a[i], z));
      add(sum[a[i]], x);
      add(cnt[a[i]], z);
    }
    int res = 0;
    for (int i = 0; i < N; i++) {
      add(res, sum[i]);
    }
    return res;
  }
};

#ifdef B01
int main() {
  Solution sl;
}
#endif
",1448224710
Upayan De,twoplusthree,43,3612,cpp,"class Solution {
public:
  bool hasIncreasingSubarrays(vector<int>& nums, int k) {
    int n = (int)nums.size();
    vector<int> pot;
    int siz = 1;
    for(int i = 1; i < n; i++) {
      if(nums[i - 1] < nums[i]) {
        siz++;
      } else {
        pot.push_back(siz);
        siz = 1;
      }
    }
    pot.push_back(siz);
    int ans = 0;
    int m = pot.size();
    for(int i = 0; i < m; i++) {
      ans = max(ans, pot[i] / 2);
    }
    for(int i = 1; i < m; i++) {
      ans = max(ans, min(pot[i - 1], pot[i]));
    }
    return (k <= ans);
  }
};",1448189233
Upayan De,twoplusthree,43,3619,cpp,"class Solution {
public:
  int maxIncreasingSubarrays(vector<int> &nums) {
    int n = (int)nums.size();
    vector<int> pot;
    int siz = 1;
    for(int i = 1; i < n; i++) {
      if(nums[i - 1] < nums[i]) {
        siz++;
      } else {
        pot.push_back(siz);
        siz = 1;
      }
    }
    pot.push_back(siz);
    int ans = 0;
    int m = pot.size();
    for(int i = 0; i < m; i++) {
      ans = max(ans, pot[i] / 2);
    }
    for(int i = 1; i < m; i++) {
      ans = max(ans, min(pot[i - 1], pot[i]));
    }
    return ans;
  }
};",1448187469
Upayan De,twoplusthree,43,3631,cpp,"class Solution {
public:
  int countKReducibleNumbers(string s, int k) {
    const int MOD = 1e9 + 7;
    int n = (int)s.size();
    vector<vector<int>> dp(n + 1, vector<int>(2, 0));
    dp[0][0] = dp[0][1] = 1;
    for(int i = n - 1; i >= 0; i--) {
      for(int j = n; j >= 0; j--) {
        for(int f = 0; f < 2; f++) {
          if(f) {
            if(j - 1 >= 0) {
              dp[j][1] += dp[j - 1][1];
              dp[j][1] %= MOD;
            }
          } else {
            dp[j][0] = dp[j][s[i] == '1' ? 1 : 0];
            if(s[i] == '1' && j - 1 >= 0) {
              dp[j][0] += dp[j - 1][0];
              dp[j][0] %= MOD;
            }
          }
        }
      }
    }
    vector<int> cnt(n + 1, 0);
    cnt[1] = 0;
    for(int i = 2; i <= n; i++) {
      cnt[i] = 1 + cnt[__builtin_popcount(i)];
    }
    int ans = 0;
    for(int i = 1; i <= n; i++) {
      if(1 + cnt[i] <= k) {
        ans += dp[i][0];
        ans %= MOD;
      }
    }
    int q = 0;
    for(int i = 0; i < n; i++) {
      if(s[i] == '1') {
        q++;
      }
    }
    if(1 + cnt[q] <= k) {
      ans += MOD - 1; ans %= MOD;
    }
    return ans;
  }
};",1448222991
Upayan De,twoplusthree,43,3646,cpp,"class Solution {
public:
  int sumOfGoodSubsequences(vector<int> &nums) {
    const int MOD = 1e9 + 7, _ = 1e5 + 5;
    int n = (int)nums.size();
    vector<int> dpf(n), dpb(n);
    vector<int> f(_, 0);
    for(int i = 0; i < n; i++) {
      dpb[i] = 1;
      if(nums[i] - 1 >= 0) {
        dpb[i] += f[nums[i] - 1]; dpb[i] %= MOD;
      }
      if(nums[i] + 1 < _) {
        dpb[i] += f[nums[i] + 1]; dpb[i] %= MOD;
      }
      f[nums[i]] += dpb[i]; f[nums[i]] %= MOD;
    }
    f.assign(_, 0);
    for(int i = n - 1; i >= 0; i--) {
      dpf[i] = 1;
      if(nums[i] - 1 >= 0) {
        dpf[i] += f[nums[i] - 1]; dpf[i] %= MOD;
      }
      if(nums[i] + 1 < _) {
        dpf[i] += f[nums[i] + 1]; dpf[i] %= MOD;
      }
      f[nums[i]] += dpf[i]; f[nums[i]] %= MOD;
    }
    long long ans = 0;
    for(int i = 0; i < n; i++) {
      long long foo = (long long)dpb[i] * dpf[i]; foo %= MOD;
      foo *= nums[i]; foo %= MOD;
      ans += foo; ans %= MOD;
    }
    return ans;
  }
};",1448205858
Xiaomeng Yang,yangxm,44,3612,cpp,"constexpr int MAX = 128;

int a[MAX];

class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
      int n = nums.size();
      a[0] = 0;
      a[1] = 1;
      for (int i = 1; i < n; ++i) {
        if (nums[i] > nums[i - 1]) {
          a[i + 1] = a[i] + 1;
        } else {
          a[i + 1] = 1;
        }
      }
      for (int i = 1; i <= n; ++i) {
        if (a[i] >= k && a[i - k] >= k) {
          return true;
        }
      }
      return false;
    }
};",1448184619
Xiaomeng Yang,yangxm,44,3619,cpp,"constexpr int MAX = 200010;

int a[MAX];

bool Check(int n, int k) {
  for (int i = 1; i <= n; ++i) {
    if (a[i] >= k && a[i - k] >= k) {
      return true;
    }
  }
  return false;
}

class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
      int n = nums.size();
      a[0] = 0;
      a[1] = 1;
      for (int i = 1; i < n; ++i) {
        if (nums[i] > nums[i - 1]) {
          a[i + 1] = a[i] + 1;
        } else {
          a[i + 1] = 1;
        }
      }
      int l = 1, r = n, ret = -1;
      while (l < r) {
        int mid = l + (r - l) / 2;
        if (Check(n, mid)) {
          ret = mid;
          l = mid + 1;
        } else {
          r = mid;
        }
      }
      return ret;
    }
};",1448188009
Xiaomeng Yang,yangxm,44,3631,cpp,"using i64 = long long;

constexpr int MAX = 1024;
constexpr int INF = 0x3F3F3F3F;
constexpr int MOD = 1000000007;

int w[MAX], d[MAX];
i64 dp[MAX][MAX];

void Init() {
  w[0] = INF;
  w[1] = 0;
  for (int i = 2; i < MAX; ++i) {
    int c = __builtin_popcount(i);
    w[i] = w[c] + 1;
  }
}

i64 DFS(int k, int p, int cnt, bool lim) {
  if (p == -1) {
    return w[cnt] <= k;
  }
  if (!lim && ~dp[p][cnt]) {
    return dp[p][cnt];
  }
  int m = lim ? d[p] : 1;
  i64 ret = 0;
  for (int i = 0; i <= m; ++i) {
    i64 cur = DFS(k, p - 1, cnt + i, lim && i == m);
    ret = (ret + cur) % MOD;
  }
  if (!lim) {
    dp[p][cnt] = ret;
  }
  return ret;
}

class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
      static bool init = []() {
        Init();
        return true;
      }();

      int n = s.length(), cnt = 0;
      for (int i = 0; i < n; ++i) {
        int v = s[i] - '0';
        d[n - 1 - i] = v;
        cnt += v;
      }
      for (int i = 0; i <= n; ++i) {
        fill(dp[i], dp[i] + n + 1, -1);
      }
      i64 ret = DFS(k - 1, n - 1, 0, true);
      if (w[cnt] < k) {
        ret = (ret - 1 + MOD) % MOD;
      }
      return ret;
    }
};",1448223757
Xiaomeng Yang,yangxm,44,3646,cpp,"using i64 = long long;

constexpr int MAX = 100010;
constexpr int MOD = 1000000007;

using i64 = long long;

i64 dp[MAX][2];

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
      int n = nums.size(), m = *max_element(nums.begin(), nums.end());
      memset(dp, 0, sizeof(dp));
      for (int x : nums) {
        dp[x][0] = (dp[x][0] + 1) % MOD;
        dp[x][1] = (dp[x][1] + x) % MOD;
        if (x > 0) {
          dp[x][0] = (dp[x][0] + dp[x - 1][0]) % MOD;
          dp[x][1] = (dp[x][1] + dp[x - 1][1] + dp[x - 1][0] * (i64)x) % MOD;
        }
        if (x < m) {
          dp[x][0] = (dp[x][0] + dp[x + 1][0]) % MOD;
          dp[x][1] = (dp[x][1] + dp[x + 1][1] + dp[x + 1][0] * (i64)x) % MOD;
        }
      }
      int ret = 0;
      for (int i = 0; i <= m; ++i) {
        ret = (ret + dp[i][1]) % MOD;
      }
      return ret;
    }
};",1448203110
Julian,juliany2,45,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();

        vector<int> len(n);
        len[n - 1] = 1;
        for (int i = n - 2; i >= 0; i--) {
            len[i] = (nums[i] < nums[i + 1] ? len[i + 1] + 1 : 1);
        }

        int mid = k;
            bool f = 0;
            for (int i = 0; i + mid < n; i++) {
                f |= len[i] >= mid && len[i + mid] >= mid;
            }

        return f;
    }
};",1448207863
Julian,juliany2,45,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();

        vector<int> len(n);
        len[n - 1] = 1;
        for (int i = n - 2; i >= 0; i--) {
            len[i] = (nums[i] < nums[i + 1] ? len[i + 1] + 1 : 1);
        }

        int lo = 1, hi = n / 2;
        while (lo < hi) {
            int mid = (lo + hi + 1) / 2;

            bool f = 0;
            for (int i = 0; i + mid < n; i++) {
                f |= len[i] >= mid && len[i + mid] >= mid;
            }

            if (f)
                lo = mid;
            else
                hi = mid - 1;
        }
        return lo;
    }
};",1448206635
Julian,juliany2,45,3631,cpp,"class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        const int mod = 1e9 + 7;
        using ll = long long;
        int n = s.size();

        auto binpow = [&](ll x, ll y) {
            ll res = 1;
            for (; y; y >>= 1, (x *= x) %= mod)
                if (y & 1)
                    (res *= x) %= mod;
            return res;
        };

        vector<ll> fac(n + 1), ifac(n + 1);
        fac[0] = ifac[0] = 1;
        for (int i = 1; i <= n; i++) {
            fac[i] = fac[i - 1] * i % mod;
            ifac[i] = binpow(fac[i], mod - 2);
        }
        
        auto nck = [&](int n, int k) {
            return fac[n] * ifac[n - k] % mod * ifac[k] % mod;
        };

        // ways to start with i zeros
        vector<ll> ways(n + 1);

        int seen = 0;
        for (int i = 0; i < n; i++) {
            if (s[i] == '1') {
                int rem = n - i - 1;
                for (int j = 0; j <= rem; j++) {
                    (ways[seen + j] += nck(rem, j)) %= mod;
                    //cout << ""adding: "" << seen + j << ' ' << nck(rem, j) << '\n';
                }
                seen++;
            }
        }

        ll ans = 0;
        for (int i = 1; i <= n; i++) {
            int here = i, steps = 1;
            while (here > 1) {
                here = __builtin_popcount(here);
                steps++;
            }

            if (steps <= k)
                (ans += ways[i]) %= mod;
        }
        return ans;
    }
};",1448193048
Julian,juliany2,45,3646,cpp,"class Solution {
using ll = long long;
ll cnt[100007], sum[100007];

public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        const int mod = 1e9 + 7;

        for (int &x : nums) {
            x += 5;
            sum[x] = cnt[x] = 0;
        }

        ll ans = 0;
        for (int x : nums) {
            ll ways = (cnt[x - 1] + cnt[x + 1] + 1) % mod;
            ll here = (sum[x - 1] + sum[x + 1] + ways * (x - 5) % mod) % mod;
            (ans += here) %= mod;
            (cnt[x] += ways) %= mod;
            (sum[x] += here) %= mod;
        }

        return ans;
    }
};",1448201869
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,46,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        def isinc(x):
            for i in range(len(x) - 1):
                if x[i+1] <= x[i]:
                    return False
            return True
        
        for i in range(len(nums) - 2 * k + 1):
            a, b = nums[i:i+k], nums[i+k:i+2*k]
            if isinc(a) and isinc(b):
                return True
        return False",1448183128
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,46,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        inc = []
        cur = -inf
        r = 0
        for x in nums:
            if x > cur:
                r += 1
            else:
                r = 1
            cur = x
            inc.append(r)

        def check(x):
            for i in range(2*x - 1, len(nums)):
                if inc[i] >= x and inc[i-x] >= x:
                    return True
            return False

        a, b = 1, len(nums)//2
        while a < b:
            mi = (a + b + 1) // 2
            if check(mi):
                a = mi
            else:
                b = mi - 1
        return a",1448193906
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,46,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        MOD = 10**9+7
        
        @cache
        def dist(x):
            if x == 0:
                return inf
            if x == 1:
                return 0
            t = x.bit_count()
            return 1 + dist(t)

        @cache
        def ct(idx, limit, amt):
            if idx == len(s):
                return int(dist(amt) <= k - 1)
            if not limit:
                return (ct(idx+1, False, amt+1) + ct(idx+1, False, amt)) % MOD
            else:
                if idx == len(s) - 1:
                    if s[idx] == '1':
                        return (ct(idx+1, False, amt)) % MOD
                    else:
                        return 0
                else:
                    if s[idx] == '1':
                        return (ct(idx+1, True, amt+1) + ct(idx+1, False, amt)) % MOD
                    else:
                        return ct(idx+1, True, amt)

        return ct(0, True, 0) % MOD
        ",1448232620
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,46,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        MOD = 10**9+7
        ret = 0
        d = defaultdict(int)
        sm = defaultdict(int)
        for x in nums:
            v = d[x-1] + d[x+1] + 1
            s = sm[x-1] + sm[x+1] + v * x
            ret += s
            ret %= MOD
            d[x] += v
            d[x] %= MOD
            sm[x] += s
            sm[x] %= MOD
            # print(d, sm, ret)
        return ret
            ",1448205003
mastoori1234,mastoori1234,48,3612,cpp,"typedef long long int ll;

class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& arr, int k) {
        
        ll n = arr.size();
        
        vector<ll> dp( n, 1);
        
        for( ll i=n-2; i>=0; i--) {
            if(arr[i]<arr[i+1]) {
                dp[i] += dp[i+1];
            }
        }
        
        ll sv = k;
        ll ev = k;
        ll ans = 1;
        
        while(sv<=ev) {
            ll mv = (sv+ev)/2;
            bool f = false;
            for( ll i=0; i+mv<n; i++) {
                f = f || ((dp[i]>=mv) && (dp[i+mv]>=mv));
            }
            if(f) {
                return true;
            } else {
                ev = mv - 1;
            }
        }
        
        return false;     
    }
};",1448233240
mastoori1234,mastoori1234,48,3619,cpp,"typedef long long int ll;

class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& arr) {
        
        ll n = arr.size();
        
        vector<ll> dp( n, 1);
        
        for( ll i=n-2; i>=0; i--) {
            if(arr[i]<arr[i+1]) {
                dp[i] += dp[i+1];
            }
        }
        
        ll sv = 1;
        ll ev = n/2;
        ll ans = 1;
        
        while(sv<=ev) {
            ll mv = (sv+ev)/2;
            bool f = false;
            for( ll i=0; i+mv<n; i++) {
                f = f || ((dp[i]>=mv) && (dp[i+mv]>=mv));
            }
            if(f) {
                ans = max( ans, mv);
                sv = mv + 1;
            } else {
                ev = mv - 1;
            }
        }
        
        return ans;
    }
};",1448231246
mastoori1234,mastoori1234,48,3631,cpp,"typedef long long int ll;


class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        
        ll ans = 0;
        
        ll n = s.length();
        const ll mod = 1e9+7;
        
        reverse( s.begin(), s.end());
        
        vector<bool> v(n+1, false);
        
        /*
            idx, bit, sum, 
        */
        vector< vector< vector<ll> > > dp( n, vector< vector<ll> >( 2, vector<ll>(n+1, 0)));
        
        v[1] = true;
        
        for( ll i=1; i<k; i++) {
            for( ll j=n; j>=1; j--) {
                int bc = __builtin_popcount(j);
                v[j] = v[j] || v[bc];
            }   
        }
        
        // for( ll i=1; i<=n; i++) {
        //     if(v[i]) {
        //         cout << i << "" "";
        //     }
        // }
        // cout << ""\n"";
        
        dp[0][1][1] = 1;
        dp[0][0][0] = 1;
        
        for( ll idx=1; idx<n; idx++) {
            for( ll bit=0; bit<2; bit++) {
                for( ll sum=0; sum<=n; sum++) {
                    for( ll nbit=0; nbit<2; nbit++) {
                        if(sum+nbit<=n) {
                            ll & val = dp[idx][nbit][sum+nbit];
                            val += dp[idx-1][bit][sum];
                            val %= mod;
                        }
                    }
                }
            }
        }
        
        for( ll idx=0; idx+1<n; idx++) {
            for( ll sum=1; sum<=n; sum++) {
                ans += (v[sum]*dp[idx][1][sum]);
                ans %= mod;
            }
        }
        
        ll tot = 0;
        for( ll idx=n-1; idx>=0; idx--) {
            if((s[idx]=='1') && (idx<n-1)) {
                for( ll sum=0; sum<=n; sum++) {
                    if((sum+tot<=n) && v[sum+tot]) {
                        ans += dp[idx][0][sum];
                        ans %= mod;
                    }
                }
            }
            tot += (s[idx]=='1'); 
        }
        
        // ans += tot;
        // ans %= mod;
        
        return ans;
    }
};",1448218341
mastoori1234,mastoori1234,48,3646,cpp,"typedef long long int ll;

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& arr) {
        
        ll ans = 0;
        
        const ll mod = 1e9+7;
        
        unordered_map<ll,ll> smp;
        unordered_map<ll,ll> cmp;
        
        for( ll v: arr) {
            ll s = smp[v-1] + smp[v+1];
            ll c = cmp[v-1] + cmp[v+1];
            
            ll ns = s + c*v + v;
            ll nc = c + 1;
            
            ns%=mod;
            nc%=mod;
            
            ans += ns;
            ans %= mod;
            
            smp[v] += ns;
            smp[v] %= mod;
            
            cmp[v] += nc;
            cmp[v] %= mod;
        }
        
        return ans;
    }
};",1448226545
Abhishek Srivastava,Abhi_Srivastava,50,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        for (int i = 0; i + k * 2 <= nums.size(); i++) {
            bool poss = 1;
            for (int j = i + 1; j < i + k; j++)
                if (nums[j] <= nums[j - 1]) {
                    poss = 0;
                    break;
                }
            for (int j = i + k + 1; j < i + k * 2; j++)
                if (nums[j] <= nums[j - 1]) {
                    poss = 0;
                    break;
                }
            if (poss)
                return 1;
        }
        return 0;
    }
};",1448182706
Abhishek Srivastava,Abhi_Srivastava,50,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        vector<int> vec;
        int curr = 1, res;
        for (int i = 1; i < nums.size(); i++) {
            if (nums[i] <= nums[i - 1]) {
                vec.push_back(curr);
                curr = 0;
            }
            curr++;
        }
        vec.push_back(curr);
        res = *max_element(vec.begin(), vec.end()) / 2;
        for (int i = 1; i < vec.size(); i++)
            res = max(res, min(vec[i], vec[i - 1]));
        return res;
    }
};",1448186301
Abhishek Srivastava,Abhi_Srivastava,50,3631,cpp,"const int mod = 1e9 + 7;

bool reducible(int num, int k) {
    for (int i = 0; i < k; i++) 
        num = __builtin_popcount(num);
    return (num == 1);
}

class Solution {
public:
    long long solve(int ind, string& s, bool tight, int setBits, int k, vector<vector<vector<int>>>& dp) {
        if (ind == s.size())
            return reducible(setBits, k);
        if (dp[tight][setBits][ind] != -1)
            return dp[tight][setBits][ind];
        long long res;
        if (tight) {
            if (s[ind] == '0')
                res = solve(ind + 1, s, 1, setBits, k, dp);
            else 
                res = (solve(ind + 1, s, 0, setBits, k, dp) + solve(ind + 1, s, 1, setBits + 1, k, dp)) % mod;
        }
        else 
            res = (solve(ind + 1, s, 0, setBits, k, dp) + solve(ind + 1, s, 0, setBits + 1, k, dp)) % mod;
        return dp[tight][setBits][ind] = res;
    }
    int countKReducibleNumbers(string s, int k) {
        int n = s.size(), bitCnt = 0;
        for (char x : s)
            bitCnt += (x - '0');
        vector<vector<vector<int>>> dp(2, vector<vector<int>>(n + 1, vector<int>(n, -1)));
        return (solve(0, s, 1, 0, k - 1, dp) + mod - reducible(bitCnt, k - 1)) % mod;
    }
};",1448233343
Abhishek Srivastava,Abhi_Srivastava,50,3646,cpp,"const int mod = 1e9 + 7;
class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        map<int, long long> mp, num;
        long long ans = 0;
        for (int x : nums) {
            long long res = x, sub = 1;
            if (mp.find(x + 1) != mp.end()) {
                (res += mp[x + 1]) %= mod;
                (res += num[x + 1] * x) %= mod;
                (sub += num[x + 1]) %= mod;
            }
            if (mp.find(x - 1) != mp.end()) {
                (res += mp[x - 1]) %= mod;
                (res += num[x - 1] * x) %= mod;
                (sub += num[x - 1]) %= mod;
            }
            (num[x] += sub) %= mod;
            (ans += res) %= mod;
            (mp[x] += res) %= mod;
        }
        return ans;
    }
};",1448205705
OTTFF,OTTFF,51,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& a, int k) {
        int n = a.size();
        vector<int> b;
        for (int i = 0; i + k - 1 < n; i++) {
            int f = 1;
            for (int j = i + 1; j < i + k; j++) {
                if (a[j - 1] >= a[j]) {
                    f = 0;
                    break;
                }
            }
            b.push_back(f);
        }
        n = b.size();
        for (int i = 0; i + k < n; i++) {
            if (b[i] && b[i + k]) {
                return true;
            }
        }
        return false;
    }
};",1448183064
OTTFF,OTTFF,51,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& a) {
        int n = a.size();

        vector<int> l(n), r(n);
        l[0] = r[n - 1] = 1;

        for (int i = 1; i < n; i++) {
            if (a[i - 1] < a[i]) {
                l[i] = l[i - 1] + 1;
            } else {
                l[i] = 1;
            }
        }
        for (int i = n - 2; i >= 0; i--) {
            if (a[i] < a[i + 1]) {
                r[i] = r[i + 1] + 1;
            } else {
                r[i] = 1;
            }
        }

        int ans = 0;
        for (int i = 0; i + 1 < n; i++) {
            ans = max(ans, min(l[i], r[i + 1]));
        }
        return ans;
    }
};",1448186726
OTTFF,OTTFF,51,3631,cpp,"template<long long Mo=998244353> struct ModInt {
  static long long MO;
  static void setMo(long long mo) { MO = mo; }
  long long x;
  ModInt(long long x=0) : x(x){ norm(); }
  friend istream &operator>>(istream& in, ModInt &B) { in>>B.x; return in; }
  friend ostream &operator<<(ostream& out, const ModInt &B) { 
    out<<B.x; return out; }
  // ModInt operator=(int x_) { x=x_; norm(); return *this; }
  void norm() { x = (x%MO + MO) % MO; }
  long long get() { return x; }

  ModInt operator-() const { return ModInt(MO - x); }
  ModInt operator+=(const ModInt &B) { x+=B.x; if(x>=MO) x-=MO; return *this; }
  ModInt operator-=(const ModInt &B) { x-=B.x; if(x<0) x+=MO; return *this; }
  ModInt operator*=(const ModInt &B) { x=x*B.x%MO; return *this; }
  ModInt operator+(const ModInt &B) const { ModInt ans=*this; return ans+=B; }
  ModInt operator-(const ModInt &B) const { ModInt ans=*this; return ans-=B; }
  ModInt operator*(const ModInt &B) const { ModInt ans=*this; return ans*=B; }
  ModInt operator^(long long n) const  {
    ModInt a=*this; ModInt ans(1);
    while(n) { if(n&1) ans*=a; a*=a; n>>=1; }
    return ans;
  }
  ModInt inv() const { return (*this)^(MO-2); } // if MO is prime
  ModInt operator/=(const ModInt &B) { (*this)*=B.inv(); return *this; }
  ModInt operator/(const ModInt &B) const { ModInt ans=*this; return ans/=B; }

  bool operator<(const ModInt &B) const { return x<B.x; }
  bool operator==(const ModInt &B) const { return x==B.x; }
  bool operator!=(const ModInt &B) const { return x!=B.x; }
};
template<long long Mo> long long ModInt<Mo>::MO = Mo;
// typedef ModInt<998244353> Mint;
typedef ModInt<1'000'000'007> Mint;

int f = 0;
const int M = 805;
int cnt[M];
void init() {
    if (f) return;
    f = 1;

    for (int i = 2; i < M; i++) {
        cnt[i] = cnt[__builtin_popcount(i)] + 1;
    }
}

Mint dp[M][M][2];
int vis[M][M][2];

class Solution {
public:
    string s;
    int n;

    Mint dfs(int cur, int cnt, int lim) {
        if (cnt < 0) return 0;
        if (cur == n) {
            if (cnt == 0) return 1;
            else return 0;
        }
        if (vis[cur][cnt][lim]) return dp[cur][cnt][lim];
        vis[cur][cnt][lim] = 1;
        dp[cur][cnt][lim] = 0;
        int up = lim ? (s[cur] - '0') : 1;
        for (int i = 0; i <= up; i++) {
            dp[cur][cnt][lim] += dfs(cur + 1, cnt - i, lim && i == up);
        }
        // cout << cur << ' ' << cnt << ' ' << lim << ' ' << dp[cur][cnt][lim] << endl;
        return dp[cur][cnt][lim];
    }

    void solve() {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j <= n; j++) {
                vis[i][j][0] = vis[i][j][1] = 0;
            }
        }
    }

    int countKReducibleNumbers(string s, int k) {
        init();
        
        this->s = s;
        this->n = s.length();

        solve();

        Mint ans = 0;
        for (int i = 1; i <= n; i++) {
            // cout << i << ' ' << cnt[i] << endl;
            if (cnt[i] + 1 <= k) {
                ans += dfs(0, i, 1);
            }
        }

        int c = 0;
        for (int i = 0; i < n; i++) {
            if (s[i] == '1') c++;
        }
        if (cnt[c] + 1 <= k) {
            ans.x -= 1;
        }
        return ans.x;
    }
};",1448233359
OTTFF,OTTFF,51,3646,cpp,"template<long long Mo=998244353> struct ModInt {
  static long long MO;
  static void setMo(long long mo) { MO = mo; }
  long long x;
  ModInt(long long x=0) : x(x){ norm(); }
  friend istream &operator>>(istream& in, ModInt &B) { in>>B.x; return in; }
  friend ostream &operator<<(ostream& out, const ModInt &B) { 
    out<<B.x; return out; }
  // ModInt operator=(int x_) { x=x_; norm(); return *this; }
  void norm() { x = (x%MO + MO) % MO; }
  long long get() { return x; }

  ModInt operator-() const { return ModInt(MO - x); }
  ModInt operator+=(const ModInt &B) { x+=B.x; if(x>=MO) x-=MO; return *this; }
  ModInt operator-=(const ModInt &B) { x-=B.x; if(x<0) x+=MO; return *this; }
  ModInt operator*=(const ModInt &B) { x=x*B.x%MO; return *this; }
  ModInt operator+(const ModInt &B) const { ModInt ans=*this; return ans+=B; }
  ModInt operator-(const ModInt &B) const { ModInt ans=*this; return ans-=B; }
  ModInt operator*(const ModInt &B) const { ModInt ans=*this; return ans*=B; }
  ModInt operator^(long long n) const  {
    ModInt a=*this; ModInt ans(1);
    while(n) { if(n&1) ans*=a; a*=a; n>>=1; }
    return ans;
  }
  ModInt inv() const { return (*this)^(MO-2); } // if MO is prime
  ModInt operator/=(const ModInt &B) { (*this)*=B.inv(); return *this; }
  ModInt operator/(const ModInt &B) const { ModInt ans=*this; return ans/=B; }

  bool operator<(const ModInt &B) const { return x<B.x; }
  bool operator==(const ModInt &B) const { return x==B.x; }
  bool operator!=(const ModInt &B) const { return x!=B.x; }
};
template<long long Mo> long long ModInt<Mo>::MO = Mo;
// typedef ModInt<998244353> Mint;
typedef ModInt<1'000'000'007> Mint;

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        map<int, Mint> cnt;
        map<int, Mint> dp;

        Mint ans = 0;
        for (int i : nums) {
            cnt[i] += cnt[i - 1];
            cnt[i] += cnt[i + 1];
            cnt[i] += 1;

            dp[i] += dp[i - 1] + cnt[i - 1] * i;
            dp[i] += dp[i + 1] + cnt[i + 1] * i;
            dp[i] += i;
            
            // ans += dp[i];
            // cout << i << ' ' << cnt[i] << ' ' << dp[i] << ' ' << ans << endl;
        }
        for (auto [v, c] : dp) {
            ans += c;
        }
        return ans.x;
    }
};",1448201741
Brian Law,lwm7708,54,3612,cpp,"#include <algorithm>
#include <cstdint>
#include <vector>

class Solution {

public:

    bool hasIncreasingSubarrays(std::vector<int>& nums, int k) {

        const std::int32_t n = std::size(nums);

        for (std::int32_t i = 0; i < n; ++i) {
            nums[i] -= i;
        }

        for (std::int32_t i = 0; i <= n - k * 2; ++i) {
            if (
                std::is_sorted(std::begin(nums) + i, std::begin(nums) + i + k) &&
                std::is_sorted(std::begin(nums) + i + k, std::begin(nums) + i + k * 2)
            ) {
                return true;
            }
        }

        return false;

    }

};
",1448183549
Brian Law,lwm7708,54,3619,cpp,"#include <algorithm>
#include <cstdint>
#include <vector>

class Solution {

public:

    int maxIncreasingSubarrays(std::vector<int>& nums) {

        std::int32_t mx = 0;
        const std::int32_t n = std::size(nums);

        std::vector<std::int32_t> dp_1(n);
        std::vector<std::int32_t> dp_2(n);

        dp_1[0] = 1;
        dp_2[n - 1] = 1;

        for (std::int32_t i = 1; i < n; ++i) {
            dp_1[i] = nums[i] > nums[i - 1] ? dp_1[i - 1] + 1 : 1;
        }

        for (std::int32_t i = n - 2; i >= 0; --i) {
            dp_2[i] = nums[i] < nums[i + 1] ? dp_2[i + 1] + 1 : 1;
        }

        for (std::int32_t i = 0; i < n - 1; ++i) {
            mx = std::max(mx, std::min(dp_1[i], dp_2[i + 1]));
        }

        return mx;

    }

};
",1448188883
Brian Law,lwm7708,54,3631,cpp,"#include <array>
#include <cstdint>
#include <string>
#include <utility>
#include <vector>

template <typename T>
std::array<T, 3> extended_gcd(T m, T n) {

    T a = 1;
    T a_in = 0;
    T b = 0;
    T b_in = 1;

    while (n) {
        const T q = m / n;
        a_in = std::exchange(a, a_in) - a_in * q;
        b_in = std::exchange(b, b_in) - b_in * q;
        n = std::exchange(m, n) - n * q;
    }

    return std::array<T, 3>({m, a, b});

}

template <std::int32_t MOD>
class modular_integer {

private:

    static constexpr std::int32_t MODULUS = MOD;

public:

    static std::int32_t get_modulus() {

        return MODULUS;

    }

    std::int32_t val;

    explicit modular_integer() : modular_integer(0) {}

    explicit modular_integer(std::int64_t val) : val(val % get_modulus()) {

        if (this->val < 0) {
            this->val += get_modulus();
        }

    }

    modular_integer operator-() const {

        return modular_integer(-val);

    }

    void operator++() {

        *this += modular_integer(1);

    }

    void operator--() {

        *this -= modular_integer(1);

    }

    void operator+=(modular_integer other) {

        if (other.val >= get_modulus() - val) {
            val -= get_modulus();
        }

        val += other.val;

    }

    void operator-=(modular_integer other) {

        val -= other.val;

        if (val < 0) {
            val += get_modulus();
        }

    }

    void operator*=(modular_integer other) {

        val = (std::int64_t(val) * other.val) % get_modulus();

    }

    void operator/=(modular_integer other) {

        *this *= modular_integer(extended_gcd(other.val, get_modulus())[1]);

    }

    friend modular_integer operator+(modular_integer lhs, modular_integer rhs) {

        lhs += rhs;

        return lhs;

    }

    friend modular_integer operator-(modular_integer lhs, modular_integer rhs) {

        lhs -= rhs;

        return lhs;

    }

    friend modular_integer operator*(modular_integer lhs, modular_integer rhs) {

        lhs *= rhs;

        return lhs;

    }

    friend modular_integer operator/(modular_integer lhs, modular_integer rhs) {

        lhs /= rhs;

        return lhs;

    }

};

class Solution {

public:

    int countKReducibleNumbers(std::string s, int k) {

        static constexpr std::int32_t MOD = 1000000007;

        using num_t = modular_integer<MOD>;

        num_t cnt;
        const std::int32_t sz = std::size(s);

        std::vector<std::array<num_t, 3>> dp(sz + 1);

        dp[0][1] = num_t(1);

        for (std::int32_t i = sz - 1; i >= 0; --i) {
            std::vector<std::array<num_t, 3>> n_dp(sz + 1);
            for (std::int32_t j = 0; j < sz; ++j) {
                for (std::int32_t l = 0; l < 2; ++l) {
                    for (std::int32_t m = 0; m < 3; ++m) {
                        std::int32_t st = m;
                        if (l == 0 && s[i] == '1') {
                            st = 0;
                        } else if (l == 1 && s[i] == '0') {
                            st = 1;
                        }
                        n_dp[j + l][st] += dp[j][m];
                    }
                }
            }
            dp = std::move(n_dp);
        }

        for (std::int32_t i = 1; i <= sz; ++i) {
            std::int32_t bits = i;
            for (std::int32_t j = 0; j < k - 1; ++j) {
                bits = __builtin_popcount(bits);
            }
            if (bits == 1) {
                cnt += dp[i][0];
            }
        }

        return cnt.val;

    }

};
",1448234244
Brian Law,lwm7708,54,3646,cpp,"#include <algorithm>
#include <array>
#include <cstdint>
#include <numeric>
#include <utility>
#include <vector>

template <typename T>
std::array<T, 3> extended_gcd(T m, T n) {

    T a = 1;
    T a_in = 0;
    T b = 0;
    T b_in = 1;

    while (n) {
        const T q = m / n;
        a_in = std::exchange(a, a_in) - a_in * q;
        b_in = std::exchange(b, b_in) - b_in * q;
        n = std::exchange(m, n) - n * q;
    }

    return std::array<T, 3>({m, a, b});

}

template <std::int32_t MOD>
class modular_integer {

private:

    static constexpr std::int32_t MODULUS = MOD;

public:

    static std::int32_t get_modulus() {

        return MODULUS;

    }

    std::int32_t val;

    explicit modular_integer() : modular_integer(0) {}

    explicit modular_integer(std::int64_t val) : val(val % get_modulus()) {

        if (this->val < 0) {
            this->val += get_modulus();
        }

    }

    modular_integer operator-() const {

        return modular_integer(-val);

    }

    void operator++() {

        *this += modular_integer(1);

    }

    void operator--() {

        *this -= modular_integer(1);

    }

    void operator+=(modular_integer other) {

        if (other.val >= get_modulus() - val) {
            val -= get_modulus();
        }

        val += other.val;

    }

    void operator-=(modular_integer other) {

        val -= other.val;

        if (val < 0) {
            val += get_modulus();
        }

    }

    void operator*=(modular_integer other) {

        val = (std::int64_t(val) * other.val) % get_modulus();

    }

    void operator/=(modular_integer other) {

        *this *= modular_integer(extended_gcd(other.val, get_modulus())[1]);

    }

    friend modular_integer operator+(modular_integer lhs, modular_integer rhs) {

        lhs += rhs;

        return lhs;

    }

    friend modular_integer operator-(modular_integer lhs, modular_integer rhs) {

        lhs -= rhs;

        return lhs;

    }

    friend modular_integer operator*(modular_integer lhs, modular_integer rhs) {

        lhs *= rhs;

        return lhs;

    }

    friend modular_integer operator/(modular_integer lhs, modular_integer rhs) {

        lhs /= rhs;

        return lhs;

    }

};

class Solution {

public:

    int sumOfGoodSubsequences(std::vector<int>& nums) {

        static constexpr std::int32_t MOD = 1000000007;

        using num_t = modular_integer<MOD>;

        const std::int32_t mx = *std::max_element(std::begin(nums), std::end(nums));
        const std::int32_t sz = std::size(nums);

        std::vector<num_t> dp(mx + 1);
        std::vector<num_t> sums(sz);

        for (std::int32_t i = 0; i < sz; ++i) {
            const num_t prv = dp[nums[i]];
            if (nums[i]) {
                dp[nums[i]] += dp[nums[i] - 1];
            }
            if (nums[i] < mx) {
                dp[nums[i]] += dp[nums[i] + 1];
            }
            ++dp[nums[i]];
            sums[i] = dp[nums[i]] - prv;
        }

        std::fill_n(std::begin(dp), mx + 1, num_t());

        for (std::int32_t i = sz - 1; i >= 0; --i) {
            const num_t prv = dp[nums[i]];
            if (nums[i]) {
                dp[nums[i]] += dp[nums[i] - 1];
            }
            if (nums[i] < mx) {
                dp[nums[i]] += dp[nums[i] + 1];
            }
            ++dp[nums[i]];
            sums[i] *= dp[nums[i]] - prv;
        }

        for (std::int32_t i = 0; i < sz; ++i) {
            sums[i] *= num_t(nums[i]);
        }

        return std::accumulate(std::begin(sums), std::end(sums), num_t()).val;

    }

};
",1448208806
megaspazz,megaspazz,55,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        def isIncreasing(arr):
            for i in range(1, len(arr)):
                if arr[i - 1] >= arr[i]:
                    return False
            return True
        
        N = len(nums)
        
        for i in range(0, N):
            if i + 2 * k > N:
                break
            if isIncreasing(nums[i:i+k]) and isIncreasing(nums[i+k:i+k+k]):
                return True
        return False",1448183117
megaspazz,megaspazz,55,3619,java,"class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        final int[] A = toIntArray(nums);
        final int N = A.length;
        
        IntDeque incrsLst = new IntDeque();
        int curr = 1;
        for (int i = 1; i < N; ++i) {
            if (A[i] <= A[i - 1]) {
                incrsLst.add(curr);
                curr = 1;
            } else {
                ++curr;
            }
        }
        incrsLst.add(curr);
        
        final int[] incrs = incrsLst.toArray();
        final int K = incrs.length;
        
        int best = 1;
        for (int x : incrs) {
            best = Math.max(best, x >> 1);
        }
        for (int i = 1; i < K; ++i) {
            best = Math.max(best, Math.min(incrs[i - 1], incrs[i]));
        }
        return best;
    }
    
	/**
	 * Circular buffer of int values, can be used as:
	 *   - ArrayList: values are added to end.
	 *   - Queue: values are added to end and removed from front.
	 *   - Stack: values are added to and removed from front.
	 */
	public static class IntDeque {
		private int[] arr;
		private int off;
		private int len;

		public IntDeque() {
			this(2);
		}

		public IntDeque(int capacity) {
			this.arr = new int[capacity];
		}

		public void addFirst(int x) {
			if (len == arr.length) {
				increaseCapacity();
			}
			if (off == 0) {
				off = arr.length;
			}
			arr[--off] = x;
			++len;
		}

		public void addLast(int x) {
			if (len == arr.length) {
				increaseCapacity();
			}
			int idx = index(off + len);
			arr[idx] = x;
			++len;
		}

		public int peekFirst() {
			return arr[off];
		}

		public int peekLast() {
			int idx = index(off + len - 1);
			return arr[idx];
		}

		public int removeFirst() {
			int ans = peekFirst();
			off = index(off + 1);
			--len;
			return ans;
		}

		public int removeLast() {
			int ans = peekLast();
			--len;
			return ans;
		}

		public void add(int x) {
			addLast(x);
		}

		public void offer(int x) {
			addLast(x);
		}

		public int poll() {
			return removeFirst();
		}

		public void push(int x) {
			addFirst(x);
		}

		public int pop() {
			return removeFirst();
		}

		public int peek() {
			return peekFirst();
		}

		public int get(int i) {
			if (i >= len) {
				throw new ArrayIndexOutOfBoundsException(String.format(""index %d out of range [0, %d)"", i, len));
			}
			int idx = index(i + off);
			return arr[idx];
		}

		public void set(int i, int x) {
			if (i >= len) {
				throw new ArrayIndexOutOfBoundsException(String.format(""index %d out of range [0, %d)"", i, len));
			}
			int idx = index(i + off);
			arr[idx] = x;
		}

		public int size() {
			return len;
		}

		public boolean isEmpty() {
			return size() == 0;
		}

		public int[] toArray() {
			if (len == 0) {
				return new int[0];
			}
			int idx = index(off + len);
			if (idx > off) {
				return Arrays.copyOfRange(arr, off, idx);
			}
			int[] A = new int[len];
			int endLen = arr.length - off;
			int startLen = len - endLen;
			System.arraycopy(arr, off, A, 0, endLen);
			System.arraycopy(arr, 0, A, endLen, startLen);
			return A;
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder();
			sb.append('[');
			printToBuffer(sb, "", "");
			sb.append(']');
			return sb.toString();
		}

		private void increaseCapacity() {
			int[] next = new int[arr.length << 1];
			int endLen = arr.length - off;
			System.arraycopy(arr, off, next, 0, endLen);
			System.arraycopy(arr, 0, next, endLen, off);
			arr = next;
			off = 0;
		}

		private int index(int i) {
			if (i >= arr.length) {
				i -= arr.length;
			} else if (i < 0) {
				i += arr.length;
			}
			return i;
		}

		private void printToBuffer(StringBuilder sb, CharSequence sep) {
			for (int i = 0; i < len; ++i) {
				if (i > 0) {
					sb.append(sep);
				}
				sb.append(get(i));
			}
		}

		public static IntDeque of(int... arr) {
			IntDeque deq = new IntDeque();
			for (int x : arr) {
				deq.add(x);
			}
			return deq;
		}
	}
    
    private static int[] toIntArray(List<Integer> lst) {
        final int N = lst.size();
        
        int[] A = new int[N];
        int idx = 0;
        for (int x : lst){
            A[idx++] = x;
        }
        return A;
    }
}",1448188661
megaspazz,megaspazz,55,3631,java,"class Solution {
    private static final int MOD = 1_000_000_007;
    
    private static final int[] R = new int[801];
    static {
        R[0] = 999_999;
        
        for (int i = 2; i < R.length; ++i) {
            R[i] = 1 + R[Integer.bitCount(i)];
        }
    }
    
    private static final long[][] C = computeCombinations(800, MOD);
    
    public int countKReducibleNumbers(String s, int k) {
        return (int) count(s, k, 0);
    }
    
    private static long count(String s, int k, int extraBits) {
        if (s.length() == 0) {
            return 0;
        }
        
        if (s.charAt(0) == '0') {
            return count(s.substring(1), k, extraBits);
        }
        
        long ans = 0;
        int bits = s.length() - 1;
        for (int b = 0; b <= bits; ++b) {
            if (1 + R[b + extraBits] <= k) {
                ans = add(ans, C[bits][b]);
            }
        }
        
        ans = add(ans, count(s.substring(1), k, extraBits + 1));
        
        return ans;
    }

	/**
	 * Computes all the combinations (i.e. Pascal's triangle) for the given levels, modulo some number.
	 * For example, combos[n][k] = (n choose k) % mod.
	 */
	public static long[][] computeCombinations(int n, int mod) {
		long[][] combos = new long[n + 1][n + 1];
		combos[0][0] = 1;
		for (int r = 1; r <= n; r++) {
			combos[r][0] = 1;
			for (int c = 1; c <= r; c++) {
				combos[r][c] = (combos[r - 1][c - 1] + combos[r - 1][c]) % mod;
			}
		}
		return combos;
	}
    
    private static final long RAW_MULTIPLY_MAX = 3037000499L;

    private static final int CHUNK_SIZE = Long.SIZE - Long.numberOfLeadingZeros(Long.MAX_VALUE / MOD) - 1;
    private static final long CHUNK_MASK = (1L << CHUNK_SIZE) - 1;

    @SuppressWarnings(""unused"")
    public static long multiply(long a, long b) {
        if (MOD <= RAW_MULTIPLY_MAX) {
            return a * b % MOD;
        }
        return multiplyInternal(a, b);
    }

    public static long multiply(long... arr) {
        long ans = 1;
        for (long x : arr) {
            ans = multiply(ans, x);
        }
        return ans;
    }

    public static long add(long a, long b) {
        long ans = a + b;
        if (ans >= MOD) {
            ans -= MOD;
        }
        return ans;
    }

    public static long add(long... arr) {
        long ans = 0;
        for (long x : arr) {
            ans = add(ans, x);
        }
        return ans;
    }

    public static long subtract(long a, long b) {
        return add(a, MOD - b);
    }

    private static long normalize(long x) {
        if (x <= -MOD || x >= MOD) {
            x %= MOD;
        }
        if (x < 0) {
            x += MOD;
        }
        return x;
    }

    /**
     * Computes the value of (b ^ e) % MOD.
     */
    public static long modPow(long b, long e) {
        long p = b;
        long ans = 1;
        while (e > 0) {
            if ((e & 1) == 1) {
                ans = multiply(ans, p);
            }
            p = multiply(p, p);
            e >>= 1;
        }
        return ans;
    }

    /**
     * Computes the modular inverse, such that: ak % MOD = 1, for some k.
     * See this page for details:  http://rosettacode.org/wiki/Modular_inverse
     */
    public static long modInverse(long a) {
        long b = MOD;
        long x0 = 0, x1 = 1;
        long t, q;

        while (a > 1) {
            q = a / b;

            t = b;
            b = a % b;
            a = t;

            t = x0;
            x0 = x1 - q * x0;
            x1 = t;
        }

        if (x1 < 0) {
            x1 += MOD;
        }
        return x1;
    }

    private static long multiplyInternal(long a, long b) {
        if (a > b) {
            return multiplyInternal(b, a);
        }
        if (a == 0) {
            return 0;
        }

        long ans = 0;
        while (a > 0) {
            long mask = a & CHUNK_MASK;
            if (mask > 0) {
                ans = add(ans, (mask * b) % MOD);
            }
            b = (b << CHUNK_SIZE) % MOD;
            a >>= CHUNK_SIZE;
        }
        return ans;
    }
}",1448234497
megaspazz,megaspazz,55,3646,java,"class Solution {
    private static final int MOD = 1_000_000_007;
    
    public int sumOfGoodSubsequences(int[] nums) {
        HashMap<Integer, Long> count = new HashMap<>();
        HashMap<Integer, Long> sum = new HashMap<>();
        long total = 0;
        for (int x : nums) {
            total = add(total, sum.getOrDefault(x - 1, 0L), multiply(count.getOrDefault(x - 1, 0L), x));
            total = add(total, sum.getOrDefault(x + 1, 0L), multiply(count.getOrDefault(x + 1, 0L), x));
            total = add(total, x);
            count.put(x, add(count.getOrDefault(x, 0L), 1, count.getOrDefault(x - 1, 0L), count.getOrDefault(x + 1, 0L)));
            sum.put(x, add(
                sum.getOrDefault(x, 0L),
                x,
                sum.getOrDefault(x - 1, 0L),
                multiply(count.getOrDefault(x - 1, 0L), x),
                sum.getOrDefault(x + 1, 0L),
                multiply(count.getOrDefault(x + 1, 0L), x)
            ));
            // System.out.format(""x = %d, total = %d, count = %s, sum = %s%n"", x, total, count, sum);
        }
        return (int) total;
    }
    
    private static final long RAW_MULTIPLY_MAX = 3037000499L;

    private static final int CHUNK_SIZE = Long.SIZE - Long.numberOfLeadingZeros(Long.MAX_VALUE / MOD) - 1;
    private static final long CHUNK_MASK = (1L << CHUNK_SIZE) - 1;

    @SuppressWarnings(""unused"")
    public static long multiply(long a, long b) {
        if (MOD <= RAW_MULTIPLY_MAX) {
            return a * b % MOD;
        }
        return multiplyInternal(a, b);
    }

    public static long multiply(long... arr) {
        long ans = 1;
        for (long x : arr) {
            ans = multiply(ans, x);
        }
        return ans;
    }

    public static long add(long a, long b) {
        long ans = a + b;
        if (ans >= MOD) {
            ans -= MOD;
        }
        return ans;
    }

    public static long add(long... arr) {
        long ans = 0;
        for (long x : arr) {
            ans = add(ans, x);
        }
        return ans;
    }

    public static long subtract(long a, long b) {
        return add(a, MOD - b);
    }

    private static long normalize(long x) {
        if (x <= -MOD || x >= MOD) {
            x %= MOD;
        }
        if (x < 0) {
            x += MOD;
        }
        return x;
    }

    /**
     * Computes the value of (b ^ e) % MOD.
     */
    public static long modPow(long b, long e) {
        long p = b;
        long ans = 1;
        while (e > 0) {
            if ((e & 1) == 1) {
                ans = multiply(ans, p);
            }
            p = multiply(p, p);
            e >>= 1;
        }
        return ans;
    }

    /**
     * Computes the modular inverse, such that: ak % MOD = 1, for some k.
     * See this page for details:  http://rosettacode.org/wiki/Modular_inverse
     */
    public static long modInverse(long a) {
        long b = MOD;
        long x0 = 0, x1 = 1;
        long t, q;

        while (a > 1) {
            q = a / b;

            t = b;
            b = a % b;
            a = t;

            t = x0;
            x0 = x1 - q * x0;
            x1 = t;
        }

        if (x1 < 0) {
            x1 += MOD;
        }
        return x1;
    }

    private static long multiplyInternal(long a, long b) {
        if (a > b) {
            return multiplyInternal(b, a);
        }
        if (a == 0) {
            return 0;
        }

        long ans = 0;
        while (a > 0) {
            long mask = a & CHUNK_MASK;
            if (mask > 0) {
                ans = add(ans, (mask * b) % MOD);
            }
            b = (b << CHUNK_SIZE) % MOD;
            a >>= CHUNK_SIZE;
        }
        return ans;
    }
}",1448208285
Arnab Mondal,arnab_97,56,3612,java,"class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        int n = nums.size();
        if (n < 2 * k) {
            return false;
        }
        if (k == 1) {
            return n >= 2;
        }
        int[] inc = new int[n];
        inc[n - 1] = 1; 
        for (int i = n - 2; i >= 0; i--) {
            if (nums.get(i) < nums.get(i + 1)) {
                inc[i] = inc[i + 1] + 1;
            } else {
                inc[i] = 1;
            }
        }
        for (int a = 0; a <= n - 2 * k; a++) {
            if (inc[a] >= k && inc[a + k] >= k) {
                return true;
            }
        }
        return false;
    }
}",1448187637
Arnab Mondal,arnab_97,56,3619,java,"class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        int n = nums.size();
        if (n < 2) {
            return 0;
        }
        int[] inc = new int[n];
        inc[n - 1] = 1; 
        
        for (int i = n - 2; i >= 0; i--) {
            if (nums.get(i) < nums.get(i + 1)) {
                inc[i] = inc[i + 1] + 1;
            } else {
                inc[i] = 1;
            }
        }
        int left = 1;
        int right = n / 2;
        int maxK = 0;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (existsTwoAdjacentSubarrays(inc, n, mid)) {
                maxK = mid;
                left = mid + 1; 
            } else {
                right = mid - 1; 
            }
        }
        
        return maxK;
    }
    private boolean existsTwoAdjacentSubarrays(int[] inc, int n, int k) {
        for (int a = 0; a <= n - 2 * k; a++) {
            if (inc[a] >= k && inc[a + k] >= k) {
                return true;
            }
        }
        return false;
    }
}",1448193047
Arnab Mondal,arnab_97,56,3631,java,"class Solution {
    public int countKReducibleNumbers(String s, int k) {
        final int MOD = 1_000_000_007;
        int len = s.length();
        long[][] C = new long[len + 1][len + 1];
        C[0][0] = 1;
        for(int i = 1; i <= len; i++) {
            C[i][0] = 1;
            for(int j = 1; j <= i; j++) {
                C[i][j] = (C[i-1][j] + C[i-1][j-1]) % MOD;
            }
        }
        int[] steps = new int[len + 1];
        for(int c = 1; c <= len; c++) {
            int current = c;
            int step = 0;
            while(current != 1) {
                current = Integer.bitCount(current);
                step++;
                if(step > k) {
                    break;
                }
            }
            if(current == 1) {
                steps[c] = step;
            }
            else {
                steps[c] = k + 1; // Indicates steps > k
            }
        }
        long[] counts = new long[len + 1];
        int set_bits_so_far = 0;
        for(int i = 0; i < len; i++) {
            if(s.charAt(i) == '1') {
                int remaining_bits = len - i - 1;
                for(int c = 0; c <= remaining_bits; c++) {
                    if(set_bits_so_far + c > len) continue;
                    counts[set_bits_so_far + c] = (counts[set_bits_so_far + c] + C[remaining_bits][c]) % MOD;
                }
                set_bits_so_far++;
            }
        }
        long total = 0;
        for(int c = 1; c <= len; c++) {
            if(steps[c] <= (k - 1)) {
                total = (total + counts[c]) % MOD;
            }
        }
        
        return (int) total;
    }
}
",1448235238
Arnab Mondal,arnab_97,56,3646,java,"class Solution {
    public int sumOfGoodSubsequences(int[] nums) {
        final int MOD = 1_000_000_007;
        int MAX = 100_002;
        long[] count = new long[MAX];
        long[] sum = new long[MAX];
        long totalSum = 0;
        
        for(int num : nums){
            long count_prev1 = 0;
            long sum_prev1 = 0;
            if(num > 0){
                count_prev1 = count[num -1];
                sum_prev1 = sum[num -1];
            }
            long count_prev2 = 0;
            long sum_prev2 = 0;
            if(num +1 < MAX){
                count_prev2 = count[num +1];
                sum_prev2 = sum[num +1];
            }
            long new_count = (1 + count_prev1 + count_prev2) % MOD;
            long new_sum = (num 
                            + (sum_prev1 + count_prev1 * (long)num) % MOD 
                            + (sum_prev2 + count_prev2 * (long)num) % MOD
                           ) % MOD;
            count[num] = (count[num] + new_count) % MOD;
            sum[num] = (sum[num] + new_sum) % MOD;
            
            totalSum = (totalSum + new_sum) % MOD;
        }
        return (int)totalSum;
    }
}",1448201360
veraci2,veraci2,58,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, A: List[int], K: int) -> bool:
        N = len(A)
        def incr(i, j):
            return all(A[k] < A[k+1] for k in range(i, j - 1))
        for i in range(N - 2 * K + 1):
            if incr(i, i + K) and incr(i + K, i + 2 * K):
                return True
        return False",1448185585
veraci2,veraci2,58,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, A: List[int]) -> int:
        B = [A[i] < A[i+1] for i in range(len(A) - 1)]
        pre = B[:]
        for i in range(1, len(B)):
            if pre[i] and pre[i-1]:
                pre[i] += pre[i-1]
        suf = B[:]
        for i in range(len(B) - 2, -1, -1):
            if suf[i] and suf[i+1]:
                suf[i] += suf[i+1]

        ans = 1
        for i in range(1, len(B) - 1):
            cand = min(pre[i-1], suf[i+1]) + 1
            if cand >ans:ans=cand
        return ans",1448189491
veraci2,veraci2,58,3631,python3,"@cache
def brute(N, K):
    if N == 1:
        return 1
    if K == 0:
        return 0
    return brute(bin(N).count('1'), K - 1)

MOD = 10 ** 9 + 7
class Solution:
    def countKReducibleNumbers(self,S,K) -> int:
        A = list(map(int, S))
        N = len(A)
        
        @cache
        def dp(i, tight, s):
            if i == N:
                return 1 if not tight and brute(s, K - 1) else 0

            high = A[i] if tight else 1
            ans = 0
            for d in range(0, high + 1):
                s2 = s + d
                tight2 = tight and d==A[i]
                ans += dp(i+1, tight2, s2)
                ans %= MOD
            return ans

        return dp(0, 1, 0)",1448213684
veraci2,veraci2,58,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, A: List[int]) -> int:
        count = defaultdict(lambda: [0, 0])
        MOD = 10**9 + 7
        ans = 0
        for x in A:
            s1, w1 = count[x-1]
            s2, w2 = count[x+1]
            s0, w0 = count[x]
            s = s0 + s1 + w1 * x + s2 + w2 * x + x
            s %= MOD
            w = w0 + w1 + w2 + 1
            w %= MOD
            count[x] = [s,w]

        for s,w in count.values():
            ans += s
            ans %=MOD
        return ans",1448227573
hxu10,hxu10,61,3612,python,"class Solution(object):
    def hasIncreasingSubarrays(self, nums, k):
        """"""
        :type nums: List[int]
        :type k: int
        :rtype: bool
        """"""
        n = len(nums)
        for i in range(n-2*k+1):
            if nums[i:i+k]==sorted(nums[i:i+k]) and nums[i+k:i+2*k]==sorted(nums[i+k:i+2*k]):
                if len(set(nums[i:i+k]))==k and len(set(nums[i+k:i+2*k]))==k:
                    return True
            
        return False
    ",1448182401
hxu10,hxu10,61,3619,python,"class Solution(object):
    def maxIncreasingSubarrays(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        n = len(nums)
        diff = [nums[i+1]-nums[i] for i in range(n-1)]
        accu = [0]*(n)
        
        for i in range(n-1):
            accu[i] = accu[i-1]
            if diff[i] > 0:  accu[i] += 1
                
        def search(target):
            for i in range(n-2*target-1):
                if accu[i+target-1] - accu[i-1] == target and accu[i+2*target] - accu[i+target] == target:
                    return True
            return False
        
        front = 1
        rear = n //2 + 1
        
        while front < rear:
            mid = front + (rear-front) // 2
            if search(mid):
                front = mid + 1
            else:
                rear = mid
                
        return front 
    
                
                ",1448190229
hxu10,hxu10,61,3631,python,"

MAX = 1001

dp = [0]*(MAX+1)

dp[0] = 100

for i in range(2,MAX+1):
    count = 0
    for c in bin(i)[2:]:
        count += int(c)
    dp[i] = dp[count] + 1
    
    


    
    


    

    

M = 10**9 + 7

    



class Solution(object):
    def countKReducibleNumbers(self, s, k):
        """"""
        :type s: str
        :type k: int
        :rtype: int
        """"""
        
        dic = {}
        n = len(s)
        
        #print(dp[:10])
        
        def getnext(index,flag,pre):
            if index==n:
                if dp[pre] < k:
                    return 1
                return 0
            
            if (index,flag,pre) in dic:
                return dic[(index,flag,pre)]
            
            

            
            res = 0
            if s[index]=='1':
                res += getnext(index+1, flag, pre+1)
                res += getnext(index+1, False, pre)

            else:
                if flag:
                    res = getnext(index+1, True, pre)
                else:
                    res = getnext(index+1, False, pre+1)
                    res += getnext(index+1, False, pre)
            res %= M
            
            dic[(index,flag,pre)] = res
            
            
           # print(index,flag,pre,res)
            return res
        
        
        ans = getnext(0,True,0) % M
        
        
        count = 0
        for c in s:
            count += int(c)
            
        if dp[count] < k:
            ans -= 1
            ans %= M
    
        
        
        return ans 
                    
                    
            
                    
                
                
            

                
            
                    
            
        

            
        
        
        
        ",1448236270
hxu10,hxu10,61,3646,python,"M = 10**9 + 7

class Solution(object):
    def sumOfGoodSubsequences(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        dic = {}
        
        ans = 0
        
        for num in nums:
            count = 1
            accu = 0
            if num - 1 in dic:
                count += dic[num-1][0]
                accu += dic[num-1][1]
            if num + 1 in dic:
                count += dic[num+1][0]
                accu += dic[num+1][1]
            
            accu = (accu + count * num)%M
            
            count %= M
            accu %= M
            if num not in dic: 
                dic[num] = [0,0]
                
            dic[num][0] = (dic[num][0] + count)%M
            dic[num][1] = (dic[num][1] + accu)%M
            
            ans += accu
            ans %= M
            
           # print(num,ans)
            
        return ans
    
            
        
            
                
        ",1448202698
CHANDRAPRABHU,Chandraprabhu,62,3612,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int ans = 0 ;
        int pre = 0,cur = 0;
        int  pre_val = INT_MIN;
        nums.push_back(INT_MIN);
        for(int i: nums){
            if(i>pre_val){
                cur++;
            }
            else{
                ans = max(ans,cur/2);
                ans = max(ans,min(pre,cur));
                pre = cur;
                cur = 1;
            }
            pre_val = i;
        }
        return ans;
    }
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        return maxIncreasingSubarrays(nums)>=k;
    }
};",1448187257
CHANDRAPRABHU,Chandraprabhu,62,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int ans = 0 ;
        int pre = 0,cur = 0;
        int  pre_val = INT_MIN;
        nums.push_back(INT_MIN);
        for(int i: nums){
            if(i>pre_val){
                cur++;
            }
            else{
                ans = max(ans,cur/2);
                ans = max(ans,min(pre,cur));
                pre = cur;
                cur = 1;
            }
            pre_val = i;
        }
        return ans;
    }
};",1448184770
CHANDRAPRABHU,Chandraprabhu,62,3631,cpp,"#define ll long long
const int UL5 = 1e5+10;

const int mod = 1e9+7;
class mint{
    public:
    int val;
    inline mint(){/*val=0;*/}
    inline mint(int _val){ if(_val<mod){ if(_val >=0) val = _val; else { val = _val%mod; if(val<0) val+=mod;} } else val = _val%mod; }
    inline mint(ll _val){ if(_val<mod){ if(_val >=0) val = _val; else { val = _val%mod; if(val<0) val+=mod;} } else val = _val%mod; }
    inline mint& operator+=(const mint& other){ if((val+=other.val) >= mod) val-=mod; return *this; }
    inline mint& operator-=(const mint& other){ if((val-=other.val) < 0) val+=mod; return *this; }
    inline mint& operator*=(const mint& other){ val = ((ll)val*other.val)%mod; return *this; }
    inline mint& operator/=(const mint& other){ (*this)*=inv(other); return *this; }
    inline mint& operator<<=(int exp){ll ans = (ll)val<<exp ; if(ans<mod)val = ans;else val = ans%mod; return *this;}
    inline mint& operator>>=(int exp){val>>=exp; return *this;}
    inline mint& operator%=(const mint& other){val%=other.val;return *this;}
    inline explicit operator bool() const{ return bool(val) ;}
    inline mint inv(mint base,int exp=mod-2) {
        mint res(1);
        while (exp) {
            if (exp&1) res*=base;
            exp >>= 1;
            base *= base;
        }
        return res;
    }
    inline mint& pow(int exp){ return (*this)=exp<0?0:inv(*this,exp); }
};
inline mint operator+(const mint& cur , const mint& other){ return mint(cur)+=other;}
inline mint operator-(const mint& cur , const mint& other){ return mint(cur)-=other;}
inline mint operator*(const mint& cur , const mint& other){ return mint(cur)*=other;}
inline mint operator/(const mint& cur , const mint& other){ return mint(cur)/=other;}
inline bool operator==(const mint& cur , const mint& other){ return cur.val==other.val;}
inline bool operator!=(const mint& cur , const mint& other){ return cur.val!=other.val;}
istream& operator >>(istream& in,mint& other){static ll val;in>>val;other = mint(val);return in; }
ostream& operator <<(ostream& out,const mint& other){ out<<other.val;return out; }

const int UL25 = 810;

mint fac[UL25]={1,1} ;
void fac_init(){
    for(int i = 2;i<UL25;i++) fac[i]=i*fac[i-1];
}
inline mint ncr(int n , int r){ if(r>n)return 0; return fac[n]/fac[r]/fac[n-r]; }


class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        fac_init();
        int n = s.size();
        int dp[UL25] = {};
        for(int i = 2;i<UL25;i++){
            dp[i] = dp[__builtin_popcount(i)]+1;
        }
        mint res = 0;
        int pre_co = 0;
        for(int i = 0 ;i<n;i++){
            if(s[i]=='1'){
                int dig = n-i-1;
                for(int ones = 0 ;ones<=dig;ones++){
                    int cur_ones = pre_co + ones;
                    if(dp[cur_ones]+1<=k){
                        res+=ncr(dig,ones);
                    }
                }
                pre_co+=1;
            }
        }
        res-=1;
        return res.val;
    }
};

",1448228180
CHANDRAPRABHU,Chandraprabhu,62,3646,cpp,"#define ll long long
const int UL5 = 1e5+10;
const int mod = 1e9+7;
class mint{
    public:
    int val;
    inline mint(){/*val=0;*/}
    inline mint(int _val){ if(_val<mod){ if(_val >=0) val = _val; else { val = _val%mod; if(val<0) val+=mod;} } else val = _val%mod; }
    inline mint(ll _val){ if(_val<mod){ if(_val >=0) val = _val; else { val = _val%mod; if(val<0) val+=mod;} } else val = _val%mod; }
    inline mint& operator+=(const mint& other){ if((val+=other.val) >= mod) val-=mod; return *this; }
    inline mint& operator-=(const mint& other){ if((val-=other.val) < 0) val+=mod; return *this; }
    inline mint& operator*=(const mint& other){ val = ((ll)val*other.val)%mod; return *this; }
    inline mint& operator/=(const mint& other){ (*this)*=inv(other); return *this; }
    inline mint& operator<<=(int exp){ll ans = (ll)val<<exp ; if(ans<mod)val = ans;else val = ans%mod; return *this;}
    inline mint& operator>>=(int exp){val>>=exp; return *this;}
    inline mint& operator%=(const mint& other){val%=other.val;return *this;}
    inline explicit operator bool() const{ return bool(val) ;}
    inline mint inv(mint base,int exp=mod-2) {
        mint res(1);
        while (exp) {
            if (exp&1) res*=base;
            exp >>= 1;
            base *= base;
        }
        return res;
    }
    inline mint& pow(int exp){ return (*this)=exp<0?0:inv(*this,exp); }
};
inline mint operator+(const mint& cur , const mint& other){ return mint(cur)+=other;}
inline mint operator-(const mint& cur , const mint& other){ return mint(cur)-=other;}
inline mint operator*(const mint& cur , const mint& other){ return mint(cur)*=other;}
inline mint operator/(const mint& cur , const mint& other){ return mint(cur)/=other;}
inline bool operator==(const mint& cur , const mint& other){ return cur.val==other.val;}
inline bool operator!=(const mint& cur , const mint& other){ return cur.val!=other.val;}
istream& operator >>(istream& in,mint& other){static ll val;in>>val;other = mint(val);return in; }
ostream& operator <<(ostream& out,const mint& other){ out<<other.val;return out; }

//mint fac[UL25]={1,1} ;
//void fac_init(){
//    FOR(i,2,UL25)fac[i]=i*fac[i-1];
//}
//inline mint ncr(int n , int r){ if(r>n)return 0; return fac[n]/fac[r]/fac[n-r]; }
//fac_init();

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int n= nums.size();
        // sum,co
        mint dp[UL5][2];
        memset(dp,0,sizeof(dp));
        for(int i: nums){
            if(i){
                dp[i][1]+=dp[i-1][1];
                dp[i][0]+=dp[i-1][0] + i*dp[i-1][1];
            }
            dp[i][1]+=dp[i+1][1];
            dp[i][0]+=dp[i+1][0] + i*dp[i+1][1];
            
            dp[i][0]+=i;
            dp[i][1]+=1;
        }
        mint res = 0;
        for(int i = 0 ;i<UL5;i++){
            res+=dp[i][0];
        }
        return res.val;
    }
};

",1448201589
Said Abdulaev,said_v15,63,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& v, int k) {
        int n = v.size();

        vector<int> st;
        int cnt = 1;

        for (int i = 1; i < n; i++) {
            if (v[i] > v[i - 1]) {
                cnt++;
                continue;
            }
            st.push_back(cnt);
            cnt = 1;
        }
        st.push_back(cnt);

        int ans = 0, sz = st.size();
        for (int i = 0; i < sz; i++) {
            ans = max(ans, st[i] / 2);
            if (i != sz - 1) ans = max(ans, min(st[i], st[i + 1]));
        }

        return (ans >= k);
    }
};",1448204564
Said Abdulaev,said_v15,63,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& v) {
        int n = v.size();

        vector<int> st;
        int cnt = 1;

        for (int i = 1; i < n; i++) {
            if (v[i] > v[i - 1]) {
                cnt++;
                continue;
            }
            st.push_back(cnt);
            cnt = 1;
        }
        st.push_back(cnt);

        int ans = 0, sz = st.size();
        for (int i = 0; i < sz; i++) {
            ans = max(ans, st[i] / 2);
            if (i != sz - 1) ans = max(ans, min(st[i], st[i + 1]));
        }

        return ans;
    }
};",1448202355
Said Abdulaev,said_v15,63,3631,cpp,"class Solution {
public:
    const int MAXSZ = 1000;
    const int mod = int(1e9) + 7;

    int fact[1010];
    int inv_fact[1010];

    int mul(int a, int b) {
        return (long long) a * b % mod;
    }
    
    int add(int a, int b) {
        long long res = (long long) a + b;
        if (res < 0)
            res += mod;
        else if (res > mod)
            res -= mod;
        return (int) res % mod;
    }
    int bpow(int x, int p) {
        int res = 1;
        while (p) {
            if (p & 1)
                res = mul(res, x);
    
            p >>= 1;
    
            if (p)
                x = mul(x, x);
        }
        return res;
    }
    
    int inv(int x) {
    	return bpow(x, mod - 2);
    }
    
    void calc_fact() {
    	fact[0] = inv_fact[0] = 1;
    	for (int i = 1; i <= MAXSZ; i++) {
    		fact[i] = mul(fact[i - 1], i);
    		inv_fact[i] = inv(fact[i]);
    	}
    }
    
    int cnk(int n, int k) {
    	if (k > n)
    		return 0;
    	return mul(fact[n], mul(inv_fact[k], inv_fact[n - k]));
    }

    int countKReducibleNumbers(string s, int k) {
        calc_fact();
        
        vector<int> st(MAXSZ + 1);
        int n = s.size();

        for (int i = 1; i <= MAXSZ; i++) {
            int cnt = 0, num = i;
            while (num > 1) {
                cnt++;
                num = __builtin_popcount(num);
            }
            if (num == 1) st[i] = cnt;
        }

        // now we need to compute how many numbers are less then s
        // and can be reduced to st[x] such that st[x] + 1 <= k

        s = ""#"" + s; // for balance
        int ans = 0, ones = 0;

        for (int i = 1; i <= n; i++) {
            if (s[i] == '0') continue;
            // try to put lower digit in i-th place
            for (int j = 0; j <= n - i; j++) {
                // how many ones we can place
                if (st[ones + j] + 1 <= k) ans = add(ans, cnk(n - i, j));
            }
            ones++;
        }

        return ans - 1;
        
    }
};",1448236940
Said Abdulaev,said_v15,63,3646,cpp,"class Solution {
public:
    const int mod = int(1e9) + 7;

    int mul(int a, int b) {
        return (long long) a * b % mod;
    }
    
    int add(int a, int b) {
        long long res = (long long) a + b;
        if (res < 0)
            res += mod;
        else if (res > mod)
            res -= mod;
        return (int) res % mod;
    }
    int sumOfGoodSubsequences(vector<int>& v) {
        int n = v.size();
        int sz = 0;
        for (auto &x: v) sz = max(sz, x);

        vector<int> dp(sz + 10), ndp(sz + 10);
        for (int i = 0; i < n; i++) {
            int x = v[i];

            dp[x] = add(dp[x], 1);
            ndp[x] = add(ndp[x], x);
            
            dp[x] = add(dp[x], dp[x + 1]);
            int to = add(ndp[x + 1], mul(dp[x + 1], x));
            ndp[x] = add(ndp[x], to);
            if (x) {
                to = add(ndp[x - 1], mul(dp[x - 1], x));
                dp[x] = add(dp[x], dp[x - 1]);
                ndp[x] = add(ndp[x], to);
            }
        }

        int ans = 0, ways = 0;
        for (int i = 0; i <= sz + 1; i++) {
            ans = add(ans, ndp[i]);
            ways = add(ways, dp[i]);
        }

        // cout << ans << "" "" << ways << ""\n"";
        return ans;
    }
};",1448191942
green_pig,green_pig,64,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        s = [int(a < b) for a, b in zip(nums, nums[1:])] + [1]
        t = list(accumulate(s[::-1], lambda a, b: a * b + 1))[::-1] + [0]
        m = 0
        for i in range(len(s)-k+1):
            if t[i] >= k and t[i+k] >= k:
                return True
        return False",1448190623
green_pig,green_pig,64,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        s = [int(a < b) for a, b in zip(nums, nums[1:])] + [1]
        t = list(accumulate(s[::-1], lambda a, b: a * b + 1))[::-1] + [0]
        m = 0
        for i in range(len(s)):
            m = max(m, t[i] // 2, min(t[i], t[i+t[i]]))
        return m
",1448187652
green_pig,green_pig,64,3631,python3,"P = 1000000007
F = [1] * 900
for i in range(1, len(F)):
    F[i] = F[i-1]*i%P
I = [pow(x, -1, P) for x in F]
C = lambda n, k: F[n] * I[k] * I[n-k] % P if 0 <= k <= n else 0
class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        n = len(s)
        c = [0] * (n+1)
        t = 0
        for i in range(n):
            if s[i] == '1':
                for j in range(n+1-t):
                    c[t+j] += C(n-i-1, j)
                t += 1
        d = [0] * (n+1)
        for i in range(2, n+1):
            d[i] = d[i.bit_count()] + 1
        return sum(c[i] for i in range(1, n+1) if d[i] < k) % P
",1448213261
green_pig,green_pig,64,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        M = 10**9+7
        s = defaultdict(int)
        w = defaultdict(int)
        for n in nums:
            s[n] = (s[n] + (1 + w[n-1] + w[n+1]) * n + s[n-1] + s[n+1]) % M
            w[n] = (w[n] + 1 + w[n-1] + w[n+1]) % M
        return sum(s.values()) % M",1448196810
Shayan_Jahan,Shayan_Jahan,66,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        
        for (int i = 0; i < n - 2 * k + 1; i++) {
            bool flag = true;
            for (int j = i; j < i + k - 1; j++) flag &= (nums[j] < nums[j + 1]);
            for (int j = i + k; j < i + 2 * k - 1; j++) flag &= (nums[j] < nums[j + 1]);

            if (flag) return true;
        }

        return false;
    }
};",1448182505
Shayan_Jahan,Shayan_Jahan,66,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector <int> vec;

        int cnt = 0;
        for (int i = 0; i < n; i++) {
            cnt++;
            if (i == n - 1 || nums[i] >= nums[i + 1]) {
                vec.push_back(cnt);
                cnt = 0;
            }
        }

        int ans = 0;
        for (int i = 0; i < (int)vec.size() - 1; i++)
            ans = max(ans, min(vec[i], vec[i + 1]));

        for (int i = 0; i < vec.size(); i++) 
            ans = max(ans, vec[i] / 2);

        return ans;
    }
};",1448188840
Shayan_Jahan,Shayan_Jahan,66,3631,cpp,"class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        const int N = 800 + 10, mod = 1e9 + 7;

        vector <vector<int>> C;

        for (int i = 0; i < N; i++) {
            vector <int> vec(N);
            C.push_back(vec);

            C[i][0] = C[i][i] = 1;

            for (int j = 1; j < i; j++) {
                C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;
            }
        }
        
        vector <int> dp(N);

        for (int i = 2; i < N; i++) {
            dp[i] = dp[__builtin_popcount(i)] + 1;
        }

        int ans = 0;
        
        int n = s.size(), c0 = 0, c1 = 0;
        for (int i = 0; i < n; i++) {
            if (s[i] == '0') {
                c0++;
                continue;
            }

            c0++;

            for (int j = 0; j < n - i; j++) {
                if (dp[c1 + j] < k) {
                    ans = (ans + C[n - i - 1][j]) % mod;
                }
            }
            
            c0--;
            c1++;
        }

        return (ans + mod - 1) % mod;
    }
};",1448222046
Shayan_Jahan,Shayan_Jahan,66,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        const int N = 1e5 + 20, mod = 1e9 + 7;
        int n = nums.size();
        
        vector <int> cnt(N), sum(N);

        int ans = 0;
        
        for (int i = 0; i < n; i++) {
            int val = 0;
            val = (val + sum[nums[i] + 1]) % mod;
            val = (val + 1ll * nums[i] * cnt[nums[i] + 1]) % mod;
            
            (cnt[nums[i]] += cnt[nums[i] + 1]) %= mod;
            (sum[nums[i]] += val) %= mod;
            (ans += val) %= mod;
            
            if (nums[i] > 0) {
                val = 0;
                val = (val + sum[nums[i] - 1]) % mod;
                val = (val + 1ll * nums[i] * cnt[nums[i] - 1]) % mod;
                
                (cnt[nums[i]] += cnt[nums[i] - 1]) %= mod;
                (sum[nums[i]] += val) %= mod;
                (ans += val) %= mod;                
            }

            (cnt[nums[i]] += 1) %= mod;
            (sum[nums[i]] += nums[i]) %= mod;
            (ans += nums[i]) %= mod;
        }

        return ans;
    }
};",1448204199
Balakrishnan Varadarajan,balakrishnan_v,67,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n=nums.size();
        vector<int> fwd(n);
        for(int i=0;i<n;i++) {
            fwd[i]=1;
            if (i && nums[i]>nums[i-1]) fwd[i]=fwd[i-1]+1;
        }
        vector<int> bck(n);
        for(int i=n-1;i>=0;i--) {
            bck[i]=1;
            if (i+1<n && nums[i]<nums[i+1]) bck[i]=bck[i+1]+1;
        }
        for(int i=1;i<n;i++) {
            int curr = min(fwd[i-1],bck[i]);
            if (curr >= k) return true;
        }
        return false;
    }
    

    
};",1448230208
Balakrishnan Varadarajan,balakrishnan_v,67,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n=nums.size();
        vector<int> fwd(n);
        for(int i=0;i<n;i++) {
            fwd[i]=1;
            if (i && nums[i]>nums[i-1]) fwd[i]=fwd[i-1]+1;
        }
        vector<int> bck(n);
        for(int i=n-1;i>=0;i--) {
            bck[i]=1;
            if (i+1<n && nums[i]<nums[i+1]) bck[i]=bck[i+1]+1;
        }
        int ans=0;
        for(int i=1;i<n;i++) {
            ans=max(ans,min(fwd[i-1],bck[i]));
        }
        return ans;
        
    }
};",1448228340
Balakrishnan Varadarajan,balakrishnan_v,67,3631,cpp,"#define MODD 1000000007
#define MAXN 800
class Solution {
public:
    
    bool Check(int x, int k) {
        if (x==1) return true;
        for(int j=1;j<=k-1;j++) {
            x = __builtin_popcount(x);
            if (x==1) return true;
        }
        return false;
    }
    
    bool is_valid[MAXN+2];
    
    int dp[MAXN+1][MAXN+1][2];
    
    int Solve(const string& s, int pos, int num_ones, bool is_less,  int k) {
        int n=s.size();
        if (pos == n) {
            return is_less && is_valid[num_ones];
        }
        
        int curr = s[pos]-'0';
        if (dp[pos][num_ones][is_less]!=-1) return dp[pos][num_ones][is_less];
        
        int ans=0;
        for(int c : {0,1}) {
            if (!is_less & c > curr) continue;
            ans += Solve(s, pos+1,  num_ones + c, is_less || (c < curr), k);
            if (ans >= MODD) ans -= MODD;
        }
        return dp[pos][num_ones][is_less]=ans;
        
    }
    
    int countKReducibleNumbers(string s, int k) {
        int n=s.size();
        
        for(int o=0;o<=n;o++) {
            is_valid[o]=Check(o,k);
        }
        for(int i=0;i<=n;i++) for(int j=0;j<=n;j++) for(int l : {0,1}) dp[i][j][l]=-1;
        return Solve(s, 0, 0, false, k);
        
    }
};",1448200349
Balakrishnan Varadarajan,balakrishnan_v,67,3646,cpp,"#define ll long long
#define MODD 1000000007
class Solution {
public:
    
    
    int sumOfGoodSubsequences(vector<int>& nums) {
        int maxx = *max_element(nums.begin(),nums.end());
        int n=nums.size();
        vector<pair<ll,ll>> dp(n);
        vector<pair<ll,ll>> summ(maxx+1,{0ll,0ll});
        ll ans = 0;
        for(int i=n-1;i>=0;i--) {
            int x = nums[i];
            // ways, summ
            dp[i]={1, x};
            for(int y : {x-1,x+1}) {
                if (y >= 0 && y <= maxx) {
                    dp[i].first += summ[y].first;
                    dp[i].second += summ[y].second + (ll)summ[y].first * (ll)x%MODD;
                    dp[i].first %= MODD;
                    dp[i].second %= MODD;
                }
            }
            summ[x].first += dp[i].first;
            summ[x].second += dp[i].second;
            summ[x].first %= MODD;
            summ[x].second %= MODD;
            ans += dp[i].second;
            ans %= MODD;
        }
        return ans;
    }
};",1448217004
peace,shankardtu21,70,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& n, int k) {
        if (n.size() < 2 * k) return false;

        for (int i = 0; i <= n.size() - 2 * k; ++i) {
            if (helper(n, i, k) && helper(n, i + k, k)) {
                return true;
            }
        }
        return false;
    }

private:
    bool helper(const vector<int>& n, int s, int k) {
        for (int i = s + 1; i < s + k; ++i) {
            if (n[i - 1] >= n[i]) {
                return false;
            }
        }
        return true;
    }
};
",1448182908
peace,shankardtu21,70,3619,cpp,"#include <vector>
using namespace std;

class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& n) {
        int sz = n.size();
        vector<int> inc(sz, 1);
        for (int i = sz - 2; i >= 0; --i) {
            if (n[i] < n[i + 1]) {
                inc[i] = inc[i + 1] + 1;
            } else {
                inc[i] = 1;
            }
        }
        
        int l = 1, h = sz / 2, ans = 0;
        while (l <= h) {
            int m = l + (h - l) / 2;
            if (helper(n, inc, m)) {
                ans = m;
                l = m + 1;
            } else {
                h = m - 1;
            }
        }
        return ans;
    }
    
private:
    bool helper(const vector<int>& n, const vector<int>& inc, int k) {
        int sz = n.size();
        for (int s = 0; s <= sz - 2 * k; ++s) {
            if (inc[s] >= k && inc[s + k] >= k) {
                return true;
            }
        }
        return false;
    }
};
",1448207152
peace,shankardtu21,70,3631,cpp,"typedef long long ll;
const int M = 1'000'000'007;
class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        int len = s.length();
        
        vector<int> f(801, 0);
        f[1] = 0;
        for (int v = 2; v <= 800; v++) {
            int pc = __builtin_popcount(v);
            f[v] = 1 + f[pc];
        }
        
        vector<int> allowed;
        for (int v = 1; v <= 800; v++) {
            if (f[v] <= k - 1) {
                allowed.push_back(v);
            }
        }
        
        vector<vector<int>> C(801, vector<int>(801, 0));
        C[0][0] = 1;
        for (int i = 1; i <= 800; i++) {
            C[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % M;
            }
        }

        auto count_lt = [&](int ts) -> int {
            if (ts < 0) return 0;
            int cnt = 0, rem = ts;
            for (int i = 0; i < len; i++) {
                if (s[i] == '1') {
                    int br = len - 1 - i;
                    if (br >= rem) {
                        cnt = (cnt + (ll)C[br][rem]) % M;
                    }
                    rem--;
                    if (rem < 0) break;
                }
            }
            return cnt;
        };

        ll total = 0;
        for (auto v : allowed) {
            total = (total + (ll)count_lt(v)) % M;
        }

        if (s == ""1"") return 0;
        return (int)total;
    }
};
",1448223687
peace,shankardtu21,70,3646,cpp,"#include <vector>
using namespace std;

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& n) {
        const int M = 1'000'000'007;

        int m = 0;
        for (auto x : n) {
            if (x > m) m = x;
        }

        vector<long long> c(m + 2, 0), s(m + 2, 0);
        long long t = 0;

        for (auto x : n) {
            long long nc = 0;
            if (x > 0) {
                nc += c[x - 1];
            }
            if (x + 1 <= m + 1) {
                nc += c[x + 1];
            }
            nc += 1;

            long long ns = 0;
            if (x > 0) {
                ns += s[x - 1];
            }
            if (x + 1 <= m + 1) {
                ns += s[x + 1];
            }

            long long add = 0;
            if (x > 0) {
                add += c[x - 1];
            }
            if (x + 1 <= m + 1) {
                add += c[x + 1];
            }
            add += 1;

            ns += add * (long long)x;
            ns %= M;

            t = (t + ns) % M;

            c[x] = (c[x] + nc) % M;
            s[x] = (s[x] + ns) % M;
        }

        return (int)t;
    }
};
",1448201235
Chinnu,chinnu11,73,3612,cpp,"class Solution{
public:
    bool f(const vector<int>&v,int s,int k){
        for(int i=s;i<s+k-1;++i)if(v[i]>=v[i+1])return 0;
        return 1;
    }
    bool hasIncreasingSubarrays(vector<int>&v,int k){
        int n=v.size();
        for(int i=0;i<=n-2*k;++i)if(f(v,i,k)&&f(v,i+k,k))return 1;
        return 0;
    }
};
",1448197943
Chinnu,chinnu11,73,3619,cpp,"class Solution{
public:
    int maxIncreasingSubarrays(vector<int>&v){
        int n=v.size();
        vector<int>inc(n,1);
        for(int i=n-2;i>=0;--i)if(v[i]<v[i+1])inc[i]=inc[i+1]+1;
        int l=1,r=n/2,ans=1;
        while(l<=r){
            int m=l+(r-l)/2,f=0;
            for(int i=0;i<=n-2*m;++i){
                if(inc[i]>=m&&inc[i+m]>=m){f=1;break;}
            }
            if(f)ans=m,l=m+1;
            else r=m-1;
        }
        return ans;
    }
};
",1448202246
Chinnu,chinnu11,73,3631,cpp,"class Solution{
public:
    const long long M=1'000'000'007;
    vector<int>f;
    vector<bool>v;
    
    int cs(int x){
        int c=0;
        while(x){c+=x&1;x>>=1;}
        return c;
    }

    void pf(int sm){
        f=vector<int>(sm+1,-1);
        f[1]=0;
        for(int i=2;i<=sm;i++){
            int c=cs(i);
            f[i]=1+f[c];
        }
    }

    void pv(int sm,int k){
        v=vector<bool>(sm+1,0);
        for(int i=1;i<=sm;i++)if(f[i]<=(k-1))v[i]=1;
    }

    long long dp(int p,int c,bool t,int l,const vector<int>&b,vector<vector<vector<long long>>>&m){
        if(p==l)return c>=1&&v[c];
        if(m[p][c][t]!=-1)return m[p][c][t];
        int lim=t?b[p]:1;
        long long r=0;
        for(int d=0;d<=lim;d++){
            bool nt=t&&(d==b[p]);
            r=(r+dp(p+1,c+d,nt,l,b,m))%M;
        }
        return m[p][c][t]=r;
    }

    int countKReducibleNumbers(string s,int k){
        int sm=800;
        pf(sm);
        pv(sm,k);
        int l=s.size();
        vector<int>b(l);
        for(int i=0;i<l;i++)b[i]=s[i]-'0';
        vector<vector<vector<long long>>>m(l+1,vector<vector<long long>>(l+1,vector<long long>(2,-1)));
        long long r=dp(0,0,1,l,b,m);
        int sc=0;
        for(int i=0;i<l;i++)if(b[i]==1)sc++;
        if(v[sc])r=(r-1+M)%M;
        return r%M;
    }
};",1448241159
Chinnu,chinnu11,73,3646,cpp,"class Solution{
public:
    int sumOfGoodSubsequences(vector<int>&v){
        const int M=1'000'000'007,N=100001;
        vector<long long>c(N+2,0),s(N+2,0);
        long long t=0;
        for(auto &x:v){
            long long nc=1,ns=x;
            if(x>=1){
                nc=(nc+c[x-1])%M;
                ns=(ns+s[x-1]+x*c[x-1]%M)%M;
            }
            if(x+1<=N){
                nc=(nc+c[x+1])%M;
                ns=(ns+s[x+1]+x*c[x+1]%M)%M;
            }
            c[x]=(c[x]+nc)%M;
            s[x]=(s[x]+ns)%M;
            t=(t+ns)%M;
        }
        return t;
    }
};
",1448208381
lukewu28,lukewu28,75,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        stack<int> s;
        int last = -1;
        int n = nums.size();
        vector<int> g(n, 0);
        for(int i = 0; i < n; i++){
            if(nums[i] > last) last = nums[i];
            else{
                while(!s.empty()){
                    g[s.top()] = i - s.top();
                    s.pop();
                }
                last = nums[i];
            }
            s.push(i);
        }
        
        while(!s.empty()){
            g[s.top()] = n - s.top();
            s.pop();
        }
        
        for(int i = 0; i < n - k; i++){
            if(g[i] >= k && g[i + k] >= k) return true;
        }
        return false;
    }
};",1448188354
lukewu28,lukewu28,75,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        stack<int> s;
        int last = -1;
        int n = nums.size();
        vector<int> g(n, 0);
        for(int i = 0; i < n; i++){
            if(nums[i] > last) last = nums[i];
            else{
                while(!s.empty()){
                    g[s.top()] = i - s.top();
                    s.pop();
                }
                last = nums[i];
            }
            s.push(i);
        }
        
        while(!s.empty()){
            g[s.top()] = n - s.top();
            s.pop();
        }
        
        int l = 1, r = n;
        while(l < r){
            int m = (r + l + 1) / 2;
            
            bool ok = 0;
            for(int i = 0; i < n - m; i++){
                if(g[i] >= m && g[i + m] >= m) ok = 1;
            }
            
            if(ok) l = m;
            else r = m - 1;
        }
        
        return l;
    }
};",1448186930
lukewu28,lukewu28,75,3631,cpp,"typedef long long ll;
class Solution {
public:
    const ll MOD = 1000000007;
    const int MAXN = 1000;
    ll fac[1000 + 1], invfac[1000 + 1];
    ll inv(ll x){return x>1?inv(MOD%x)*(MOD-MOD/x)%MOD:x;}
    void factorial() {
        fac[0] = 1;
        for (ll i = 1; i <= MAXN; i++) {
            fac[i] = fac[i - 1] * i % MOD;
        }
    }
    void inverses() {
        invfac[MAXN] = inv(fac[MAXN]);
        for (ll i = MAXN; i >= 1; i--) {
            invfac[i - 1] = invfac[i] * i % MOD;
        }
    }
    ll C(ll g, ll r) {
        return fac[g] * invfac[r] % MOD * invfac[g - r] % MOD;
    }
    int countKReducibleNumbers(string s, int k) {
        factorial();
        inverses();
        bool red[1000][5] = {};
        for(int i = 0 ; i <5; i++) red[1][i] = 1;
        
        for(int i = 2; i < 1000; i++){
            int x = __builtin_popcount(i);
            for(int j = 1; j < 5; j++) red[i][j] = red[x][j - 1];
        }
        
        int n = s.size();
        vector<int> reds;
        for(int i = 1; i < n; i++){
            if(red[i][k - 1]) reds.push_back(i);
        }
        
        ll re = 0;
        int ones = 0;
        for(int i = 0; i < n; i++){
            if(s[i] == '0') continue;
            int cnt = n - i - 1;
            for(int j : reds){
                if(j - ones < 0) continue;
                if(j - ones > cnt) break;
                
                re = (re + C(cnt, j - ones)) % MOD;
            }
            ones++;
        }
        return re;
    }
};",1448234475
lukewu28,lukewu28,75,3646,cpp,"typedef long long ll;
class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        ll n = nums.size();
        ll mx = *max_element(nums.begin(), nums.end());
        vector<ll> dp(mx + 1, 0), cnt(mx + 1, 0);
        const ll mod = 1000000007;
        long long re = 0;
        for(int i = 0; i < n; i++){
            ll x = nums[i];
            if(x != 0) {
                ll tot = cnt[x - 1] * x % mod;
                ll add = (tot + dp[x - 1]) % mod;
                dp[x] = (dp[x] + add) % mod;
                cnt[x] = (cnt[x] + cnt[x - 1]) % mod;
            }
            if(x != mx) {
                ll tot = cnt[x + 1] * x % mod;
                ll add = (tot + dp[x + 1]) % mod;
                dp[x] = (dp[x] + add) % mod;
                cnt[x] = (cnt[x] + cnt[x + 1]) % mod;
            }
            dp[x] += x;
            cnt[x]++;
            
            dp[x] %= mod;
            cnt[x] %= mod;
            
//             for(int j : dp) cout << j << ' ';
//             cout << endl;
            
        }

        
        for(int i = 0; i <= mx; i++){
            re = (re + dp[i]) % mod;
        }
        return re;
    }
};",1448213168
Larry,LarryNY,77,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        N = len(nums)
        
        def good(index):
            streak = 1
            for offset in range(1, k):
                if index + offset < N and nums[index + offset] > nums[index + offset - 1]:
                    streak += 1
                else:
                    return False
            return True
            
        for i in range(N):
            if good(i) and good(i + k):
                return True
        return False
",1448183027
Larry,LarryNY,77,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        N = len(nums)
        
        best = [1] * N
        for i in range(1, N):
            if nums[i] > nums[i - 1]:
                best[i] = best[i - 1] + 1
            else:
                best[i] = 1
                
        mx = 1
        for i in range(1, N):
            start = i - best[i]
            
            if start >= 0:
                mx = max(mx, min(best[start], best[i]))
            mx = max(mx, best[i] // 2)
        
        return mx",1448190831
Larry,LarryNY,77,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        MOD = 10 ** 9 + 7
        s = str(int(s) - 1)
        N = len(s)
        
        lookup = [None] * (N + 2)
        for i in range(1, N + 1):
            lookup[i] = i.bit_count()
            
        steps = [None] * (N + 2)
        steps[1] = 0
        for i in range(2, N + 1):
            steps[i] = steps[i.bit_count()] + 1
        
        # how many with left bits
        @cache
        def go(index, prefix, left):
            if index == N:
                if left == 0:
                    return 1
                return 0
            if left < 0:
                return 0
            
            total = 0
            if prefix:
                if s[index] == ""0"":
                    total += go(index + 1, prefix, left)
                else:
                    total += go(index + 1, False, left)
                    if left - 1 >= 0:
                        total += go(index + 1, prefix, left - 1)
            else:
                total += go(index + 1, False, left)
                if left - 1 >= 0:
                    total += go(index + 1, False, left - 1)
            return total % MOD

        #print(""--"")
        total = 0
        for i in range(1, N + 1):
            if steps[i] < k:
                f = go(0, True, i)
                total = (total + f) % MOD
                #print(i, steps[i], f)
        go.cache_clear()
        
        return total % MOD",1448242374
Larry,LarryNY,77,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        MOD = 10 ** 9 + 7
        
        f = collections.Counter()
        t = collections.Counter()

        total = 0
        for x in nums:
            p = (1 + f[x - 1] + f[x + 1]) % MOD
            f[x] = (1 + f[x] + f[x - 1] + f[x + 1]) % MOD
            t[x] = (p * x + t[x] + t[x - 1] + t[x + 1]) % MOD

        total = 0
        for k, v in t.items():
            total += v
            total %= MOD
        return total % MOD",1448216156
Xianjie Deng,Dengxj,79,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        A = [0] * (n + 1)
        for i in reversed(range(n)):
            if i + 1 < n and nums[i] < nums[i + 1]:
                A[i] = A[i + 1] + 1
            else:
                A[i] = 1
        for i in range(n):
            if i + k < n and A[i] >= k and A[i + k] >= k:
                return True
        return False",1448182976
Xianjie Deng,Dengxj,79,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        A = [0] * (n + 1)
        for i in reversed(range(n)):
            if i + 1 < n and nums[i] < nums[i + 1]:
                A[i] = A[i + 1] + 1
            else:
                A[i] = 1

        def check(k):
            for i in range(n):
                if i + k < n and A[i] >= k and A[i + k] >= k:
                    return True
            return False

        lf, rt = 0, n
        while lf < rt:
            mid = rt - (rt - lf) // 2
            if check(mid):
                lf = mid
            else:
                rt = mid - 1
        return lf",1448185936
Xianjie Deng,Dengxj,79,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        n = len(s)
        M = 10 ** 9 + 7

        def calc(val):
            if val <= 0:
                return -1
            cnt = 0
            while val != 1:
                val = val.bit_count()
                cnt += 1
            return cnt

        @functools.lru_cache(None)
        def rec(pos, tight, ones):
            if pos == n:
                return 1 if not tight and ones > 0 and calc(ones) < k else 0
            d = int(s[pos])
            ret = rec(pos + 1, tight and d == 0, ones)
            if not tight or d == 1:
                ret = (ret + rec(pos + 1, tight and d == 1, ones + 1)) % M
            return ret

        return rec(0, True, 0)
",1448242659
Xianjie Deng,Dengxj,79,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        A = dict()
        M = 10**9+7
        for x in nums:
            a, b = 1, 0
            if x - 1 in A:
                a = (a + A[x - 1][0]) % M
                b = (b + A[x - 1][1]) % M
            if x + 1 in A:
                a = (a + A[x + 1][0]) % M
                b = (b + A[x + 1][1]) % M
            if x not in A:
                A[x] = [0, 0]
            A[x][0] = (A[x][0] + a) % M
            A[x][1] = (A[x][1] + a * x + b) % M
        res = 0
        for _, a in A.values():
            res = (res + a) % M
        return res
",1448215257
Sanath_Kulla,Sanath_Kulla,80,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        vector<int> h;
        int c = 1;
        for(int i = 1 ; i < nums.size() ; i++){
            if(nums[i] <= nums[i-1]){
                h.push_back(c);
                c = 1;
            }else{
                c++;
            }
        }
        h.push_back(c);
        int ans = 0;
        for(int i = 0 ; i < h.size() ; i++){
            ans = max(ans , h[i]/2);
            if(i){
                ans = max(ans , min(h[i] , h[i-1]));
            }
        }
        return ans >= k;
    }
};",1448186910
Sanath_Kulla,Sanath_Kulla,80,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        vector<int> h;
        int c = 1;
        for(int i = 1 ; i < nums.size() ; i++){
            if(nums[i] <= nums[i-1]){
                h.push_back(c);
                c = 1;
            }else{
                c++;
            }
        }
        h.push_back(c);
        int ans = 0;
        for(int i = 0 ; i < h.size() ; i++){
            ans = max(ans , h[i]/2);
            if(i){
                ans = max(ans , min(h[i] , h[i-1]));
            }
        }
        return ans;
    }
};",1448185084
Sanath_Kulla,Sanath_Kulla,80,3631,cpp,"using ll = long long;
const ll mod = 1e9+7;
ll bits(ll x) { ll cnt = 0; while(x > 0) { cnt++; x >>= 1; } return cnt; }
ll setbits(ll x) { ll cnt = 0; while(x > 0) { cnt += (x & 1); x >>= 1; } return cnt; }
ll pow(ll a, ll b) {ll res = 1;while (b > 0) {if (b & 1)res = res * a;a = a * a;b >>= 1;}return res;}
ll pow(ll a, ll b, ll m = mod) {a %= m;ll res = 1;while (b > 0) {if (b & 1)res = res * a % m;a = a * a % m;b >>= 1;}return res;}
ll add(ll a, ll b, ll m = mod){a %= m , b %= m; return (a + b) % m;}
ll sub(ll a, ll b, ll m = mod){a %= m , b %= m; return (a - b + m) % m;}
ll mul(ll a, ll b, ll m = mod){a %= m , b %= m; return (1ll * a * b) % m;}
ll div(ll a, ll b, ll m = mod){a %= m , b %= m; return mul(a , pow(b , m - 2 , m) , m);}
const ll N = 1e3+10;
ll fact[N],inv[N];
ll ncr(ll n,ll r){
   if(r > n || n < 0 || r < 0)return 0;
   return fact[n]*inv[n-r]%mod*inv[r]%mod;
}

auto init_ncr = [](){
  fact[0] = 1;
  ll i;
  for(i = 1;i<N;i++)fact[i] = i*fact[i-1]%mod;
  i--;
  inv[i] = pow(fact[i],mod-2,mod);
  for(i--;i>=0;i--)inv[i] = inv[i+1]*(i+1)%mod;
    return 1;
}();

vector<int> mn(810 , 0);
auto doo = [](){
    mn[1] = 0;
    mn[0] = 300;
    for(int len = 2 ; len <= 800 ; len++){
        ll c = 1;
        ll x = len;
        while(true){
            if(c > 5)break;
            if(x == 1)break;
            x = __builtin_popcount(x);
            c++;
        }
        mn[len] = c;
    }
    return 0;
}();

class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        ll ans = 0;
        ll ex = 0;
        ll n = s.size();
        for(int i = 0 ; i < s.size() ; i++){
                if(s[i] == '1'){
                        ll x = n - i-1;
                        for(ll choose = 0 ; choose <= x ; choose++){
                            ll len = ex + choose;
                            ll ways = ncr(x , choose);
                            if(mn[len] <= k)ans += ways,ans%=mod;
                        }
                    ex++;
                }
        }
        // ans -= 1;
        // ans += mod;
        // ans %= mod;
        return ans;
        
    }
};",1448242743
Sanath_Kulla,Sanath_Kulla,80,3646,cpp,"const int N = 1e5+10;
const int mod = 1e9+7;
using ll = long long;
vector<ll> dp(N , 0);

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        ll n = nums.size();
        vector<ll> p(n , 0) , s(n , 0);
        for(auto it:nums){
            dp[it] = 0;
            if(it-1>=0)dp[it-1] = 0;
            dp[it+1] = 0;
        }
        for(int i = 0;i<n;i++){
            ll ways = 1;
            ll x = nums[i];
            if(x)ways += dp[x-1] , ways %= mod;
            ways += dp[x+1] , ways %= mod;
            p[i] = ways;
            dp[x] += ways;
            dp[x] %= mod;
        }
        for(auto it:nums){
            dp[it] = 0;
                        if(it-1>=0)dp[it-1] = 0;
            dp[it+1] = 0;
        }
        for(int i = n-1;i>=0;i--){
            ll ways = 1;
            ll x = nums[i];
            if(x)ways += dp[x-1] , ways %= mod;
            ways += dp[x+1] , ways %= mod;
            s[i] = ways;
            dp[x] += ways;
            dp[x] %= mod;
        }
        ll ans = 0;
        for(int i = 0 ; i < n ; i++){
            ans += p[i] * s[i] % mod * nums[i] % mod;
            ans %= mod;
        }
        return ans;
    }
};",1448203857
Monik L,monik_gowda_21,81,3612,cpp,"class Solution {
public:
    
    bool forK(int k, vector<int>& p) {
        cout << k << endl;
        
        int n = p.size();
        for(int i=0;i<n;i++) {
            cout << i << "" "" << p[i] << endl;
            if(p[i] < k or ((i+k) >= n))
                continue;
            
            cout << i << endl;
            int next = i + k;
        
            if(p[next] >= k)
                return true;
        }
        
        return false;
    }
    
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        
        int n = nums.size();
        
        vector<int> p(n, 1);
        
        p[n-1] = 1;
        
        for(int i=n-2;i>=0;i--) {
            if(nums[i] < nums[i+1])
                p[i] = p[i+1] + 1;
            else
                p[i] = 1;
        }
        
        for(int i=0;i<n;i++)
            cout<<p[i] << "" "";
        
        return forK(k, p);
    }
};",1448198306
Monik L,monik_gowda_21,81,3619,cpp,"class Solution {
public:
    bool forK(int k, vector<int>& p) {
        int n = p.size();
        for(int i=0;i<n;i++) {
            if(p[i] < k or ((i+k) >= n))
                continue;
            
            int next = i + k;
        
            if(p[next] >= k)
                return true;
        }
        
        return false;
    }
    
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        
        vector<int> p(n, 0);
        
        p[n-1] = 1;
        
        for(int i=n-2;i>=0;i--) {
            if(nums[i] < nums[i+1])
                p[i] = p[i+1] + 1;
            else
                p[i] = 1;
        }
        
        
        
        int low = 1, high = n / 2;
        
        while((high-low) > 1) {
            int mid = (high + low) / 2;
            
            if(forK(mid, p))
                low = mid;
            else
                high = mid - 1;
        }
        
        if(forK(high, p))
            return high;
        
        return low;
    }
};",1448192646
Monik L,monik_gowda_21,81,3631,cpp,"class Solution {
public:
    int n, k;
    string s;
    
    map<int,int> memory;
    
    bool can(int x) {
        if(memory.find(x) != memory.end())
            return memory[x];
        
        int op = 0;
        int tempx = x;
        
        int lastk = x;
        
        while(tempx != 1) {
            lastk = tempx;
            
            tempx = __builtin_popcount(tempx);
            if(tempx == lastk)
                return memory[x] = false;
            
            op++;
        }
        
        if(op < k){
           // cout << x << endl;
            return memory[x] = true;
        }
           // return true;
        
        return memory[x] = false;
    }

    int dp[801][2][801];
    
    int fun(int i, int eq, int sum) {
        if(i >= n) {
            if(can(sum) && (eq==0))
                return 1;
            
            return 0;
        }
        
        if(dp[i][eq][sum] != -1)
            return dp[i][eq][sum];
        
        long long ans = 0;
        int mod = (int)1e9+7;
        
        if(eq == 0) {
            ans = ans + fun(i+1, 0, sum + 1) + fun(i+1, 0, sum);
        } else {
            if(s[i] == '0') {
                ans = ans + fun(i+1, 1, sum);
            } else {
                ans = ans + fun(i+1, 0, sum) + fun(i+1, 1, sum+1);
            }
        }
        
        ans = ans % mod;
        
        return dp[i][eq][sum] = ans;
    }
    
    int countKReducibleNumbers(string s1, int k1) {
        s = s1, k = k1;
        n = s.size();
        
        for(int i=0;i<=n;i++) {
            for(int j=0;j<2;j++) {
                for(int k=0;k<=n;k++) {
                    dp[i][j][k] = -1;
                }
            }
        }
        
        return fun(0, 1, 0);
    }
};",1448235149
Monik L,monik_gowda_21,81,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        map<int,int> ends;
        map<int, long long> sumt;
        
        int mod = (int)1e9+7;
        
        long long ans = 0;
        for(int x: nums) {
            int value1 = x - 1, value2 = x + 1;
            
            int f = (ends[value1] + ends[value2] + 1) % mod;
            
            long long kf = (sumt[value1] + sumt[value2] + (long long)f * x) % mod;
            ans = ans + kf;
            ans = ans % mod;
            sumt[x] += kf;
            sumt[x] %= mod;
            ends[x] += f;
            ends[x] %= mod;
        }
        
        return ans;
    }
};",1448210619
Decision,Decision,82,3612,java,"class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        final int n = nums.size();
        final int[] ns = new int[n], cs = new int[n];
        int p = 0;
        for(int a : nums){
            ns[p++] = a;
        }
        cs[0] = 1;
        for(int i=1;i<n;++i){
            if(ns[i] > ns[i-1]){
                cs[i] = cs[i-1] + 1;
            }else{
                cs[i] = 1;
            }
        }
        boolean res = false;
        for(int i=k+k-1;i<n;++i){
            if(cs[i] >= k && cs[i-k] >= k){
                res = true;
                break;
            }
        }
        return res;
    }
}",1448225113
Decision,Decision,82,3619,java,"class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        final int n = nums.size();
        final int[] ns = new int[n], cs = new int[n];
        int p = 0;
        for(int a : nums){
            ns[p++] = a;
        }
        cs[0] = 1;
        for(int i=1;i<n;++i){
            if(ns[i] > ns[i-1]){
                cs[i] = cs[i-1] + 1;
            }else{
                cs[i] = 1;
            }
        }
        int l=1, r=n/2;
        while(l <= r){
            final int mid = (l+r) >> 1;
            boolean f = false;
            for(int i=mid+mid-1;i<n;++i){
                if(cs[i] >= mid && cs[i-mid] >= mid){
                    f = true;
                    break;
                }
            }
            if(f){
                l = mid + 1;
            }else{
                r = mid - 1;
            }
        }
        return r;
    }
}",1448221226
Decision,Decision,82,3631,java,"class Solution {
    final static int m = 810;
    final static int[] fs = new int[m];
    static{
        for(int i=2;i<m;++i){
            fs[i] = fs[Integer.bitCount(i)] + 1;
        }
    }
    public int countKReducibleNumbers(String s, int k) {
        final int n = s.length(), MODE = 1000000007;;
        final char[] cc = s.toCharArray();
        final long[][] comb = new long[n+1][n+1];
        comb[0][0] = 1L;
        for(int i=1;i<=n;++i){
            comb[i][0] = comb[i][i] = 1L;
            for(int j=1;j<i;++j){
                comb[i][j] = (comb[i-1][j] + comb[i-1][j-1]) % MODE;
            }
        }
        int pre = 0;
        long res = 0;
        for(int i=0;i<n;++i){
            if(cc[i] == '1'){
                int cnt = n-1-i, st = 0;
                while(st <= cnt){
                    if(pre + st > 0 && fs[pre+st] < k){
                        res += comb[cnt][st];
                        res %= MODE;
                    }
                    st++;
                }
                pre++;
            }
        }
        return (int)res;
    }
}",1448209162
Decision,Decision,82,3646,java,"class Solution {
    public int sumOfGoodSubsequences(int[] nums) {
        int m = 0, MODE = 1000000007;
        for(int a : nums){
            m = Math.max(m, a);
        }
        long res = 0;
        final long[] vs = new long[m+1], cs = new long[m+1];
        for(int a : nums){
            long v = a, c = 1;
            if(a-1 >= 0){
                v = (v + vs[a-1]) % MODE;
                v += a * cs[a-1];
                v %= MODE;
                c = (c + cs[a-1]) % MODE;
            }
            if(a+1 <= m){
                v = (v + vs[a+1]) % MODE;
                v += a * cs[a+1];
                v %= MODE;
                c = (c + cs[a+1]) % MODE;
            }
            res = (res + v) % MODE;
            vs[a] = (vs[a] + v) % MODE;
            cs[a] = (cs[a] + c) % MODE;
        }
        return (int)res;
    }
}",1448243219
junbinliang,junbinliang,85,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& a, int k) {
        int n = a.size();
        vector<bool> b(n);
        for(int i = 0; i < a.size(); i++) {
            if(i + k - 1 >= n) break;
            bool ok = true;
            for(int j = i + 1; j <= i + k - 1; j++) {
                if(a[j] <= a[j - 1]) ok = false;
            }
            if(ok) {
                b[i] = true;
                //cout << i << endl;
            }
        }
        
        for(int i = 0; i < b.size(); i++) {
            for(int j = i + 1; j < b.size(); j++) {
                if(b[i] && b[j] && j - i == k) return true;
            }
        }
        return false;
    }
};",1448182679
junbinliang,junbinliang,85,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& a) {
        int n = a.size();
        vector<int> dp(n);
        vector<pair<int, int>> b;
        for(int i = 0; i < n; i++) {
            int j = i + 1;
            int cnt = 1;
            while(j < n && a[j] > a[j - 1]) {
                cnt++;
                j++;
            }
            
            int k = i;
            while(k < j) {
                dp[k] = cnt--;
                k++;
            }
            
            b.push_back({i, j - 1});
            
            i = j - 1;
        }
        
        int ans = 0;
        for(int i = 0; i < b.size(); i++) {
            int l = b[i].first, r = b[i].second;
            int sz = (r - l + 1) / 2;
            ans = max(ans, sz);
            for(int j = l; j <= r; j++) {
                if(r + 1 < n) {
                    ans = max(ans, min(dp[j], dp[r + 1]));
                }
            }
        }
        
        //for(int i = 0; i < n; i++) cout << dp[i] << "" "";
        //cout << endl;
        return ans;
    }
};",1448197374
junbinliang,junbinliang,85,3631,cpp,"const int MOD = 1e9 + 7;
int k;
bool yes = false;
int ok[810][6], c[810][810];
int get(int n) {
    int cnt = 0;
    for(int j = 0; j < 12; j++) {
        if(n & (1 << j)) cnt++;
    }
    return cnt;
}

void init() {
    if(yes) return;
    yes = true;
    for(int i = 1; i <= 800; i++) {
        for(int j = 1; j <= 5; j++) {
            int v = i;
            for(int t = 0; t < j; t++) {
                v = get(v);
            }
            if(v == 1) ok[i][j] = 1;
            else ok[i][j] = 0;
        }
    }
    ok[1][0] = 1;
    
    c[0][0] = 1;
    for(int i = 1;i <= 805; i++) {
      c[i][0]=1;
      for(int j = 1;j <= i;j++) {
        c[i][j] = (c[i-1][j] + c[i-1][j-1] ) % MOD;
      }
    }
}

class Solution {
public:
    int countKReducibleNumbers(string& s, int k) {
        init();
        int n = s.size();
        
        long long ans = 0;
        int cnt = 0;
        for(int i = 0; i < s.size(); i++) {
            //same prefix
            int tot = 0;
            if(s[i] == '1') {
                //replace with 0
                int poslen = s.size() - (i + 1);
                for(int j = 0; j <= poslen; j++) {
                    if(ok[cnt + j][k - 1]) {
                        int w = c[poslen][j];
                        tot += w;
                        tot %= MOD;
                        //cout << i << ""   |"" << cnt << ""  "" << j << ""  ""  << w << endl;
                    }
                }
                ans += tot;
                ans %= MOD;
               // cout << i << "" "" << tot << endl;
            
            } else {
                continue;
            }
            
            if(s[i] == '1') {
                cnt++;
            }
        }
        
        return ans;
    }
};",1448235759
junbinliang,junbinliang,85,3646,cpp,"const int MOD = 1e9 + 7;
const int N = 1e5 + 10;
class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& a) {
        int n = a.size();
        
        unordered_map<int, long long> dp1, dp2;
        for(int i = 0; i < n; i++) {
            int v = a[i];
            long long s = 0, cnt = 0;
            if(dp1.find(v - 1) != dp1.end()) {
                cnt += dp1[v - 1];
                cnt %= MOD;
                s += dp2[v - 1];
                s %= MOD;
            }
            
            if(dp1.find(v + 1) != dp1.end()) {
                cnt += dp1[v + 1];
                cnt %= MOD;
                s += dp2[v + 1];
                s %= MOD;
            }
            
            //single 
            cnt++;
            cnt %= MOD;
            s += ((cnt + 0ll) * a[i]);
            s %= MOD;
            
            if(dp1.find(v) != dp1.end()) {
                cnt += dp1[v];
                cnt %= MOD;
                s += dp2[v];
                s %= MOD;
            }
            
            dp1[v] = cnt;
            dp2[v] = s;
            
            //cout << i << ""   | "" << cnt << "" ""  << s << endl;
            
        }
        
        long long ans = 0;
        for(auto it = dp2.begin(); it != dp2.end(); it++) {
            ans += (it -> second);
            ans %= MOD;
        }
        return ans;
    }
};",1448207195
Nguyễn Thảo,nguyenquocthao00,87,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n=len(nums)
        data=[0]*(n)
        data[n-1]=1
        for i in range(n-2,-1,-1):
            data[i]=1 + (0 if nums[i]>=nums[i+1] else data[i+1])
        # print(data)
        for i in range(n-k):
            if data[i]>=k and data[i+k]>=k: return True
        return False
        ",1448185200
Nguyễn Thảo,nguyenquocthao00,87,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        data,cur = [], 1
        for i in range(1, len(nums)):
            if nums[i]>nums[i-1]: cur+=1
            else: 
                data.append(cur)
                cur=1
        data.append(cur)
        # print(data)
        res=max(v//2 for v in data)
        for i in range(len(data)-1):
            res=max(res, min(data[i], data[i+1]))
        return res

        ",1448189418
Nguyễn Thảo,nguyenquocthao00,87,3631,python3,"MOD = 10**9 + 7
cached=[0]*801
for i in range(2, len(cached)):
    cached[i] = 1+ cached[i.bit_count()]
# @lru_cache(None)
def nre(i):
    return cached[i]
    # if i==1: return 0
    # return 1 + nre(i.bit_count())
class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        n=len(s)
        @lru_cache(None)
        def dp(i, n1, less):
            # print(i,n1,less)
            if i==n:
                if not less: return 0
                if n1>0 and nre(n1)<k: return 1
                return 0
            if less:
                return (dp(i+1, n1, True) + dp(i+1,n1+1,True))%MOD
            if s[i]=='0': return dp(i+1, n1, False)
            if s[i]=='1': return (dp(i+1,n1+1,False) + dp(i+1,n1,True))%MOD
        return dp(0,0,False)
        # for i in range(1,801):
        #     print(i, dp(i))
        # return 0
        
        ",1448236343
Nguyễn Thảo,nguyenquocthao00,87,3646,python3,"MOD = 10**9 + 7
class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        count,m=defaultdict(int),defaultdict(int)
        for v in nums:
            added = 1 + count[v-1] + count[v+1]
            m[v] = (m[v] + added*v + m[v-1] + m[v+1])%MOD
            count[v] = (count[v] + added)%MOD
            
            # print(count, m)
            # m[v]=(v+m[v-1] + m[v+1])%MOD
            # print(v, m)
        return sum(m.values())%MOD
        ",1448209431
Salamander,BelgianSalamander,88,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        vector<int> dpLeft(nums.size(), 1), dpRight(nums.size(), 1);
        
        dpRight[0] = 1;
        for (int i = 1; i < nums.size(); i++) {
            if (nums[i] > nums[i-1]) {
                dpRight[i] = dpRight[i-1]+1;
            }
        }

        dpLeft.back() = 1;
        for (int i = nums.size() - 2; i >= 0; i--) {
            if (nums[i] < nums[i+1]) {
                dpLeft[i] = dpLeft[i+1]+1;
            }
        }

        int res = 0;

        for (int i = 0; i < nums.size() - 1; i++) {
            //cout << dpRight[i] << "" "" << dpLeft[i] << endl;
            res = max(res, min(dpRight[i], dpLeft[i+1]));
        }

        return res >= k;
    }
};",1448236506
Salamander,BelgianSalamander,88,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        vector<int> dpLeft(nums.size(), 1), dpRight(nums.size(), 1);
        
        dpRight[0] = 1;
        for (int i = 1; i < nums.size(); i++) {
            if (nums[i] > nums[i-1]) {
                dpRight[i] = dpRight[i-1]+1;
            }
        }

        dpLeft.back() = 1;
        for (int i = nums.size() - 2; i >= 0; i--) {
            if (nums[i] < nums[i+1]) {
                dpLeft[i] = dpLeft[i+1]+1;
            }
        }

        int res = 0;

        for (int i = 0; i < nums.size() - 1; i++) {
            //cout << dpRight[i] << "" "" << dpLeft[i] << endl;
            res = max(res, min(dpRight[i], dpLeft[i+1]));
        }

        return res;
    }
};",1448235747
Salamander,BelgianSalamander,88,3631,python3,"def reduce(x):
    res = 0
    while x:
        if x % 2:
            res += 1

        x //= 2
    return res

def goes(x):
    res = 0
    while x != 1:
        x = reduce(x)
        res += 1
    return res

MOD = 1000000007

class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        pows = [1] * 1000
        for i in range(1, 1000):
            pows[i] = (pows[i-1] * 2) % MOD

        dp = [[0] * (len(s) + 1) for _ in range((len(s) + 1))]
        dp2 = [[0] * (len(s) + 1) for _ in range((len(s) + 1))]
        dp2[-1] = [1] + [0] * len(s)

        for idx in range(len(s) - 1 , -1, -1):
            left = len(s) - idx - 1

            dp2[idx][0] = 1
            for cnt in range(1, len(s)+1):
                dp2[idx][cnt] = (dp2[idx+1][cnt] + dp2[idx+1][cnt-1]) % MOD


            for cnt in range(len(s)+1):
                if s[idx] == '0':
                    dp[idx][cnt] = dp[idx+1][cnt]
                else:
                    dp[idx][cnt] = (dp2[idx+1][cnt] + (dp[idx+1][cnt-1] if cnt != 0 else 0)) % MOD

        #print(*dp, sep=""\n"")
        #print(*dp2, sep = ""\n"")
            
        res = 0
        for i in range(1, len(s) + 1):
            if goes(i) < k:
                #print(i)
                res = (res + dp[0][i]) % MOD

        return res",1448222058
Salamander,BelgianSalamander,88,3646,python3,"MOD = 1000000007

class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        vals = {}
        res = 0

        for x in nums:
            tot = x
            cnt = 1
            
            if x-1 in vals:
                cnt += vals[x-1][0]
                tot += x * vals[x-1][0] + vals[x-1][1]
            if x+1 in vals:
                cnt += vals[x+1][0]
                tot += x * vals[x+1][0] + vals[x+1][1]

            #print(x, tot, cnt)

            res += tot
            if x in vals:
                vals[x] = (vals[x][0] + cnt, vals[x][1] + tot)
            else:
                vals[x] = (cnt, tot)

        return res % MOD",1448230430
Anonymous,never_seen,89,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        int cnt = 0;
        for (int i = 0; i < n; i++){
            int j = i;
            while (i + 1 < n and nums[i] < nums[i + 1]) ++i;
            if (i - j + 1 >= 2 * k) return true;
            if (i - j + 1 < k) cnt = 0;
            else cnt++;
            if (cnt > 1) return true;
        }
        return false;
    }
};",1448187390
Anonymous,never_seen,89,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        int cnt = 0, ans = 0;
        for (int i = 0; i < n; i++){
            int j = i;
            while (i + 1 < n and nums[i] < nums[i + 1]) ++i;
            ans = max(ans, (i - j + 1) / 2);
            ans = max(ans, min(cnt, i - j + 1));
            cnt = i - j + 1;
        }
        return ans;
    }
};",1448190059
Anonymous,never_seen,89,3631,cpp,"class Solution {
public:
    int p[801][5];
    int dp[800][800][2];
    const int mod = 1e9 + 7;
    int rec(int i, int cnt, bool t, int k, string &s){
        if (i == size(s)) return !t and cnt > 0 and p[cnt][k] == 1;
        int &ans = dp[i][cnt][t];
        if (~ans) return ans;
        ans = 0;
        int x = (t ? s[i] - '0' : 1);
        for (int j = 0; j <= x; j++){
            ans += rec(i + 1, cnt + j, t & (j == x), k, s);
            if (ans >= mod) ans -= mod;
        }
        return ans;
    }
    int countKReducibleNumbers(string s, int k) {
        for (int i = 0; i < 5; i++) p[1][i] = 1;
        for (int i = 2; i <= 800; i++){
            int k = __builtin_popcount(i);
            p[i][0] = i, p[i][1] = k;
            for (int j = 2; j < 5; j++){
                p[i][j] = p[k][1];
                k = p[k][1];
            }
        }
        memset(dp, -1, sizeof dp);
        return rec(0, 0, 1, k - 1, s);
    }
};",1448228781
Anonymous,never_seen,89,3646,cpp,"template <class T, T mod, class U = typename conditional<is_same<T, int32_t>::value, int64_t, __int128_t>::type> 
class modnum{
    T phi = mod - 1, u; // prime mod, a ^ b % mod = a ^ (b % phi) % mod
public: modnum() : modnum(0){}
    modnum(U v) : u(v >= 0 ? v % mod : (mod - (-v) % mod) % mod){}
    modnum(T v) : u(v >= mod ? v - mod : (v < 0 ? v + mod : v)){}
    T val()const{return u;}
    operator bool()const{return u != 0;}
    modnum &operator+=(const modnum &p){u += p.val(); if (u >= mod) u -= mod; return *this;}
    modnum &operator-=(const modnum &p){u += mod - p.val(); if (u >= mod) u -= mod; return *this;}
    modnum &operator*=(const modnum &p){u = T((U)u * (p.val()) % mod); return *this;}
    modnum &operator/=(const modnum &p){return *this *= p.inv();}
    template<class V> modnum &operator+=(const V &val){ return *this += modnum(val);}
    template<class V> modnum &operator-=(const V &val){ return *this -= modnum(val);}
    template<class V> modnum &operator*=(const V &val){ return *this *= modnum(val);}
    template<class V> modnum &operator/=(const V &val){ return *this /= modnum(val);}
    modnum &operator++(){return *this += 1;} 
    modnum &operator--(){return *this -= 1;}
    modnum operator++(T){modnum tmp = *this; ++*this; return tmp;}
    modnum operator--(T){modnum tmp = *this; --*this; return tmp;}
    modnum operator+(const modnum &p)const{return modnum(*this) += p;}
    modnum operator-(const modnum &p)const{return modnum(*this) -= p;}
    modnum operator*(const modnum &p)const{return modnum(*this) *= p;}
    modnum operator/(const modnum &p)const{return modnum(*this) /= p;}
    template<class V> modnum operator+(const V &val)const{return modnum(*this) += val;}
    template<class V> modnum operator-(const V &val)const{return modnum(*this) -= val;}
    template<class V> modnum operator*(const V &val)const{return modnum(*this) *= val;}
    template<class V> modnum operator/(const V &val)const{return modnum(*this) /= val;}
    modnum operator-()const{return modnum(0) - *this;}
    bool operator!()const{return !u;}
    bool operator~()const{return ~u;}
    bool operator==(const modnum &p)const{return u == p.u;}
    template<class V> bool operator==(const V val)const{return *this == modnum(val);}
    template<class V> bool operator!=(const V val)const{return *this != modnum(val);}
    bool operator!=(const modnum &p)const{return u != p.u;} 
    modnum inv()const{assert(*this); return expo(phi - 1);}
    modnum expo(U k)const{modnum now = *this, ret = 1; for (; k; k >>= 1, now *= now) if (k & 1) ret *= now; return ret;}
    modnum pow(U k)const{return k < 0 ? inv().expo(-k) : expo(k);}
    template<class V> friend modnum operator+(V lhs, const modnum& rhs){return rhs + lhs;}
    template<class V> friend modnum operator-(V lhs, const modnum& rhs){return -rhs + lhs;}
    template<class V> friend modnum operator*(V lhs, const modnum& rhs){return rhs * lhs;}
    template<class V> friend modnum operator/(V lhs, const modnum& rhs){return rhs.inv() * lhs;}
    template<class V> friend bool operator==(V lhs, const modnum& rhs){return rhs == lhs;}
    template<class V> friend bool operator!=(V lhs, const modnum& rhs){return rhs != lhs;}
    friend istream &operator>>(istream &is, modnum &p){U a; is >> a; p = a; return is;}
    friend ostream &operator<<(ostream &os, const modnum &p){return os << p.val();}
    friend void __print(modnum &p){cerr << p.val();}
};
const int mod = 1e9 + 7;
using mint = modnum<int32_t, mod>;
class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        const int m = 1e5;
        vector<mint> dp(m + 1), sum(m + 1);
        for (auto &e : nums){
            dp[e]++, sum[e] += e;
            if (e > 0){
                dp[e] += dp[e - 1];
                sum[e] += sum[e - 1] + dp[e - 1] * e;
            }
            if (e < m){
                dp[e] += dp[e + 1];
                sum[e] += sum[e + 1] + dp[e + 1] * e;
            }
        }
        mint ans = 0;
        for (auto &e : sum) ans += e;
        return ans.val();
    }
};",1448200433
Yatin Kwatra,yatin_kwatra,91,3612,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

#define ll                      long long
#define ar                      array
// #define int                     ll
#define sz(v)                   (int)(v.size())
#define FIO                     ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define ld                      long double
#define ull                     unsigned long long
#define endl                    ""\n""
#define fo(i,a,b)               for(int i = a; i<=b ; i++)
#define rfo(i,a,b)              for(int i = a; i>=b ; i--)
#define vii                     vector<int>
#define pq                      priority_queue
#define uomii                   unordered_map<int,int,best_hash>
#define all(v)                  v.begin(),v.end()
#define mp                      make_pair
#define pb                      push_back
#define pob                     pop_back
#define ff                      first
#define ss                      second
#define pii                     pair<int,int>
#define mii                     map<int,int>
#define vvii                    vector<vii>
#define mod                     1000000007
#define inf                     5e18
#define pi                      3.1415926535897932384626433832795
#define cz(x)                   63 - __builtin_clzll(x)



using namespace std;
using namespace __gnu_pbds;
template<class T> using oset =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;


// https://codeforces.com/blog/entry/68809

void __print(int x) {cout << x;}
void __print(long x) {cout << x;}
void __print(unsigned x) {cout << x;}
void __print(unsigned long x) {cout << x;}
void __print(unsigned long long x) {cout << x;}
void __print(float x) {cout << x;}
void __print(double x) {cout << x;}
void __print(long double x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(const char *x) {cout << '\""' << x << '\""';}
void __print(const string &x) {cout << '\""' << x << '\""';}
void __print(bool x) {cout << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << ','; __print(x.second); cout << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cout << '{'; for (auto &i : x) cout << (f++ ? "","" : """"), __print(i); cout << ""}"";}
void _print() {cout << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define pr(x...) cout << ""["" << #x << ""] = [""; _print(x)
#else
#define pr(x...)
#endif

// https://codeforces.com/blog/entry/62393

struct best_hash {
	static uint64_t splitmix64(uint64_t x) {

		x += 0x9e3779b97f4a7c15;
		x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
		x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
		return x ^ (x >> 31);
	}

	size_t operator()(uint64_t x) const {
		static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x + FIXED_RANDOM);
	}
};


/* ------------------------------- REAL CODING STARTS NOW --------------------------- */



class Solution {
public:
	bool hasIncreasingSubarrays(vector<int>& v, int k) {
		int n = sz(v);

		vii suf(n, 1), pre(n, 1);

		rfo(i, n - 2, 0) {
			if (v[i] < v[i + 1]) suf[i] = 1 + suf[i + 1];
		}
		fo(i, 1, n - 1) {
			if (v[i] > v[i - 1]) pre[i] = 1 + pre[i - 1];
		}

		fo(i, 0, n - 1) {
			if (i < k or n - i < k) continue;
			if (min(pre[i - 1], suf[i]) >= k) return true;
		}

		return false;
	}
};",1448190114
Yatin Kwatra,yatin_kwatra,91,3619,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

#define ll                      long long
#define ar                      array
// #define int                     ll
#define sz(v)                   (int)(v.size())
#define FIO                     ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define ld                      long double
#define ull                     unsigned long long
#define endl                    ""\n""
#define fo(i,a,b)               for(int i = a; i<=b ; i++)
#define rfo(i,a,b)              for(int i = a; i>=b ; i--)
#define vii                     vector<int>
#define pq                      priority_queue
#define uomii                   unordered_map<int,int,best_hash>
#define all(v)                  v.begin(),v.end()
#define mp                      make_pair
#define pb                      push_back
#define pob                     pop_back
#define ff                      first
#define ss                      second
#define pii                     pair<int,int>
#define mii                     map<int,int>
#define vvii                    vector<vii>
#define mod                     1000000007
#define inf                     5e18
#define pi                      3.1415926535897932384626433832795
#define cz(x)                   63 - __builtin_clzll(x)



using namespace std;
using namespace __gnu_pbds;
template<class T> using oset =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;


// https://codeforces.com/blog/entry/68809

void __print(int x) {cout << x;}
void __print(long x) {cout << x;}
void __print(unsigned x) {cout << x;}
void __print(unsigned long x) {cout << x;}
void __print(unsigned long long x) {cout << x;}
void __print(float x) {cout << x;}
void __print(double x) {cout << x;}
void __print(long double x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(const char *x) {cout << '\""' << x << '\""';}
void __print(const string &x) {cout << '\""' << x << '\""';}
void __print(bool x) {cout << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << ','; __print(x.second); cout << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cout << '{'; for (auto &i : x) cout << (f++ ? "","" : """"), __print(i); cout << ""}"";}
void _print() {cout << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define pr(x...) cout << ""["" << #x << ""] = [""; _print(x)
#else
#define pr(x...)
#endif

// https://codeforces.com/blog/entry/62393

struct best_hash {
	static uint64_t splitmix64(uint64_t x) {

		x += 0x9e3779b97f4a7c15;
		x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
		x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
		return x ^ (x >> 31);
	}

	size_t operator()(uint64_t x) const {
		static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x + FIXED_RANDOM);
	}
};


/* ------------------------------- REAL CODING STARTS NOW --------------------------- */



class Solution {
public:
	int maxIncreasingSubarrays(vector<int>& v) {
		int n = sz(v);

		vii suf(n, 1), pre(n, 1);

		rfo(i, n - 2, 0) {
			if (v[i] < v[i + 1]) suf[i] = 1 + suf[i + 1];
		}
		fo(i, 1, n - 1) {
			if (v[i] > v[i - 1]) pre[i] = 1 + pre[i - 1];
		}

		int k = 0;

		fo(i, 1, n - 1) {
			k = max(k, min(pre[i - 1], suf[i]));
		}
		return k;
	}
};",1448186409
Yatin Kwatra,yatin_kwatra,91,3631,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

#define ll                      long long
#define ar                      array
// #define int                     ll
#define sz(v)                   (int)(v.size())
#define FIO                     ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define ld                      long double
#define ull                     unsigned long long
#define endl                    ""\n""
#define fo(i,a,b)               for(int i = a; i<=b ; i++)
#define rfo(i,a,b)              for(int i = a; i>=b ; i--)
#define vii                     vector<int>
#define pq                      priority_queue
#define uomii                   unordered_map<int,int,best_hash>
#define all(v)                  v.begin(),v.end()
#define mp                      make_pair
#define pb                      push_back
#define pob                     pop_back
#define ff                      first
#define ss                      second
#define pii                     pair<int,int>
#define mii                     map<int,int>
#define vvii                    vector<vii>
#define mod                     1000000007
#define inf                     5e18
#define pi                      3.1415926535897932384626433832795
#define cz(x)                   63 - __builtin_clzll(x)



using namespace std;
using namespace __gnu_pbds;
template<class T> using oset =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;


// https://codeforces.com/blog/entry/68809

void __print(int x) {cout << x;}
void __print(long x) {cout << x;}
void __print(unsigned x) {cout << x;}
void __print(unsigned long x) {cout << x;}
void __print(unsigned long long x) {cout << x;}
void __print(float x) {cout << x;}
void __print(double x) {cout << x;}
void __print(long double x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(const char *x) {cout << '\""' << x << '\""';}
void __print(const string &x) {cout << '\""' << x << '\""';}
void __print(bool x) {cout << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << ','; __print(x.second); cout << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cout << '{'; for (auto &i : x) cout << (f++ ? "","" : """"), __print(i); cout << ""}"";}
void _print() {cout << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define pr(x...) cout << ""["" << #x << ""] = [""; _print(x)
#else
#define pr(x...)
#endif

// https://codeforces.com/blog/entry/62393

struct best_hash {
	static uint64_t splitmix64(uint64_t x) {

		x += 0x9e3779b97f4a7c15;
		x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
		x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
		return x ^ (x >> 31);
	}

	size_t operator()(uint64_t x) const {
		static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x + FIXED_RANDOM);
	}
};


/* ------------------------------- REAL CODING STARTS NOW --------------------------- */


ll addmod(ll a, ll b) {
	a %= mod;
	b %= mod;
	return (a + b) % mod;
}

ll submod(ll a, ll b) {
	a %= mod;
	b %= mod;
	a -= b;
	return (a % mod + mod) % mod;
}

ll mulmod(ll a, ll b) {
	a %= mod;
	b %= mod;

	return (a * b) % mod;
}


ll power(ll n, ll p) {
	ll res = 1;
	while (p) {
		if (p & 1) res = mulmod(res, n);
		n = mulmod(n, n);
		p /= 2;
	}
	return res;
}


ll divmod(ll a, ll b) {
	a %= mod;
	b %= mod;

	return mulmod(a, power(b, mod - 2));
}

const int N = 802;
int op[N];

void precompute() {
	fo(i, 1, N - 1) {
		int x = i;
		op[i] = 0;
		while (x > 1) {
			op[i]++;
			x = __builtin_popcount(x);
		}
	}
}

int dp[2][N][N];
int n;

class Solution {
public:

	int gino(bool sig, int pos, int sum, string &s, int k) {
		if (pos == n) {
			if (sig) return 0;
			return sum and op[sum] < k;
		}
		int &ans = dp[sig][pos][sum];
		if (ans != -1) return ans;
		ans = 0;

		if (sig) {
			if (s[pos] == '1') {
				ans = addmod(ans, gino(0, pos + 1, sum, s, k));
				ans = addmod(ans, gino(1, pos + 1, sum + 1, s, k));
			}
			else {
				ans = addmod(ans, gino(1, pos + 1, sum, s, k));
			}
		}
		else {
			ans = addmod(ans, gino(0, pos + 1, sum, s, k));
			ans = addmod(ans, gino(0, pos + 1, sum + 1, s, k));
		}
        
		return ans;
	}

	int countKReducibleNumbers(string s, int k) {
		if (!op[2]) precompute();
    
        n = sz(s);
		fo(i, 0, 1) {
			fo(j, 0, n) {
				fo(q, 0, n) {
					dp[i][j][q] = -1;
				}
			}
		}

		return gino(1, 0, 0, s, k);

	}
};













",1448245041
Yatin Kwatra,yatin_kwatra,91,3646,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

#define ll                      long long
#define ar                      array
// #define int                     ll
#define sz(v)                   (int)(v.size())
#define FIO                     ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define ld                      long double
#define ull                     unsigned long long
#define endl                    ""\n""
#define fo(i,a,b)               for(int i = a; i<=b ; i++)
#define rfo(i,a,b)              for(int i = a; i>=b ; i--)
#define vii                     vector<int>
#define pq                      priority_queue
#define uomii                   unordered_map<int,int,best_hash>
#define all(v)                  v.begin(),v.end()
#define mp                      make_pair
#define pb                      push_back
#define pob                     pop_back
#define ff                      first
#define ss                      second
#define pii                     pair<int,int>
#define mii                     map<int,int>
#define vvii                    vector<vii>
#define mod                     1000000007
#define inf                     5e18
#define pi                      3.1415926535897932384626433832795
#define cz(x)                   63 - __builtin_clzll(x)



using namespace std;
using namespace __gnu_pbds;
template<class T> using oset =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;


// https://codeforces.com/blog/entry/68809

void __print(int x) {cout << x;}
void __print(long x) {cout << x;}
void __print(unsigned x) {cout << x;}
void __print(unsigned long x) {cout << x;}
void __print(unsigned long long x) {cout << x;}
void __print(float x) {cout << x;}
void __print(double x) {cout << x;}
void __print(long double x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(const char *x) {cout << '\""' << x << '\""';}
void __print(const string &x) {cout << '\""' << x << '\""';}
void __print(bool x) {cout << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << ','; __print(x.second); cout << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cout << '{'; for (auto &i : x) cout << (f++ ? "","" : """"), __print(i); cout << ""}"";}
void _print() {cout << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define pr(x...) cout << ""["" << #x << ""] = [""; _print(x)
#else
#define pr(x...)
#endif

// https://codeforces.com/blog/entry/62393

struct best_hash {
	static uint64_t splitmix64(uint64_t x) {

		x += 0x9e3779b97f4a7c15;
		x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
		x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
		return x ^ (x >> 31);
	}

	size_t operator()(uint64_t x) const {
		static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x + FIXED_RANDOM);
	}
};


/* ------------------------------- REAL CODING STARTS NOW --------------------------- */





ll addmod(ll a, ll b) {
	a %= mod;
	b %= mod;
	return (a + b) % mod;
}

ll submod(ll a, ll b) {
	a %= mod;
	b %= mod;
	a -= b;
	return (a % mod + mod) % mod;
}

ll mulmod(ll a, ll b) {
	a %= mod;
	b %= mod;

	return (a * b) % mod;
}


ll power(ll n, ll p) {
	ll res = 1;
	while (p) {
		if (p & 1) res = mulmod(res, n);
		n = mulmod(n, n);
		p /= 2;
	}
	return res;
}

ll divmod(ll a, ll b) {
	a %= mod;
	b %= mod;

	return mulmod(a, power(b, mod - 2));
}




const int N = 1e5 + 5;
int nxtBig[N], nxtSmall[N], nxtSame[N];
ar<int, 2> dp[N];
int n;

class Solution {
public:

	ar<int, 2> gino(int pos, vii &v) {
		if (pos == n) return {0, 1};
		auto &ans = dp[pos];
		if (ans[0] != -1) return ans;
		ans = {v[pos], 1};

		if (nxtBig[pos] != -1) {
			auto got = gino(nxtBig[pos], v);
			ans[0] = addmod(ans[0], got[0]);
			ans[0] = addmod(ans[0], mulmod(got[1], v[pos]));
			ans[1] = addmod(ans[1], got[1]);
		}


		if (nxtSmall[pos] != -1) {
			auto got = gino(nxtSmall[pos], v);
			ans[0] = addmod(ans[0], got[0]);
			ans[0] = addmod(ans[0], mulmod(got[1], v[pos]));
			ans[1] = addmod(ans[1], got[1]);
		}


		if (nxtSame[pos] != -1) {
			auto got = gino(nxtSame[pos], v);
			ans[0] = addmod(ans[0], got[0]);
			ans[1] = addmod(ans[1], got[1]);
		}

		return ans;
	}

	int sumOfGoodSubsequences(vector<int>& v) {
		n = sz(v);

		fo(i, 0, n - 1) {
			nxtBig[i] = -1;
			nxtSmall[i] = -1;
			dp[i][0] = dp[i][1] = -1;
			nxtSame[i] = -1;
		}

		uomii pos;

		rfo(i, n - 1, 0) {
			if (pos.count(v[i] + 1)) nxtBig[i] = pos[v[i] + 1];
			if (pos.count(v[i] - 1)) nxtSmall[i] = pos[v[i] - 1];
			if (pos.count(v[i])) nxtSame[i] = pos[v[i]];

			pos[v[i]] = i;
		}

		pos.clear();

		int ans = 0;

		fo(i, 0, n - 1) {
			if (pos.count(v[i])) continue;
			auto got = gino(i, v);
			ans = addmod(ans, got[0]);
			pos[v[i]] = 1;
		}
		return ans;
	}
};",1448216470
furuyarei,furuyarei,92,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        for (int i = 0; i + k * 2 <= n; ++i) {
            bool check = true;
            for (int j = i + 1; j < i + k; ++j) {
                if (nums[j] <= nums[j - 1]) {
                    check = false;
                }
            }
            for (int j = i + k + 1; j < i + k * 2; ++j) {
                if (nums[j] <= nums[j - 1]) {
                    check = false;
                }
            }
            if (check) {
                return true;
            }
        }
        return false;
    }
};",1448234724
furuyarei,furuyarei,92,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> v(n, 1);
        for (int i = n - 2; i >= 0; --i) {
            if (nums[i] < nums[i + 1]) {
                v[i] = v[i + 1] + 1;
            }
        }
        int ans = (*max_element(v.begin(), v.end())) / 2;
        for (int i = 0; i < n; ++i) {
            if (i + v[i] < n && v[i + v[i]] >= v[i]) {
                ans = max(ans, v[i]);
            }
        }
        return ans;
    }
};",1448238232
furuyarei,furuyarei,92,3631,python3,"N = 810
MOD = 10**9 + 7
cc = [[0] * N for _ in range(N)]

for i in range(N):
    cc[i][0] = 1
    for j in range(1, i + 1):
        cc[i][j] = (cc[i - 1][j - 1] + cc[i - 1][j]) % MOD

f = [0] * N
f[1] = 0
for i in range(2, N):
    f[i] = f[i.bit_count()] + 1

def calc(s: str, x: int) -> int:
    if len(s) < x:
        return 0

    ans = 0
    cur = 0
    for i, o in enumerate(s):
        if o == '1':
            ans = (ans + cc[len(s) - i - 1][x - cur]) % MOD
            cur += 1
    return ans

class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        ans = 0
        for i in range(1, N):
            if f[i] <= k - 1:
               ans = (ans + calc(s, i)) % MOD
                
        return ans",1448212561
furuyarei,furuyarei,92,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int mod = 1000000007;
        unordered_map<int, long long> sum, cnt;
        for (int num: nums) {
            sum[num] = (sum[num] + num) % mod;
            cnt[num] = (cnt[num] + 1) % mod;
            
            if (sum.count(num - 1)) {
                sum[num] = (sum[num] + sum[num - 1] + cnt[num - 1] * num) % mod;
                cnt[num] = (cnt[num] + cnt[num - 1]) % mod;
            }
            
            if (sum.count(num + 1)) {
                sum[num] = (sum[num] + sum[num + 1] + cnt[num + 1] * num) % mod;
                cnt[num] = (cnt[num] + cnt[num + 1]) % mod;
            }
        }

        int ans = 0;
        for (auto&& [_, v]: sum) {
            ans = (ans + v) % mod;
        }
        return ans;
    }
};",1448227826
Iakobos,Iakobos,93,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(std::vector<int>& nums, int k) {
        int n = nums.size();
        if (n < 2 * k) return false;  // 需要至少两个长度为k的子数组
        
        // 检查从索引start开始的长度为k的子数组是否严格递增
        auto isStrictlyIncreasing = [&](int start) {
            for (int i = start; i < start + k - 1; ++i) {
                if (nums[i] >= nums[i + 1]) return false;
            }
            return true;
        };

        // 遍历找到两个相邻的严格递增子数组
        for (int i = 0; i <= n - 2 * k; ++i) {
            if (isStrictlyIncreasing(i) && isStrictlyIncreasing(i + k)) {
                return true;
            }
        }
        return false;
    }
};",1448180983
Iakobos,Iakobos,93,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        if (n < 2) return 0;

        vector<int> inc_len(n, 1);
        for (int i = n - 2; i >= 0; --i) {
            if (nums[i] < nums[i + 1]) {
                inc_len[i] = inc_len[i + 1] + 1;
            }
        }

        int low = 1, high = n / 2, result = 0;


        while (low <= high) {
            int mid = low + (high - low) / 2;
            if (check(nums, inc_len, mid)) {
                result = mid;
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }

        return result;
    }

private:
    bool check(vector<int>& nums, vector<int>& inc_len, int k) {
        int n = nums.size();
        for (int i = 0; i <= n - 2 * k; ++i) {
            if (inc_len[i] >= k && inc_len[i + k] >= k) {
                return true;
            }
        }
        return false;
    }
};
",1448216176
Iakobos,Iakobos,93,3631,cpp,"class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        const int MOD = 1e9 + 7;
        int L = s.length();
        vector<int> sp(1001, -1);

        function<int(int)> compute_sp = [&](int p) {
            if (sp[p] != -1) return sp[p];
            if (p == 1) return sp[p] = 0;
            return sp[p] = compute_sp(__builtin_popcount(p)) + 1;
        };

        for (int p = 1; p <= L; ++p) {
            compute_sp(p);
        }

        vector<vector<vector<int>>> dp(L+1, vector<vector<int>>(2, vector<int>(L+1, 0)));
        dp[0][1][0] = 1;

        for (int pos = 0; pos < L; ++pos) {
            for (int tight = 0; tight <= 1; ++tight) {
                for (int ones = 0; ones <= pos; ++ones) {
                    int max_digit = tight ? (s[pos] - '0') : 1;
                    for (int digit = 0; digit <= max_digit; ++digit) {
                        int new_tight = tight && (digit == max_digit);
                        int new_ones = ones + digit;
                        dp[pos+1][new_tight][new_ones] = (dp[pos+1][new_tight][new_ones] + dp[pos][tight][ones]) % MOD;
                    }
                }
            }
        }

        vector<int> count_p(L+1, 0);
        for (int ones = 1; ones <= L; ++ones) {
            int total = (dp[L][0][ones] + dp[L][1][ones]) % MOD;
            count_p[ones] = total;
        }

        int ans = 0;
        for (int p = 1; p <= L; ++p) {
            if (sp[p] <= k - 1) {
                ans = (ans + count_p[p]) % MOD;
            }
        }

        if (s == ""1"") {
            ans = 0;
        } else {
            int total_ones_in_n = 0;
            for (char c : s) {
                if (c == '1') total_ones_in_n++;
            }
            if (sp[total_ones_in_n] <= k - 1) {
                ans = (ans - 1 + MOD) % MOD;
            }
        }

        return ans;
    }
};
",1448230356
Iakobos,Iakobos,93,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        const int MOD = 1e9 + 7;
        unordered_map<int, long long> counts;
        unordered_map<int, long long> sums;

        for (int num : nums) {
            long long temp_count = counts[num];
            long long temp_sum = sums[num];


            long long new_count = temp_count + 1;
            long long new_sum = (temp_sum + num) % MOD;


            if (counts.count(num - 1)) {
                new_count = (new_count + counts[num - 1]) % MOD;
                new_sum = (new_sum + sums[num - 1] + num * counts[num - 1] % MOD) % MOD;
            }

            if (counts.count(num + 1)) {
                new_count = (new_count + counts[num + 1]) % MOD;
                new_sum = (new_sum + sums[num + 1] + num * counts[num + 1] % MOD) % MOD;
            }

            counts[num] = new_count;
            sums[num] = new_sum;
        }

        long long total_sum = 0;
        for (auto& pair : sums) {
            total_sum = (total_sum + pair.second) % MOD;
        }

        return total_sum;
    }
};
",1448213357
Wei Liu,nevergiveup,94,3612,java,"class Solution {

    private boolean check(List<Integer> nums, int l, int r) {
        for (int i = l;i < r;i ++) {
            if (nums.get(i) >= nums.get(i + 1)) {
                return false;
            }
        }
        return true;
    }

    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        int n = nums.size();
        for (int i = 0;i + 2 * k - 1 < n;i ++) {
            if (check(nums, i, i + k -1) && check(nums, i + k, i + 2 * k - 1)) {
                return true;
            }
        }
        return false;
    }

}",1448181973
Wei Liu,nevergiveup,94,3619,java,"class Solution {

    private void build(List<Integer> nums) {
        for (int i = 0;i < nums.size();i ++) {
            dp[i] = 1;
            if (i > 0 && (nums.get(i) > nums.get(i - 1))) {
                dp[i] = dp[i - 1] + 1;
            }
        }
    }

    private static int[] dp = new int[200010];

    private boolean isAsc(int l, int r) {
        int result = dp[r];
        int expect = r - l + 1;
        if (result >= expect) {
            return true;
        } else {
            return false;
        }
    }

    private boolean check(int n, int k) {
        for (int i = 0;i + 2 * k - 1 < n;i ++) {
            if (isAsc(i, i + k - 1) && isAsc(i + k, i + 2 * k - 1)) {
                return true;
            }
        }
        return false;
    }

    public int maxIncreasingSubarrays(List<Integer> nums) {
        build(nums);
        int low = 1, high = 1000_10;
        while (low < high) {
            int mid = (low + high) / 2;
            if (check(nums.size(), mid)) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return high - 1;
    }
}",1448190319
Wei Liu,nevergiveup,94,3631,java,"class Solution {

    private int getBits(int value) {
        int ans = 0;
        while (value > 0) {
            if (value % 2 != 0) {
                ans ++;
            }
            value /= 2;
        }
        return ans;
    }

    private void build(String s) {
        // build result
        result[1] = 1;
        for (int i = 2;i <= 1000;i ++) {
            int bits = getBits(i);
            result[i] = result[bits] + 1;
        }
    }

    private int[] result = new int[1010];
    private static long[][][] dp = new long[1010][1010][2];

    private static final long MOD = 1000_000_007L;

    public int countKReducibleNumbers(String s, int k) {
        Arrays.fill(result, -1);
        build(s);
        for (int i = 0;i < 1010;i ++) {
            for (int j = 0;j < 1010;j ++) {
                for (int less = 0;less < 2;less ++) {
                    dp[i][j][less] = - 1;
                }
            }
        }
        return (int) ((solve(s, 0, 0, 0, k) % MOD));
    }

    private long solve(String s, int cur, int count, int less, int k) {
        if (cur == s.length()) {
            if (result[count] <= k && less > 0 && count > 0) {
                return 1;
            } else {
                return 0;
            }
        }
        if (dp[cur][count][less] >= 0) {
            return dp[cur][count][less];
        }
        long ans = 0;
        if (less > 0) {
            // use one
            ans = (ans + solve(s, cur + 1, count + 1, less, k)) % MOD;
            // use zero
            ans = (ans + solve(s, cur + 1, count, less, k)) % MOD;
        } else {
            int curDigit = s.charAt(cur) - '0';
            if (curDigit == 1) {
                ans = (ans + solve(s, cur + 1, count + 1, 0, k)) % MOD;
                ans = (ans + solve(s, cur + 1, count, 1, k)) % MOD;
            } else {
                ans = (ans + solve(s, cur + 1, count, 0, k)) % MOD;
            }
        }
        return dp[cur][count][less] = ans;
    }

}",1448246769
Wei Liu,nevergiveup,94,3646,java,"class Solution {


    private final long MOD = 1000_000_007L;

    private long[] sum = new long[100010];
    private long[] total = new long[100010];

    public int sumOfGoodSubsequences(int[] nums) {
        long ans = 0;
        for (int i = 0;i < nums.length;i ++) {
            int cur = nums[i];
            if (cur - 1 >= 0) {
                sum[cur] = (sum[cur] + ((((total[cur - 1] * cur) % MOD) + sum[cur - 1]) % MOD)) % MOD;
                total[cur] = (total[cur] + total[cur - 1]) % MOD;
            }
            sum[cur] = (sum[cur] + ((((total[cur + 1] * cur) % MOD) + sum[cur + 1]) % MOD)) % MOD;
            total[cur] = (total[cur] + total[cur + 1]) % MOD;
            // single
            sum[cur] = (sum[cur] + cur) % MOD;
            total[cur] = (total[cur] + 1) % MOD;
        }
        for (int i = 0;i <= 100000;i ++) {
            ans = (ans + sum[i]) % MOD;
        }
        return (int) ans;
    }

}",1448223842
xs_pg,xs_pg,99,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        for i in range(n):
            if i + 2 * k > n:
                return False
            f = True
            for j in range(i, i+k-1):
                if nums[j] >= nums[j+1]:
                    f = False
            for j in range(i+k, i+k+k-1):
                if nums[j] >= nums[j+1]:
                    f = False
            if f:
                return True
        ",1448182353
xs_pg,xs_pg,99,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        v = [1] * n
        for i in range(n-2, -1, -1):
            if nums[i] < nums[i+1]:
                v[i] = v[i+1] + 1
        # print(v)
        
        def check(x):
            for i in range(n):
                if i + 2 * x > n:
                    return False
                if v[i] >= x and v[i+x] >= x:
                    return True
        
        l, r = 1, n // 2
        while l < r:
            mi = (l + r + 1) >> 1
            if check(mi):
                l = mi
            else:
                r = mi - 1
        
        return l
        ",1448192098
xs_pg,xs_pg,99,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        mod = 10 ** 9 + 7
        n = len(s)
        os = 0
        for x in s:
            if x == '1':
                os += 1
        zs = n - os
        
        if k == 1:
            if os == 1:
                return n - 1
            else:
                return n
        
        a = []
        def f(x):
            cnt = 0
            while x != 1:
                x = x.bit_count()
                cnt += 1
            return cnt
        d = defaultdict(list)
        for x in range(1, 802):
            if f(x) < k and x <= n:
                a.append(x)
        # print(a)
        
        C = [[0 for _ in range(n+1)] for _ in range(n+1)]
        C[0][0] = 1
        for i in range(1, n+1):
            for j in range(i+1):
                if j:
                    C[i][j] += C[i-1][j-1]
                if j != i:
                    C[i][j] += C[i-1][j]
                C[i][j] %= mod
        # print(C)
        
        @cache
        def dp(index, left):
            if index + left > n:
                return 0
            if left == 0:
                return 1
            if s[index] == '0':
                return dp(index+1, left)
            else:
                return dp(index+1, left-1) + C[n-index-1][left] % mod
        
        ans = 0
        for x in a:
            # print(x, dp(0, x))
            ans += dp(0, x)
        
        if f(os) < k:
            ans -= 1
        
        return ans % mod
        
        
",1448247934
xs_pg,xs_pg,99,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        n = len(nums)
        mod = 10 ** 9 + 7
        
        cs = defaultdict(int)
        vs = defaultdict(int)
        
        for i in range(n):
            x = nums[i]
            cs[x] += 1
            vs[x] += x
            for y in [x-1, x+1]:
                if y not in cs:
                    continue
                c, v = cs[y], vs[y]
                cs[x] += c
                vs[x] += v + x * c
            cs[x] %= mod
            vs[x] %= mod
        
        ans = 0
        for k in vs:
            ans += vs[k]
        return ans % mod
                
        ",1448213317
parallel_stream,parallel_stream,101,3612,java,"class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        return IntStream.rangeClosed(0, nums.size() - 2 * k)
                .anyMatch(i -> isStrictlyIncreasing(nums.subList(i, i + k)) && isStrictlyIncreasing(nums.subList(i + k, i + 2 * k)));
    }

    private boolean isStrictlyIncreasing(List<Integer> sublist) {
        return IntStream.range(0, sublist.size() - 1)
                .allMatch(i -> sublist.get(i) < sublist.get(i + 1));
    }
}",1448183475
parallel_stream,parallel_stream,101,3619,java,"class Solution {
  public int maxIncreasingSubarrays(List<Integer> nums) {
    int n = nums.size();
    int[] left = new int[n];
    int[] right = new int[n];
    IntStream.range(0, n)
        .forEach(i -> left[i] = (i == 0 || nums.get(i) <= nums.get(i - 1)) ? 1 : left[i - 1] + 1);
    IntStream.iterate(n - 1, i -> i >= 0, i -> i - 1)
        .forEach(i -> right[i] = (i == n - 1 || nums.get(i) >= nums.get(i + 1)) ? 1 : right[i + 1] + 1);
    return IntStream.range(1, n).map(i -> Math.min(left[i - 1], right[i])).max().orElse(0);
  }
}",1448190507
parallel_stream,parallel_stream,101,3631,java,"class Solution {
  private static final int MOD = 1_000_000_007;

  public int countKReducibleNumbers(String s, int k) {
    int n = s.length();
    int[] steps = new int[n + 1];
    steps[1] = 0;
    IntStream.rangeClosed(2, n).forEach(c -> steps[c] = 1 + (c > 0 ? steps[popCount(c)] : 0));
    long[][][] dp = new long[n + 1][2][2];
    dp[0][1][0] = 1;
    for (int i = 0; i < n; i++) {
      long[][][] dpn = new long[n + 1][2][2];
      int bit = s.charAt(i) - '0';
      for (int c = 0; c <= n; c++) {
        for (int p = 0; p <= 1; p++) {
          for (int q = 0; q <= 1; q++) {
            if (dp[c][p][q] != 0) {
              int limit = p == 1 ? bit : 1;
              for (int r = 0; r <= limit; r++) {
                int np = (p == 1 && r == limit) ? 1 : 0;
                int nq = (q == 1 || r == 1) ? 1 : 0;
                int nc = nq == 1 ? c + r : 0;
                if (nc <= n) {
                  dpn[nc][np][nq] = (dpn[nc][np][nq] + dp[c][p][q]) % MOD;
                }
              }
            }
          }
        }
      }
      dp = dpn;
    }
    long ans = 0;
    for (int c = 1; c <= n; c++) {
      if (steps[c] <= k - 1) {
        ans = (ans + dp[c][0][1] + dp[c][1][1]) % MOD;
      }
    }
    int count = 0;
    for (char ch : s.toCharArray()) {
      if (ch == '1') {
        count++;
      }
    }
    if (count > 0 && steps[count] <= k - 1) {
      ans = (ans - 1 + MOD) % MOD;
    }
    return (int) ans;
  }

  private int popCount(int x) {
    int count = 0;
    while (x > 0) {
      count += x & 1;
      x >>= 1;
    }
    return count;
  }
}",1448241323
parallel_stream,parallel_stream,101,3646,java,"class Solution {

  private static final int MOD = 1_000_000_007;
  private static final int MAX = 100001;
  
  public int sumOfGoodSubsequences(int[] nums) {
    long[] c = new long[MAX];
    long[] s = new long[MAX];
    AtomicLong ans = new AtomicLong();
    Arrays.stream(nums).forEach(num -> {
      long cnt = (1 + (num > 0 ? c[num - 1] : 0) + (num < 100000 ? c[num + 1] : 0)) % MOD;
      long sm = (num + (num > 0 ? s[num - 1] : 0) + (num > 0 ? (num * c[num - 1]) % MOD : 0)
          + (num < 100000 ? s[num + 1] : 0) + (num < 100000 ? (num * c[num + 1]) % MOD : 0)) % MOD;
      c[num] = (c[num] + cnt) % MOD;
      s[num] = (s[num] + sm) % MOD;
      ans.set((ans.get() + sm) % MOD);
    });
    return (int) ans.get();
  }
}",1448202499
arignote,arignote,102,3612,java,"class Solution {

    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        return maxIncreasingSubarrays(nums) >= k;
    }

    public int maxIncreasingSubarrays(List<Integer> nums) {
        int max = 1;
        for (int i = 1, j = 0, k = 0; i <= nums.size(); i++) {
            if (i == nums.size() || nums.get(i) <= nums.get(i - 1)) {
                max = Math.max(max, Math.max((i - j) / 2, Math.min(k, i - j)));
                k = i - j;
                j = i;
            }
        }
        return max;
    }
}",1448241663
arignote,arignote,102,3619,java,"class Solution {

    public int maxIncreasingSubarrays(List<Integer> nums) {
        int max = 1;
        for (int i = 1, j = 0, k = 0; i <= nums.size(); i++) {
            if (i == nums.size() || nums.get(i) <= nums.get(i - 1)) {
                max = Math.max(max, Math.max((i - j) / 2, Math.min(k, i - j)));
                k = i - j;
                j = i;
            }
        }
        return max;
    }
}",1448241339
arignote,arignote,102,3631,java,"class Solution {

    public int countKReducibleNumbers(String s, int k) {
        return countKReducibleNumbers(0, 1, 0, s, k, new Integer[s.length()][s.length()][2]);
    }

    private int countKReducibleNumbers(int i, int flag, int count, String s, int k, Integer[][][] dp) {
        if (i == s.length()) {
            for (int j = 1; j < k; j++) {
                count = Integer.bitCount(count);
            }
            return flag < 1 && count == 1 ? 1 : 0;
        } else if (dp[i][count][flag] == null) {
            dp[i][count][flag] = (countKReducibleNumbers(i + 1, flag > 0 && s.charAt(i) == '0' ? 1 : 0, count, s, k, dp) + (flag == 0 || s.charAt(i) > '0' ? countKReducibleNumbers(i + 1, flag > 0 && s.charAt(i) > '0' ? 1 : 0, count + 1, s, k, dp) : 0)) % 1000000007;
        }
        return dp[i][count][flag];
    }
}",1448241037
arignote,arignote,102,3646,java,"class Solution {

    public int sumOfGoodSubsequences(int[] nums) {
        HashMap<Integer, long[]> map = new HashMap<>();
        for (int num : nums) {
            map.put(num, new long[] { (map.getOrDefault(num, new long[2])[0] + map.getOrDefault(num - 1, new long[2])[0] + map.getOrDefault(num + 1, new long[2])[0] + (map.getOrDefault(num - 1, new long[2])[1] + map.getOrDefault(num + 1, new long[2])[1] + 1) * num) % 1000000007, (map.getOrDefault(num, new long[2])[1] + map.getOrDefault(num - 1, new long[2])[1] + map.getOrDefault(num + 1, new long[2])[1] + 1) % 1000000007 });
        }
        long sum = 0;
        for (long[] i : map.values()) {
            sum += i[0];
        }
        return (int) (sum % 1000000007);
    }
}",1448240721
Ashwanth K,ashwanthkannan,104,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
         int n = nums.size();
        vector<int> dp(n , 0);
        
        dp[n-1] = 1;
        
        for(int i = n-2 ; i >= 0 ; i --)
        {
            if(nums[i] < nums[i+1])
            {
                dp[i] = 1 + dp[i+1];
            }
            else
            {
                dp[i] = 1;
            }
        }
        
        
        for(int i = 0 ; i+k < n ; i ++)
        {
            if((dp[i] >= k) && (dp[i+k] >= k)) return true;
        }
        return false;
    }
};",1448249626
Ashwanth K,ashwanthkannan,104,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        
        
        int n = nums.size();
        vector<int> dp(n , 0);
        
        dp[n-1] = 1;
        
        for(int i = n-2 ; i >= 0 ; i --)
        {
            if(nums[i] < nums[i+1])
            {
                dp[i] = 1 + dp[i+1];
            }
            else
            {
                dp[i] = 1;
            }
            
            
            
           // cout << dp[i] << "" "";
        }
        
        //cout << endl;
        
        int fans = 0;
        
        int j = -1;
        for(int i = n-1 ; i >= 0 ; i --)
        {
            if(i+1 < n  && nums[i] >= nums[i+1])
            {
                j = i+1;
            }
            
            fans = max(fans , dp[i]/2);
            if(j != -1)
            {
                int k = j-i;
                if((dp[i] >= k) && (dp[j] >= k))
                {
                    fans = max(fans , k);
                }
                
              //  cout << i << j << endl;
            }
            
        }
        
        return fans;
        
    }
};",1448247600
Ashwanth K,ashwanthkannan,104,3631,cpp,"#define ll long long

class Solution {
public:
    
    int precalc[1000];
    int K;
    string ss;
    
    
    ll dp[1005][1005][2];
    ll mod = 1e9 + 7;
    
    ll recur(int i , int sb , bool tight)
    {   
        
        if(i == -1)
        {
            return (!tight) && (precalc[sb] <= K);
        }
        
        
        if(dp[i][sb][tight]  != -1) return dp[i][sb][tight];
    
        ll ans = 0;
        for(int b = 0 ; b < 2 ; b ++)
        {
            bool allow = (!tight) || (b <= (ss[i]-'0')); 
            if(allow)
            {
                bool newtight = tight & ((ss[i] - '0') == b); 
                ans += recur(i-1  , sb + ((b ==1)?1:0) , newtight);
            }
        }
        
        
        if(ans >= mod) ans -= mod;
        
        return dp[i][sb][tight] = ans;
    }
    
    int countKReducibleNumbers(string s, int k) {
        
        int n = s.length();
        ss = s;
        K = k;
        reverse(ss.begin() , ss.end());
        
        
        
        for(int i = 0 ; i <= n ; i ++)
        {
            for(int j = 0 ; j <= n ; j ++)
            {
                dp[i][j][0] = -1;
                dp[i][j][1] = -1;
            }
        }
        
        precalc[1] = 1;
        precalc[0] = 1500;
        
        for(int i = 2 ; i <= n ; i ++)
        {
            precalc[i] = 1 + precalc[__builtin_popcountl(i)];
        }
        
        ll ans = recur(n-1 , 0 , 1);
        ans %= mod;
        if(ans < 0) ans += mod;
        
        return ans;
        
    }
};",1448216809
Ashwanth K,ashwanthkannan,104,3646,cpp,"#define ll long long


ll mod = 1e9 + 7;

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        
        ll n = nums.size();
        ll pref[n];
        ll suff[n];
        
        map<ll  , ll> info;
        
        for(int i = 0 ; i < n ; i ++)
        {
            ll v = info[nums[i]-1] + info[nums[i]+1] + 1;
            info[nums[i]] += v;
            info[nums[i]] %=mod;
            pref[i] = v;
        }
        
        
        info.clear();
        
        for(int i = n-1; i >=0 ; i --)
        {
            ll v = info[nums[i]-1] + info[nums[i]+1] + 1;
            info[nums[i]] += v;
            info[nums[i]] %=mod;
            suff[i] = v;
        }
        
        
        
        ll ans = 0;
        for(int i = 0 ; i < n ; i ++)
        {
            ans += (((nums[i]*pref[i])%mod)*suff[i])%mod;
            ans %= mod;
        }
        
        
        return ans;
    }
};",1448188337
turneja,turneja,105,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& a, int k) {
        int n = a.size();
        vector<int> pos;
        for (int i = 1; i < n; i++) {
            if (a[i] <= a[i - 1]) {
                pos.push_back(i);
            }
        }
        if (pos.empty()) {
            int ans = n / 2;
            if (ans >= k) {
                return true;
            }
            return false;
        }
        int ans = 1;
        for (int i = 0; i < n; i++) {
            int j = lower_bound(pos.begin(), pos.end(), i + 1) - pos.begin();
            if (j == pos.size()) {
                ans = max(ans, (n - i) / 2);
                continue;
            }
            int l = pos[j] - 1, r = ((j == pos.size() - 1) ? n - 1 : pos[j + 1] - 1);
            ans = max(ans, (l - i + 1) / 2);
            ans = max(ans, min(l - i + 1, r - l));
        }
        if (ans >= k) {
            return true;
        }
        return false;
    }
};",1448198724
turneja,turneja,105,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& a) {
        int n = a.size();
        vector<int> pos;
        for (int i = 1; i < n; i++) {
            if (a[i] <= a[i - 1]) {
                pos.push_back(i);
            }
        }
        if (pos.empty()) {
            int ans = n / 2;
            return ans;
        }
        int ans = 1;
        for (int i = 0; i < n; i++) {
            int j = lower_bound(pos.begin(), pos.end(), i + 1) - pos.begin();
            if (j == pos.size()) {
                ans = max(ans, (n - i) / 2);
                continue;
            }
            int l = pos[j] - 1, r = ((j == pos.size() - 1) ? n - 1 : pos[j + 1] - 1);
            ans = max(ans, (l - i + 1) / 2);
            ans = max(ans, min(l - i + 1, r - l));
        }
        return ans;
    }
};",1448195983
turneja,turneja,105,3631,cpp,"const int N = 805;
const long long M = 1e9 + 7;
long long dp[N][N][3];
class Solution {
public:
    bool dfs(int n, int k) {
        if (k == 0) {
            return n == 1;
        }
        n = __builtin_popcount(n);
        return dfs(n, k - 1);
    }
    
    long long calc(string s, int k) {
        int n = s.size();
        if (s[0] == '1') {
            dp[0][1][2] = 1;
        } else {
            dp[0][1][1] = 1;
        }
        
        for (int i = 1; i < n; i++) {
            for (int j = 1; j <= i + 1; j++) {
                if (s[i] == '1') {
                    dp[i][j][0] = (dp[i][j][0] + dp[i - 1][j - 1][0]) % M;
                    dp[i][j][1] = (dp[i][j][1] + dp[i - 1][j - 1][1]) % M;
                    dp[i][j][2] = (dp[i][j][2] + dp[i - 1][j - 1][2]) % M;
                    
                    dp[i][j][1] = (dp[i][j][1] + dp[i - 1][j][1]) % M;
                    dp[i][j][0] = (dp[i][j][0] + dp[i - 1][j][0] + dp[i - 1][j][2]) % M;
                } else {
                    dp[i][j][0] = (dp[i][j][0] + dp[i - 1][j - 1][0]) % M;
                    dp[i][j][1] = (dp[i][j][1] + dp[i - 1][j - 1][1] + dp[i - 1][j - 1][2]) % M;
                    
                    dp[i][j][0] = (dp[i][j][0] + dp[i - 1][j][0]) % M;
                    dp[i][j][1] = (dp[i][j][1] + dp[i - 1][j][1]) % M;
                    dp[i][j][2] = (dp[i][j][2] + dp[i - 1][j][2]) % M;
                    
                }
            }
        }
        long long ans = 0;
        for (int j = 1; j <= n; j++) {
            bool can = dfs(j, k - 1);
            if (!can) {
                continue;
            }
            for (int i = 0; i < n; i++) {
                ans = (ans + dp[i][j][0]) % M;
                if (i != n - 1) {
                    ans = (ans + dp[i][j][1] + dp[i][j][2]) % M;
                }
            }
        }
        return ans;
        
    }
        
    int countKReducibleNumbers(string s, int k) {
        long long ans = calc(s, k);
        int n = s.size();
        for (int i = 0; i < n; i++) {
            for (int j = 1; j <= n; j++) {
                dp[i][j][0] = 0;
                dp[i][j][1] = 0;
                dp[i][j][2] = 0;
            }
        }
        return ans % M;
    }
};",1448242299
turneja,turneja,105,3646,cpp,"const int M = 1e9 + 7;
const int N = 1e5 + 5;
class Solution {
public:
    pair<long long, long long> dp[N];
    bool seen[N];
    
    int sumOfGoodSubsequences(vector<int>& a) {
        int n = a.size();
        for (int i = 0; i < n; i++) {
            if (a[i] != 0) {
                dp[a[i]].first = (dp[a[i]].first + dp[a[i] - 1].first) % M;
                dp[a[i]].second = (dp[a[i]].second + dp[a[i] - 1].first * a[i] + dp[a[i] - 1].second) % M;
            }
            dp[a[i]].first = (dp[a[i]].first + dp[a[i] + 1].first) % M;
            dp[a[i]].second = (dp[a[i]].second + dp[a[i] + 1].first * a[i] + dp[a[i] + 1].second) % M;
            dp[a[i]].first = (dp[a[i]].first + 1) % M;
            dp[a[i]].second = (dp[a[i]].second + a[i]) % M;
        }
        long long ans = 0;
        for (int i = 0; i < n; i++) {
            if (!seen[a[i]]) {
                seen[a[i]] = true;
                ans += dp[a[i]].second;
            }
        }
        return ans % M;
    }
};",1448214181
hanbro0112,hanbro0112,108,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        cnt = [1] * len(nums)
        i = 0
        while i < n:
            j = i
            s = 1
            while j + 1 < n and nums[j] < nums[j + 1]:
                s += 1
                j += 1
            for t in range(i, i + s):
                cnt[t] = s - (t - i)
            i = j + 1
        return any(cnt[i] >= k and cnt[i + k] >= k for i in range(n - k))",1448188603
hanbro0112,hanbro0112,108,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        cnt = [1] * len(nums)
        i = 0
        while i < n:
            j = i
            s = 1
            while j + 1 < n and nums[j] < nums[j + 1]:
                s += 1
                j += 1
            for t in range(i, i + s):
                cnt[t] = s - (t - i)
            i = j + 1
        
        ans = i = 0
        for j in range(n):
            ans = max(ans, min(j - i, cnt[j]))
            if i + cnt[i] <= j:
                i = j
            
        return ans",1448198445
hanbro0112,hanbro0112,108,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        MOD = 10 ** 9 + 7
        n = len(s)
        op = [0] * (n + 1)
        for num in range(2, n + 1):
            x = num
            while x != 1:
                op[num] += 1
                x = x.bit_count()
        @cache
        def dfs(i, count, isLimit, isNum) -> int: 
            if i == n:  
                return int(isNum and 1 + op[count] <= k)
            res = 0
            if not isNum:
                res += dfs(i + 1, count, False, False)
            low = 0 if isNum else 1
            up = int(s[i]) if isLimit else 1
            for d in range(low, up + 1):
                if isNum or d == 1:
                    res += dfs(i + 1, count + d, isLimit and d == up, True)
            return res % MOD
        
        return dfs(0, 0, True, False) - int(1 + op[s.count('1')] <= k)",1448243198
hanbro0112,hanbro0112,108,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        MOD = 10 ** 9 + 7
        cnt = Counter()
        value = Counter()
        ans = 0
        for x in nums:
            upVal = (value[x + 1] + x * cnt[x + 1]) % MOD
            downVal = (value[x - 1] + x * cnt[x - 1]) % MOD
            cnt[x] = (cnt[x] + cnt[x + 1] + cnt[x - 1] + 1) % MOD
            value[x] = (value[x] + upVal + downVal + x) % MOD
            ans = (ans + upVal + downVal + x) % MOD
        return ans",1448214710
HFDnpkp1cs,HFDnpkp1cs,109,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        for(int i = 0; i + 2 * k - 1 < n; i++) {
            if(check(nums, i, i + k - 1) && check(nums, i + k, i + 2 * k - 1))
                return true;
        }
        return false;
    }

    bool check(vector<int>& nums, int lo, int hi) {
        int val = nums[lo];
        for(int i = lo + 1; i <= hi; i++) {
            if(nums[i] <= val)
                return false;
            val = nums[i];
        }
        return true;
    }
};",1448182920
HFDnpkp1cs,HFDnpkp1cs,109,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp(n, 1);

        for(int i = 1; i < n; i++) {
            if(nums[i] > nums[i - 1]) {
                dp[i] = max(dp[i], dp[i - 1] + 1);
            }
        }

        int lo = 1, hi = n / 2;
        while(lo < hi) {
            int mid = (lo + hi + 1) / 2;
            if(check(dp, mid)) {
                lo = mid;
            }
            else {
                hi = mid - 1;
            }
        }
        return lo;
    }

    bool check(vector<int>& dp, int len) {
        int n = dp.size();
        for(int i = 0; i + 2 * len - 1 < n; i++) {
            int a = dp[i + len - 1], b = dp[i + 2 * len - 1];
            if(a >= len && b >= len)
                return true;
        }
        return false;
    }
};",1448188227
HFDnpkp1cs,HFDnpkp1cs,109,3631,cpp,"using ll = long long;
ll mod = 1e9 + 7;

ll dp[810];
ll dp2[810][810];

ll mem[810][810];

ll nCr(ll n, ll r) 
{
    if (r == 0 || r == n)
        return 1;
    if(mem[n][r] > 0)
        return mem[n][r];
    mem[n][r] = (nCr(n-1, r-1) + nCr(n-1, r)) % mod;
    return mem[n][r];
}

class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        if(s == ""0"")
            return 0;
        
        int n = s.size();

        memset(dp, 0x3f, sizeof(dp));
        memset(dp2, 0, sizeof(dp2));
        
        dp[1] = 0;
        for(int i = 2; i <= 800; i++) {
            int cnt = __builtin_popcount(i);
            dp[i] = 1 + dp[cnt];
        }

        for(int i = 0; i <= n; i++)
            dp2[i][0] = 1;

        for(int i = n - 1; i >= 0; i--) {
            for(int j = 1; j <= n - i; j++) {
                if(s[i] == '0') {
                    dp2[i][j] = dp2[i + 1][j];
                }
                else {
                    dp2[i][j] = dp2[i + 1][j - 1];
                    if(j <= n - i - 1) {
                        dp2[i][j] = (dp2[i][j] + nCr(n - i - 1, j)) % mod;
                    }
                }
            }
        }

        ll ret = 0;
        for(int i = 1; i <= n; i++) {
            if(dp[i] < k) {
                // cout << i << "" "" << dp[i] << "" "" << dp2[0][i] << endl;
                ret = (ret + dp2[0][i]) % mod;
            }
        }

        int cnt = 0;
        for(auto c : s) {
            if(c == '1')
                cnt++;
        }
        if(dp[cnt] < k)
            ret--;
        if(ret < 0)
            ret += mod;

        return ret;
    }
};",1448251252
HFDnpkp1cs,HFDnpkp1cs,109,3646,cpp,"using ll = long long;
ll mod = 1e9 + 7;

ll cnt[100010];
ll sum[100010];

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        ll n = nums.size();
        memset(cnt, 0, sizeof(cnt));
        memset(sum, 0, sizeof(sum));

        for(int i = 0; i < n; i++) {
            int val = nums[i];
            if(val - 1 >= 0) {
                sum[val] = (sum[val] + cnt[val - 1] * val % mod + sum[val - 1]) % mod;
                cnt[val] = (cnt[val] + cnt[val - 1]) % mod;
            }
            if(val + 1 <= 1e5) {
                sum[val] = (sum[val] + cnt[val + 1] * val % mod + sum[val + 1]) % mod;
                cnt[val] = (cnt[val] + cnt[val + 1]) % mod;
            }
            sum[val] = (sum[val] + val) % mod;
            cnt[val] = (cnt[val] + 1) % mod;
        }

        ll ret = 0;
        for(int i = 0; i <= 1e5; i++) {
            ret = (ret + sum[i]) % mod;
        }
        return ret;
    }
};",1448199620
g129512,g129512,111,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n=len(nums)
        pre=[1]*n
        suf=[1]*n
        for i in range(1,n):
            if nums[i]>nums[i-1]:
                pre[i]=pre[i-1]+1
        res=1
        for i in range(n-2,0,-1):
            if nums[i]<nums[i+1]:
                suf[i]=suf[i+1]+1
            res=max(res,min(pre[i-1],suf[i]))
        return res>=k",1448244871
g129512,g129512,111,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n=len(nums)
        pre=[1]*n
        suf=[1]*n
        for i in range(1,n):
            if nums[i]>nums[i-1]:
                pre[i]=pre[i-1]+1
        res=1
        for i in range(n-2,0,-1):
            if nums[i]<nums[i+1]:
                suf[i]=suf[i+1]+1
            res=max(res,min(pre[i-1],suf[i]))
        return res",1448244530
g129512,g129512,111,3631,python3,"from collections import Counter
from functools import cache


class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        n=len(s)
        M=10**9+7
        @cache
        def dfs(i,lim):
            if i==n:
                res = [0]*(n+1)
                res[0]=1
                return res

            dp1=dfs(i+1,lim and s[i]=='0')
            res=[*dp1]
            if not lim or s[i]=='1':
                dp2=dfs(i+1, lim and s[i]=='1')
                for j in range(n):
                    res[j+1]+=dp2[j]
                    res[j+1]%=M
            return res
        
        def red(x):
            res=0
            while x>1:
                x=x.bit_count()
                res+=1
            return res

        dp=dfs(0,True)
        dp[Counter(s)['1']]-=1
        res=0
        for i in range(1,n):
            if red(i)<k:
                res+=dp[i]
            res%=M
        return res",1448242457
g129512,g129512,111,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        mx=max(nums)
        n=len(nums)
        dp=[[0,0] for _ in range(mx+1)]
        M=10**9+7
        for i in range(n):
            ns,nc=0,0
            if nums[i]>0:
                s,c=dp[nums[i]-1]
                nc+=c
                ns+=c*nums[i]+s
            if nums[i]+1<=mx:
                s,c=dp[nums[i]+1]
                nc+=c
                ns+=c*nums[i]+s
            nc+=1
            ns+=nums[i]
            dp[nums[i]][0]+=ns
            dp[nums[i]][1]+=nc
            dp[nums[i]][0]%=M
            dp[nums[i]][1]%=M
        res=0
        for i in range(mx+1):
            res+=dp[i][0]
        return res%M
        ",1448242651
Sergei Sobol,sobols,112,3612,cpp,"class Solution {
public:
    int FindK(const vector<int>& nums) {
        int n = nums.size();
        int last = -1;
        int res = 0;
        for (int i = 0; i < n; ) {
            int j = i + 1;
            while (j < n && nums[j-1] < nums[j]) {
                ++j;
            }
            int len = j - i;
            res = max(res, len / 2);
            if (last != -1) {
                res = max(res, min(last, len));
            }
            last = len;
            i = j;
        }
        return res;
    }

    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        return k <= FindK(nums);
    }
};",1448193278
Sergei Sobol,sobols,112,3619,cpp,"class Solution {
public:
    int FindK(const vector<int>& nums) {
        int n = nums.size();
        int last = -1;
        int res = 0;
        for (int i = 0; i < n; ) {
            int j = i + 1;
            while (j < n && nums[j-1] < nums[j]) {
                ++j;
            }
            int len = j - i;
            res = max(res, len / 2);
            if (last != -1) {
                res = max(res, min(last, len));
            }
            last = len;
            i = j;
        }
        return res;
    }

    int maxIncreasingSubarrays(vector<int>& nums) {
        return FindK(nums);
    }
};",1448191907
Sergei Sobol,sobols,112,3631,cpp,"constexpr int MOD = 1'000'000'007;

void Add(int& x, int y) {
    x += y;
    if (x >= MOD) {
        x -= MOD;
    }
}

class Solution {
public:
    bool IsKReducible(int n, int k) {
        while (n != 1 && k > 0) {
            n = popcount((unsigned)n);
            k--;
        }
        return n == 1;
    }

    int countKReducibleNumbers(string s, int k) {
        const int len = s.size();
        vector<bool> r(len + 1);
        for (int i = 0; i <= len; ++i) {
            r[i] = IsKReducible(i, k - 1);
        }
        
        vector<vector<int>> c(len + 1, vector<int>(len + 1));
        for (int i = 0; i <= len; ++i) {
            c[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                Add(c[i][j], c[i-1][j]);
                Add(c[i][j], c[i-1][j-1]);
            }
        }
        
        int prev = 0;
        int ans = 0;
        for (int i = 0; i < len; ++i) {
            if (s[i] == '1') {
                int rest = len - 1 - i;

                for (int j = 0; j <= rest; ++j) {
                    if (r[prev + j]) {
                        Add(ans, c[rest][j]);
                    }
                }
                
                prev++;
            }
        }
        return ans;
    }
};",1448252669
Sergei Sobol,sobols,112,3646,cpp,"constexpr int MOD = 1'000'000'007;

void Add(int& x, int y) {
    x += y;
    if (x >= MOD) {
        x -= MOD;
    }
}

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        unordered_map<int, pair<int, int>> f; // (count, sum)
        int ans = 0;
        for (int x : nums) {
            auto& res = f[x];
            Add(res.first, 1);
            Add(res.second, x);
            
            for (int y : {x-1, x+1}) {
                if (auto it = f.find(y); it != f.end()) {
                    const auto& val = it->second;
                    Add(res.first, val.first);
                    Add(res.second, val.second);
                    Add(res.second, ((long long)x * val.first) % MOD);
                }
            }
        }
        for (const auto& [x, res] : f) {
            Add(ans, res.second);
        }
        return ans;
    }
};",1448217408
Superultra,Superultra,113,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& A, int k) {
        int n = A.size();
        vector<int> P(n), S(n);

        int l = 0;
        for (int i = 0; i < n; i++){
            if (i and A[i] <= A[i - 1])
                l = i;
            P[i] = i - l + 1;
        }

        int r = n - 1;
        for (int i = n - 1; i >= 0; i--){
            if (i + 1 < n and A[i] >= A[i + 1])
                r = i;
            S[i] = r - i + 1;
        }

        for (int i = 0; i < n; i++){
            int v1 = P[i];
            int v2 = (i + 1 < n ? S[i + 1] : 0);
            if (v1 >= k and v2 >= k)
                return true;
        }
        return false;
    }
};",1448245336
Superultra,Superultra,113,3619,cpp,"#include <bits/stdc++.h>
using namespace std;

#define FOR(i, x, y) for (int i = x; i < y; i++)

#define ll long long

#define pb push_back
#define all(x) x.begin(), x.end()
#define sz(x) x.size()

#define pii pair<int, int>
#define f first
#define s second
#define mp make_pair

const int MOD = 1e9 + 7;

class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& A) {
        int n = A.size();
        vector<int> P(n), S(n);

        int l = 0;
        for (int i = 0; i < n; i++){
            if (i and A[i] <= A[i - 1])
                l = i;
            P[i] = i - l + 1;
        }

        int r = n - 1;
        for (int i = n - 1; i >= 0; i--){
            if (i + 1 < n and A[i] >= A[i + 1])
                r = i;
            S[i] = r - i + 1;
        }

        int ans = 0;

        for (int i = 0; i < n; i++){
            ans = max(ans, min(P[i], (i + 1 < n ? S[i + 1] : 0)));
        }
        return ans;
    }
};",1448243472
Superultra,Superultra,113,3631,cpp,"#include <bits/stdc++.h>
using namespace std;

#define FOR(i, x, y) for (int i = x; i < y; i++)

#define ll long long

#define pb push_back
#define all(x) x.begin(), x.end()
#define sz(x) x.size()

#define pii pair<int, int>
#define f first
#define s second
#define mp make_pair

const int MOD = 1e9 + 7;

class Solution {
public:
    int countKReducibleNumbers(string S, int k) {
        int n = S.size();

        vector<vector<ll>> choose(n + 5, vector<ll>(n + 5, 0));

        for (int i = 0; i <= n and (choose[i][0] = 1); i++)
            for (int j = 1; j <= i; j++)
                choose[i][j] = (choose[i - 1][j] + choose[i - 1][j - 1]) % MOD;

        auto countNums = [&](int bits){
            int cnt = 0;
            ll ret = 0;

            for (int i = 0; i < n; i++){
                if (S[i] == '1'){
                    // If this is the first one we turn to 0
                    int rem = n - i - 1;

                    if (bits - cnt >= 0)
                        ret = (ret + choose[rem][bits - cnt]) % MOD;
                    
                    cnt++;
                }
            }
            // include the number itself
            // if (cnt == bits)
                // ret = (ret + 1) % MOD;
            
            return ret;
        };
        ll ans = 0;

        for (int i = 1; i <= n; i++){
            // can we reduce i in k - 1 moves
            int moves = 0;
            int num = i;

            while (num != 1){
                num = __builtin_popcount(num);
                moves++;
            }

            // All numbers with i bits
            if (moves + 1 <= k){
                // cout << i << "": "" << countNums(i) << endl;
                ans = (ans + countNums(i)) % MOD;
            }
        }

        return ans;
    }
};",1448210983
Superultra,Superultra,113,3646,cpp,"#include <bits/stdc++.h>
using namespace std;

#define FOR(i, x, y) for (int i = x; i < y; i++)

#define ll long long

#define pb push_back
#define all(x) x.begin(), x.end()
#define sz(x) x.size()

#define pii pair<int, int>
#define f first
#define s second
#define mp make_pair

const int MOD = 1e9 + 7;

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& A) {
        // number of ss ending at i
        unordered_map<int, ll> ways, dp;
        ll ans = 0;
        
        for (int i : A){
            ll nw = ((dp[i - 1] + i * ways[i - 1]) + (dp[i + 1] + i * ways[i + 1]) + i) % MOD;
            dp[i] = (dp[i] + nw) % MOD;

            ll nwWays = (ways[i - 1] + ways[i + 1] + 1) % MOD;
            ways[i] = (ways[i] + nwWays) % MOD;
        }
        for (auto [_, v] : dp)
            ans = (ans + v) % MOD;
        return ans;
    }
};",1448234980
Abhay Singh,FSPINDLE,115,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
          int n = nums.size() , ans = 1;
            
             vector <int> A(n , 1) , B(n , 1) ;
            
             for(int i = 1 ; i < n ; i ++){
                    if(nums[i] > nums[i - 1]) A[i] = A[i - 1] + 1 ;
             }
             for(int i = n - 2 ; i >= 0 ; i --){
                       if(nums[i] < nums[i + 1]) B[i] = B[i + 1] + 1 ;
             }
            
             for(int i = 1  ; i < n; i ++){
                      ans = max(ans , min(B[i] , A[i - 1])) ;
             }
            return ans >= k;
    }
};",1448186698
Abhay Singh,FSPINDLE,115,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
                    
             int n = nums.size() , ans = 1;
            
             vector <int> A(n , 1) , B(n , 1) ;
            
             for(int i = 1 ; i < n ; i ++){
                    if(nums[i] > nums[i - 1]) A[i] = A[i - 1] + 1 ;
             }
             for(int i = n - 2 ; i >= 0 ; i --){
                       if(nums[i] < nums[i + 1]) B[i] = B[i + 1] + 1 ;
             }
            
             for(int i = 1  ; i < n; i ++){
                      ans = max(ans , min(B[i] , A[i - 1])) ;
             }
            return ans;
    }
};",1448185919
Abhay Singh,FSPINDLE,115,3631,cpp,"class Solution {
public:
         int dp[801][801][3] ;
         const int mod = 1e9 + 7 ; 
        
    int countKReducibleNumbers(string s, int k) {
                   
               int n = s.size() ;
               memset(dp , -1 , sizeof(dp)) ;
            
                auto solve = [&](auto &&solve , int cnt , int k ){
                         
                           if(cnt == 1) return true ;
                           if(k == 0 || cnt == 0) return false ;
                           k -- ;
                         return solve(solve ,  __builtin_popcount(cnt) , k) ;
                }; 
            
               auto func = [&](auto &&func , int idx , int cnt , bool f) -> int{
                       
                         if(idx == n){
                                 if(f) return 0 ;
                                 return solve(solve , cnt , k - (cnt != 1)) ;
                         } 
                       
                           if(dp[idx][cnt][f] != -1) return dp[idx][cnt][f] ;     
                       
                       int ret  = 0 ;
                        if(f){
                            if(s[idx] == '1'){
                                 ret =  (func(func , idx + 1 , cnt + 1 , f) + func(func , idx + 1 , cnt , !f)) % mod ;     
                            } 
                            else{
                                ret = func(func , idx + 1 , cnt , f) % mod;    
                            }
                        }
                       else{
                              ret =  (func(func , idx + 1 , cnt + 1 , f) + func(func , idx + 1 , cnt , f)) % mod;       
                       }
                       return  dp[idx][cnt][f] =  ret ;
                       
               };
             
              int ans = func(func , 0 , 0 , 1) ;
            return ans;
    }
};",1448253196
Abhay Singh,FSPINDLE,115,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
                     
             int n = nums.size() ;
             int mx = *max_element(nums.begin() , nums.end()) + 10;
            
             vector <long long> dp1(mx) , dp2(mx) ;
            const int mod =1e9 + 7 ;
            
             for(auto num : nums){
                       

                     int prev = num - 1 ;
                     
                     if(prev >= 0){
                     dp1[num] += dp1[prev] ;
                     dp2[num] += (dp1[prev] *1ll* num) % mod  + dp2[prev];
                     }
                     prev = num + 1 ;
                     dp1[num] += dp1[prev]  ;
                     dp2[num] += (dp1[prev] *1ll* num ) % mod + dp2[prev] ;
                     dp2[num] += num ;
                     dp1[num] = 1 + dp1[num] ;
                     dp1[num] %= mod ;
                     dp2[num] %= mod ;
                                       
             }
            
             int ans = 0 ;
          //  for(auto num : {1 , 2}) cout << dp2[num] << endl;
            
            for(int i = 0 ; i < mx ; i ++) {
                   ans = (ans + dp2[i]) % mod ;
            }
            return ans ;
    } 
};",1448221440
yu46656,yu46656,118,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(std::vector<int>& nums, int k) {
        int n{ static_cast<int>(nums.size()) };

        std::vector<int> segs;

        int acc{ 1 };

        for (int i{ 1 }; i < n; ++i) {
            if (nums[i - 1] < nums[i]) {
                ++acc;
            } else {
                segs.push_back(acc);
                acc = 1;
            }
        }

        segs.push_back(acc);

        int ret{ 0 };

        for (auto seg : segs) { ret = std::max(ret, seg / 2); }

        int s{ static_cast<int>(segs.size()) };

        for (int i{ 1 }; i < s; ++i) {
            ret = std::max(ret, std::min(segs[i - 1], segs[i]));
        }

        return k <= ret;
    }
};
",1448187462
yu46656,yu46656,118,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(std::vector<int>& nums) {
        int n{ static_cast<int>(nums.size()) };

        std::vector<int> segs;

        int acc{ 1 };

        for (int i{ 1 }; i < n; ++i) {
            if (nums[i - 1] < nums[i]) {
                ++acc;
            } else {
                segs.push_back(acc);
                acc = 1;
            }
        }

        segs.push_back(acc);

        int ret{ 0 };

        for (auto seg : segs) { ret = std::max(ret, seg / 2); }

        int s{ static_cast<int>(segs.size()) };

        for (int i{ 1 }; i < s; ++i) {
            ret = std::max(ret, std::min(segs[i - 1], segs[i]));
        }

        return ret;
    }
};
",1448186438
yu46656,yu46656,118,3631,cpp,"class Solution {
public:
    static constexpr long long M{ 1000000007 };

    long long PowerMod(long long base, long long exp) {
        long long ret{ 1 };

        for (; 0 < exp; exp /= 2) {
            if (exp % 2 == 1) { ret = (ret * base) % M; }
            base = (base * base) % M;
        }

        return ret;
    }

    long long Factorial(long long x) {
        static std::vector<long long> table{ 1, 1, 2, 6 };

        while (static_cast<long long>(table.size()) <= x) {
            table.push_back(
                (table.back() * static_cast<long long>(table.size())) % M);
        }

        return table[x];
    }

    long long InvFactorial(long long x) {
        static std::unordered_map<long long, long long> table;

        auto iter{ table.find(x) };

        if (iter == table.end()) {
            iter = table.insert({ x, PowerMod(Factorial(x), M - 2) }).first;
        }

        return iter->second;
    }

    long long Combination(long long n, long long k) {
        return (Factorial(n) * ((InvFactorial(k) * InvFactorial(n - k)) % M)) %
               M;
    }

    long long Count(const std::string& s, int* cnts) {
        long long ret{ 0 };

        for (char c : s) {
            if (c == '0') {
                if (cnts[0] == 0) { break; }
                --cnts[0];
                continue;
            }

            if (0 < cnts[0]) {
                ret = (ret + Combination(cnts[0] + cnts[1] - 1, cnts[1])) % M;
            }

            if (cnts[1] == 0) { break; }

            --cnts[1];
        }

        return ret;
    }

    int GetK(int x) {
        int ret{ 0 };
        for (; 1 < x; x = __builtin_popcount(x)) { ++ret; }
        return ret;
    }

    int countKReducibleNumbers(const std::string& s, int k) {
        int n{ static_cast<int>(s.size()) };

        long long ret{ 0 };

        int cnts[2];

        for (int x{ 1 }; x <= n; ++x) {
            if (GetK(x) <= k - 1) {
                cnts[0] = n - x;
                cnts[1] = x;
                ret = (ret + Count(s, cnts)) % M;
            }
        }

        return ret;
    }
};
",1448246904
yu46656,yu46656,118,3646,cpp,"class Solution {
public:
    static constexpr long long M{ 1000000007 };

    template <typename Cntr, typename Key, typename Value>
    const Value& Find(const Cntr& cntr, const Key& key, const Value& value) {
        auto iter{ cntr.find(key) };
        return iter == cntr.end() ? value : iter->second;
    }

    int sumOfGoodSubsequences(std::vector<int>& nums) {
        int n{ static_cast<int>(nums.size()) };

        long long ret{ 0 };

        std::unordered_map<int, std::pair<long long, long long>> dp;

        for (auto num : nums) {
            auto l_iter{ dp.find(num - 1) };
            auto r_iter{ dp.find(num + 1) };

            long long cur_cnt{ 1 };
            long long cur_sum{ 0 };

            if (l_iter != dp.end()) {
                cur_cnt += l_iter->second.first;
                cur_sum += l_iter->second.second;
            }

            if (r_iter != dp.end()) {
                cur_cnt += r_iter->second.first;
                cur_sum += r_iter->second.second;
            }

            cur_cnt %= M;
            cur_sum = (cur_sum + num * cur_cnt) % M;

            ret = (ret + cur_sum) % M;

            auto& p{ dp.insert({ num, { 0, 0 } }).first->second };

            p.first = (p.first + cur_cnt) % M;
            p.second = (p.second + cur_sum) % M;
        }

        return static_cast<int>(ret);
    }
};
",1448212572
dirigibility,dirigibility,119,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        for i in range(len(nums)-2*k+1):
            if all(nums[j] < nums[j+1] for x in (i,i+k) for j in range(x,x+k-1)):
                return True
        return False",1448182278
dirigibility,dirigibility,119,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        runs = [1]
        for a,b in pairwise(nums):
            if a < b:
                runs[-1] += 1
            else:
                runs.append(1)
        return max(max(runs)//2,max((min(a,b) for a,b in pairwise(runs)),default=0))",1448185948
dirigibility,dirigibility,119,3631,python3,"mod = 10**9+7
@cache
def c(n,k):
    if n == k == 0:
        return 1
    if not 0 <= k <= n:
        return 0
    return (c(n-1,k-1)+c(n-1,k))%mod

@cache
def f(n):
    if n == 0:
        return inf
    if n == 1:
        return 0
    return f(n.bit_count())+1
    
class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        l = len(s)
        n = 0
        total = 0
        for i,b in enumerate(s,1):
            if b == '1':
                total += sum(c(l-i,j) for j in range(l-i+1) if f(n+j) < k)
                total %= mod
                n += 1
        return total
                ",1448240042
dirigibility,dirigibility,119,3646,python3,"mod = 10**9+7
class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        c = Counter()
        s = Counter()
        for n in nums:
            s[n] += s[n-1]+s[n+1]+n*(c[n-1]+c[n+1]+1)
            c[n] += c[n-1]+c[n+1]+1
            s[n] %= mod
            c[n] %= mod
        return s.total()%mod",1448199344
Jiabei Zhu,zzjjbb,121,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k) -> int:
        nums.append(nums[-1])
        diff = [j - i for i, j in pairwise(nums)]
        diff.append(-1)
        curr = 0
        gl = []
        for i in diff:
            curr += 1
            if i <= 0:
                gl.append(curr)
                curr = 0
        ans = 0
        for i in pairwise(gl):
            ans = max(ans, max(i) // 2)
            ans = max(ans, min(i))
        return ans >= k",1448192001
Jiabei Zhu,zzjjbb,121,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        nums.append(nums[-1])
        diff = [j - i for i, j in pairwise(nums)]
        diff.append(-1)
        curr = 0
        gl = []
        for i in diff:
            curr += 1
            if i <= 0:
                gl.append(curr)
                curr = 0
        ans = 0
        for i in pairwise(gl):
            ans = max(ans, max(i) // 2)
            ans = max(ans, min(i))
        return ans
            ",1448190918
Jiabei Zhu,zzjjbb,121,3631,python3,"M = 1_000_000_007
comb = [[None] * 810 for _ in range(810)]
fact = [1]
for i in range(1, 1700):
    fact.append(fact[-1] * i % M)
for i in range(810):
    for j in range(810):
        comb[i][j] = fact[i + j] * pow(fact[i] * fact[j], -1, M) % M

def red(i):
    out = 0
    while i > 1:
        i = f'{i:b}'.count('1')
        out += 1
    return out
cnt = [red(i) for i in range(810)]
cnt[0] = 10
    
class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        sbs = [1]
        for i, si in enumerate(s[::-1]):
            # print(sbs)
            if si != '1':
                sbs.append(0)
                continue
            sbs = [0] + sbs
            for j in range(i + 1):
                # print(i, j)
                sbs[j] = (sbs[j] + comb[j][i - j]) % M
            # print(sbs)
        sbs[s.count('1')] -= 1
        # print(cnt)
        ans = 0
        for i, si in enumerate(sbs):
            if cnt[i] < k:
                ans = (ans + sbs[i]) % M
        return ans
                ",1448255708
Jiabei Zhu,zzjjbb,121,3646,python3,"M = 1_000_000_007
class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        endby = defaultdict(int)
        endsum = defaultdict(int)
        ans = 0
        for i in nums:
            eb = endby[i - 1] + endby[i + 1] + 1
            curr = endsum[i - 1] + endsum[i + 1] + eb * i
            endby[i] += eb
            endsum[i] = (endsum[i] + curr) % M
            ans = (ans + curr) % M
            # print(endby, endsum)
        return ans",1448203772
raincoat911,raincoat911,122,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        vector<int> dp(nums.size());
        int n = 0;
        for (int i = 0; i < nums.size(); i++) {
            if (i == 0 || nums[i] > nums[i - 1]) n++;
            else n = 1;
            dp[i] = n;
        }
        for (int i = k - 1; i < nums.size() - k; i++) {
            if (dp[i] >= k && dp[i + k] >= k) return true;
        }
        return false;
    }
};",1448182510
raincoat911,raincoat911,122,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        vector<int> dp(nums.size());
        int n = 0;
        for (int i = 0; i < nums.size(); i++) {
            if (i == 0 || nums[i] > nums[i - 1]) n++;
            else n = 1;
            dp[i] = n;
        }
        int lo = 1, hi = nums.size() / 2 + 1;
        while (lo < hi) {
            int mid = (lo + hi) / 2;
            if (f(dp, mid)) lo = mid + 1;
            else hi = mid;
        }
        return lo - 1;
    }
    
private:
    
    bool f(vector<int>& dp, int k) {
        for (int i = k - 1; i < dp.size() - k; i++) {
            if (dp[i] >= k && dp[i + k] >= k) return true;
        }
        return false;
    }
    
};",1448184399
raincoat911,raincoat911,122,3631,cpp,"class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        vector<int> arr(s.size() + 1);
        for (int i = 2; i < arr.size(); i++) {
            arr[i] = arr[f(i)] + 1;
            // if (arr[i] == k) a.push_back(i);
            // if (arr[i] < k) b.push_back(i);
        }
        // for (int i = 1; i < arr.size)
        int res = 0;
        int n = 0;
        dp.resize(s.size(), vector<int>(s.size()));
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == '0') continue;
            for (int l = 0; l < s.size() - i; l++) {
                if (arr[l + n] < k) {
                    res += cnk(s.size() - i - 1, l);
                    res %= M;
                }
            }
            // cout << res << "", "";
            n++;
        }
        return res - 1;
    }
    
private:
    vector<vector<int>> dp;
    int M = 1e9 + 7;
    
    int f(int n) {
        int res = 0;
        while (n) {
            res += n & 1;
            n >>= 1;
        }
        return res;
    }
    
    int cnk(int n, int k) {
        if (n == k || k == 0) return 1;
        if (dp[n][k] != 0) return dp[n][k];
        return dp[n][k] = (cnk(n - 1, k - 1) + cnk(n - 1, k)) % M;
    }
};",1448240515
raincoat911,raincoat911,122,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        vector<int> left = f(nums);
        reverse(nums.begin(), nums.end());
        vector<int> right = f(nums);
        reverse(right.begin(), right.end());
        reverse(nums.begin(), nums.end());
        int res = 0;
        for (int i = 0; i < nums.size(); i++) {
            res += (long) left[i] * right[i] % M * nums[i] % M;
            // cout << num
            // cout << left[i] << "" "" << right[i] << "" "" << ((long) left[i] * right[i] % M * nums[i]) << endl;
            res %= M;
        }
        return res;
    }
    
private:
    int M = 1e9 + 7;
    
    vector<int> f(vector<int>& nums) {
        unordered_map<int, int> m;
        vector<int> dp(nums.size());
        for (int i = 0; i < nums.size(); i++) {
            int n = nums[i];
            int cur = 1;
            if (m.count(n - 1)) cur += m[n - 1];
            if (m.count(n + 1)) cur += m[n + 1];
            cur %= M;
            dp[i] = cur;
            m[n] += cur;
            m[n] %= M;
        }
        return dp;
    }
};",1448197461
fxfxxxfxx,fxfxxxfxx,123,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        auto f = [&](int a) {
            if (a + 2*k > n) return false;
            for (int i = a+1; i < a+k; i++)
                if (nums[i] <= nums[i-1]) return false;
            for (int i = a+k+1; i < a+2*k; i++)
                if (nums[i] <= nums[i-1]) return false;
            return true;
        };
        for (int i = 0; i < n; i++)
            if (f(i)) return true;
        return false;
    }
};",1448184065
fxfxxxfxx,fxfxxxfxx,123,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> V(n);
        V[0] = 1;
        int count = 1;
        for (int i = 1; i < n; i++) {
            if (nums[i] > nums[i-1]) count += 1;
            else count = 1;
            V[i] = count;
        }
        
        auto f = [&](int k) {
            for (int i = 2*k-1; i < n; i++)
                if (V[i] >= k && V[i-k] >= k) return true;
            return false;
        };

        int low = 0, high = n;
        while (low < high) {
            int mid = low + (high - low) / 2;
            if (!f(mid)) high = mid;
            else low = mid + 1;
        }
        return low - 1;
    }
};",1448191496
fxfxxxfxx,fxfxxxfxx,123,3631,cpp,"template<int M>
struct mint {
private:
    int pow(int a, int b) {
        int64_t res = 1, mul = a;
        while (b) {
            if (b & 1) res = (res * mul) % M;
            mul = (mul * mul) % M;
            b >>= 1;
        }
        return res;
    }
public:
    int x;
    mint() : x(0) {}
    mint(int x) : x(x) {}
    mint& operator +=(mint o) {
        x = (x + o.x) % M;
        x = (x + M) % M;
        return *this;
    }
    mint& operator -=(mint o) {
        x = (x - o.x) % M;
        x = (x + M) % M;
        return *this;
    }
    mint& operator *=(mint o) {
        x = int64_t(x) * o.x % M;
        x = (x + M) % M;
        return *this;
    }
    mint& operator ^=(mint o) {
        x = pow(x, o.x);
        x = (x + M) % M;
        return *this;
    }
    mint& operator /=(mint o) {
        int rev_y = pow(o.x, M - 2);
        x = int64_t(x) * rev_y % M;
        x = (x + M) % M;
        return *this;
    }

    friend mint operator +(const mint x, const mint y) { return mint(x) += y; }
    friend mint operator -(const mint x, const mint y) { return mint(x) -= y; }
    friend mint operator *(const mint x, const mint y) { return mint(x) *= y; }
    friend mint operator /(const mint x, const mint y) { return mint(x) /= y; }
    friend mint operator ^(const mint x, const mint y) { return mint(x) ^= y; }
    friend bool operator <(const mint x, const mint y) { return x.x < y.x; }
    friend bool operator <=(const mint x, const mint y) { return x.x <= y.x; }
    friend bool operator >(const mint x, const mint y) { return x.x > y.x; }
    friend bool operator >=(const mint x, const mint y) { return x.x >= y.x; }
    friend bool operator ==(const mint x, const mint y) { return x.x == y.x; }
    friend bool operator !=(const mint x, const mint y) { return x.x != y.x; }
    explicit operator int() { return x; }
};

template<int M>
struct Factorial {
    using Mint = mint<M>;

    int N;
    std::vector<Mint> fact, ifact, rev;

    Factorial(int n): N(n + 1), fact(n + 1), ifact(n + 1), rev(n + 1) {
        fact[0] = fact[1] = 1;
        ifact[0] = ifact[1] = 1;
        rev[0] = rev[1] = 1;
        for (int i = 2; i < N; i++) {
            fact[i] = fact[i-1] * i;
            rev[i] = rev[M % i] * (M - M/i);
            ifact[i] = ifact[i-1] * rev[i];
        }
    }

    Mint F(int n) {
        assert(n >= 0);
        return fact[n];
    }

    Mint C(int n, int k) {
        assert(n < N);
        assert(n >= k);
        return fact[n] * ifact[n-k] * ifact[k];
    }

    Mint H(int n, int k) {
        // a_1 + ... + a_n = k
        // a_i >= 0
        return C(n - 1 + k, k);
    }
};

class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        constexpr int M = 1000000007;
        static Factorial<M> F(801);
        static constexpr auto V = []{
            array<int, 801> ret = {};
            for (uint32_t r = 2; r <= 800; r++)
                ret[r] = ret[std::popcount(r)] + 1;
            return ret;
        }();

        using Mint = mint<M>;
        vector<Mint> A(801);
        int total = 0, n = s.size();
        for (int i = 0; i < n; i++) {
            char c = s[i];
            if (c == '0') continue;
            int n_free = n - (i + 1);
            for (int v = 0; v <= n_free; v++)
                A[v+total] += F.C(n_free, v);
            total += 1;
        }

        Mint ans = 0;
        for (int v = 1; v <= 800; v++)
            if (V[v] < k) ans += A[v];
        return int(ans);
        
    }
};",1448248258
fxfxxxfxx,fxfxxxfxx,123,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        using T = pair<int,int>;
        constexpr int M = 1000000007;
        constexpr int N = 100000;
        vector<T> DP(N+1); // count, sum
        auto Add = [&](T x, T y) {
            return T{(x.first + y.first) % M, (x.second + y.second) % M};
        };

        int n = nums.size();
        for (int x : nums) {
            T res = {1, x}; // self
            if (x > 0) {
                res = Add(res, DP[x-1]);
                res.second += (int64_t{DP[x-1].first} * x) % M;
                res.second %= M;
            }
            if (x < N) {
                res = Add(res, DP[x+1]);
                res.second += (int64_t{DP[x+1].first} * x) % M;
                res.second %= M;
            }
            DP[x] = Add(res, DP[x]);
        }

        int ans = 0;
        for (int v = 0; v <= N; v++)
            ans = (ans + DP[v].second) % M;
        return ans;
    }
};",1448215740
rithwikgupta,rithwikgupta,126,3612,cpp,"class Solution {
public:
    int hasIncreasingSubarrays(vector<int>& a, int k) {
        int n = a.size();
        vector<int> seq;
        int cur = 1;
        for (int i = 1; i < n; i++) {
            if (a[i] > a[i-1]) cur++;
            else {
                seq.push_back(cur);
                cur = 1;
            }
        }     
        seq.push_back(cur);
        int res = 0;

        for (int i = 0; i < seq.size(); i++) {

            res = max(res, seq[i]/2);
            if (i) res = max(res, min(seq[i], seq[i-1]));
        }
        return res >= k;
    }
};",1448226321
rithwikgupta,rithwikgupta,126,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& a) {
        int n = a.size();
        vector<int> seq;
        int cur = 1;
        for (int i = 1; i < n; i++) {
            if (a[i] > a[i-1]) cur++;
            else {
                seq.push_back(cur);
                cur = 1;
            }
        }     
        seq.push_back(cur);
        int res = 0;

        for (int i = 0; i < seq.size(); i++) {

            res = max(res, seq[i]/2);
            if (i) res = max(res, min(seq[i], seq[i-1]));
        }
        return res;
    }
};",1448225206
rithwikgupta,rithwikgupta,126,3631,cpp,"class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        vector<int> done(801);
        int MOD = 1e9 + 7;
        for (int i = 1; i < 801; i++) {
            int cur = i;
            while (cur != 1) {
                done[i] += 1;
                int res = 0;
                for (int b = 0; b < 10; b++) {
                    if ((1 << b) & cur) res++;
                }
                cur=res;
            }
        }
        int n = s.size();
        
        vector<vector<vector<int> > > dp(n+1, vector<vector<int> >(n+1, vector<int>(2))); // 0 is less than
        s = ' ' + s;
        dp[0][0][1]=1;
        for (int dig = 1; dig <= n; dig++) {
            for (int sm = 0; sm <= n; sm++) {
                dp[dig][sm][0] = dp[dig-1][sm][0];
                if (sm) dp[dig][sm][0] = (dp[dig][sm][0] + dp[dig-1][sm-1][0]) % MOD;
                
                if (s[dig] == '1') {
                    dp[dig][sm][0] = (dp[dig-1][sm][1] + dp[dig][sm][0]) % MOD;
                    // if (sm) dp[dig][sm][0] = (dp[dig][sm][0] + dp[dig-1][sm-1][0]) % MOD;
                    if (sm) dp[dig][sm][1] = dp[dig-1][sm-1][1];
                } else {
                    dp[dig][sm][1] = dp[dig-1][sm][1];
                }
                // cout << dig << sm << ' ' << dp[dig][sm][0] << endl;
            }
        }
        long long res = 0;
        for (int i = 1; i <= n; i++) {
            // cout << i << done[i] << endl;
            if (done[i] + 1 <= k) {
                // cout << i << endl;
                res = (res + dp[n][i][0]) % MOD;
            }
        }

        return res;
    }
};",1448200403
rithwikgupta,rithwikgupta,126,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int mx = 1e5 + 10;
        long long MOD = 1e9 +7 ;
        vector<long long > ans(mx);
        vector<long long> sm(mx);
        long long res = 0;
        for (int i = nums.size() - 1; i >= 0; i--) {
            nums[i]++;
            res = (res + (ans[nums[i] + 1] + ans[nums[i]-1] + 1) * (nums[i]-1) + sm[nums[i] + 1] + sm[nums[i] - 1]) % MOD;
            ans[nums[i]] = (ans[nums[i]] + ans[nums[i] + 1] + ans[nums[i]-1] + 1) % MOD;
            sm[nums[i]] = (sm[nums[i]] + (ans[nums[i] + 1] + ans[nums[i]-1] + 1) * (nums[i]-1) + sm[nums[i] + 1] + sm[nums[i] - 1]) % MOD;
            // cout << i << res << endl;
        }
        // ans = vector<int>(mx, 0);
        // for (int i = 0; i < nums.size(); i++) {
        //     res = (res + (ans[nums[i] + 1] + ans[nums[i]-1] + 1) * nums[i]) % MOD;
        //     ans[nums[i]] = (ans[nums[i]] + ans[nums[i] + 1] + ans[nums[i]-1] + 1) % MOD;
        //     // cout << i << res << endl;
        // }
        return res;

        // for (int i = nums.size()-1; i >= 0; i--) {
        //     where[nums[i]].push_back(i);
        // }

        // vector<pair<int, int> > layer;
    
        // long long res = 0;
        // for (int i = mx-1; i >= 0; i--) {
        //     vector<pair<int, int> > new_layer;
        //     int p = layer.size()-1;
        //     int cur = 1;
        //     for (auto val: where[i]) {
        //         if (p != -1 && layer[p].first > val) {
        //             cur+=layer[p].second;
        //             p--;
        //         }
        //         new_layer.push_back({val, cur});
        //         res = (res + i * cur) % MOD;
        //     }
            
        //     layer = new_layer;
        // }
        // return res;
    }
};",1448219206
Ryan,ryanwong0127,128,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
    
        for a in range(0, n - 2 * k + 1):
            b = a + k 
            a1 = nums[a : a + k]
            a2 = nums[b : b + k]

            def func(sub):
                for i in range(1, len(sub)):
                    if sub[i] <= sub[i - 1]:
                        return False
                return True

            if func(a1) and func(a2):
                return True  

        return False ",1448182459
Ryan,ryanwong0127,128,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        run_length = [1] * n   
        for i in range(n - 2, -1, -1):
            if nums[i] < nums[i + 1]:
                run_length[i] = run_length[i + 1] + 1
            else:
                run_length[i] = 1

        l, r, res = 1, n // 2, 0

        while l <= r:
            mid = (l + r) // 2
            found = False
            for a in range(n - 2 * mid + 1):
                if run_length[a] >= mid and run_length[a + mid] >= mid:
                    found = True
                    break 

            if found:
                res = mid
                l = mid + 1
            else:
                r = mid - 1 
        return res",1448185279
Ryan,ryanwong0127,128,3631,python3,"MOD = 10**9 + 7
def precompute_steps(max_x):
    step = [0] * (max_x + 1)
    step[1] = 0 
    for x in range(2, max_x + 1):
        pop = bin(x).count('1')
        if pop <= max_x:
            step[x] = 1 + step[pop]
        else:
            step[x] = 1 + step[max_x]
    return step

MAX_X = 800
STEP = precompute_steps(MAX_X)
class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        bits = list(map(int, s))
        L = len(bits)

        dp_prev = [[0] * 2 for _ in range(L + 1)]
        dp_prev[0][1] = 1  

        for pos in range(L):
            dp = [[0] * 2 for _ in range(L + 1)]
            for cnt in range(0, L + 1):
                for t in [0, 1]:
                    if dp_prev[cnt][t] == 0:
                        continue
                    max_bit = bits[pos] if t else 1
                    for bit in [0, 1]:
                        if bit > max_bit:
                            continue
                        new_t = t and (bit == max_bit)
                        new_cnt = cnt + bit
                        if new_cnt > L:
                            continue
                        dp[new_cnt][new_t] = (dp[new_cnt][new_t] + dp_prev[cnt][t]) % MOD
            dp_prev = dp

        cnt = [0] * (L + 1)
        for c in range(1, L + 1):
            cnt[c] = (dp_prev[c][0] + dp_prev[c][1]) % MOD

        res = 0
        for x in range(1, L + 1):
            if x <= MAX_X:
                if STEP[x] <= k -1:
                    res = (res + cnt[x]) % MOD

        x_n = sum(bits)
        if x_n <= MAX_X:
            step_n = 1 + STEP[x_n]
        else:
            step_n = 1 + STEP[MAX_X]

        if step_n <= k:
            res = (res - 1) % MOD

        return res",1448257595
Ryan,ryanwong0127,128,3646,cpp,"#include <bits/stdc++.h>
#pragma GCC optimize(2)
#define rep(i, a, b) for (int i = (a); i < (b); ++i)
#define rep_(i, a, b) for (int i = (a); i > (b); i--)
#define CEIL_DIV(a, b) ((b) == 0 ? 0 : (((a) >= 0) ? ((a) + (b) - 1) / (b) : (a) / (b)))
#define FLOOR_DIV(a, b) (((a) / (b)) - ((a) % (b) != 0 &&(((a) < 0) != ((b) < 0))))
#define mst(x, a) memset(x, a, sizeof(x))
#define all(a) begin(a), end(a)
#define lowbit(x) ((x) & (-(x)))
#define bitcnt(x) (__builtin_popcountll(x))
#define se second
#define fi first
#define pb push_back
#define maxe max_element
#define mine min_element
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<ll, ll> pll;
typedef pair<int, ll> pil;
typedef pair<int, int> pii;
typedef vector<int> vi;
typedef vector<ll> vll;
typedef vector<vi> vvi;
constexpr static int dirs[4][2] = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};
constexpr static int inf = 0x3f3f3f3f, mod = 1e9 + 7;
const ll infl = 0x3f3f3f3f3f3f3f3fll;
template<class T> bool chmax(T &a, T b) {
    if (a >= b) return false;
    a = b; return true;
}
template<class T> bool chmin(T &a, T b) {
    if (a <= b) return false;
    a = b; return true;
}
template<class T> bool chsum(T &a, T b) {
    a = (a + b + mod) % mod;
    return 0;
}
class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        const int n = nums.size();
        int maxV = *maxe(all(nums));
        vector<pll> dp(maxV+2, {0, 0});
    
        ll total = 0;

        for(auto num : nums){
            ll new_count = 1;
            ll new_sum = num;

            if(num >=1){
                ll prev_count = dp[num-1].fi;
                ll prev_sum = dp[num-1].se;
                chsum(new_count , prev_count);
                chsum(new_sum , (prev_sum + prev_count * num));
            }

            if(num +1 <= 100000){
                ll prev_count = dp[num+1].fi;
                ll prev_sum = dp[num+1].se;
                chsum(new_count , prev_count);
                chsum(new_sum , (prev_sum + prev_count * num));
            }

            chsum(dp[num].fi , new_count);
            chsum(dp[num].se , new_sum);

            chsum(total, new_sum) ;
        }

        return total;
    }
};",1448203694
PooyaZ,pooyaz,130,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& arr, int k) {
        int n = arr.size();
        for(int i = 0; i + 2 * k <= n; i++){
            bool ok = true;
            for(int j = 0; j < k - 1; j++){
                if(arr[i + j] >= arr[i + j + 1]) ok = false;
                if(arr[i + k + j] >= arr[i + k + j + 1]) ok = false;
            }
            if(ok) return true;
        }
        return false;
    }
};",1448182825
PooyaZ,pooyaz,130,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& arr) {
        int n = arr.size();
        int fr[n], bc[n];
        fr[0] = 1;
        for(int i = 1; i < n; i++){
            if(arr[i] > arr[i - 1]){
                fr[i] = fr[i - 1] + 1;
            }
            else fr[i] = 1;
        }

        bc[n - 1] = 1;
        for(int i = n - 2; i >= 0; i--){
            if(arr[i] < arr[i + 1]){
                bc[i] = bc[i + 1] + 1;
            }
            else bc[i] = 1;
        }

        int res = 0;
        for(int i = 0; i + 1 < n; i++){
            res = max(res, min(fr[i], bc[i + 1]));
        }
        return res;
    }
};",1448191001
PooyaZ,pooyaz,130,3631,cpp,"#define Mod 1000000007

class Solution {
public:
    int n;
    string s;
    long long c[810][810];
    long long dp[810][810];
    long long comb(int k, int r){
        if(k > r) return 0;
        if(k == 0 || k == r) return 1;
        if(c[k][r] != -1) return c[k][r];
        return c[k][r] = (comb(k, r - 1) + comb(k - 1, r - 1)) % Mod;
    }

    long long mem(int idx, int rem){
        if(idx == n){
            return 0;
        }
        if(rem == 0){
            
        }
        if(dp[idx][rem] != -1) return dp[idx][rem];

        long long& ref = dp[idx][rem];
        if(s[idx] == '0'){
            ref = mem(idx + 1, rem);
        }
        else if(rem == 0){
            ref = 1;
        }
        else{
            ref = (comb(rem, n - idx - 1) + mem(idx + 1, rem - 1)) % Mod;;
        }
        return ref;
    }

    int countKReducibleNumbers(string ss, int k) {
        s = ss;
        n = s.length();
        memset(dp, -1, sizeof dp);
        memset(c, -1, sizeof c);
        int red[810];
        red[1] = 0;
        for(int i = 2; i < 810; i++){
            int cnt = 0, x = i;
            while(x){
                cnt += x & 1;
                x /= 2;
            }
            red[i] = red[cnt] + 1;
        }

        long long res = 0;
        for(int i = 1; i <= n; i++){
            if(red[i] + 1 <= k){
                long long cnt = mem(0, i);
                res = (res + cnt) % Mod;
            }
        }
        return res;
    }
};",1448250541
PooyaZ,pooyaz,130,3646,cpp,"#define Mod 1000000007

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& arr) {
        int n = arr.size();
        long long fr[n], bc[n];
        long long num[100010];
        
        memset(num, 0, sizeof num);
        for(int i = 0; i < n; i++){
            fr[i] = 1 + num[arr[i] + 1];
            if(arr[i] > 0) fr[i] += num[arr[i] - 1];
            fr[i] %= Mod;
            num[arr[i]] += fr[i];
            // cout << fr[i] << ' ';
        }
        // cout << endl;

        memset(num, 0, sizeof num);
        for(int i = n - 1; i >= 0; i--){
            bc[i] = 1 + num[arr[i] + 1];
            if(arr[i] > 0) bc[i] += num[arr[i] - 1];
            bc[i] %= Mod;
            num[arr[i]] += bc[i];
            // cout << bc[i] << ' ';
        }
        // cout << endl;

        long long res = 0;
        for(int i = 0; i < n; i++){
            res = (res + (fr[i] * bc[i]) % Mod * arr[i]) % Mod;
        }
        return res;
    }
};",1448209589
Remineva,Remineva,131,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        for i in range(k, n - k + 1):
            for j in range(i - k, i - 1):
                if nums[j] >= nums[j+1]:
                    break
            else:
                for j in range(i, i + k - 1):
                    if nums[j] >= nums[j+1]:
                        break
                else:
                    return True
        return False",1448183338
Remineva,Remineva,131,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        ls = [1] * n

        for i in range(n - 2, -1, -1):
            if nums[i] < nums[i + 1]:
                ls[i] = ls[i + 1] + 1
            else:
                ls[i] = 1

        def check(l):
            for i in range(n - l):
                if ls[i] >= l and ls[i+l] >= l:
                    return True
            return False
        
        l = 1
        r = n // 2
        while l < r:
            m = (l + r + 1) // 2
            if check(m):
                l = m
            else:
                r = m - 1
        return r",1448199064
Remineva,Remineva,131,3631,python3,"M = 10 ** 9 + 7
class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        if s == '1':
            return 0
        
        @cache
        def f(x):
            if x == 1:
                return 1
            return 1 + f(x.bit_count())

        n = len(s)
        flag = [False] * (n + 1)
        for cnt in range(1, n + 1):
            if f(cnt) <= k:
                flag[cnt] = True




        @cache
        def dp(i, cnt, b, is_flag):
            if i == n:
                if is_flag:
                    return 1 if flag[cnt] else 0
                else:
                    return 0
            limit = int(s[i]) if b else 1
            res = 0
            for digit in range(0, limit + 1):
                new_b = b and (digit == limit)
                new_is_flag = is_flag or (digit != 0)
                new_cnt = cnt + digit if new_is_flag else cnt
                res += dp(i + 1, new_cnt, new_b, new_is_flag)
                res %= M
            return res
        
        if flag[s.count('1')]:
            return dp(0, 0, True, False) - 1
        else:
            return dp(0, 0, True, False)",1448258102
Remineva,Remineva,131,3646,python3,"M = 10 ** 9 + 7
class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        res = 0
        n = len(nums)
        d = defaultdict(int)
        cnt = defaultdict(int)
        for i, num in enumerate(nums):
            curr = (d[num - 1] + d[num + 1]) % M
            cc = (cnt[num - 1] + cnt[num + 1] + 1) % M
            curr += cc * num % M
            curr %= M
            d[num] += curr
            d[num] %= M
            cnt[num] += cc
            cnt[num] %= M
            res += curr
            res %= M
        return res",1448212998
Agnibha Chakraborty,zanj0,136,3612,cpp,"/*
	JAI JAGANNATH!
*/
//@Author : zanj0

#include<bits/stdc++.h>
using namespace std;

#define ff              first
#define ss              second
#define pb              push_back
#define MOD             1000000007
#define inf             1e18

typedef long long int lli;


class Solution {
public:
	bool IsIncreasing(vector<int>& nums, int start, int end) {
		for (int i = start + 1; i <= end; i++) {
			if (nums[i] <= nums[i - 1]) return false;
		}
		return true;
	}
	bool hasIncreasingSubarrays(vector<int>& nums, int k) {
		int n = nums.size();
		for (int i = 0; i < n; i++) {
			int start1 = i;
			int end1 = i + k - 1;
			int start2 = end1 + 1;
			int end2 = start2 + k - 1;
			if (end2 >= nums.size()) return false;
			if (IsIncreasing(nums, start1, end1) && IsIncreasing(nums, start2, end2)) return true;
		}
		return false;
	}
};

#ifdef LOCAL
int main() {
	freopen(""output.txt"", ""w"", stdout);
	cout << ""Compiled!"" << endl;
}
#endif",1448182413
Agnibha Chakraborty,zanj0,136,3619,cpp,"/*
	JAI JAGANNATH!
*/
//@Author : zanj0

#include<bits/stdc++.h>
using namespace std;

#define ff              first
#define ss              second
#define pb              push_back
#define MOD             1000000007
#define inf             1e18

typedef long long int lli;


class Solution {
public:

	int maxIncreasingSubarrays(vector<int>& nums) {
		int n = nums.size();
		vector<int> pre(n, 1), suff(n, 1);
		for (int i = 1; i < n; i++) {
			if (nums[i] > nums[i - 1])pre[i] = 1 + pre[i - 1];
		}
		int ret = 0;
		for (int i = n - 2 ; i >= 0; i--) {
			if (nums[i] < nums[i + 1]) {
				suff[i] = 1 + suff[i + 1];
			}
		}
		for (int i = 1; i < n; i++) {
			ret = max(ret, min(pre[i - 1], suff[i]));
		}
		return ret;
	}
};

#ifdef LOCAL
int main() {
	freopen(""output.txt"", ""w"", stdout);
	cout << ""Compiled!"" << endl;
}
#endif",1448187174
Agnibha Chakraborty,zanj0,136,3631,cpp,"/*
	JAI JAGANNATH!
*/
//@Author : zanj0

#include<bits/stdc++.h>
using namespace std;

#define ff              first
#define ss              second
#define pb              push_back
#define MOD             1000000007
#define inf             1e18

typedef long long int lli;

lli Add(lli a, lli b) {
	return ((a % MOD)  + (b % MOD)) % MOD;
}
lli Mul(lli a, lli b) {
	return ((a % MOD)  * (b % MOD)) % MOD;
}
map<lli, lli> moves;
lli GetMoves(lli x) {
	if (moves.count(x)) return moves[x];
	lli ret = 1;
	lli org = x;
	while (x > 1) {
		ret++;
		x = __builtin_popcountll(x);
	}
	return moves[org] = ret;
}
class Solution {
public:
	lli Dfs(lli idx, lli tight, lli set_bits, string& s, lli k, vector<vector<vector<lli>>>& dp) {
		if (idx >= s.size()) {
            // cout << set_bits << "" "" << GetMoves(set_bits) << endl;
			bool ok= !tight && set_bits && (GetMoves(set_bits) <= k);
            // cout << ok << endl;
            return ok;
		}
		if (dp[idx][tight][set_bits] != -1) return dp[idx][tight][set_bits];
		lli ret = 0;
		for (auto it : {'1', '0'}) {
            if(tight && it> s[idx]) continue;
			lli n_tight = s[idx] == it && tight;
			ret = Add(ret, Dfs(idx + 1, n_tight, set_bits + (it - '0'), s, k, dp));
		}
		return dp[idx][tight][set_bits] = ret;
	}
	int countKReducibleNumbers(string s, int k) {
		int n = s.size();
		vector<vector<vector<lli>>> dp(n + 2, vector<vector<lli>>(2, vector<lli>(n + 2, -1)));
		return Dfs(0, 1, 0, s, k, dp);
	}
};

#ifdef LOCAL
int main() {
	freopen(""output.txt"", ""w"", stdout);
	cout << ""Compiled!"" << endl;
}
#endif",1448251236
Agnibha Chakraborty,zanj0,136,3646,cpp,"/*
	JAI JAGANNATH!
*/
//@Author : zanj0

#include<bits/stdc++.h>
using namespace std;

#define ff              first
#define ss              second
#define pb              push_back
#define MOD             1000000007
#define inf             1e18

typedef long long int lli;

lli Add(lli a, lli b) {
	return ((a % MOD)  + (b % MOD)) % MOD;
}
lli Mul(lli a, lli b) {
	return ((a % MOD)  * (b % MOD)) % MOD;
}
class Solution {
public:
	int sumOfGoodSubsequences(vector<int>& nums) {
		lli ret = 0;
		map<lli, lli> dp;
		map<lli, lli> sum;
		for (auto& it : nums) {
			lli small = dp[it - 1];
			lli big = dp[it + 1];
			dp[it] = Add(dp[it], Add(1, Add(small, big)));
			sum[it] = Add(sum[it], Mul(Add(1, Add(small, big)), it));
			sum[it] = Add(sum[it], sum[it - 1]);
			sum[it] = Add(sum[it], sum[it + 1]);
            // cout << small << "" "" << big << "" "" << sum[it + 1] << "" -> "" << sum[it - 1] << endl;
            // cout << it << "" -- "" << dp[it] << ""  "" << sum[it] << endl;
		}
		for (auto& it : sum) {
            ret = Add(ret, it.ss);
            // cout << it.ff << "" "" << it.ss << endl;
        }
		return ret;
	}
};

#ifdef LOCAL
int main() {
	freopen(""output.txt"", ""w"", stdout);
	cout << ""Compiled!"" << endl;
}
#endif",1448213679
urverymean,urverymean,138,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        def inc(arr):
            for i in range(1,len(arr)):
                if arr[i]<=arr[i-1]:
                    return False
            return True
        for i in range(len(nums) - 2*k + 1):
            if inc(nums[i:i+k]) and inc(nums[i+k:i+k+k]):
                return True
        return False",1448181756
urverymean,urverymean,138,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        pref = [0]*len(nums)
        pref[0] = 1
        for i in range(1,len(nums)):
            pref[i]+=pref[i-1]
            if nums[i] > nums[i-1]:
                pref[i] += 1
        lp = 2
        rp = len(nums)//2
        while lp<=rp:
            mid = (lp+rp)>>1
            p = 0
            good = False
            while p + 2*mid - 1 < len(nums):
                arr1 = pref[p + mid - 1]
                arr1-=pref[p]
                arr2 = pref[p+2*mid - 1]
                arr2-=pref[p+mid]
                if arr2>=mid-1 and arr1>=mid-1:
                    good = True
                    break
                p+=1
            if good:
                lp = mid +  1
            else:
                rp = mid - 1
        return rp",1448220605
urverymean,urverymean,138,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        st = set()
        for i in range(len(s)):
            curr = i
            for j in range(k-1):
                curr = curr.bit_count()
            if curr==1:
                st.add(i)
        MOD = 10**9+7
        @cache
        def dfs(i, bits, tight):
            if i==len(s):
                return int(not tight and bits in st)
            res = dfs(i + 1, bits, tight and s[i]=='0')
            if (not tight or s[i]=='1'):
                res+=dfs(i+1,bits+1, tight and s[i]=='1')
            return res%MOD
        res = dfs(0,0,True)
        dfs.cache_clear()
        return res",1448251442
urverymean,urverymean,138,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        MOD = 10**9+7
        ct = defaultdict(int)
        cl = [0]*len(nums)
        cr = [0]*len(nums)
        res = 0
        for i in range(len(nums)):
            curr = 1
            if nums[i]-1 in ct:
                curr+=ct[nums[i]-1]
            if nums[i]+1 in ct:
                curr+=ct[nums[i]+1]
            curr%=MOD
            cl[i] = curr
            ct[nums[i]] += curr
        ct1 = defaultdict(int)
        for i in range(len(nums)-1,-1,-1):
            curr = 1
            if nums[i]-1 in ct1:
                curr+=ct1[nums[i]-1]
            if nums[i]+1 in ct1:
                curr+=ct1[nums[i]+1]
            curr%=MOD
            cr[i] = curr
            ct1[nums[i]] += curr
        for i in range(len(nums)):
            res+=(nums[i]*cl[i]*cr[i])%MOD
            res%=MOD
        return res
        
            ",1448208973
Abhishek Kumar Jain,abhidot,139,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        vector<int> on;
        int n=nums.size();
        on.push_back(0);
        for(int i=1;i<n;i++){
            if(nums[i]<=nums[i-1]) on.push_back(i);
        }
        
        on.push_back(n);
        int ok=(k==1);
        for(int i=1;i<on.size()-1;i++){
            if(on[i]-on[i-1]>=k&&on[i+1]-on[i]>=k) ok=1;
            if(on[i]-on[i-1]>=2*k) ok=1;
            if(on[i+1]-on[i]>=2*k) ok=1;
        }
        
        if(on.size()==2){
            if(on[1]-on[0]>=2*k) ok=1;
        }
        
        return ok;
        
    }
};",1448190797
Abhishek Kumar Jain,abhidot,139,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        vector<int> on;
        int n=nums.size();
        on.push_back(0);
        for(int i=1;i<n;i++){
            if(nums[i]<=nums[i-1]) on.push_back(i);
        }
        
        on.push_back(n);
        int k=1;
        for(int i=1;i<on.size()-1;i++){
            k = max(k, min(on[i]-on[i-1], on[i+1]-on[i]));
            k = max(k, (on[i]-on[i-1])/2);
            k = max(k, (on[i+1]-on[i])/2);
        }
        
        if(on.size()==2){
            k = max(k, (on[1]-on[0])/2);
        }
        
        return k;
    }
};",1448195411
Abhishek Kumar Jain,abhidot,139,3631,cpp,"#define setbits(x) __builtin_popcountll(x)
const int N = 805;
class Solution {
public:
    bool get_bit(int a, int i)
    {
    	return a & (1ll << i);
    }
    const long long MOD=1e9+7;
    long long power(long long x, unsigned long long y)  
    {  
        long long res = 1;
        x = x % MOD;
        if (x == 0) return 0;
      
        while (y > 0)  
        { 
            if (y & 1)  
                res = (res*x) % MOD;
            y = y>>1;
            x = (x*x) % MOD;  
        }  
        return res;  
    }
    long long modInv(long long a){return power(a,MOD-2);}
    long long fact[N],inv[N];
    void factorial(long long n){
    	fact[0]=1;
    	for(int i=1;i<n;i++){
    		fact[i]=fact[i-1]*i;
    		if(fact[i]>=MOD)
    			fact[i]%=MOD;
    	}
    }
    void InvFactorial(long long n){
    	inv[0]=1;
    	for(int i=1;i<n;i++)
    		inv[i]=modInv(fact[i]);
    }
    long long ncr(int n,int r){
    	if(n<r||n<0||r<0)
    		return 0;
    	long long b=inv[n-r];
    	long long c=inv[r];
    	long long  a=fact[n]*b;
    	if(a>=MOD)
    		a%=MOD;
    	a*=c;
    	if(a>=MOD)
    		a%=MOD;
    	return a;
    }
    int countKReducibleNumbers(string s, int k) {
        int n=s.size();
        int f[n+5];
        factorial(n+5);
        InvFactorial(n+5);
        f[0]=0;
        f[1]=0;
        f[2]=1;
        for(int j=3; j<n+5; j++){
        	f[j]=f[setbits(j)]+1;
        } 

        vector<int> g(n+5, 0);
        for(int i=1;i<n+5;i++){
            g[i]=(f[i]<k);
        }

    	int ans=0,bits=0;
    	for(int j=0; j<n; j++){
    		if(s[j]=='1'){
    			
    			for(int k=0; k<=n-1-j; k++){
    				ans+=ncr(n-1-j,k)*(g[k+bits]);
    				ans%=MOD;
    			}
    			bits++;
    		}
    	}
    	
        return ans;
    }
};",1448251628
Abhishek Kumar Jain,abhidot,139,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        unordered_map<int,int> idx, idx2;
        int n = nums.size();
        vector<long long> dp(n), dp2(n);
        long long ans=0;
        long long mod = 1e9+7;
        for(int i=0;i<n;i++){
            dp2[i]=1;
            if(idx2.find(nums[i]+1)!=idx2.end()){
                dp2[i] = (dp2[i]+idx2[nums[i]+1])%mod;
            }

            if(idx2.find(nums[i]-1)!=idx2.end()){
                dp2[i] = (dp2[i]+idx2[nums[i]-1])%mod;
            }
            idx2[nums[i]] = (idx2[nums[i]]+dp2[i])%mod;

            // cout<<dp[i]<<"" "";

            // ans = (ans + dp[i]*nums[i]%mod)%mod;
        }
        for(int i=n-1;i>=0;i--){
            dp[i]=1;
            if(idx.find(nums[i]+1)!=idx.end()){
                dp[i] = (dp[i]+idx[nums[i]+1])%mod;
            }

            if(idx.find(nums[i]-1)!=idx.end()){
                dp[i] = (dp[i]+idx[nums[i]-1])%mod;
            }
            idx[nums[i]] = (idx[nums[i]]+dp[i])%mod;

            // cout<<dp[i]*dp2[i]<<"" "";

            ans = (ans + dp[i]*dp2[i]%mod*nums[i]%mod)%mod;
        }

        return ans;
    }
};",1448225995
cc4414,lu-chen-chen,141,3612,java,"class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        int n = nums.size();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = nums.get(i);
        }
        for (int i = 0; i <= n - 2 * k; i++) {
            boolean b = true;
            for (int j = 1; j < k; j++) {
                if (arr[i + j] <= arr[i + j - 1]) {
                    b = false;
                    break;
                }
            }
            for (int j = 1; j < k; j++) {
                if (arr[i + j + k] <= arr[i + j - 1 + k]) {
                    b = false;
                    break;
                }
            }
            if (b) {
                return true;
            }
        }
        return false;
    }
}",1448184518
cc4414,lu-chen-chen,141,3619,java,"class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        int n = nums.size();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = nums.get(i);
        }
        int l = 0;
        int r = n;
        while (l < r) {
            int mid = (l + r + 1) >> 1;
            if (hasIncreasingSubarrays(arr, mid)) {
                l = mid;
            } else {
                r = mid - 1;
            }
        }
        return l;
    }

    public boolean hasIncreasingSubarrays(int[] arr, int k) {
        int n = arr.length;
        int[] cnt = new int[n];
        cnt[n - 1] = 1;
        for (int i = n - 2; i >= 0; i--) {
            if (arr[i] < arr[i + 1]) {
                cnt[i] = cnt[i + 1] + 1;
            } else {
                cnt[i] = 1;
            }
        }
        for (int i = 0; i <= n - 2 * k; i++) {
            if (cnt[i] < k) {
                continue;
            }
            if (cnt[i + k] >= k) {
                return true;
            }
        }
        return false;
    }
}",1448196476
cc4414,lu-chen-chen,141,3631,java,"class Solution {
    long mod = (long) (1e9 + 7);
    char[] chars;
    long[][] dp;
    int[] r;
    int k;
    boolean[][] vis;

    public int countKReducibleNumbers(String s, int k) {
        this.k = k;
        chars = s.toCharArray();
        int n = chars.length;
        r = new int[n + 5];
        for (int i = 2; i < r.length; i++) {
            r[i] = r[Integer.bitCount(i)] + 1;
        }
        dp = new long[n][n + 1];
        vis = new boolean[n][n + 1];
        int sum = 0;
        for (int i = 0; i < n; i++) {
            sum += chars[i] - '0';
        }
        long ans = f(0, 0, true, false) - (r[sum] < k ? 1 : 0);
        return (int) ((ans % mod + mod) % mod);
    }

    long f(int i, int cnt, boolean isLimit, boolean isNum) {
        if (i == chars.length) {
            // （修改点）满足条件则返回1
            return isNum && r[cnt] < k && cnt > 0 ? 1 : 0;
        }
        if (!isLimit && isNum && vis[i][cnt]) {
            return dp[i][cnt];
        }
        long res = 0;
        if (!isNum) {
            // 可以跳过当前数位
            res = f(i + 1, cnt, false, false);
        }
        // 枚举要填入的数字 d
        for (int d = isNum ? 0 : 1, up = isLimit ? chars[i] - '0' : 1; d <= up; d++) {
            res += f(i + 1, cnt + d, isLimit && d == up, true);
        }
        if (!isLimit && isNum) {
            dp[i][cnt] = res % mod;
            vis[i][cnt] = true;
        }
        return res;
    }
}",1448259404
cc4414,lu-chen-chen,141,3646,java,"class Solution {
    public int sumOfGoodSubsequences(int[] nums) {
        long mod = (long) (1e9 + 7);
        int n = nums.length;
        long sum = 0;
        Map<Integer, Long> mapCnt = new HashMap<>();
        Map<Integer, Long> mapSum = new HashMap<>();
        for (int i = 0; i < n; i++) {
            int v = nums[i];
            long t1 = mapCnt.getOrDefault(v + 1, 0L);
            long t2 = mapCnt.getOrDefault(v - 1, 0L);
            long t = t1 + t2;
            long s1 = mapSum.getOrDefault(v + 1, 0L);
            long s2 = mapSum.getOrDefault(v - 1, 0L);
            long s = (s1 + s2 + t * v + v) % mod;
            mapCnt.put(v, (mapCnt.getOrDefault(v, 0L) + t + 1) % mod);
            mapSum.put(v, (mapSum.getOrDefault(v, 0L) + s) % mod);
            sum += s;
            sum %= mod;
        }
        return (int) ((sum % mod + mod) % mod);
    }
}",1448221505
gabriel88766,gabriel88766,142,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        for(int i=0;i<nums.size();i++){
            if(i + 2*k > nums.size()) break;
            bool ok = true;
            for(int j=i+1;j<i+k;j++){
                if(nums[j] <= nums[j-1]) ok = false;
            }
            for(int j=i+k+1;j<i+2*k;j++){
                if(nums[j] <= nums[j-1]) ok = false;
            }
            if(ok) return true;
        }
        return false;
    }
};",1448184841
gabriel88766,gabriel88766,142,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        vector<int> pr(nums.size()), su(nums.size());
        int ln = -1'000'000'001;
        int cs = 0;
        for(int j=0;j<nums.size();j++){
            if(nums[j] > ln) cs++;
            else{
                cs = 1;
            }
            ln = nums[j];
            pr[j] = cs;
        }
        ln = -1'000'000'001;
        cs = 0;
        for(int j=nums.size()-1;j>=0;j--){
            if(nums[j] < ln) cs++;
            else{
                cs = 1;
            }
            ln = nums[j];
            su[j] = cs;
        }
        int ans = 0;
        for(int j=0;j<nums.size()-1;j++){
            ans = max(ans, min(pr[j], su[j+1]));
        }
        return ans;
    }
};",1448198577
gabriel88766,gabriel88766,142,3631,cpp,"class Solution {
public:
    const long long MOD = 1'000'000'007;
    int countKReducibleNumbers(string s, int k) {
        int n = s.size();
        vector<int> red(n+1, 0);
        for(int i=1;i<=n;i++){
            int aux = i;
            int cnt = 0;
            while(aux != 1){
                aux = __builtin_popcount(aux);
                cnt++;
            }
            red[i] = cnt;
        }
        int dp[n+2][n+2][2];
        memset(dp, 0, sizeof(dp));
        dp[n][0][0] = dp[n][0][1] = 1;
        for(int i=n-1;i>=0;i--){
            for(int j=0;j<=n;j++){
                dp[i][j][0] += dp[i+1][j][0];
                dp[i][j+1][0] += dp[i+1][j][0];
                dp[i][j][0] %= MOD;
                dp[i][j+1][0] %= MOD;
            }
            if(s[i] == '1'){
                for(int j=0;j<=n;j++){
                    dp[i][j][1] += dp[i+1][j][0];
                    dp[i][j+1][1] += dp[i+1][j][1];   
                    dp[i][j][1] %= MOD;
                    dp[i][j+1][1] %= MOD;
                }
            }else{
                for(int j=0;j<=n;j++){
                    dp[i][j][1] += dp[i+1][j][1];
                    dp[i][j][1] %= MOD;
                }
            }
        }
        long long ans = 0;
        for(int i=1;i<=n;i++){
            if(red[i] + 1 <= k){
                ans += dp[0][i][1];
                ans %= MOD;
            }
        }
        int c1 = 0;
        for(auto c : s) if(c == '1') c1++;
        if(red[c1] + 1 <= k){
            if(ans != 0) ans--;
            else ans = MOD - 1;
        }
        return ans;
    }
};",1448259687
gabriel88766,gabriel88766,142,3646,cpp,"class Solution {
public:
    const long long MOD = 1'000'000'007;
    int sumOfGoodSubsequences(vector<int>& nums) {
        int n = nums.size();
        vector<long long> pr(n);
        vector<long long> su(n);
        map<long long,long long> dp;
        for(int i=0;i<nums.size();i++){
            long long cur = 1;
            if(dp.count(nums[i] - 1)) cur += dp[nums[i] - 1];
            if(dp.count(nums[i] + 1)) cur += dp[nums[i] + 1];
            cur %= MOD;
            pr[i] = cur;
            dp[nums[i]] = (dp[nums[i]] + cur) % MOD;
        }
        dp.clear();
        for(int i=nums.size()-1;i>=0;i--){
            long long cur = 1;
            if(dp.count(nums[i] - 1)) cur += dp[nums[i] - 1];
            if(dp.count(nums[i] + 1)) cur += dp[nums[i] + 1];
            cur %= MOD;
            su[i] = cur;
            dp[nums[i]] = (dp[nums[i]] + cur) % MOD;
        }
        long long ans = 0;
        for(int i=0;i<nums.size();i++){
            ans = (ans + nums[i] * ((pr[i] * su[i])%MOD)) % MOD;
        }
        return ans;
    }
};",1448227122
trchen,trchen,143,3612,cpp,"class Solution {
 public:
  bool Ok(const vector<int>& lengths, int k) {
    int n = lengths.size();
    for (int i = 0; i <= n - 2 * k; ++i) {
      if (lengths[i] >= k && lengths[i + k] >= k) {
        return true;
      }
    }
    return false;
  }

  bool hasIncreasingSubarrays(vector<int>& nums, int k) {
    int n = nums.size();
    vector<int> lengths(n);
    lengths.back() = 1;
    for (int i = n - 2; i >= 0; --i) {
      if (nums[i] < nums[i + 1]) {
        lengths[i] = lengths[i + 1] + 1;
      } else {
        lengths[i] = 1;
      }
    }
    return Ok(lengths, k);
  }
};",1448199522
trchen,trchen,143,3619,cpp,"class Solution {
 public:
  bool Ok(const vector<int>& lengths, int k) {
    int n = lengths.size();
    for (int i = 0; i <= n - 2 * k; ++i) {
      if (lengths[i] >= k && lengths[i + k] >= k) {
        return true;
      }
    }
    return false;
  }

  int maxIncreasingSubarrays(vector<int>& nums) {
    int n = nums.size();
    vector<int> lengths(n);
    lengths.back() = 1;
    for (int i = n - 2; i >= 0; --i) {
      if (nums[i] < nums[i + 1]) {
        lengths[i] = lengths[i + 1] + 1;
      } else {
        lengths[i] = 1;
      }
    }
    // for (auto c : lengths) {
    //   cout << c << ' ';
    // }
    // cout << endl;
    int low = 1;
    int high = n / 2;
    while (low + 3 < high) {
      int mid = (low + high) / 2;
      if (Ok(lengths, mid)) {
        low = mid;
      } else {
        high = mid - 1;
      }
    }
    for (int i = high; i >= low; --i) {
      if (Ok(lengths, i)) {
        return i;
      }
    }
    return 1;
  }
};",1448195783
trchen,trchen,143,3631,cpp,"using ll = long long;

class Solution {
 public:
  Solution() {
    reducible_counts.resize(801);
    for (int i = 1; i <= 800; ++i) {
      reducible_counts[i] = ReducibleCount(i);
    }
    int X = 800;
    factorials.resize(X + 1);
    inverse_factorials.resize(X + 1);
    factorials[0] = 1;
    for (ll i = 1; i <= X; ++i) {
      factorials[i] = (factorials[i - 1] * i) % MOD;
    }
    inverse_factorials.resize(X + 1);
    for (int i = 0; i <= X; ++i) {
      inverse_factorials[i] = Inverse(factorials[i]);
    }
  }

  ll Power(ll a, int power) {
    if (a == 0) {
      return 0;
    }
    ll ret = 1;
    while (power > 0) {
      if (power % 2 == 1) {
        ret = (ret * a) % MOD;
      }
      a = (a * a) % MOD;
      power /= 2;
    }
    return ret;
  }

  ll Inverse(int a) {
    return Power(a, MOD - 2);
  }

  int ReducibleCount(int n) {
    int ret = 0;
    while (n > 1) {
      ++ret;
      int new_n = 0;
      while (n > 0) {
        if (n % 2 == 1) {
          ++new_n;
        }
        n /= 2;
      }
      n = new_n;
    }
    return ret;
  }

  ll Choose(int n, int k) {
    ll ret = ((factorials[n] * inverse_factorials[k]) % MOD) * inverse_factorials[n - k] % MOD;
    return ret;
  }

  int countKReducibleNumbers(string s, int k) {
    int n = s.size();
    int count1 = 0;
    ll ret = 0;
    for (int i = 0; i < n; ++i) {
      if (s[i] == '0') {
        continue;
      }
      for (int j = 0; j <= n - (i + 1); ++j) {
        if (j + count1 > 0 && reducible_counts[j + count1] <= k - 1) {
          ret = (ret + Choose(n - (i + 1), j)) % MOD; 
        }
      }
      count1++;
    }
    return ret;
  }

  static constexpr ll MOD = 1000000007;
  vector<int> reducible_counts;
  vector<ll> factorials;
  vector<ll> inverse_factorials;
};",1448252265
trchen,trchen,143,3646,cpp,"
using ll = long long;

class Solution {
 public:
  int sumOfGoodSubsequences(vector<int>& nums) {
    unordered_map<int, pair<ll, ll>> prevs;
    int n = nums.size();
    ll ret = 0;
    for (auto c : nums) {
      pair<ll, ll> additional{ 1, c };
      if (prevs.find(c - 1) != prevs.end()) {
        auto p = prevs[c - 1];
        additional.first += p.first;
        additional.second += p.first * c + p.second;
      }
      additional.first %= MOD;
      additional.second %= MOD;
      if (prevs.find(c + 1) != prevs.end()) {
        auto p = prevs[c + 1];
        additional.first += p.first;
        additional.second += p.first * c + p.second;
      }
      additional.first %= MOD;
      additional.second %= MOD;
      ret = (ret + additional.second) % MOD;
      prevs[c].first = (prevs[c].first + additional.first) % MOD;
      prevs[c].second = (prevs[c].second + additional.second) % MOD;
    }
    return ret;
  }

  static inline constexpr ll MOD = 1000000007;
};",1448217099
Akash,Akash_0P,144,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();

        auto f = [&](int id) -> int {
            if(id + k - 1 >= n) return 0;
            for(int i = id + 1; i < id + k; i++) if(nums[i - 1] >= nums[i]) return 0;

            return 1;
        };

        for(int i = 0; i < n; i++) {
            if(f(i) && f(i + k)) return 1;
        }

        return 0;
    }
};",1448183269
Akash,Akash_0P,144,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp(n);

        for(int i = n - 1; i >= 0; i--) {
            dp[i] = 1;
            if(i + 1 < n && nums[i] < nums[i + 1]) dp[i] += dp[i + 1];
        }

        auto check = [&](int i, int k) {
            return i + k - 1 < n;
        };

        auto f = [&](int k) -> int {
            for(int i = 0; i < n; i++) if(check(i, k) && check(i + k, k)) {
                if(dp[i] >= k && dp[i + k] >= k) return 1;
            }

            return 0;
        };

        int l = 1, r = n, ans = 0;
        while(l <= r) {
            int m = (l + r) / 2;
            if(f(m)) ans = m, l = m + 1;
            else r = m - 1;
        }

        return ans;
    }
};",1448191554
Akash,Akash_0P,144,3631,cpp,"using ll = long long;

class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        int n = s.size(), M = 1e9 + 7;

        auto ok = [&](int total) {
            int cnt = 1;
            while(total > 1) {
                total = __builtin_popcount(total);
                cnt++;
            }

            return cnt;
        };

        vector<vector<vector<int>>> dp(2, vector<vector<int>> (n + 10, vector<int> (n + 10, -1)));

        auto f = [&](int i, int tight, int sum, auto && f) -> ll {
            if(i == n) {
                if(tight) return 0;
                return (sum > 0 && ok(sum) <= k);
            };

            if(dp[tight][i][sum] != -1) return dp[tight][i][sum];

            ll ans = 0;
    
            if(tight) {
                if(s[i] == '0') ans = f(i + 1, 1, sum, f);
                else {
                    ans = f(i + 1, 0, sum, f);
                    ans = (ans + f(i + 1, 1, sum + 1, f)) % M;
                }
            }else {
                ans = f(i + 1, 0, sum, f);
                ans = (ans + f(i + 1, 0, sum + 1, f)) % M;
            }

            return dp[tight][i][sum] = ans;

        };

        return f(0, 1, 0, f);
    }
};",1448259766
Akash,Akash_0P,144,3646,cpp,"using ll = long long;

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int n = nums.size(), M = 1e9 + 7;
        map<int, ll>mpp, cnt;

        ll ans = 0;

        auto add = [&](ll a, ll b) {
            return (a + b) % M;
        };

        auto mul = [&](ll a, ll b) {
            return (a * b) % M;
        };

        for(int i = n - 1; i >= 0; i--) {
            ll value = nums[i], sum = nums[i];

            if(mpp.count(value + 1)) {
                sum = add(sum, add(mul(value, cnt[value + 1]), mpp[value + 1]));
                cnt[value] = add(cnt[value], cnt[value + 1]);
            }

            if(mpp.count(value - 1)) {
                sum = add(sum, add(mul(value, cnt[value - 1]), mpp[value - 1]));
                cnt[value] = add(cnt[value], cnt[value - 1]);
            }

            ans = add(ans, sum);
            mpp[nums[i]] = add(mpp[nums[i]], sum);
            cnt[nums[i]] = add(cnt[nums[i]], 1);
        }

        return ans;
    }
};",1448215672
a_k,a0518,145,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        
        for i in range(n):
            if i+k >= n: continue
            ok = True
            for j in range(i+1, i+k):
                if nums[j]<=nums[j-1]:
                    ok = False
                    break
            # if i == 0: print(ok)
            if ok:
                ok = True
                idx = i+k
                if idx+k-1 <= n-1: 
                    for j in range(idx+1, idx+k):
                        if nums[j]<=nums[j-1]:
                            ok = False
                            break
                    if ok: return True
        return False",1448182914
a_k,a0518,145,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        prefix = [0 for _ in range(n)]
        suffix = [0 for _ in range(n)]
        i = 0
        while i < n:
            prv = -float(""inf"")
            l = 0
            while i < n and nums[i] > prv:
                l+=1
                prefix[i] = l
                prv = nums[i]
                i+=1
        
        i = n-1
        while i >= 0:
            prv = float(""inf"")
            l = 0
            while i >= 0 and nums[i] < prv:
                l+=1
                prv = nums[i]
                suffix[i] = l
                i-=1
        
        # print(prefix)
        # print(suffix)
        res = 0
        for i in range(n-1):
            res = max(res, min(prefix[i], suffix[i+1]))
        return res",1448187460
a_k,a0518,145,3631,python3,"
class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        mod = 10**9 + 7
        n = len(s)
        
        def good(x):
            cur = x
            for i in range(k - 1):
                cur = bin(cur)[2:].count('1')
            return cur == 1 
        
        dp = [[[0] * 2 for _ in range(n + 1)] for _ in range(n + 1)]
        
        dp[0][0][0] = 1
        
        for i in range(n):
            for cnt in range(n + 1):
                for ok in range(2):
                    dp[i + 1][cnt][ok or (s[i] == '1')] += dp[i][cnt][ok]
                    dp[i + 1][cnt][ok or (s[i] == '1')] %= mod
                    
                    if cnt > 0 and (ok or s[i] == '1'):
                        dp[i + 1][cnt][ok] += dp[i][cnt - 1][ok]
                        dp[i + 1][cnt][ok] %= mod
        

        res = 0
        for i in range(1, n + 1):
            if good(i):
                res = (res + dp[n][i][1]) % mod
                
        return res
",1448237211
a_k,a0518,145,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        mod = 10**9+7
        n = len(nums)
        mp = defaultdict(int)
        count = defaultdict(int)
        
        res = 0
        for i in range(n):
            cur = nums[i]
            count[nums[i]]+=1
            if nums[i]-1 in mp:
                count[nums[i]] = (count[nums[i]] + count[nums[i]-1]) % mod
                cur = (cur + mp[nums[i]-1] + (nums[i] * count[nums[i]-1]) % mod) % mod
            if nums[i]+1 in mp:
                count[nums[i]] = (count[nums[i]] + count[nums[i]+1]) % mod
                cur = (cur + mp[nums[i]+1] + (nums[i] * count[nums[i]+1]) % mod) % mod
            # if i == 1: print(mp)
            mp[nums[i]] = (mp[nums[i]] + cur) % mod
            res = (res + cur) % mod
        return res
        
                ",1448201308
lccfatc,lccfatc,146,3612,cpp,"#ifdef sigma-yyf
#include ""/Users/yangyf/Desktop/cpcode/leetcode/lc_help.hpp""
#endif
using namespace std;

using ll = long long;
#define ar(x) array<int,x> 
#define all(c) (c).begin(), (c).end()
#define rall(x) (x).rbegin(), (x).rend() 
#define sz(x) (int)(x).size()
#define f0(e) for(int i = 0; i < (e); ++i)
#define f1(e) for(int i = 1; i <= (e); ++i)
#define f2(i,e) for(int i = 0; i < (e); ++i)
#define f3(i,a,b) for (int i=(a);i<(b);i++)
#define r3(i,b,a) for (int i=(b)-1;i>=(a);i--)
#define Sm(a) accumulate((a).begin(), (a).end() , 0ll)
#define Mn(a) (*min_element((a).begin(), (a).end()))
#define Mx(a) (*max_element((a).begin(), (a).end()))
#define rev(a) reverse((a).begin(), (a).end())
#define each(x,a) for(auto& x : a)
mt19937 mrand(random_device{}()); 
int rng(int x) { return mrand() % x;}
int pct(long long x) {return __builtin_popcountll(x);} 
int lg(int x) {return x == 0 ? -1 : 31 - __builtin_clz(x);}
int clg(int x) {return x <= 1 ? 0 : 32 - __builtin_clz(x - 1);}
template<class t,class u> bool cmx(t &a, const u &b){return a < b ? a = b, 1 : 0;}
template<class t,class u> bool cmn(t &a, const u &b){return b < a ? a = b, 1 : 0;}
template <class T> T f_div(const T x, const T y) { T q = x / y, r = x % y; return q - ((x ^ y) < 0 and (r != 0));}
template <class T> T c_div(const T x, const T y) { T q = x / y, r = x % y; return q + ((x ^ y) > 0 and (r != 0));}
template <class T> int lb(const vector<T> &v, const T &x) { return distance(begin(v), lower_bound(begin(v), end(v), x));}
template <class T> int rb(const vector<T> &v, const T &x) { return distance(begin(v), upper_bound(begin(v), end(v), x));}
template<class T,class A> void psum(vector<T>& s, const vector<A>&a){
    int n=a.size();s.resize(n+1);s[0]=0;for(int i=0;i<n;++i)s[i+1]=s[i]+a[i];  
};
template<typename T, typename F> T b_search(T l, T r, bool fst, F &&f) {
    T c = fst ? r : l;
    while(l<=r){T md=(l+r)/2;if(f(md)){c=md; fst?(r=md-1):(l=md+1);} else fst?(l=md+1):(r=md-1);}
    return c;
}
template <typename T, typename U> // pair
ostream& operator<<(ostream& out, const pair<T, U>& a) {return out << a.first << ' ' << a.second;}
template <typename T>  // vector
ostream& operator<<(ostream& out, const vector<T>& a) {for(int i=0,n=a.size(); i<n; ++i) out<<a[i]<<"" \n""[i==n-1]; return out;}
template <typename T, size_t N> // array
ostream& operator<<(ostream& out, const array<T, N>& a) {for(int i=0;i<N;++i)cout<<a[i]<<"" \n""[i==N-1];return out;}
template <typename T, typename U> // pair
istream& operator>>(istream& in, pair<T, U>& a) {return in >> a.first >> a.second;}
template <typename T> // vector
istream& operator>>(istream& in, vector<T>& a) {for (auto &x: a) in >> x; return in;}
template <typename T, size_t N> // array
istream& operator>>(istream& in, array<T, N>& a) {for (int i=0;i<N;++i) in >> a[i]; return in;}
template<class T> void rd(T& x) {cin >> x;}
template<class H, class... T> void rd(H& h, T&... t) {rd(h); rd(t...);}
template<class A> void wt(A x) { cout << x;}
template<class H, class... T> void wt(const H& h, const T&... t) { wt(h); wt(t...);}
bool is_vo(char c){return c=='a' || c=='e' || c=='i' || c=='o' || c=='u';}
int s2t(string &s){return s[0]*600 + s[1]*60 + s[3]*10 + s[4] - 32208;} //s: ""HH:MM"" 
#ifdef sigma-yyf
#define dbg(...) debug_impl(#__VA_ARGS__, __VA_ARGS__)
template <class H, class... Ts> void debug_impl(const char* s, const H& h, const Ts&... t) {
    cerr << s << "": "" << h, ((cerr << "", "" << t), ..., (cerr << ""\n""));
}
#else
#define dbg(...) void(0)
#endif
template<class Fun> class Y_comb {
    Fun _f;
public:
    template<class T> explicit Y_comb(T &&fun): _f(forward<T>(fun)) {}
    template<class ...Args> decltype(auto) operator()(Args &&...As) {return _f(ref(*this), forward<Args>(As)...);}
};
template<class Fun> decltype(auto) y_comb(Fun &&fun) { return Y_comb<decay_t<Fun>>(forward<Fun>(fun));}
struct fast_ios { 
    fast_ios(){ cin.tie(nullptr), ios::sync_with_stdio(false), cout << fixed << setprecision(10);};
} fast_ios_;
constexpr char nl = '\n';
constexpr int inf = 1'061'109'567;
constexpr ll infll = 2'000'000'000'000'000'000;
constexpr int N = 2e5 + 5;
int n, m, k;

class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& a, int k) {
        n=sz(a);
       vector<int> f(n);
        f[n-1]=1;
        for(int i=n-2;i>=0;--i){
        	if(a[i]<a[i+1])f[i]=f[i+1]+1;
        	else f[i]=1;
        }
        // auto chk=[&](int pct,int k){
        // 	for(int i=p;i<p+k-1;++i)if(a[i]>=a[i+1])return 0;
        // 	return 1;
        // };
        if(n<2*k)return 0;
        for(int i=0;i<=n-2*k;++i){
        	if(f[i]>=k&&f[i+k]>=k)return 1;
        }
        return 0;
    }
};

#ifdef sigma-yyf
int main(){
    vector<int> v,a,b;
    string s,t;
    vector<string> sv;
    vector<vector<int>> vv;
    // ListNode* head = nullptr, *l1,*l2;
    // TreeNode* root = nullptr,*p,*q;
    // Solution so;
    // rd(a,k);
    // auto ans = so.;
    // wt(ans);
    cout<<'\n';
    return 0;
}
#endif
",1448260076
lccfatc,lccfatc,146,3619,cpp,"#ifdef sigma-yyf
#include ""/Users/yangyf/Desktop/cpcode/leetcode/lc_help.hpp""
#endif
using namespace std;

using ll = long long;
#define ar(x) array<int,x> 
#define all(c) (c).begin(), (c).end()
#define rall(x) (x).rbegin(), (x).rend() 
#define sz(x) (int)(x).size()
#define f0(e) for(int i = 0; i < (e); ++i)
#define f1(e) for(int i = 1; i <= (e); ++i)
#define f2(i,e) for(int i = 0; i < (e); ++i)
#define f3(i,a,b) for (int i=(a);i<(b);i++)
#define r3(i,b,a) for (int i=(b)-1;i>=(a);i--)
#define Sm(a) accumulate((a).begin(), (a).end() , 0ll)
#define Mn(a) (*min_element((a).begin(), (a).end()))
#define Mx(a) (*max_element((a).begin(), (a).end()))
#define rev(a) reverse((a).begin(), (a).end())
#define each(x,a) for(auto& x : a)
mt19937 mrand(random_device{}()); 
int rng(int x) { return mrand() % x;}
int pct(long long x) {return __builtin_popcountll(x);} 
int lg(int x) {return x == 0 ? -1 : 31 - __builtin_clz(x);}
int clg(int x) {return x <= 1 ? 0 : 32 - __builtin_clz(x - 1);}
template<class t,class u> bool cmx(t &a, const u &b){return a < b ? a = b, 1 : 0;}
template<class t,class u> bool cmn(t &a, const u &b){return b < a ? a = b, 1 : 0;}
template <class T> T f_div(const T x, const T y) { T q = x / y, r = x % y; return q - ((x ^ y) < 0 and (r != 0));}
template <class T> T c_div(const T x, const T y) { T q = x / y, r = x % y; return q + ((x ^ y) > 0 and (r != 0));}
template <class T> int lb(const vector<T> &v, const T &x) { return distance(begin(v), lower_bound(begin(v), end(v), x));}
template <class T> int rb(const vector<T> &v, const T &x) { return distance(begin(v), upper_bound(begin(v), end(v), x));}
template<class T,class A> void psum(vector<T>& s, const vector<A>&a){
    int n=a.size();s.resize(n+1);s[0]=0;for(int i=0;i<n;++i)s[i+1]=s[i]+a[i];  
};
template<typename T, typename F> T b_search(T l, T r, bool fst, F &&f) {
    T c = fst ? r : l;
    while(l<=r){T md=(l+r)/2;if(f(md)){c=md; fst?(r=md-1):(l=md+1);} else fst?(l=md+1):(r=md-1);}
    return c;
}
template <typename T, typename U> // pair
ostream& operator<<(ostream& out, const pair<T, U>& a) {return out << a.first << ' ' << a.second;}
template <typename T>  // vector
ostream& operator<<(ostream& out, const vector<T>& a) {for(int i=0,n=a.size(); i<n; ++i) out<<a[i]<<"" \n""[i==n-1]; return out;}
template <typename T, size_t N> // array
ostream& operator<<(ostream& out, const array<T, N>& a) {for(int i=0;i<N;++i)cout<<a[i]<<"" \n""[i==N-1];return out;}
template <typename T, typename U> // pair
istream& operator>>(istream& in, pair<T, U>& a) {return in >> a.first >> a.second;}
template <typename T> // vector
istream& operator>>(istream& in, vector<T>& a) {for (auto &x: a) in >> x; return in;}
template <typename T, size_t N> // array
istream& operator>>(istream& in, array<T, N>& a) {for (int i=0;i<N;++i) in >> a[i]; return in;}
template<class T> void rd(T& x) {cin >> x;}
template<class H, class... T> void rd(H& h, T&... t) {rd(h); rd(t...);}
template<class A> void wt(A x) { cout << x;}
template<class H, class... T> void wt(const H& h, const T&... t) { wt(h); wt(t...);}
bool is_vo(char c){return c=='a' || c=='e' || c=='i' || c=='o' || c=='u';}
int s2t(string &s){return s[0]*600 + s[1]*60 + s[3]*10 + s[4] - 32208;} //s: ""HH:MM"" 
#ifdef sigma-yyf
#define dbg(...) debug_impl(#__VA_ARGS__, __VA_ARGS__)
template <class H, class... Ts> void debug_impl(const char* s, const H& h, const Ts&... t) {
    cerr << s << "": "" << h, ((cerr << "", "" << t), ..., (cerr << ""\n""));
}
#else
#define dbg(...) void(0)
#endif
template<class Fun> class Y_comb {
    Fun _f;
public:
    template<class T> explicit Y_comb(T &&fun): _f(forward<T>(fun)) {}
    template<class ...Args> decltype(auto) operator()(Args &&...As) {return _f(ref(*this), forward<Args>(As)...);}
};
template<class Fun> decltype(auto) y_comb(Fun &&fun) { return Y_comb<decay_t<Fun>>(forward<Fun>(fun));}
struct fast_ios { 
    fast_ios(){ cin.tie(nullptr), ios::sync_with_stdio(false), cout << fixed << setprecision(10);};
} fast_ios_;
constexpr char nl = '\n';
constexpr int inf = 1'061'109'567;
constexpr ll infll = 2'000'000'000'000'000'000;
constexpr int N = 2e5 + 5;
int n, m, k;

class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& a) {
        n=sz(a);
        vector<int> f(n);
        f[n-1]=1;
        for(int i=n-2;i>=0;--i){
        	if(a[i]<a[i+1])f[i]=f[i+1]+1;
        	else f[i]=1;
        }
        int c=0,l=1,r=n/2;
        while(l<=r){
        	int x=(l+r)/2;
        	bool o=0;
        	for(int i=0;i<=n-2*x;++i){
            	if(f[i]>=x&&f[i+x]>=x){
                    o=1;break;
                }
            }
            if(o){
            	c=x;l=x+1;
            }else r=x-1;
        }

        return c;
    }
};

#ifdef sigma-yyf
int main(){
    vector<int> v,a,b;
    string s,t;
    vector<string> sv;
    vector<vector<int>> vv;
    // ListNode* head = nullptr, *l1,*l2;
    // TreeNode* root = nullptr,*p,*q;
    // Solution so;
    // rd(a,k);
    // auto ans = so.;
    // wt(ans);
    cout<<'\n';
    return 0;
}
#endif
",1448259811
lccfatc,lccfatc,146,3631,cpp,"#ifdef sigma-yyf
#include ""/Users/yangyf/Desktop/cpcode/leetcode/lc_help.hpp""
#endif
using namespace std;

using ll = long long;
#define ar(x) array<int,x> 
#define all(c) (c).begin(), (c).end()
#define rall(x) (x).rbegin(), (x).rend() 
#define sz(x) (int)(x).size()
#define f0(e) for(int i = 0; i < (e); ++i)
#define f1(e) for(int i = 1; i <= (e); ++i)
#define f2(i,e) for(int i = 0; i < (e); ++i)
#define f3(i,a,b) for (int i=(a);i<(b);i++)
#define r3(i,b,a) for (int i=(b)-1;i>=(a);i--)
#define Sm(a) accumulate((a).begin(), (a).end() , 0ll)
#define Mn(a) (*min_element((a).begin(), (a).end()))
#define Mx(a) (*max_element((a).begin(), (a).end()))
#define rev(a) reverse((a).begin(), (a).end())
#define each(x,a) for(auto& x : a)
mt19937 mrand(random_device{}()); 
int rng(int x) { return mrand() % x;}
int pct(long long x) {return __builtin_popcountll(x);} 
int lg(int x) {return x == 0 ? -1 : 31 - __builtin_clz(x);}
int clg(int x) {return x <= 1 ? 0 : 32 - __builtin_clz(x - 1);}
template<class t,class u> bool cmx(t &a, const u &b){return a < b ? a = b, 1 : 0;}
template<class t,class u> bool cmn(t &a, const u &b){return b < a ? a = b, 1 : 0;}
template <class T> T f_div(const T x, const T y) { T q = x / y, r = x % y; return q - ((x ^ y) < 0 and (r != 0));}
template <class T> T c_div(const T x, const T y) { T q = x / y, r = x % y; return q + ((x ^ y) > 0 and (r != 0));}
template <class T> int lb(const vector<T> &v, const T &x) { return distance(begin(v), lower_bound(begin(v), end(v), x));}
template <class T> int rb(const vector<T> &v, const T &x) { return distance(begin(v), upper_bound(begin(v), end(v), x));}
template<class T,class A> void psum(vector<T>& s, const vector<A>&a){
    int n=a.size();s.resize(n+1);s[0]=0;for(int i=0;i<n;++i)s[i+1]=s[i]+a[i];  
};
template<typename T, typename F> T b_search(T l, T r, bool fst, F &&f) {
    T c = fst ? r : l;
    while(l<=r){T md=(l+r)/2;if(f(md)){c=md; fst?(r=md-1):(l=md+1);} else fst?(l=md+1):(r=md-1);}
    return c;
}
template <typename T, typename U> // pair
ostream& operator<<(ostream& out, const pair<T, U>& a) {return out << a.first << ' ' << a.second;}
template <typename T>  // vector
ostream& operator<<(ostream& out, const vector<T>& a) {for(int i=0,n=a.size(); i<n; ++i) out<<a[i]<<"" \n""[i==n-1]; return out;}
template <typename T, size_t N> // array
ostream& operator<<(ostream& out, const array<T, N>& a) {for(int i=0;i<N;++i)cout<<a[i]<<"" \n""[i==N-1];return out;}
template <typename T, typename U> // pair
istream& operator>>(istream& in, pair<T, U>& a) {return in >> a.first >> a.second;}
template <typename T> // vector
istream& operator>>(istream& in, vector<T>& a) {for (auto &x: a) in >> x; return in;}
template <typename T, size_t N> // array
istream& operator>>(istream& in, array<T, N>& a) {for (int i=0;i<N;++i) in >> a[i]; return in;}
template<class T> void rd(T& x) {cin >> x;}
template<class H, class... T> void rd(H& h, T&... t) {rd(h); rd(t...);}
template<class A> void wt(A x) { cout << x;}
template<class H, class... T> void wt(const H& h, const T&... t) { wt(h); wt(t...);}
bool is_vo(char c){return c=='a' || c=='e' || c=='i' || c=='o' || c=='u';}
int s2t(string &s){return s[0]*600 + s[1]*60 + s[3]*10 + s[4] - 32208;} //s: ""HH:MM"" 
#ifdef sigma-yyf
#define dbg(...) debug_impl(#__VA_ARGS__, __VA_ARGS__)
template <class H, class... Ts> void debug_impl(const char* s, const H& h, const Ts&... t) {
    cerr << s << "": "" << h, ((cerr << "", "" << t), ..., (cerr << ""\n""));
}
#else
#define dbg(...) void(0)
#endif
template<class Fun> class Y_comb {
    Fun _f;
public:
    template<class T> explicit Y_comb(T &&fun): _f(forward<T>(fun)) {}
    template<class ...Args> decltype(auto) operator()(Args &&...As) {return _f(ref(*this), forward<Args>(As)...);}
};
template<class Fun> decltype(auto) y_comb(Fun &&fun) { return Y_comb<decay_t<Fun>>(forward<Fun>(fun));}
struct fast_ios { 
    fast_ios(){ cin.tie(nullptr), ios::sync_with_stdio(false), cout << fixed << setprecision(10);};
} fast_ios_;
constexpr char nl = '\n';
constexpr int inf = 1'061'109'567;
constexpr ll infll = 2'000'000'000'000'000'000;
constexpr int N = 2e5 + 5;
int n, m, k;

ll inverse(ll a, ll m) { 
    a %= m; if (a == 0) return 0; if (a < 0) a += m;
    ll u = 0, v = 1;
    while (a) { ll t = m / a;  m -= t * a; swap(a, m); u -= t * v; swap(u, v); }
    return u;
}
template <int m, bool is_prime = true>
struct static_mod {
    using mint = static_mod;
    static constexpr int mod() { return m; }
    static_mod() : _v(0) {}
    template <class T> static_mod(T v) {ll x = (ll)(v % (ll)(umod())); if (x < 0) x += umod(); _v = (unsigned int)(x);}
    static_mod(unsigned int v) { _v = (unsigned int)(v % umod());}
    unsigned int val() const { return _v; }
    mint& operator++() { _v++; if (_v == umod()) _v = 0; return *this;}
    mint& operator--() { if (_v == 0) _v = umod(); _v--; return *this;}
    mint operator++(int) { mint result = *this; ++*this; return result;}
    mint operator--(int) { mint result = *this; --*this; return result;}
    mint& operator+=(const mint& rhs) { _v += rhs._v; if (_v >= umod()) _v -= umod();return *this;}
    mint& operator-=(const mint& rhs) { _v -= rhs._v; if (_v >= umod()) _v += umod();return *this;}
    mint& operator*=(const mint& rhs) { unsigned long long z = _v; z *= rhs._v; _v = (unsigned int)(z % umod()); return *this;}
    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }
    mint operator+() const { return *this; }
    mint operator-() const { return mint() - *this; }
    mint pow(ll n) const {mint x = *this, r = 1; while (n) { if (n & 1) r *= x; x *= x;n >>= 1;} return r;}
    mint inv() const { if(is_prime) {assert(_v);return pow(umod() - 2);} return inverse(_v, m);}
    friend mint operator+(const mint& lhs, const mint& rhs) { return mint(lhs) += rhs;}
    friend mint operator-(const mint& lhs, const mint& rhs) { return mint(lhs) -= rhs;}
    friend mint operator*(const mint& lhs, const mint& rhs) { return mint(lhs) *= rhs;}
    friend mint operator/(const mint& lhs, const mint& rhs) { return mint(lhs) /= rhs;}
    friend bool operator==(const mint& lhs, const mint& rhs) { return lhs._v == rhs._v;}
    friend bool operator!=(const mint& lhs, const mint& rhs) { return lhs._v != rhs._v;}
    friend ostream& operator << (ostream& out, const mint& n) { return out << n.val(); }
    friend istream& operator >> (istream& in, mint& n) { ll x; in >> x; n = mint(x); return in; }
private:
    unsigned int _v;
    static constexpr unsigned int umod() { return m; }
};
using mint = static_mod<1000000007>; // 1000000007

struct Comb {
    vector<mint> fac, inv;
    vector<vector<mint>> s1, s2;
    Comb() : fac(1, 1), inv(1, 1){}
    void reserve(int a){
        if(fac.size() >= a) return;
        if(a < fac.size() * 2) a = fac.size() * 2;
        while(fac.size() < a) fac.push_back(fac.back() * mint(fac.size()));
        inv.resize(fac.size());
        inv.back() = fac.back().inv();
        for(int i = inv.size() - 1; inv[i - 1] == 0; i--) inv[i - 1] = inv[i] * i;
    }
    mint fact(int n){ if(n < 0) return 0; reserve(n + 1); return fac[n]; }
    mint invfac(int n) {if(n < 0) return 0; reserve(n + 1); return inv[n]; }
    mint P(int n, int r){ // 排列数
        if(r < 0 || n < r) return 0;
        if(n >> 24){ mint ans = 1; for(int i = 0; i < r; i++) ans *= n--; return ans; }
        reserve(n + 1); return fac[n] * inv[n - r];
    }
    mint Q(int n) {reserve(n); return fac[n - 1];} // n个元素的圆排列数
    mint C(int n, int m) { // 组合数
        if (n < m || m < 0) return 0;
        reserve(n + 1);
        return fac[n] * inv[m] * inv[n - m];
    }
    mint MC(int n, int m) { // r个相同物品放到n个篮子方案数
        return C(n + m - 1, n - 1);
    }
    mint catalan(int n) {
        reserve(n * 2 + 1); return fac[n * 2] * inv[n] * inv[n + 1];
    }
    mint CQ(int n, int m) {  // n个元素中选m个元素围成一圈的圆排列数。
        return C(n, m) * Q(m);
    }
    mint D(int n) { // 1-n的排列p的错位排列数  D[n]=(n-1)*(D[n-1]+D[n-2])
        if (n <= 3) return mint(n - 1);
        mint x = 1, y = 2, ans;
        for (int i = 4; i <= n; ++i) {
            ans = (i - 1) * (x + y);
            x = y, y = ans;
        }
        return ans;
    }
    mint stl1(int n, int m) { //n个不同元素，划分为m个非空圆排列的方案数(第一类斯特林数)
        if (s1.size() == 0) {
            int N = 10, M = 5;  // 根据题目数据范围调整
            s1.assign(N, vector<mint>(M));
            s1[0][0] = 1;
            for (int i = 1; i < N; ++i) for (int j = 1; j < M; ++j) {
                s1[i][j] = s1[i - 1][j - 1] + (i - 1) * s1[i - 1][j];
            }
        }
        return s1[n][m];
    }
    mint stl2(int n, int m) {// n个不同元素，划分为m个非空子集的方案数(第二类斯特林数)
        if (s2.size() == 0) {
            int N = 10, M = 5;  // 根据题目数据范围调整
            s2.assign(N, vector<mint>(M));
            s2[0][0] = 1;
            for (int i = 1; i < N; ++i) for (int j = 1; j < M; ++j) {
                s2[i][j] = s2[i - 1][j - 1] + j * s2[i - 1][j];
            }
        }
        return s2[n][m];
    }
} comb;

void sub(string &s){
	int n=sz(s);
	for(int j=n-1;j>=0;--j){
		if(s[j]=='1'){
			s[j]='0';
			for(int i=j+1;i<n;++i){
				s[i]='1';
			}
			break;
		}
	}
	rev(s);
	while(s.back()=='0')s.pop_back();
	rev(s);
}

class Solution {
public:
    int countKReducibleNumbers(string s, int K) {
    	if(s==""1"") return 0;
    	sub(s);
    	n=sz(s);
    	int c1=count(all(s),'1');
    	vector<mint> f(n+1);
        f[1]=0;
        for(int i=2;i<=n;++i){
        	f[i]=f[pct(i)]+1;
        }
        auto calk = [&](int k){
	        mint c=0;
	        int e=0;
	        f0(n){
	        	if(s[i]=='0')continue;
	        	int l=max(e,1);
	        	for(int j=l;j<=n;++j){
	        		if(f[j]==k-1){
	        			c+=comb.C(n-i-1,j-e);
	        			if(i==0&&k==1)c--;
	        		}
	        	}
	        	e++;
	        }
	        if(f[c1]==k-1)c++;
	        return c;
        };
        mint c=1;
        for(int k=1;k<=K;++k)
        	c+=calk(k);
        return c.val();
    }
};

#ifdef sigma-yyf
int main(){
    vector<int> v,a,b;
    string s,t;
    vector<string> sv;
    vector<vector<int>> vv;
    // ListNode* head = nullptr, *l1,*l2;
    // TreeNode* root = nullptr,*p,*q;
    // Solution so;
    // rd(a,k);
    // auto ans = so.;
    // wt(ans);
    cout<<'\n';
    return 0;
}
#endif
",1448259271
lccfatc,lccfatc,146,3646,cpp,"#ifdef sigma-yyf
#include ""/Users/yangyf/Desktop/cpcode/leetcode/lc_help.hpp""
#endif
using namespace std;

using ll = long long;
#define ar(x) array<int,x> 
#define all(c) (c).begin(), (c).end()
#define rall(x) (x).rbegin(), (x).rend() 
#define sz(x) (int)(x).size()
#define f0(e) for(int i = 0; i < (e); ++i)
#define f1(e) for(int i = 1; i <= (e); ++i)
#define f2(i,e) for(int i = 0; i < (e); ++i)
#define f3(i,a,b) for (int i=(a);i<(b);i++)
#define r3(i,b,a) for (int i=(b)-1;i>=(a);i--)
#define Sm(a) accumulate((a).begin(), (a).end() , 0ll)
#define Mn(a) (*min_element((a).begin(), (a).end()))
#define Mx(a) (*max_element((a).begin(), (a).end()))
#define rev(a) reverse((a).begin(), (a).end())
#define each(x,a) for(auto& x : a)
mt19937 mrand(random_device{}()); 
int rng(int x) { return mrand() % x;}
int pct(long long x) {return __builtin_popcountll(x);} 
int lg(int x) {return x == 0 ? -1 : 31 - __builtin_clz(x);}
int clg(int x) {return x <= 1 ? 0 : 32 - __builtin_clz(x - 1);}
template<class t,class u> bool cmx(t &a, const u &b){return a < b ? a = b, 1 : 0;}
template<class t,class u> bool cmn(t &a, const u &b){return b < a ? a = b, 1 : 0;}
template <class T> T f_div(const T x, const T y) { T q = x / y, r = x % y; return q - ((x ^ y) < 0 and (r != 0));}
template <class T> T c_div(const T x, const T y) { T q = x / y, r = x % y; return q + ((x ^ y) > 0 and (r != 0));}
template <class T> int lb(const vector<T> &v, const T &x) { return distance(begin(v), lower_bound(begin(v), end(v), x));}
template <class T> int rb(const vector<T> &v, const T &x) { return distance(begin(v), upper_bound(begin(v), end(v), x));}
template<class T,class A> void psum(vector<T>& s, const vector<A>&a){
    int n=a.size();s.resize(n+1);s[0]=0;for(int i=0;i<n;++i)s[i+1]=s[i]+a[i];  
};
template<typename T, typename F> T b_search(T l, T r, bool fst, F &&f) {
    T c = fst ? r : l;
    while(l<=r){T md=(l+r)/2;if(f(md)){c=md; fst?(r=md-1):(l=md+1);} else fst?(l=md+1):(r=md-1);}
    return c;
}
template <typename T, typename U> // pair
ostream& operator<<(ostream& out, const pair<T, U>& a) {return out << a.first << ' ' << a.second;}
template <typename T>  // vector
ostream& operator<<(ostream& out, const vector<T>& a) {for(int i=0,n=a.size(); i<n; ++i) out<<a[i]<<"" \n""[i==n-1]; return out;}
template <typename T, size_t N> // array
ostream& operator<<(ostream& out, const array<T, N>& a) {for(int i=0;i<N;++i)cout<<a[i]<<"" \n""[i==N-1];return out;}
template <typename T, typename U> // pair
istream& operator>>(istream& in, pair<T, U>& a) {return in >> a.first >> a.second;}
template <typename T> // vector
istream& operator>>(istream& in, vector<T>& a) {for (auto &x: a) in >> x; return in;}
template <typename T, size_t N> // array
istream& operator>>(istream& in, array<T, N>& a) {for (int i=0;i<N;++i) in >> a[i]; return in;}
template<class T> void rd(T& x) {cin >> x;}
template<class H, class... T> void rd(H& h, T&... t) {rd(h); rd(t...);}
template<class A> void wt(A x) { cout << x;}
template<class H, class... T> void wt(const H& h, const T&... t) { wt(h); wt(t...);}
bool is_vo(char c){return c=='a' || c=='e' || c=='i' || c=='o' || c=='u';}
int s2t(string &s){return s[0]*600 + s[1]*60 + s[3]*10 + s[4] - 32208;} //s: ""HH:MM"" 
#ifdef sigma-yyf
#define dbg(...) debug_impl(#__VA_ARGS__, __VA_ARGS__)
template <class H, class... Ts> void debug_impl(const char* s, const H& h, const Ts&... t) {
    cerr << s << "": "" << h, ((cerr << "", "" << t), ..., (cerr << ""\n""));
}
#else
#define dbg(...) void(0)
#endif
template<class Fun> class Y_comb {
    Fun _f;
public:
    template<class T> explicit Y_comb(T &&fun): _f(forward<T>(fun)) {}
    template<class ...Args> decltype(auto) operator()(Args &&...As) {return _f(ref(*this), forward<Args>(As)...);}
};
template<class Fun> decltype(auto) y_comb(Fun &&fun) { return Y_comb<decay_t<Fun>>(forward<Fun>(fun));}
struct fast_ios { 
    fast_ios(){ cin.tie(nullptr), ios::sync_with_stdio(false), cout << fixed << setprecision(10);};
} fast_ios_;
constexpr char nl = '\n';
constexpr int inf = 1'061'109'567;
constexpr ll infll = 2'000'000'000'000'000'000;
constexpr int N = 2e5 + 5;
int n, m, k;

ll inverse(ll a, ll m) { 
    a %= m; if (a == 0) return 0; if (a < 0) a += m;
    ll u = 0, v = 1;
    while (a) { ll t = m / a;  m -= t * a; swap(a, m); u -= t * v; swap(u, v); }
    return u;
}
template <int m, bool is_prime = true>
struct static_mod {
    using mint = static_mod;
    static constexpr int mod() { return m; }
    static_mod() : _v(0) {}
    template <class T> static_mod(T v) {ll x = (ll)(v % (ll)(umod())); if (x < 0) x += umod(); _v = (unsigned int)(x);}
    static_mod(unsigned int v) { _v = (unsigned int)(v % umod());}
    unsigned int val() const { return _v; }
    mint& operator++() { _v++; if (_v == umod()) _v = 0; return *this;}
    mint& operator--() { if (_v == 0) _v = umod(); _v--; return *this;}
    mint operator++(int) { mint result = *this; ++*this; return result;}
    mint operator--(int) { mint result = *this; --*this; return result;}
    mint& operator+=(const mint& rhs) { _v += rhs._v; if (_v >= umod()) _v -= umod();return *this;}
    mint& operator-=(const mint& rhs) { _v -= rhs._v; if (_v >= umod()) _v += umod();return *this;}
    mint& operator*=(const mint& rhs) { unsigned long long z = _v; z *= rhs._v; _v = (unsigned int)(z % umod()); return *this;}
    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }
    mint operator+() const { return *this; }
    mint operator-() const { return mint() - *this; }
    mint pow(ll n) const {mint x = *this, r = 1; while (n) { if (n & 1) r *= x; x *= x;n >>= 1;} return r;}
    mint inv() const { if(is_prime) {assert(_v);return pow(umod() - 2);} return inverse(_v, m);}
    friend mint operator+(const mint& lhs, const mint& rhs) { return mint(lhs) += rhs;}
    friend mint operator-(const mint& lhs, const mint& rhs) { return mint(lhs) -= rhs;}
    friend mint operator*(const mint& lhs, const mint& rhs) { return mint(lhs) *= rhs;}
    friend mint operator/(const mint& lhs, const mint& rhs) { return mint(lhs) /= rhs;}
    friend bool operator==(const mint& lhs, const mint& rhs) { return lhs._v == rhs._v;}
    friend bool operator!=(const mint& lhs, const mint& rhs) { return lhs._v != rhs._v;}
    friend ostream& operator << (ostream& out, const mint& n) { return out << n.val(); }
    friend istream& operator >> (istream& in, mint& n) { ll x; in >> x; n = mint(x); return in; }
private:
    unsigned int _v;
    static constexpr unsigned int umod() { return m; }
};
using mint = static_mod<1000000007>; // 1000000007


class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& a) {
        n=sz(a);
        vector<mint> f(n);
        f[0]=1;
        vector<mint> g(n);
        map<int,mint> mp;
        mp[a[0]]=1;
        g[0]=a[0];
        map<int,mint> m1;
        m1[a[0]]=a[0];
        for(int i=1;i<n;++i){
        	mint c=1,s=a[i];
        	if(mp.count(a[i]-1)){
        		c+=mp[a[i]-1];
        		s+=mp[a[i]-1]*a[i]+m1[a[i]-1];
        	}
        	if(mp.count(a[i]+1)){
        		c+=mp[a[i]+1];
        		s+=mp[a[i]+1]*a[i]+m1[a[i]+1];
        	}
        	f[i]=c;
        	g[i]=s;
        	mp[a[i]]+=c;
        	m1[a[i]]+=s;
        }
        mint c=0;
        f0(n)c+=g[i];
        return c.val();
    }
};

#ifdef sigma-yyf
int main(){
    vector<int> v,a,b;
    string s,t;
    vector<string> sv;
    vector<vector<int>> vv;
    // ListNode* head = nullptr, *l1,*l2;
    // TreeNode* root = nullptr,*p,*q;
    // Solution so;
    // rd(a,k);
    // auto ans = so.;
    // wt(ans);
    cout<<'\n';
    return 0;
}
#endif
",1448259521
Huzaifa Khilawala,RedHeadphone,147,3612,python3,"
class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)

        incre = [0] * n
        for i in range(1,n):
            if nums[i] > nums[i-1]:
                incre[i] = 1
        
        incre_preffix = list(itertools.accumulate(incre))

        def incresi(l,r):
            return incre_preffix[r-1] - incre_preffix[l] == (r-l-1)

        def check(k):  
            for i in range(n-2*k+1):
                if incresi(i,i+k) and incresi(i+k,i+2*k):
                    return True
            return False

        return check(k)",1448199406
Huzaifa Khilawala,RedHeadphone,147,3619,python3,"
def binary_search(left, right, check, start_from_left):
    if start_from_left:
        ans = left
    else:
        ans = right
    while left <= right:
        mid = (left + right) // 2
        if start_from_left:
            if check(mid):
                ans, left = mid, mid + 1
            else:
                right = mid - 1
        else:
            if check(mid):
                ans, right = mid, mid - 1
            else:
                left = mid + 1
    return ans

class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)

        incre = [0] * n
        for i in range(1,n):
            if nums[i] > nums[i-1]:
                incre[i] = 1
        
        incre_preffix = list(itertools.accumulate(incre))

        def incresi(l,r):
            return incre_preffix[r-1] - incre_preffix[l] == (r-l-1)

        def check(k):  
            for i in range(n-2*k+1):
                if incresi(i,i+k) and incresi(i+k,i+2*k):
                    return True
            return False


        ans = binary_search(1,n//2,check,True)
        return ans",1448198259
Huzaifa Khilawala,RedHeadphone,147,3631,python3,"
MOD = 10**9 + 7

class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        n = len(s)

        precom = [0]*(n+1)
        precom[0] = -1
        for i in range(2,n+1):
            set_c = bin(i).count(""1"")
            precom[i] = 1+precom[set_c]
            

        @cache
        def dp(i,set_c,touching):
            if i == n:
                if touching==1:
                    return 0
                else:
                    return 1 if (precom[set_c]<k and set_c!=0) else 0

            if touching==1:
                if s[i]=='1':
                    return (dp(i+1,set_c+1,1)+dp(i+1,set_c,0))%MOD
                else:
                    return dp(i+1,set_c,1)%MOD
            else:
                return (dp(i+1,set_c,0)+dp(i+1,set_c+1,0))%MOD

        ans = dp(0,0,1)

        return ans",1448260387
Huzaifa Khilawala,RedHeadphone,147,3646,python3,"
MOD = 10**9 + 7

class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        n = len(nums)
        mapp = {}
        ans = 0
        for i in range(n-1,-1,-1):
            temps = 0
            tempc = 1
            if nums[i]+1 in mapp:
                temps += mapp[nums[i]+1][0]
                tempc += mapp[nums[i]+1][1]
            if nums[i]-1 in mapp:
                temps += mapp[nums[i]-1][0]
                tempc += mapp[nums[i]-1][1]
            
            tempc %= MOD
            temps += tempc*nums[i]
            temps %= MOD

            ans+=temps
            ans%=MOD

            if nums[i] not in mapp:
                mapp[nums[i]] = [temps,tempc]
            else:
                mapp[nums[i]][0]+=temps
                mapp[nums[i]][0] %= MOD
                mapp[nums[i]][1]+=tempc
                mapp[nums[i]][1] %= MOD
            
        return ans

",1448216920
Muhammad Hasan,mhasan01,148,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& a, int k) {
        int n = (int) a.size();
        for (int i = 0; i < n; i++) {
            int x = i + k - 1;
            int y = i + 2 * k - 1;
            if (y >= n) {
                break;
            }
            bool ok = true;
            for (int j = i + 1; j <= x; j++) {
                if (a[j - 1] >= a[j]) {
                    ok = false;
                    break;
                }
            }
            for (int j = x + 2; j <= y; j++) {
                if (a[j - 1] >= a[j]) {
                    ok = false;
                    break;
                }
            }
            if (ok) {
                return ok;
            }
        }
        return false;
    }
};",1448257333
Muhammad Hasan,mhasan01,148,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& a) {
        int n = (int) a.size();
        vector<int> pre(n - 1);
        for (int i = 0; i + 1 < n; i++) {
            pre[i] = (a[i] >= a[i + 1]);
            if (i > 0) {
                pre[i] += pre[i - 1];
            }
        }
        
        auto can = [&](int k) {
            for (int i = 0; i < n; i++) {
                int x = i + k - 1;
                int y = i + 2 * k - 1;
                if (y >= n) {
                    break;
                }
                if (pre[x - 1] - (i > 0 ? pre[i - 1] : 0) > 0) {
                    continue;
                }
                if (pre[y - 1] - pre[x] > 0) {
                    continue;
                }
                return true;
            }
            return false;
        };
        
        int l = 2, r = n, ans = 1;
        while (l <= r) {
            int mid = (l + r) >> 1;
            if (can(mid)) {
                l = mid + 1;
                ans = mid;
            } else {
                r = mid - 1;
            }
        }
        return ans;
    }
};",1448260771
Muhammad Hasan,mhasan01,148,3631,cpp,"struct mint {
    const int MOD = 1e9 + 7;
    int x;

    mint(int _x) : x((_x % MOD + MOD) % MOD) {}
    mint(long long _x) : x((_x % MOD + MOD) % MOD) {}

    mint() : x(0) {}

    mint &operator=(const mint &rhs) {
        x = rhs.x;
        return *this;
    }

    mint pow(long long n) const {
        assert(0 <= n);
        mint x = *this, r = mint(1);
        while (n)
        {
            if (n & 1)
                r *= x;
            x *= x;
            n >>= 1;
        }
        return r;
    }

    mint inv() const {
        return pow(MOD - 2);
    }

    mint &operator+=(const mint &rhs) {
        x += rhs.x;
        if (x >= MOD)
            x -= MOD;
        return *this;
    }

    mint &operator-=(const mint &rhs) {
        x -= rhs.x;
        if (x < 0)
            x += MOD;
        return *this;
    }

    mint &operator*=(const mint &rhs) {
        unsigned long long z = x;
        z *= rhs.x;
        x = (unsigned int)(z % MOD);
        return *this;
    }

    mint &operator/=(const mint &rhs) {
        return *this = *this * rhs.inv();
    }

    friend mint operator+(const mint &lhs, const mint &rhs) {
        return mint(lhs) += rhs;
    }

    friend mint operator-(const mint &lhs, const mint &rhs) {
        return mint(lhs) -= rhs;
    }

    friend mint operator*(const mint &lhs, const mint &rhs) {
        return mint(lhs) *= rhs;
    }

    friend mint operator/(const mint &lhs, const mint &rhs) {
        return mint(lhs) /= rhs;
    }

    friend ostream& operator<<(ostream &os, const mint &m) {
        return os << m.x;
    }
};

const int N = 805;
const int K = 5;

vector<int> cnts[K + 5];
bool done = false;
mint dp[2][2][N];

class Solution {
public:
    int get(int x) {
        int cnt = 0;
        for (int i = 15; i >= 0; i--) {
            if (x & (1 << i)) {
                cnt++;
            }
        }
        x = cnt;
        return x;
    }
    
    int countKReducibleNumbers(string s, int kk) {
        if (!done) {
            for (int i = 1; i < N; i++) {
                int x = i;
                for (int j = 1; j <= K; j++) {
                    if (x == 1) {
                        cnts[j].emplace_back(i);
                    }
                    x = get(x);
                }
            }
            done = true;
        }
        int n = (int) s.length();
        for (int i = 0; i < 2; i++) {
            for (int j = 0; j < 2; j++) {
                for (int k = 0; k < N; k++) {
                    dp[i][j][k] = 0;
                }
            }
        }
        dp[0][0][1] = 1;
        dp[0][1][0] = 1;
        for (int i = 1; i < n; i++) {
            int cur = (i & 1);
            int bef = 1 - cur;
            for (int j = 0; j < 2; j++) {
                for (int k = 0; k < N; k++) {
                    dp[cur][j][k] = 0;
                }
            }
            for (int k = 0; k < N; k++) {
                if (s[i] == '1') {
                    dp[cur][1][k] += dp[bef][0][k];
                    if (k + 1 < N) {
                        dp[cur][0][k + 1] += dp[bef][0][k];
                    }
                } else {
                    dp[cur][0][k] += dp[bef][0][k];
                }
                dp[cur][1][k] += dp[bef][1][k];
                if (k + 1 < N) {
                    dp[cur][1][k + 1] += dp[bef][1][k];
                }
            }
        }
        int cur = (n - 1) & 1;
        mint ans = 0;
        for (int x : cnts[kk]) {
            ans += dp[cur][1][x];
        }
        return ans.x;
    }
};",1448255575
Muhammad Hasan,mhasan01,148,3646,cpp,"struct mint {
    const int MOD = 1e9 + 7;
    int x;

    mint(int _x) : x((_x % MOD + MOD) % MOD) {}
    mint(long long _x) : x((_x % MOD + MOD) % MOD) {}

    mint() : x(0) {}

    mint &operator=(const mint &rhs) {
        x = rhs.x;
        return *this;
    }

    mint pow(long long n) const {
        assert(0 <= n);
        mint x = *this, r = mint(1);
        while (n)
        {
            if (n & 1)
                r *= x;
            x *= x;
            n >>= 1;
        }
        return r;
    }

    mint inv() const {
        return pow(MOD - 2);
    }

    mint &operator+=(const mint &rhs) {
        x += rhs.x;
        if (x >= MOD)
            x -= MOD;
        return *this;
    }

    mint &operator-=(const mint &rhs) {
        x -= rhs.x;
        if (x < 0)
            x += MOD;
        return *this;
    }

    mint &operator*=(const mint &rhs) {
        unsigned long long z = x;
        z *= rhs.x;
        x = (unsigned int)(z % MOD);
        return *this;
    }

    mint &operator/=(const mint &rhs) {
        return *this = *this * rhs.inv();
    }

    friend mint operator+(const mint &lhs, const mint &rhs) {
        return mint(lhs) += rhs;
    }

    friend mint operator-(const mint &lhs, const mint &rhs) {
        return mint(lhs) -= rhs;
    }

    friend mint operator*(const mint &lhs, const mint &rhs) {
        return mint(lhs) *= rhs;
    }

    friend mint operator/(const mint &lhs, const mint &rhs) {
        return mint(lhs) /= rhs;
    }

    friend ostream& operator<<(ostream &os, const mint &m) {
        return os << m.x;
    }
};

const int N = 1e5 + 5;

mint dp[N];
mint ways[N];

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& a) {
        mint ans = 0;
        for (int x : a) {
            mint cur = 1;
            mint sum = 0;
            for (int y : {x - 1, x + 1}) {
                if (y < 0) {
                    continue;
                }
                cur += ways[y];
                sum += dp[y];
            }
            sum += cur * x;
            dp[x] += sum;
            ways[x] += cur;
            ans += sum;
        }
        for (int x : a) {
            dp[x] = 0;
            ways[x] = 0;
        }
        return ans.x;
    }
};",1448256381
haohao,cchao,150,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& a, int k) {
        const int n = a.size();
        vector<bool> b(n - k + 1);
        for (int i = 0; i < n - k + 1; ++i) {
            b[i] = true;
            for (int j = 0; j < k - 1; ++j) {
                if (a[i + j] >= a[i + j + 1]) {
                    b[i] = false;
                    break;
                }
            }
            if (b[i] && i >= k && b[i - k]) return true;
        }
        return false;
    }
};",1448186868
haohao,cchao,150,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        const int n = nums.size();
        vector<int> to_left(n), to_right(n);
        for (int i = 0, tmp = 0; i < n; ++i) {
            if (i && nums[i] > nums[i - 1]) {
                ++tmp;
            } else {
                tmp = 1;
            }
            to_left[i] = tmp;
        }
        for (int i = n - 1, tmp = 0; i >= 0; --i) {
            if (i + 1 < n && nums[i] < nums[i + 1]) {
                ++tmp;
            } else {
                tmp = 1;
            }
            to_right[i] = tmp;
        }
        int ans = 0;
        for (int i = 0; i + 1 < n; ++i) {
            ans = max(ans, min(to_left[i], to_right[i + 1]));
        }
        return ans;
    }
};",1448196465
haohao,cchao,150,3631,cpp,"vector<int> d(1010);
int f[801][801][2];
void init() {
  if (d[0] > 0) return;
  d[0] = INT_MAX;
  for (uint32_t i = 2; i < d.size(); ++i) {
    d[i] = d[std::popcount(i)] + 1;
  }
}

constexpr int64_t mod = 1e9 + 7;
class Solution {
  string s;
  int k;
  int dfs(int x, int cnt, bool small) {
    if (x == s.size()) {
      return small && d[cnt] <= k;
    }
    if (f[x][cnt][small] >= 0) {
      return f[x][cnt][small];
    }
    int64_t ans = 0;
    const int digit = s[x] - '0';
    ans += dfs(x + 1, cnt, small || 0 < digit);
    if (small || digit == 1) ans += dfs(x + 1, cnt + 1, small);
    return f[x][cnt][small] = ans % mod;
  }

 public:
  int countKReducibleNumbers(string s, int k) {
    memset(f, -1, sizeof f);
    init();
    this->s = s;
    this->k = k - 1;
    return dfs(0, 0, 0);
  }
};
",1448253529
haohao,cchao,150,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        constexpr long long mod = 1e9 + 7;
        unordered_map<long long, long long> sum;
        unordered_map<long long, long long> cnt;

        for (int x : nums) {
            const vector<int> b = {x - 1, x + 1};
            cnt[x] += 1;
            sum[x] += x;
            for (int y : b) {
                if (!cnt.count(y)) continue;
                cnt[x] += cnt[y];
                sum[x] += sum[y] + cnt[y] * x;
                cnt[x] %= mod;
                sum[x] %= mod;
            }
        }
        long long ans = 0;
        for (auto it : sum) ans += it.second;
        return ans % mod;
    }
};",1448208972
Tin,tin_le,151,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& a, int k) {
        int n = a.size();
        vector<int> rightMost(n);
        iota(begin(rightMost), end(rightMost), 0);
        for(int i = n - 2; i >= 0; i--) {
            if(a[i] < a[i + 1]) rightMost[i] = rightMost[i + 1]; 
        }
        int res = 0;
        for(int i = 0; i < n; i++) {
            int r = rightMost[i];
            res = max(res, (r - i + 1) / 2);
            if(r + 1 < n) {
                int f = r - i + 1;
                int g = rightMost[r + 1] - r;
                if(g >= f) {
                    res = max(res, f);
                }
            }
        }
        return res >= k;
    }
};",1448192841
Tin,tin_le,151,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& a) {
        int n = a.size();
        vector<int> rightMost(n);
        iota(begin(rightMost), end(rightMost), 0);
        for(int i = n - 2; i >= 0; i--) {
            if(a[i] < a[i + 1]) rightMost[i] = rightMost[i + 1]; 
        }
        int res = 0;
        for(int i = 0; i < n; i++) {
            int r = rightMost[i];
            res = max(res, (r - i + 1) / 2);
            if(r + 1 < n) {
                int f = r - i + 1;
                int g = rightMost[r + 1] - r;
                if(g >= f) {
                    res = max(res, f);
                }
            }
        }
        return res;
        
    }
};",1448191366
Tin,tin_le,151,3631,cpp,"#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef vector<int> vi;

const int MOD = 1e9 + 7;

class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        int n = s.size();        
        vi cnt(n + 1, 0);
        for(int i = 2; i <= n; i++) {
            int p = __builtin_popcount(i);
            cnt[i] = cnt[p] + 1;
        }
        vector<vector<vector<ll>>> dp(n, vector<vector<ll>>(n + 1, vector<ll>(2, -1)));
        auto dfs = [&](auto& dfs_ref, int pos = 0, int count = 0, bool tight = true) -> ll {
            if(pos == n) {
                return !tight && count && cnt[count] <= k - 1;
            }
            int tight_val = tight ? 1 : 0;
            if(dp[pos][count][tight_val] != -1) return dp[pos][count][tight_val];

            ll res = 0;
            int max_bit = tight ? (s[pos] - '0') : 1;
            for(int b = 0; b <= max_bit; b++) {
                bool next_tight = tight && (b == max_bit);
                res = (res + dfs_ref(dfs_ref, pos + 1, count + b, tight && b == max_bit)) % MOD;
            }
            dp[pos][count][tight_val] = res;
            return res;
        };
        return dfs(dfs);
    }
};
",1448253580
Tin,tin_le,151,3646,cpp,"//████████╗██╗███╗░░██╗  ██╗░░░░░███████╗
//╚══██╔══╝██║████╗░██║  ██║░░░░░██╔════╝
//░░░██║░░░██║██╔██╗██║  ██║░░░░░█████╗░░
//░░░██║░░░██║██║╚████║  ██║░░░░░██╔══╝░░
//░░░██║░░░██║██║░╚███║  ███████╗███████╗
//░░░╚═╝░░░╚═╝╚═╝░░╚══╝  ╚══════╝╚══════╝
//   __________________
//  | ________________ |
//  ||          ____  ||
//  ||   /\    |      ||
//  ||  /__\   |      ||
//  || /    \  |____  ||
//  ||________________||
//  |__________________|
//  \###################\
//   \###################\
//    \        ____       \
//     \_______\___\_______\
// An AC a day keeps the doctor away.

#pragma GCC optimize(""Ofast"")
#pragma GCC optimize (""unroll-loops"")
#pragma GCC target(""popcnt"")
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;
using namespace std;
template<class T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
#define vt vector
#define all(x) begin(x), end(x)
#define allr(x) rbegin(x), rend(x)
#define ub upper_bound
#define lb lower_bound
#define db double
#define ld long db
#define ll long long
#define pll pair<ll, ll>    
#define vll vt<ll>  
#define vpll vt<pll>
#define vvpll vt<vpll>
#define vvvll vt<vvll>
#define vi vector<int>
#define pii pair<int, int>
#define vpii vector<pair<int, int>>
#define vs vector<string>
#define vb vector<bool>
#define vvpii vector<vpii>
#define vvi vector<vi>
#define vd vector<db>
#define ar(x) array<int, x>
#define var(x) vector<ar(x)>
#define pq priority_queue
#define mset(m, v) memset(m, v, sizeof(m))
#define pb push_back
#define ff first
#define ss second
#define sv string_view
#define MP make_pair
#define MT make_tuple
#define rsz resize
#define sum(x) accumulate(all(x), 0LL)
#define srt(x) sort(all(x))
#define srtR(x) sort(allr(x))
#define srtU(x) sort(all(x)), (x).erase(unique(all(x)), (x).end())
#define rev(x) reverse(all(x))
#define gcd(a, b) __gcd(a, b)
#define lcm(a, b) (a * b) / gcd(a, b)
#define MAX(a) *max_element(all(a)) 
#define MIN(a) *min_element(all(a))

//SGT DEFINE
#define lc i * 2 + 1
#define rc i * 2 + 2
#define lp lc, left, middle
#define rp rc, middle + 1, right
#define entireTree 0, 0, n - 1
#define midPoint left + (right - left) / 2
#define pushDown push(i, left, right)
#define iterator int i, int left, int right

#define IOS ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0)

struct custom {
    static const uint64_t C = 0x9e3779b97f4a7c15; const uint32_t RANDOM = std::chrono::steady_clock::now().time_since_epoch().count();
    size_t operator()(uint64_t x) const { return __builtin_bswap64((x ^ RANDOM) * C); }
    size_t operator()(const std::string& s) const { size_t hash = std::hash<std::string>{}(s); return hash ^ RANDOM; } };
template <class K, class V> using umap = std::unordered_map<K, V, custom>; template <class K> using uset = std::unordered_set<K, custom>;
    
 
template<typename T> vt<T> uniqued(vt<T> arr) {  srtU(arr); return arr; }

#ifdef LOCAL
#define debug(x...) debug_out(#x, x)
void debug_out(const char* names) { std::cerr << std::endl; }
template <typename T, typename... Args>
void debug_out(const char* names, T value, Args... args) {
    const char* comma = strchr(names, ',');
    std::cerr << ""["" << (comma ? std::string(names, comma) : names) << "" = "" << value << ""]"";
    if (sizeof...(args)) { std::cerr << "", ""; debug_out(comma + 1, args...); }   
    else { std::cerr << std::endl; }
}
#define startClock clock_t tStart = clock();
#define endClock std::cout << std::fixed << std::setprecision(10) << ""\nTime Taken: "" << (double)(clock() - tStart) / CLOCKS_PER_SEC << "" seconds"" << std::endl;
#else
#define debug(...)
#define startClock
#define endClock

#endif
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());

#define eps 1e-9
#define M_PI 3.14159265358979323846
const static ll INF = 1LL << 60;
const static int MK = 20;
const static int MX = 2e6 + 5;
const static int MOD = 1e9 + 7;
int pct(ll x) { return __builtin_popcountll(x); }
const vvi dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}, {1, 1}, {-1, -1}, {1, -1}, {-1, 1}}; // UP, DOWN, LEFT, RIGHT

const vpii dirs_3_3 = { 
        {0,1}, {0,3},
        {1,0}, {1,2}, {1,4},
        {2,1}, {2,5},
        {3,0}, {3,4}, {3,6},
        {4,1}, {4,3}, {4,5}, {4,7},
        {5,2}, {5,4}, {5,8},
        {6,3}, {6,7},
        {7,4}, {7,6}, {7,8},
        {8,5}, {8,7}
};

int modExpo(ll base, ll exp, ll mod) { ll res = 1; base %= mod; while(exp) { if(exp & 1) res = (res * base) % mod; base = (base * base) % mod; exp >>= 1; } return res; }
void multiply(int f[2][2], int m[2][2]) {   
    int res[2][2] = {}; 
    for(int i = 0; i < 2; i++)  {   for(int j = 0; j < 2; j++)  {   for(int k = 0; k < 2; k++)  {   res[i][j] = (res[i][j] + f[i][k] * m[k][j]) % MOD; }   }   }   
    for(int i = 0; i < 2; i++)  {   for(int j = 0; j < 2; j++) f[i][j] = res[i][j]; }   }
int fib(int n)  {       if(n == 0) return 0;        if(n == 1) return 1;    
    int f[2][2] = {{1, 1}, {1, 0}}; int res[2][2] = {{1, 0}, {0, 1}};       
    while(n)    {   if(n & 1) multiply(res, f); multiply(f, f); n >>= 1;    }   return res[0][1] % MOD; }   
vi primes, first_divisor(MX);  
bitset<MX> primeBits;
void generatePrime() {  primeBits.set(2);   
    for(int i = 3; i < MX; i += 2) primeBits.set(i);
    for(int i = 2; i * i < MX; i += (i == 2 ? 1 : 2)) {    
        if(primeBits[i]) {  
            for(int j = i; j * i < MX; j += 2) {    primeBits.reset(i * j); }
        }
    }
    for(int i = 2; i < MX; i++) {    
        if(primeBits[i]) {  
            for(int j = i; j < MX; j += i) {    if(first_divisor[j] == 0) first_divisor[j] = i; }
        }
    }
    for(int i = 0; i < MX; i++ ) {  if(primeBits[i]) {  primes.pb(i); } }   
}
class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& a) {
        int M = MAX(a);
        vll count(M + 1), sm(M + 1);
        ll res = 0;
        for(auto& x : a) {
            ll c1 = 0, s1 = 0, c2 = 0, s2 = 0;
            if(x) {
                c1 = count[x - 1];
                s1 = (sm[x - 1] + c1 * x) % MOD;
            }
            if(x + 1 <= M) {
                c2 = count[x + 1];
                s2 = (sm[x + 1] + c2 * x) % MOD;
            }
            ll c3 = (1 + c1 + c2) % MOD;
            ll s3 = ((ll)x + s1 + s2) % MOD;
            count[x] = (count[x] + c3) % MOD;
            sm[x] = (sm[x] + s3) % MOD;
            res = (res + s3) % MOD;
        }
        return res;
    }
};
",1448209199
Milind Gupta,milind0110,152,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        for(int i = 0; i + 2 * k <= n; i++){
            bool ok = true;
            for(int j = i + 1; j < i + k; j++){
                ok &= (nums[j] > nums[j - 1]);
            }
            for(int j = i + k + 1; j < i + 2 * k; j++){
                ok &= (nums[j] > nums[j - 1]);
            }
            if(ok) return true;
        }
        return false;
    }
};",1448215877
Milind Gupta,milind0110,152,3619,cpp,"
class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& a) {
        int n = a.size();
        vector<int> ans(n);
        for(int i = n - 2; i >= 0; i--){
            if(a[i] < a[i + 1]){
                ans[i] += ans[i + 1] + 1;
            }
        }
        int mx = 1;
        for(int i = 0; i < n; i++){
            mx = max(mx,(ans[i] + 1) / 2);
            if(i + ans[i] + 1 < n){
                mx = max(mx,min(ans[i],ans[i + ans[i] + 1]) + 1);
            }
        }
        return mx;
    }
};",1448254015
Milind Gupta,milind0110,152,3631,cpp,"const int N = 1000;
const int mod = 1e9 + 7;
using uint = unsigned int;
using ll = long long;
using ull = unsigned long long;
constexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }
template <class T> using V = vector<T>;
template <class T> using VV = V<V<T>>;

template <uint MD> struct ModInt {
    using M = ModInt;
    const static M G;
    uint v;
    ModInt(ll _v = 0) { set_v(_v % MD + MD); }
    M& set_v(uint _v) {
        v = (_v < MD) ? _v : _v - MD;
        return *this;
    }
    explicit operator bool() const { return v != 0; }
    M operator-() const { return M() - *this; }
    M operator+(const M& r) const { return M().set_v(v + r.v); }
    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }
    M operator*(const M& r) const { return M().set_v(ull(v) * r.v % MD); }
    M operator/(const M& r) const { return *this * r.inv(); }
    M& operator+=(const M& r) { return *this = *this + r; }
    M& operator-=(const M& r) { return *this = *this - r; }
    M& operator*=(const M& r) { return *this = *this * r; }
    M& operator/=(const M& r) { return *this = *this / r; }
    bool operator==(const M& r) const { return v == r.v; }
    M pow(ll n) const {
        M x = *this, r = 1;
        while (n) {
            if (n & 1) r *= x;
            x *= x;
            n >>= 1;
        }
        return r;
    }
    M inv() const { return pow(MD - 2); }
    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }
};
using Mint = ModInt<mod>;
template<> const Mint Mint::G = Mint(3);

// template <class Mint> void nft(bool type, V<Mint>& a) {
//     int n = int(a.size()), s = 0;
//     while ((1 << s) < n) s++;
//     assert(1 << s == n);

//     static V<Mint> ep, iep;
//     while (int(ep.size()) <= s) {
//         ep.push_back(Mint::G.pow(Mint(-1).v / (1 << ep.size())));
//         iep.push_back(ep.back().inv());
//     }
//     V<Mint> b(n);
//     for (int i = 1; i <= s; i++) {
//         int w = 1 << (s - i);
//         Mint base = type ? iep[i] : ep[i], now = 1;
//         for (int y = 0; y < n / 2; y += w) {
//             for (int x = 0; x < w; x++) {
//                 auto l = a[y << 1 | x];
//                 auto r = now * a[y << 1 | x | w];
//                 b[y | x] = l + r;
//                 b[y | x | n >> 1] = l - r;
//             }
//             now *= base;
//         }
//         swap(a, b);
//     }
// }

// template <class Mint> V<Mint> multiply(const V<Mint>& a, const V<Mint>& b) {
//     assert(false);
//     incase of cross-correlation reverse b and the answer will be at length of reversed array - the index for answer
//     int n = int(a.size()), m = int(b.size());
//     if (!n || !m) return {};
//     int lg = 0;
//     while ((1 << lg) < n + m - 1) lg++;
//     int z = 1 << lg;
//     auto a2 = a, b2 = b;
//     a2.resize(z);
//     b2.resize(z);
//     nft(false, a2);
//     nft(false, b2);
//     for (int i = 0; i < z; i++) a2[i] *= b2[i];
//     nft(true, a2);
//     a2.resize(n + m - 1);
//     Mint iz = Mint(z).inv();
//     for (int i = 0; i < n + m - 1; i++) a2[i] *= iz;
//     return a2;
// }

Mint fact[N];
Mint inv[N];
void precalc(){
    fact[0] = 1;
    for(int i = 1; i < N; i++){
        fact[i] = fact[i - 1];
        fact[i] *= i;
    }
    for(int i = 0; i < N; i++){
        inv[i] = 1;
        inv[i] /= fact[i];
    }
}
Mint ncrmodp(int n,int r){
    if(n < 0 || n < r)
        return 0;
    return fact[n]*inv[n-r]*inv[r];
}
class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        precalc();
        const int mx = 805;
        vector<int> val(mx);
        for(int i = 2; i < mx; i++){
            val[i] += val[__builtin_popcount(i)] + 1;
        }
        int n = s.length();
        Mint ans = 0;
        int cnt = 0;
        for(int i = 0; i < n; i++){
            if(s[i] == '0') continue;
            int len = n - i - 1;
            for(int j = 0; j <= len; j++){
                if((j + cnt) && val[j + cnt] < k){
                    ans += ncrmodp(len,j);
                }
            }
            cnt++;
        }
        return ans.v;
    }
};",1448238734
Milind Gupta,milind0110,152,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        map<int,int> dp;
        int n = nums.size();
        const int mod = 1e9 + 7;
        vector<int> ways(n),oways(n);
        long long ans = 0;
        for(int i = 0; i < n; i++){
            dp[nums[i]] += 1;
            ways[i]++;
            for(auto x : {-1,1}){
                int j = nums[i] + x;
                if(dp.count(j)){
                    dp[nums[i]] += dp[j];
                    ways[i] += dp[j];
                    if(ways[i] >= mod) ways[i] -= mod;
                    if(dp[nums[i]] >= mod) dp[nums[i]] -= mod;
                }
            }
        }
        dp.clear();
        for(int i = n - 1; i >= 0; i--){
            dp[nums[i]] += 1;
            oways[i]++;
            for(auto x : {-1,1}){
                int j = nums[i] + x;
                if(dp.count(j)){
                    dp[nums[i]] += dp[j];
                    oways[i] += dp[j];
                    if(oways[i] >= mod) oways[i] -= mod;
                    if(dp[nums[i]] >= mod) dp[nums[i]] -= mod;
                }
            }
        }
        for(int i = 0; i < n; i++){
            ans += (((1LL * ways[i] * oways[i]) % mod) * nums[i]) % mod;
            if(ans >= mod) ans -= mod;
        }
        return ans;
    }
};",1448205886
LeeetCode,user3517H,153,3612,python3,"class Solution:
  def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
    n = len(nums)
    l = [None] * n
    r = [None] * n
    l[0] = r[-1] = 1
    for i in range(1, n):
      l[i] = 1 if nums[i] <= nums[i - 1] else l[i - 1] + 1
    for i in reversed(range(n - 1)):
      r[i] = 1 if nums[i] >= nums[i + 1] else r[i + 1] + 1
    return any(min(l[i], r[i + 1]) >= k for i in range(n - 1))
        ",1448185382
LeeetCode,user3517H,153,3619,python3,"class Solution:
  def maxIncreasingSubarrays(self, nums: List[int]) -> int:
    n = len(nums)
    l = [None] * n
    r = [None] * n
    l[0] = r[-1] = 1
    for i in range(1, n):
      l[i] = 1 if nums[i] <= nums[i - 1] else l[i - 1] + 1
    for i in reversed(range(n - 1)):
      r[i] = 1 if nums[i] >= nums[i + 1] else r[i + 1] + 1
    return max(min(l[i], r[i + 1]) for i in range(n - 1))
",1448184656
LeeetCode,user3517H,153,3631,python3,"class Solution:
  def countKReducibleNumbers(self, s: str, k: int) -> int:
    def count(i):
      cnt = 0
      while i > 0:
        i &= i - 1
        cnt += 1
      return cnt
    
    @cache
    def f(i):
      if i == 1:
        return 0
      c = f(count(i))
      return c + 1 if c < k else inf

    @cache
    def comb(n, k):
      if k < 0 or k > n:
        return 0
      k = min(k, n - k)
      if k == 0:
        return 1
      return (comb(n - 1, k) + comb(n - 1, k - 1)) % mod

    @cache
    def dfs(i, c):
      r = n - i
      if c > r:
        return 0
      if c == 0:
        return 1
      if i >= n:
        return 0
      if s[i] == ""0"":
        return dfs(i + 1, c)
      return (comb(r - 1, c) + dfs(i + 1, c - 1)) % mod

    mod = 10 ** 9 + 7
    n = len(s)
    k -= 1
    res = 0
    for i in range(1, n + 1):
      if f(i) < inf:
        res = (res + dfs(0, i)) % mod
    res -= 1 if f(sum(1 for i in s if i == ""1"")) < inf else 0
    return res
",1448261580
LeeetCode,user3517H,153,3646,python3,"class Solution:
  def sumOfGoodSubsequences(self, nums: List[int]) -> int:
    mod = 10 ** 9 + 7
    cnt = Counter()
    tot = Counter()
    res = 0
    for i in nums:
      c = (1 + cnt[i - 1] + cnt[i + 1]) % mod
      t = (c * i + tot[i - 1] + tot[i + 1]) % mod
      cnt[i] = (cnt[i] + c) % mod
      tot[i] = (tot[i] + t) % mod
      res = (res + t) % mod
    return res
",1448195102
JeffreyLC,JeffreyLC,155,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        const int n = nums.size();
        for (int a = 0; a + 2 * k <= n; ++a) {
            bool ok = true;
            for (int i = a + 1; i < a + k; ++i) {
                if (nums[i - 1] >= nums[i]) {
                    ok = false;
                }
            }
            int b = a + k;
            for (int i = b + 1; i < b + k; ++i) {
                if (nums[i - 1] >= nums[i]) {
                    ok = false;
                }
            }
            if (ok) return true;
        }
        return false;
    }
};",1448183004
JeffreyLC,JeffreyLC,155,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        const int n = nums.size();
        vector<int> v(n);
        v[0] = 1;
        int ans = 1;
        for (int i = 1; i < n; ++i) {
            if (nums[i - 1] < nums[i]) {
                v[i] = v[i - 1] + 1;
                ans = max(ans, v[i] / 2);
            } else {
                int prev = i - 1 - v[i - 1];
                if (prev >= 0) {
                    ans = max(ans, min(v[prev], v[i - 1]));
                }
                v[i] = 1;
            }
        }
        int prev = n - 1 - v[n - 1];
        if (prev >= 0) {
            ans = max(ans, min(v[prev], v[n - 1]));
        }
        return ans;
    }
};",1448190367
JeffreyLC,JeffreyLC,155,3631,cpp,"class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        constexpr int MOD = 1e9 + 7;
        const int n = s.length();
        vector<int> num_bits(n + 1);
        vector<vector<int>> adj(n + 1);
        for (int i = 1; i <= n; ++i) {
            num_bits[i] = num_bits[i ^ (i & (-i))] + 1;
            if (i == num_bits[i]) continue;
            adj[num_bits[i]].push_back(i);
        }
        vector<bool> check(n + 1);
        queue<pair<int, int>> q;
        check[1] = true;
        q.push({1, 0});
        while (!q.empty()) {
            auto [num, op] = q.front();
            q.pop();
            if (op + 1 == k) break;
            for (int num2 : adj[num]) {
                if (check[num2]) continue;
                check[num2] = true;
                q.push({num2, op + 1});
            }
        }
        vector<int> checks;
        for (int i = 1; i <= n; ++i) {
            if (check[i]) {
                checks.push_back(i);
            }
        }
        tri = PascalTriangle(800, MOD);
        
        int ans = 0, bitcnt = 0;
        for (int i = 0; i < n; ++i) {
            if (s[i] == '1') {
                for (int c : checks) {
                    ans += nCr(n - 1 - i, c - bitcnt);
                    ans %= MOD;
                }
                ++bitcnt;
            }
        }
        return ans;
    }
private:
    vector<vector<int>> tri;
    
    vector<vector<int>> PascalTriangle(int n, int mod) {
        vector<vector<int>> pascal_triangle;
        vector<int> row;
        for (int i = 0; i <= n; ++i) {
            row.push_back(1 % mod);
            for (int j = i - 1; j > 0; --j) {
                row[j] = (row[j - 1] + row[j]) % mod;
            }
            pascal_triangle.push_back(row);
        }
        return pascal_triangle;
    }
    
    int nCr(int n, int r) {
        if (r < 0 || n < r) return 0;
        return tri[n][r];
    }
};",1448239612
JeffreyLC,JeffreyLC,155,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        constexpr int MOD = 1e9 + 7;
        const int n = nums.size();
        unordered_map<int, pair<long long, long long>> m(100001);
        for (int num : nums) {
            auto& p = m[num];
            ++p.first;
            p.first %= MOD;
            p.second += num;
            p.second %= MOD;
            
            auto it = m.find(num - 1);
            if (it != m.end()) {
                p.first += it->second.first;
                p.first %= MOD;
                p.second += it->second.second + it->second.first * num;
                p.second %= MOD;
            }
            it = m.find(num + 1);
            if (it != m.end()) {
                p.first += it->second.first;
                p.first %= MOD;
                p.second += it->second.second + it->second.first * num;
                p.second %= MOD;
            }
        }
        int ans = 0;
        for (auto [key, val] : m) {
            ans += val.second;
            ans %= MOD;
        }
        return ans;
    }
};",1448203145
skyinde2,skyinde2,156,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        last = 0
        ret = 0
        cur = 1

        nums.append(-10000000000)

        for i in range(1, len(nums)):
            if nums[i] > nums[i - 1]:
                cur += 1
            else:
                ret = max(ret, min(last, cur))
                ret = max(ret, cur // 2)
                last = cur
                cur = 1
        
        return ret >= k

        

        ",1448190946
skyinde2,skyinde2,156,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: list[int]) -> int:
        last = 0
        ret = 0
        cur = 1

        nums.append(-10000000000)

        for i in range(1, len(nums)):
            if nums[i] > nums[i - 1]:
                cur += 1
            else:
                ret = max(ret, min(last, cur))
                ret = max(ret, cur // 2)
                last = cur
                cur = 1
        
        return ret
",1448188948
skyinde2,skyinde2,156,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        MOD = 1_000_000_007
        n = len(s)
        r = [False] * (n + 1)

        for i in range(1, n + 1):
            j = i
            for _ in range(k - 1):
                j = int.bit_count(j)
            if j == 1:
                r[i] = True

        c = [[1] * (n + 1) for _ in range(n + 1)]
        for i in range(2, n + 1):
            for j in range(1, i):
                c[i][j] = (c[i-1][j-1] + c[i-1][j]) % MOD

        pos = []
        for i in range(n):
            if s[i] == '1':
                pos.append(n - i)

        ret = -1 if r[len(pos)] else 0
        while len(pos):
            if r[len(pos)]:
                ret += 1
            
            i = pos.pop()
            for j in range(1, i):
                if r[len(pos) + j]:
                    ret = (ret + c[i-1][j]) % MOD
        
        return ret % MOD

s = Solution()
s.countKReducibleNumbers('1000', 4)



",1448247530
skyinde2,skyinde2,156,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: list[int]) -> int:
        MOD = 1_000_000_007

        dp = [0] * 100002
        cnt = [0] * 100002
        ret = 0

        for num in nums:
            a = (cnt[num - 1] + cnt[num + 1] + 1) % MOD
            b = (dp[num - 1] + dp[num + 1] + a * num) % MOD
            ret = (ret + b) % MOD
            cnt[num] = (cnt[num] + a) % MOD
            dp[num] = (dp[num] + b) % MOD
        
        return ret",1448207079
chengxia you,cy171,157,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        curr = [1]
        for i in range(1, len(nums)):
            if nums[i] > nums[i-1]:
                curr[-1] += 1
            else:
                curr.append(1)
        ans = max(curr)//2
        for i in range(1, len(curr)):
            ans = max(ans, min(curr[i], curr[i-1]))
        
        return ans >= k",1448187881
chengxia you,cy171,157,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        curr = [1]
        for i in range(1, len(nums)):
            if nums[i] > nums[i-1]:
                curr[-1] += 1
            else:
                curr.append(1)
        ans = max(curr)//2
        for i in range(1, len(curr)):
            ans = max(ans, min(curr[i], curr[i-1]))
        return ans",1448187233
chengxia you,cy171,157,3631,python3,"dic = {}
for n in range(1, 801):
    i = 0
    save = n
    while n != 1:
        i += 1
        n = bin(n)[2:].count(""1"")
    dic[save] = i
# print(dic)
mod = 10**9 + 7
class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        n = len(s)
        # top = [0, 1] + [0]*(n-1)
        curr = 1
        dp = [1] + [0]*(n)
        for i in range(1, n):
            for j in range(n,0,-1):
                dp[j] += dp[j-1]
                dp[j] %= mod
            if s[i] == ""1"":
                dp[curr] += 1
                curr += 1
            # print(dp)
        ans = 0
        for c, val in enumerate(dp[1:], 1):
            if dic[c] < k:
                ans += val
                ans %= mod
        # print(dp)
        return ans
                ",1448262458
chengxia you,cy171,157,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        total = defaultdict(int)
        count = defaultdict(int)
        for num in nums:
            count[num] += count[num-1] + count[num+1]
            total[num] += total[num+1] + total[num-1] + num * count[num-1] + num * count[num+1]
            count[num] += 1
            total[num] += num
            count[num] %= (10**9 + 7)
            total[num] %= (10**9 + 7)

        return sum(total.values())% (10**9 + 7)",1448199011
funsquared,funsquared,158,3612,python3,"def is_sorted(a):
    return all(x < y for x, y in pairwise(a))

class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        for i in range(len(nums) + 1 - 2 * k):
            if is_sorted(nums[i:i+k]) and is_sorted(nums[i+k:i+2*k]):
                return True
        return False",1448214044
funsquared,funsquared,158,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        diff = [x < y for x, y in pairwise(nums)]
        gs = [(t, len(list(g))) for t, g in groupby(diff)]
        res = 1
        for i in range(len(gs)):
            if gs[i][0]:
                res = max(res, (gs[i][1] + 1) // 2)
                if i + 2 < len(gs) and gs[i + 1][1] == 1:
                    res = max(res, min(gs[i][1], gs[i + 2][1]) + 1)
        return res
            ",1448213885
funsquared,funsquared,158,3631,python3,"MOD = 10 ** 9 + 7

class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        def good(o):
            for _ in range(k - 1):
                if o == 1:
                    return True
                o = o.bit_count()
            return o == 1
        s = int(s, 2)
        @cache
        def count(s, o=0):
            if s < 0:
                return 0
            if s == 0:
                return 1 if good(o) else 0
            return (count((s - 1) // 2, o + 1) + count(s // 2, o)) % MOD
        res = count(s - 1)
        count.cache_clear()
        return res
                ",1448247877
funsquared,funsquared,158,3646,python3,"MOD = 10 ** 9 + 7

class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        mx = max(nums)
        ct = [0] * (mx + 2)
        sm = [0] * (mx + 2)
        for x in nums:
            ct[x] = (ct[x] + ct[x - 1] + ct[x + 1] + 1)
            sm[x] = (sm[x] + x * (ct[x - 1] + ct[x + 1] + 1) + sm[x - 1] + sm[x + 1])
        return sum(sm) % MOD
        ",1448213737
Jie Chen,JustJie,159,3612,cpp,"/********************************************
 * author : Jie Chen (3rd Year CS)
 * school : Rochester Institute of Technology
 * created: 11.09.2024 21:46:00
*********************************************/
#include <bits/stdc++.h>

using namespace std;

#ifdef BROKEN_CODE
#include <bits/LC_parser.h>
#include <bits/debug.h>
#else
#define dbg(...) 10082002
#define dbp(...) ""Need Internship""
#endif

using i64 = long long;

class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& a, int k) {
        int n = a.size();
        vector<int> f(n, 1);
        int first = -1, last = -1;
        vector<bool> good(n);
        for (int i = 0; i < n; i++) {
            if (i > 0 && a[i] > a[i - 1]) {
                f[i] += f[i - 1];
            }
            if (f[i] >= k) {
                good[i] = true;
            }
        }
        for (int i = k; i < n; i++) {
            if (good[i] && good[i - k]) {
                return true;
            }
        }
        return false;
    }
};

#ifdef BROKEN_CODE
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    exec(&Solution::LoveJenney); // CHANGE FOR PROBLEM
}
#endif

// ~ JustJie",1448247925
Jie Chen,JustJie,159,3619,cpp,"/********************************************
 * author : Jie Chen (3rd Year CS)
 * school : Rochester Institute of Technology
 * created: 11.09.2024 21:48:05
*********************************************/
#include <bits/stdc++.h>

using namespace std;

#ifdef BROKEN_CODE
#include <bits/LC_parser.h>
#include <bits/debug.h>
#else
#define dbg(...) 10082002
#define dbp(...) ""Need Internship""
#endif

using i64 = long long;

class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& a) {

        auto good = [&](int k) {
            int n = a.size();
            vector<int> f(n, 1);
            int first = -1, last = -1;
            vector<bool> good(n);
            for (int i = 1; i < n; i++) {
                if (a[i] > a[i - 1]) {
                    f[i] += f[i - 1];
                }
                if (f[i] >= k) {
                    good[i] = true;
                }
            }
            for (int i = k; i < n; i++) {
                if (good[i] && good[i - k]) {
                    return true;
                }
            }
            return false;
        };

        int lo = 1, hi = a.size();
        while (lo < hi) {
            int mid = (lo + hi + 1) / 2;
            if (good(mid)) {
                lo = mid;
            } else {
                hi = mid - 1;
            }
        }
        return lo;
    }
};

#ifdef BROKEN_CODE
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    exec(&Solution::LoveJenney); // CHANGE FOR PROBLEM
}
#endif

// ~ JustJie",1448245824
Jie Chen,JustJie,159,3631,cpp,"/********************************************
 * author : Jie Chen (3rd Year CS)
 * school : Rochester Institute of Technology
 * created: 11.09.2024 21:57:54
*********************************************/
#include <bits/stdc++.h>

using namespace std;

#ifdef BROKEN_CODE
#include <bits/LC_parser.h>
#include <bits/debug.h>
#else
#define dbg(...) 10082002
#define dbp(...) ""Need Internship""
#endif

using i64 = long long;


// Credit: Jiangly
template<class T>
constexpr T power(T a, i64 b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}

constexpr i64 mul(i64 a, i64 b, i64 p) {
    i64 res = a * b - i64(1.L * a * b / p) * p;
    res %= p;
    if (res < 0) {
        res += p;
    }
    return res;
}
template<int P>
struct MInt {
    int x;
    constexpr MInt() : x{} {}
    constexpr MInt(i64 x) : x{norm(x % getMod())} {}
    
    static int Mod;
    constexpr static int getMod() {
        if (P > 0) {
            return P;
        } else {
            return Mod;
        }
    }
    constexpr static void setMod(int Mod_) {
        Mod = Mod_;
    }
    constexpr int norm(int x) const {
        if (x < 0) {
            x += getMod();
        }
        if (x >= getMod()) {
            x -= getMod();
        }
        return x;
    }
    constexpr int val() const {
        return x;
    }
    explicit constexpr operator int() const {
        return x;
    }
    constexpr MInt operator-() const {
        MInt res;
        res.x = norm(getMod() - x);
        return res;
    }
    constexpr MInt inv() const {
        assert(x != 0);
        return power(*this, getMod() - 2);
    }
    constexpr MInt &operator*=(MInt rhs) & {
        x = 1LL * x * rhs.x % getMod();
        return *this;
    }
    constexpr MInt &operator+=(MInt rhs) & {
        x = norm(x + rhs.x);
        return *this;
    }
    constexpr MInt &operator-=(MInt rhs) & {
        x = norm(x - rhs.x);
        return *this;
    }
    constexpr MInt &operator/=(MInt rhs) & {
        return *this *= rhs.inv();
    }
    friend constexpr MInt operator*(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res *= rhs;
        return res;
    }
    friend constexpr MInt operator+(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res += rhs;
        return res;
    }
    friend constexpr MInt operator-(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res -= rhs;
        return res;
    }
    friend constexpr MInt operator/(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res /= rhs;
        return res;
    }
    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {
        i64 v;
        is >> v;
        a = MInt(v);
        return is;
    }
    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {
        return os << a.val();
    }
    friend constexpr bool operator==(MInt lhs, MInt rhs) {
        return lhs.val() == rhs.val();
    }
    friend constexpr bool operator!=(MInt lhs, MInt rhs) {
        return lhs.val() != rhs.val();
    }
};
 
template<>
int MInt<0>::Mod = 998'244'353;
 
template<int V, int P>
constexpr MInt<P> CInv = MInt<P>(V).inv();
 
constexpr int P = 1'000'000'007; // 998'244'353;
using Z = MInt<P>;

// Credit: Jiangly
struct Comb {
    int n;
    vector<Z> _fac, _invfac, _inv, _pw2;
    
    Comb() : n{0}, _fac{1}, _invfac{1}, _inv{0}, _pw2{1} {}
    Comb(int n) : Comb() {
        init(n);
    }
    
    void init(int m) {
        if (m <= n) return;
        _fac.resize(m + 1);
        _invfac.resize(m + 1);
        _inv.resize(m + 1);
        _pw2.resize(m + 1);
        
        for (int i = n + 1; i <= m; i++) {
            _fac[i] = _fac[i - 1] * i;
            _pw2[i] = _pw2[i - 1] * 2;
        }
        _invfac[m] = _fac[m].inv();
        for (int i = m; i > n; i--) {
            _invfac[i - 1] = _invfac[i] * i;
            _inv[i] = _invfac[i] * _fac[i - 1];
        }
        n = m;
    }
    
    Z pw2(int m) {
        if (m > n) init(2 * m);
        return _pw2[m];
    }
    Z fac(int m) {
        if (m > n) init(2 * m);
        return _fac[m];
    }
    Z invfac(int m) {
        if (m > n) init(2 * m);
        return _invfac[m];
    }
    Z inv(int m) {
        if (m > n) init(2 * m);
        return _inv[m];
    }
    Z binom(int n, int m) {
        if (n < m || m < 0) return 0;
        return fac(n) * invfac(m) * invfac(n - m);
    }
} comb;

constexpr int N = 801;

class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        int n = s.size();
        vector<Z> f(N);
        auto rec = [&](auto&& self, int i, int cnt) {
            if (i == n) {
                return;
            }
            if (s[i] == '1') {
                self(self, i + 1, cnt + 1);
                int m = n - i - 1;
                for (int i = 0; i <= m; i++) {
                    f[i + cnt] += comb.binom(m, i);
                }
            } else {
                self(self, i + 1, cnt);
            }
        };
        rec(rec, 0, 0);
        k -= 1;

        auto count = [&](int x) {
            int ans = 0;
            for (int i = 0; x; i++) {
                if (x >> i & 1) {
                    ans++;
                    x -= (1 << i);
                }
            }
            return ans;
        };

        while (k--) {
            vector<Z> nf(N);
            for (int i = 1; i < N; i++) {
                if (f[i] == Z(0)) {
                    continue;
                }
                nf[count(i)] += f[i];
            }
            swap(f, nf);
        }
        return f[1].val();
    }
};

#ifdef BROKEN_CODE
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    exec(&Solution::LoveJenney); // CHANGE FOR PROBLEM
}
#endif

// ~ JustJie",1448244686
Jie Chen,JustJie,159,3646,cpp,"/********************************************
 * author : Jie Chen (3rd Year CS)
 * school : Rochester Institute of Technology
 * created: 11.09.2024 21:50:45
*********************************************/
#include <bits/stdc++.h>

using namespace std;

#ifdef BROKEN_CODE
#include <bits/LC_parser.h>
#include <bits/debug.h>
#else
#define dbg(...) 10082002
#define dbp(...) ""Need Internship""
#endif

using i64 = long long;

// Credit: Jiangly
template<class T>
constexpr T power(T a, i64 b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}

constexpr i64 mul(i64 a, i64 b, i64 p) {
    i64 res = a * b - i64(1.L * a * b / p) * p;
    res %= p;
    if (res < 0) {
        res += p;
    }
    return res;
}
template<int P>
struct MInt {
    int x;
    constexpr MInt() : x{} {}
    constexpr MInt(i64 x) : x{norm(x % getMod())} {}
    
    static int Mod;
    constexpr static int getMod() {
        if (P > 0) {
            return P;
        } else {
            return Mod;
        }
    }
    constexpr static void setMod(int Mod_) {
        Mod = Mod_;
    }
    constexpr int norm(int x) const {
        if (x < 0) {
            x += getMod();
        }
        if (x >= getMod()) {
            x -= getMod();
        }
        return x;
    }
    constexpr int val() const {
        return x;
    }
    explicit constexpr operator int() const {
        return x;
    }
    constexpr MInt operator-() const {
        MInt res;
        res.x = norm(getMod() - x);
        return res;
    }
    constexpr MInt inv() const {
        assert(x != 0);
        return power(*this, getMod() - 2);
    }
    constexpr MInt &operator*=(MInt rhs) & {
        x = 1LL * x * rhs.x % getMod();
        return *this;
    }
    constexpr MInt &operator+=(MInt rhs) & {
        x = norm(x + rhs.x);
        return *this;
    }
    constexpr MInt &operator-=(MInt rhs) & {
        x = norm(x - rhs.x);
        return *this;
    }
    constexpr MInt &operator/=(MInt rhs) & {
        return *this *= rhs.inv();
    }
    friend constexpr MInt operator*(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res *= rhs;
        return res;
    }
    friend constexpr MInt operator+(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res += rhs;
        return res;
    }
    friend constexpr MInt operator-(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res -= rhs;
        return res;
    }
    friend constexpr MInt operator/(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res /= rhs;
        return res;
    }
    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {
        i64 v;
        is >> v;
        a = MInt(v);
        return is;
    }
    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {
        return os << a.val();
    }
    friend constexpr bool operator==(MInt lhs, MInt rhs) {
        return lhs.val() == rhs.val();
    }
    friend constexpr bool operator!=(MInt lhs, MInt rhs) {
        return lhs.val() != rhs.val();
    }
};
 
template<>
int MInt<0>::Mod = 998'244'353;
 
template<int V, int P>
constexpr MInt<P> CInv = MInt<P>(V).inv();
 
constexpr int P = 1'000'000'007; // 998'244'353;
using Z = MInt<P>;

constexpr int N = int(1e5) + 5;

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& a) {
        Z ans = 0;
        Z f[N] {};
        Z f2[N] {};
        for (int x : a) {
            ans += x;
            f[x] += 1;
            f2[x] += x;
            for (int d : {-1, +1}) {
                if (x + d >= 0) {
                    ans += f2[x + d];
                    ans += f[x + d] * x;
                    f[x] += f[x + d];
                    f2[x] += f2[x + d] + f[x + d] * x;
                }
            }
        }
        return ans.val();
    }
};

#ifdef BROKEN_CODE
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    exec(&Solution::LoveJenney); // CHANGE FOR PROBLEM
}
#endif

// ~ JustJie",1448244776
pr3pony,pr3pony,161,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        pr = [1 for i in range(n)]
        po = [1 for i in range(n)]
        for i in range(1, n):
            if nums[i - 1] < nums[i]:
                pr[i] = pr[i - 1] + 1
            else:
                pr[i] = 1
        for i in range(n-2,-1,-1):
            if nums[i] < nums[i + 1]:
                po[i] = po[i + 1] + 1
            else:
                po[i] = 1
        ans = 1
        for i in range(n - 1):
            ans = max(ans, min(pr[i], po[i+1]))
        return ans >= k
",1448189822
pr3pony,pr3pony,161,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        pr = [1 for i in range(n)]
        po = [1 for i in range(n)]
        for i in range(1, n):
            if nums[i - 1] < nums[i]:
                pr[i] = pr[i - 1] + 1
            else:
                pr[i] = 1
        for i in range(n-2,-1,-1):
            if nums[i] < nums[i + 1]:
                po[i] = po[i + 1] + 1
            else:
                po[i] = 1
        ans = 1
        for i in range(n - 1):
            ans = max(ans, min(pr[i], po[i+1]))
        return ans
            ",1448188146
pr3pony,pr3pony,161,3631,cpp,"class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        const int C = 805;
        const int MOD = 1000000007;
        std::vector<std::vector<int>> ways(C, std::vector<int>(C, 0));
        for (int i = 0; i < C; ++i) {
            ways[i][i] = 1;
            ways[i][0] = 1;
            if (i <= 1) continue;
            for (int j = 1; j < i; ++j) {
                ways[i][j] = (ways[i-1][j] + ways[i-1][j-1]) % MOD;
            }
        }
        std::vector<int> r(C, 0);
        for (int i = 2; i < C; ++i) {
            r[i] = 1 + r[__builtin_popcount(i)];
        }
        int ans = 0;
        int lt = 0;
        for (int i = 0; i < s.length(); ++i) {
            if (s[i] == '0') continue;
            int rt = s.length() - 1 - i;
            for (int j = 0; j <= rt; ++j) {
                if (r[lt + j] >= k) continue;
                ans = (ans + ways[rt][j]) % MOD;
            }
            lt += 1;
        }
        ans = (ans - 1 + MOD) % MOD;
        return ans;
    }
};",1448255779
pr3pony,pr3pony,161,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        n = len(nums)
        a = [nums[i] + 1 for i in range(n)]
        pr = [0 for i in range(n)]
        C = 100005
        w = [0 for i in range(C)]
        MOD = 10**9+7
        for i in range(n):
            pr[i] = (1 + w[a[i] + 1] + w[a[i] - 1]) % MOD
            w[a[i]] = (w[a[i]] + pr[i]) % MOD
        w = [0 for i in range(C)]
        po = [0 for i in range(n)]
        for i in range(n-1, -1, -1):
            po[i] = (1 + w[a[i] + 1] + w[a[i] - 1]) % MOD
            w[a[i]] = (w[a[i]] + po[i]) % MOD
        ans = 0
        for i in range(n):
            ans = (ans + pr[i] * po[i] * nums[i]) % MOD
        return ans
            ",1448205793
enereltd7,enereltd7,162,3612,cpp,"class Solution {
public:

    int le[100];

    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        le[0] = 1;
        for(int i = 1; i < n; i++) {
            if(nums[i] > nums[i - 1])
                le[i] = le[i - 1] + 1;
            else
                le[i] = 1;
        }
        for(int i = k; i < n; i++)
            if(le[i] >= k && le[i - k] >= k)
                return true;
        return false;
    }
};",1448182522
enereltd7,enereltd7,162,3619,cpp,"class Solution {
public:

    int le[200005], n;

    bool check(int k) {
        for(int i = k; i < n; i++)
            if(le[i] >= k && le[i - k] >= k)
                return true;
        return false;
    }

    int find(int l, int r) {
        if(l == r) 
            return l;
        int mid = (l + r) / 2;
        if(check(mid + 1))
            return find(mid + 1, r);
        else
            return find(l, mid);
    }

    int maxIncreasingSubarrays(vector<int>& nums) {
        n = nums.size();
        le[0] = 1;
        for(int i = 1; i < n; i++) {
            if(nums[i] > nums[i - 1])
                le[i] = le[i - 1] + 1;
            else
                le[i] = 1;
        }
        return find(1, n);
    }
};",1448188183
enereltd7,enereltd7,162,3631,cpp,"class Solution {
public:

    bool is(int n, int k) {
        if(n == 1)
            return 1;
        if(!k)
            return 0;
        return is(__builtin_popcount(n), k - 1);
    }

    bool pos[801];
    long long dp[801][801], fac[801], invfac[801], mod = 1e9 + 7;
    string st;

    long long find(int ind, int num) {
        if(dp[ind][num] != -1)
            return dp[ind][num];
        if(ind == st.size())
            return dp[ind][num] = 0;
        if(st[ind] == '0')
            return dp[ind][num] = find(ind + 1, num);
        long long ans = 0;
        int k = st.size() - ind - 1;
        for(int i = 0; i <= k; i++)
            if(pos[num + i])
                ans += fac[k] * invfac[i] % mod * invfac[k - i] % mod;
        return dp[ind][num] = (ans + find(ind + 1, num + 1)) % mod;
    }

    long long deg(long long x, int d) {
        if(!d)
            return 1;
        long long ans = deg(x, d / 2);
        if(d % 2)
            return ans * ans % mod * x % mod;
        else
            return ans * ans % mod;
    }

    void pre() {
        fac[0] = 1;
        invfac[0] = 1;
        for(int i = 1; i <= 800; i++) {
            fac[i] = fac[i - 1] * i % mod;
            invfac[i] = deg(fac[i], mod - 2);
        }
    }

    int countKReducibleNumbers(string s, int k) {
        pre();
        memset(dp, -1, sizeof(dp));
        for(int i = 1; i <= 800; i++)
            pos[i] = is(i, k - 1);
        st = s;
        return find(0, 0);
    }
};",1448255810
enereltd7,enereltd7,162,3646,cpp,"class Solution {
public:

    int mod = 1e9 + 7;
    long long sum[100005], num[100005];

    int sumOfGoodSubsequences(vector<int>& nums) {
        for(auto x: nums) {
            num[x + 1]++;
            num[x + 1] += num[x];
            num[x + 1] += num[x + 2];
            num[x + 1] %= mod;
            sum[x + 1] += x;
            sum[x + 1] += sum[x] + num[x] * x;
            sum[x + 1] %= mod;
            sum[x + 1] += sum[x + 2] + num[x + 2] * x;
            sum[x + 1] %= mod;
        }
        long long ans = 0;
        for(int i = 1; i <= 100001; i++)
            ans += sum[i];
        ans %= mod;
        return ans;
    }
};",1448206511
YuningCong,YuningCong,163,3612,cpp,"class Solution {
public:
    bool check(int l, vector<int>& nums, vector<int>& dp){
        if(l*2 > nums.size()) return false;
        for(int i=l;i<nums.size();i++){
            if(dp[i]>=l&&dp[i-l]>=l) return true;
        }
        return false;
    }
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        int l = 1, r = n/2+1;
        vector<int>dp(n,1);
        for(int i=1;i<n;i++){
            if(nums[i]>nums[i-1]) dp[i] = dp[i-1]+1;
        }
        while(l<r-1){
            int mid = (l+r+1)>>1;
            if(!check(mid, nums, dp)){
                r = mid;
            }else{
                l = mid;
            }
        }
        return l;
    }
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        int l = 1, r = n/2+1;
        vector<int>dp(n,1);
        for(int i=1;i<n;i++){
            if(nums[i]>nums[i-1]) dp[i] = dp[i-1]+1;
        }
        return check(k, nums, dp);
    }
};",1448195196
YuningCong,YuningCong,163,3619,cpp,"class Solution {
public:
    bool check(int l, vector<int>& nums, vector<int>& dp){
        if(l*2 > nums.size()) return false;
        for(int i=l;i<nums.size();i++){
            if(dp[i]>=l&&dp[i-l]>=l) return true;
        }
        return false;
    }
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        int l = 1, r = n/2+1;
        vector<int>dp(n,1);
        for(int i=1;i<n;i++){
            if(nums[i]>nums[i-1]) dp[i] = dp[i-1]+1;
        }
        while(l<r-1){
            int mid = (l+r+1)>>1;
            if(!check(mid, nums, dp)){
                r = mid;
            }else{
                l = mid;
            }
        }
        return l;
    }
};",1448193329
YuningCong,YuningCong,163,3631,cpp,"class Solution {
public:
    long long dp[806];
    const int mod = 1e9+7;
    int dfs(int i, int k){
        for(int j=0;j<k;j++){
            i = __builtin_popcount(i);
        }
        return i==1;
    }
    long long chose[805][805];
    int countKReducibleNumbers(string s, int k) {
        int n = s.size();
        memset(dp,0,sizeof(dp));
        for(int i=1;i<=n;i++){
            dp[i] = dfs(i, k-1);
        }
        long long ans = 0;
        memset(chose, 0, sizeof(chose));
        chose[0][0] = 1;
        for(int i=1;i<=n;i++){
            for(int j=0;j<=i;j++){
                if(j)
                chose[i][j] = (chose[i][j]+chose[i-1][j-1])%mod;
                chose[i][j] = (chose[i][j]+chose[i-1][j])%mod;
            }
        }
        long long tot = 0;
        for(int i=0;i<n;i++){
            if(s[i]=='0') continue;
            for(int j=0;j<=n-i-1;j++){
                if(dp[j+tot]){
                    ans = (ans + chose[n-i-1][j])%mod;
                }
            }
            tot++;
        }
        return ans;
    }
};",1448255978
YuningCong,YuningCong,163,3646,cpp,"class Solution {
public:
    const long long mod = 1e9+7;
    int sumOfGoodSubsequences(vector<int>& nums) {
        unordered_map<long long, long long>m;
        unordered_map<long long, long long>counter;
        for(auto i: nums){
            long long base = 0;
            long long count = 1;
            if(m.find(i-1)!=m.end()) {
                count = (count + counter[i-1])%mod;
                base = (base + m[i-1])%mod;
            }
            if(m.find(i+1)!=m.end()) {
                count = (count + counter[i+1])%mod;
                base = (base + m[i+1])%mod;
            }
            m[i] = (m[i]+base)%mod;
            long long tmp = (long long)i;
            m[i] = (m[i] + ((count%mod)*(tmp%mod))%mod)%mod;
            counter[i] = (counter[i]+count)%mod;
        }
        long long f = 0;
        for(auto i: m){
            f = (f+i.second)%mod;
        }
        return f;
    }
};",1448216332
Jose Coves,jcoves,168,3612,cpp,"
#ifdef LOCAL_RUN
#include ""debug_leet.h""
    #else
    #define trace(...) ;
    #define dbg(...) ;
    #define dbgc(...) ;
    #define debug(x) ;
    #define debuga(a, n) ;
    #define debug2(x, y) ;
    #define debug3(x, y, z) ;
    #define debug4(x, y, z, w) ;
    #define debug5(a,b,c,d,e) ;
    #define lassert(x) ;
    #define dassert(x, ...) ;
    int recur_depth = 0; bool rec_indent = true;
    const bool isLocal = false;
    template <typename Arg, typename... Args>
    void display(TreeNode* root) {}
    #endif

    #define pb push_back
    #define eb emplace_back
    #define popb pop_back
    #define all(v) begin(v), end(v)
    #define rall(v) (v).rbegin(),(v).rend()
    #define make_unique(v) (v).erase(unique(all(v)), (v).end())
    #define sz(c) ((int) c.size())
    #define forn(i,n) for(auto i=(n)-(n);i<(n);i++)
    #define fornn(i,s,n) for(auto i=(n)-(n)+(s);i<(n);i++)
    #define forb(i,n) for(auto i=(n)-1;i>=0;i--)
    #define forbn(i,s,n) for(auto i=(n)-1;i>=(s);i--)
    #define forit(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)
    #define mem(a,b) memset(a,b,sizeof(a))
    #define abs(x) (((x) < 0) ? -(x) : (x))
    #define sqr(x) ((x) * (x))
    #define sqrt(x) sqrt(abs(x))
    #define has(c,x) (c.find(x) != c.end())
    #define pw(x) (1LL << (x))
    #define ibit(x,i) (((x) >> (i)) & 1)
    #define data(v) v.data(), sz(v) // vi -> vai
    #define gtime() ((double(clock()) - 0)/CLOCKS_PER_SEC)

    typedef stringstream sstr;
    typedef long long ll;
    typedef long double ld;
    typedef pair<int, int> pii;
    typedef pair<ll,ll> pll;
    typedef pair<ld,ld> pdd;
    typedef vector<int> vi;
    typedef vector<ll> vll;
    typedef vector<pii> vpii;
    typedef vector<vi> vvi;
    typedef vector<vll> vvll;
    typedef valarray<int> vai;
    template <class T>
    using min_pq = priority_queue<T, vector<T>, greater<T>>;
    template <class T>
    using vc = vector<T>;
    template <class T>
    using vvc = vector<vc<T>>;
    template <class T>
    using vvvc = vector<vvc<T>>;
    template <class T>
    using vvvvc = vector<vvvc<T>>;
    template <class T>
    using vvvvvc = vector<vvvvc<T>>;

    template<class F>
    struct y_comb{
        F f;
        template<class T> explicit y_comb(T &&f_in): f(forward<T>(f_in)){ }
        template<class ...Args> decltype(auto) operator()(Args &&...args){ return f(ref(*this), forward<Args>(args)...); }
    };
    template<class F>
    decltype(auto) yf(F &&f){
        return y_comb<decay_t<F>>(forward<F>(f));
    }

    inline int ni(){ int x; cin >> x;   return x; }
    inline ll  nl() { ll  x; cin >> x; return x; }

    template <class T> void mmin(T& a, const T& b) {
        a = (a) < (b) ? (a) : (b);
    }
    template <class T> void mmax(T& a, const T& b) {
        a = (a) > (b) ? (a) : (b);
    }
    template <class T> int LB(vc<T> &a, T x){
        return int(lower_bound(all(a), x) - a.begin());
    }
    template <class T> int UB(vc<T> &a, T x){
        return int(upper_bound(all(a), x) - a.begin());
    }
    template <class T> T MAX(vc<T> &a, int l=0, int r=-1){
        if(r < 0) r = sz(a);
        return *max_element(a.begin()+l, a.begin()+r);
    }
    template <class T> T MIN(vc<T> &a, int l=0, int r=-1){
        if(r < 0) r = sz(a);
        return *min_element(a.begin()+l, a.begin()+r);
    }
    template <class T> auto vv(int d1, T x){
        return vc<T>(d1, x);
    }
    template <class T> auto vv(int d1, int d2, T x){
        return vc<vc<T>>(d1, vc<T>(d2, x));
    }
    template <class T> auto vv(int d1, int d2, int d3, T x){
        return vc<vc<vc<T>>>(d1, vv(d2, d3, x));
    }
    template <class T> auto vv(int d1, int d2, int d3, int d4, T x){
        return vc<vc<vc<vc<T>>>>(d1, vv(d2, d3, d4, x));
    }
    void outv(auto &v){
        for(auto &x: v) {cout<< x <<"" "";} cout<<endl;
    }
    void rvec(int &n, auto &v){
        cin >> n; v.resize(n); for(auto &x: v) cin >> (x);
    }
    template <typename Arg, typename... Args>
    void read(Arg&& arg, Args&&... args){
        cin >> std::forward<Arg>(arg); using expander = int[];
        (void)expander{0, (void(cin >> std::forward<Args>(args)),0)...};
    }
    template <typename Arg, typename... Args>
    void out(Arg&& arg, Args&&... args){
        cout << std::forward<Arg>(arg); using expander = int[];
        (void)expander{0, (void(cout << "" "" << std::forward<Args>(args)),0)...};
        cout << endl;
    }
    template <class Integer, class F>
    Integer find_first_false(Integer l, Integer r, F&& f) {
        --l; // ++r;
        while (r - l > 1) {
            Integer m = midpoint(l, r);
            if (f(m)) l = m;
            else r = m;
        }
        return r;
    }
    template <class Integer, class F>
    Integer find_last_true(Integer l, Integer r, F &&f) {
        return find_first_false(l, r, [&f](Integer i) { return f(i); }) - 1;
    }
    template <class Integer, class F>
    Integer find_first_true(Integer l, Integer r, F &&f) {
        return find_first_false(l, r, [&f](Integer i) { return !f(i); });
    }
    auto init = []() {
        ios::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL); return 'c';
    }();

    ll pwr(ll base, ll p, ll mod){
        ll ans=1; while(p) {if(p&1) ans=(ans*base)%mod;
            base=(base*base)%mod; p/=2;}
        return ans;
    }
    ll gcd(ll a, ll b) {  return b == 0 ? a : gcd(b,a%b); }
    ll lcm(ll a, ll b) {  return a*(b/gcd(a,b)); }

    const long double PI = (long double)(3.1415926535897932384626433832795);
    const ll  mx_ll   = numeric_limits<ll> :: max();
    const int mx_int  = numeric_limits<int> :: max();

    const int oo = 0x3f3f3f3f;
    const ll  OO = 0x3f3f3f3f3f3f3f3fll;
    const double eps = 1e-9;
    const int DX[8]={0,1, 0,-1,-1,1,-1, 1};
    const int DY[8]={1,0,-1, 0,-1,1, 1,-1};

const int maxn = 1e5 + 3;
const int mod = 1e9+7;
class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& a, int k) {
        if(k==1) return true;
        int n = sz(a);
        vi p(n-1);
        forn(i, n-1) p[i] = a[i] < a[i+1];
        forn(i, n-2) if(p[i+1]) p[i+1] += p[i];
        debug(p);
        fornn(i, k, n-1) {
            if(p[i-k] >= k-1 and p[i] >= k-1) return true;
        }
        return false;
    }
};

#ifdef LOCAL_RUN
void _solve(){
    Solution sol;
    vi a; int k; cin >> a >> k;
    cout << sol.hasIncreasingSubarrays(a, k) << endl;
}


/*************************************************************************/
int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    //cout.precision(15);
    // return 0;
    while(cin.peek() == 32 or cin.peek() == 10) cin.get();
    while(cin.peek() != EOF){
        _solve();
        while(cin.peek() == 32 or cin.peek() == 10) cin.get();
    }
}
#endif
",1448186881
Jose Coves,jcoves,168,3619,cpp,"
#ifdef LOCAL_RUN
#include ""debug_leet.h""
    #else
    #define trace(...) ;
    #define dbg(...) ;
    #define dbgc(...) ;
    #define debug(x) ;
    #define debuga(a, n) ;
    #define debug2(x, y) ;
    #define debug3(x, y, z) ;
    #define debug4(x, y, z, w) ;
    #define debug5(a,b,c,d,e) ;
    #define lassert(x) ;
    #define dassert(x, ...) ;
    int recur_depth = 0; bool rec_indent = true;
    const bool isLocal = false;
    template <typename Arg, typename... Args>
    void display(TreeNode* root) {}
    #endif

    #define pb push_back
    #define eb emplace_back
    #define popb pop_back
    #define all(v) begin(v), end(v)
    #define rall(v) (v).rbegin(),(v).rend()
    #define make_unique(v) (v).erase(unique(all(v)), (v).end())
    #define sz(c) ((int) c.size())
    #define forn(i,n) for(auto i=(n)-(n);i<(n);i++)
    #define fornn(i,s,n) for(auto i=(n)-(n)+(s);i<(n);i++)
    #define forb(i,n) for(auto i=(n)-1;i>=0;i--)
    #define forbn(i,s,n) for(auto i=(n)-1;i>=(s);i--)
    #define forit(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)
    #define mem(a,b) memset(a,b,sizeof(a))
    #define abs(x) (((x) < 0) ? -(x) : (x))
    #define sqr(x) ((x) * (x))
    #define sqrt(x) sqrt(abs(x))
    #define has(c,x) (c.find(x) != c.end())
    #define pw(x) (1LL << (x))
    #define ibit(x,i) (((x) >> (i)) & 1)
    #define data(v) v.data(), sz(v) // vi -> vai
    #define gtime() ((double(clock()) - 0)/CLOCKS_PER_SEC)

    typedef stringstream sstr;
    typedef long long ll;
    typedef long double ld;
    typedef pair<int, int> pii;
    typedef pair<ll,ll> pll;
    typedef pair<ld,ld> pdd;
    typedef vector<int> vi;
    typedef vector<ll> vll;
    typedef vector<pii> vpii;
    typedef vector<vi> vvi;
    typedef vector<vll> vvll;
    typedef valarray<int> vai;
    template <class T>
    using min_pq = priority_queue<T, vector<T>, greater<T>>;
    template <class T>
    using vc = vector<T>;
    template <class T>
    using vvc = vector<vc<T>>;
    template <class T>
    using vvvc = vector<vvc<T>>;
    template <class T>
    using vvvvc = vector<vvvc<T>>;
    template <class T>
    using vvvvvc = vector<vvvvc<T>>;

    template<class F>
    struct y_comb{
        F f;
        template<class T> explicit y_comb(T &&f_in): f(forward<T>(f_in)){ }
        template<class ...Args> decltype(auto) operator()(Args &&...args){ return f(ref(*this), forward<Args>(args)...); }
    };
    template<class F>
    decltype(auto) yf(F &&f){
        return y_comb<decay_t<F>>(forward<F>(f));
    }

    inline int ni(){ int x; cin >> x;   return x; }
    inline ll  nl() { ll  x; cin >> x; return x; }

    template <class T> void mmin(T& a, const T& b) {
        a = (a) < (b) ? (a) : (b);
    }
    template <class T> void mmax(T& a, const T& b) {
        a = (a) > (b) ? (a) : (b);
    }
    template <class T> int LB(vc<T> &a, T x){
        return int(lower_bound(all(a), x) - a.begin());
    }
    template <class T> int UB(vc<T> &a, T x){
        return int(upper_bound(all(a), x) - a.begin());
    }
    template <class T> T MAX(vc<T> &a, int l=0, int r=-1){
        if(r < 0) r = sz(a);
        return *max_element(a.begin()+l, a.begin()+r);
    }
    template <class T> T MIN(vc<T> &a, int l=0, int r=-1){
        if(r < 0) r = sz(a);
        return *min_element(a.begin()+l, a.begin()+r);
    }
    template <class T> auto vv(int d1, T x){
        return vc<T>(d1, x);
    }
    template <class T> auto vv(int d1, int d2, T x){
        return vc<vc<T>>(d1, vc<T>(d2, x));
    }
    template <class T> auto vv(int d1, int d2, int d3, T x){
        return vc<vc<vc<T>>>(d1, vv(d2, d3, x));
    }
    template <class T> auto vv(int d1, int d2, int d3, int d4, T x){
        return vc<vc<vc<vc<T>>>>(d1, vv(d2, d3, d4, x));
    }
    void outv(auto &v){
        for(auto &x: v) {cout<< x <<"" "";} cout<<endl;
    }
    void rvec(int &n, auto &v){
        cin >> n; v.resize(n); for(auto &x: v) cin >> (x);
    }
    template <typename Arg, typename... Args>
    void read(Arg&& arg, Args&&... args){
        cin >> std::forward<Arg>(arg); using expander = int[];
        (void)expander{0, (void(cin >> std::forward<Args>(args)),0)...};
    }
    template <typename Arg, typename... Args>
    void out(Arg&& arg, Args&&... args){
        cout << std::forward<Arg>(arg); using expander = int[];
        (void)expander{0, (void(cout << "" "" << std::forward<Args>(args)),0)...};
        cout << endl;
    }
    template <class Integer, class F>
    Integer find_first_false(Integer l, Integer r, F&& f) {
        --l; // ++r;
        while (r - l > 1) {
            Integer m = midpoint(l, r);
            if (f(m)) l = m;
            else r = m;
        }
        return r;
    }
    template <class Integer, class F>
    Integer find_last_true(Integer l, Integer r, F &&f) {
        return find_first_false(l, r, [&f](Integer i) { return f(i); }) - 1;
    }
    template <class Integer, class F>
    Integer find_first_true(Integer l, Integer r, F &&f) {
        return find_first_false(l, r, [&f](Integer i) { return !f(i); });
    }
    auto init = []() {
        ios::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL); return 'c';
    }();

    ll pwr(ll base, ll p, ll mod){
        ll ans=1; while(p) {if(p&1) ans=(ans*base)%mod;
            base=(base*base)%mod; p/=2;}
        return ans;
    }
    ll gcd(ll a, ll b) {  return b == 0 ? a : gcd(b,a%b); }
    ll lcm(ll a, ll b) {  return a*(b/gcd(a,b)); }

    const long double PI = (long double)(3.1415926535897932384626433832795);
    const ll  mx_ll   = numeric_limits<ll> :: max();
    const int mx_int  = numeric_limits<int> :: max();

    const int oo = 0x3f3f3f3f;
    const ll  OO = 0x3f3f3f3f3f3f3f3fll;
    const double eps = 1e-9;
    const int DX[8]={0,1, 0,-1,-1,1,-1, 1};
    const int DY[8]={1,0,-1, 0,-1,1, 1,-1};

const int maxn = 1e5 + 3;
const int mod = 1e9+7;
template <class T, class F>
    T last_true(T lo, T hi, F&& f) { 
        lo--; // if all are false, return lo-1
        while(lo < hi){
            T mid = lo + (hi - lo + 1) / 2;
            if(f(mid)) lo = mid; 
            else hi = mid - 1;
        }
        return lo;
    }
class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& a, int k) {
        if(k==1) return true;
        int n = sz(a);
        vi p(n-1);
        forn(i, n-1) p[i] = a[i] < a[i+1];
        forn(i, n-2) if(p[i+1]) p[i+1] += p[i];
        debug(p);
        fornn(i, k, n-1) {
            if(p[i-k] >= k-1 and p[i] >= k-1) return true;
        }
        return false;
    }
    int maxIncreasingSubarrays(vector<int>& a) {
        int n = sz(a);
        return last_true(1, n/2, [&](int k){
            return hasIncreasingSubarrays(a, k);
        });
        // vi p(n-1);
        // forn(i, n-1) p[i] = a[i] < a[i+1];
        // forn(i, n-2) if(p[i+1]) p[i+1] += p[i];
        // debug(p);
        // fornn(i, k, n-1) {
        //     if(p[i-k] >= k-1 and p[i] >= k-1) return true;
        // }
    }
};

#ifdef LOCAL_RUN
void _solve(){
    Solution sol;
    vi a; cin >> a;
    out(sol.maxIncreasingSubarrays(a));
}


/*************************************************************************/
int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    //cout.precision(15);
    // return 0;
    while(cin.peek() == 32 or cin.peek() == 10) cin.get();
    while(cin.peek() != EOF){
        _solve();
        while(cin.peek() == 32 or cin.peek() == 10) cin.get();
    }
}
#endif
",1448191166
Jose Coves,jcoves,168,3631,cpp,"
#ifdef LOCAL_RUN
#include ""debug_leet.h""
    #else
    #define trace(...) ;
    #define dbg(...) ;
    #define dbgc(...) ;
    #define debug(x) ;
    #define debuga(a, n) ;
    #define debug2(x, y) ;
    #define debug3(x, y, z) ;
    #define debug4(x, y, z, w) ;
    #define debug5(a,b,c,d,e) ;
    #define lassert(x) ;
    #define dassert(x, ...) ;
    int recur_depth = 0; bool rec_indent = true;
    const bool isLocal = false;
    template <typename Arg, typename... Args>
    void display(TreeNode* root) {}
    #endif

    #define pb push_back
    #define eb emplace_back
    #define popb pop_back
    #define all(v) begin(v), end(v)
    #define rall(v) (v).rbegin(),(v).rend()
    #define make_unique(v) (v).erase(unique(all(v)), (v).end())
    #define sz(c) ((int) c.size())
    #define forn(i,n) for(auto i=(n)-(n);i<(n);i++)
    #define fornn(i,s,n) for(auto i=(n)-(n)+(s);i<(n);i++)
    #define forb(i,n) for(auto i=(n)-1;i>=0;i--)
    #define forbn(i,s,n) for(auto i=(n)-1;i>=(s);i--)
    #define forit(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)
    #define mem(a,b) memset(a,b,sizeof(a))
    #define abs(x) (((x) < 0) ? -(x) : (x))
    #define sqr(x) ((x) * (x))
    #define sqrt(x) sqrt(abs(x))
    #define has(c,x) (c.find(x) != c.end())
    #define pw(x) (1LL << (x))
    #define ibit(x,i) (((x) >> (i)) & 1)
    #define data(v) v.data(), sz(v) // vi -> vai
    #define gtime() ((double(clock()) - 0)/CLOCKS_PER_SEC)

    typedef stringstream sstr;
    typedef long long ll;
    typedef long double ld;
    typedef pair<int, int> pii;
    typedef pair<ll,ll> pll;
    typedef pair<ld,ld> pdd;
    typedef vector<int> vi;
    typedef vector<ll> vll;
    typedef vector<pii> vpii;
    typedef vector<vi> vvi;
    typedef vector<vll> vvll;
    typedef valarray<int> vai;
    template <class T>
    using min_pq = priority_queue<T, vector<T>, greater<T>>;
    template <class T>
    using vc = vector<T>;
    template <class T>
    using vvc = vector<vc<T>>;
    template <class T>
    using vvvc = vector<vvc<T>>;
    template <class T>
    using vvvvc = vector<vvvc<T>>;
    template <class T>
    using vvvvvc = vector<vvvvc<T>>;

    template<class F>
    struct y_comb{
        F f;
        template<class T> explicit y_comb(T &&f_in): f(forward<T>(f_in)){ }
        template<class ...Args> decltype(auto) operator()(Args &&...args){ return f(ref(*this), forward<Args>(args)...); }
    };
    template<class F>
    decltype(auto) yf(F &&f){
        return y_comb<decay_t<F>>(forward<F>(f));
    }

    inline int ni(){ int x; cin >> x;   return x; }
    inline ll  nl() { ll  x; cin >> x; return x; }

    template <class T> void mmin(T& a, const T& b) {
        a = (a) < (b) ? (a) : (b);
    }
    template <class T> void mmax(T& a, const T& b) {
        a = (a) > (b) ? (a) : (b);
    }
    template <class T> int LB(vc<T> &a, T x){
        return int(lower_bound(all(a), x) - a.begin());
    }
    template <class T> int UB(vc<T> &a, T x){
        return int(upper_bound(all(a), x) - a.begin());
    }
    template <class T> T MAX(vc<T> &a, int l=0, int r=-1){
        if(r < 0) r = sz(a);
        return *max_element(a.begin()+l, a.begin()+r);
    }
    template <class T> T MIN(vc<T> &a, int l=0, int r=-1){
        if(r < 0) r = sz(a);
        return *min_element(a.begin()+l, a.begin()+r);
    }
    template <class T> auto vv(int d1, T x){
        return vc<T>(d1, x);
    }
    template <class T> auto vv(int d1, int d2, T x){
        return vc<vc<T>>(d1, vc<T>(d2, x));
    }
    template <class T> auto vv(int d1, int d2, int d3, T x){
        return vc<vc<vc<T>>>(d1, vv(d2, d3, x));
    }
    template <class T> auto vv(int d1, int d2, int d3, int d4, T x){
        return vc<vc<vc<vc<T>>>>(d1, vv(d2, d3, d4, x));
    }
    void outv(auto &v){
        for(auto &x: v) {cout<< x <<"" "";} cout<<endl;
    }
    void rvec(int &n, auto &v){
        cin >> n; v.resize(n); for(auto &x: v) cin >> (x);
    }
    template <typename Arg, typename... Args>
    void read(Arg&& arg, Args&&... args){
        cin >> std::forward<Arg>(arg); using expander = int[];
        (void)expander{0, (void(cin >> std::forward<Args>(args)),0)...};
    }
    template <typename Arg, typename... Args>
    void out(Arg&& arg, Args&&... args){
        cout << std::forward<Arg>(arg); using expander = int[];
        (void)expander{0, (void(cout << "" "" << std::forward<Args>(args)),0)...};
        cout << endl;
    }
    template <class Integer, class F>
    Integer find_first_false(Integer l, Integer r, F&& f) {
        --l; // ++r;
        while (r - l > 1) {
            Integer m = midpoint(l, r);
            if (f(m)) l = m;
            else r = m;
        }
        return r;
    }
    template <class Integer, class F>
    Integer find_last_true(Integer l, Integer r, F &&f) {
        return find_first_false(l, r, [&f](Integer i) { return f(i); }) - 1;
    }
    template <class Integer, class F>
    Integer find_first_true(Integer l, Integer r, F &&f) {
        return find_first_false(l, r, [&f](Integer i) { return !f(i); });
    }
    auto init = []() {
        ios::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL); return 'c';
    }();

    ll pwr(ll base, ll p, ll mod){
        ll ans=1; while(p) {if(p&1) ans=(ans*base)%mod;
            base=(base*base)%mod; p/=2;}
        return ans;
    }
    ll gcd(ll a, ll b) {  return b == 0 ? a : gcd(b,a%b); }
    ll lcm(ll a, ll b) {  return a*(b/gcd(a,b)); }

    const long double PI = (long double)(3.1415926535897932384626433832795);
    const ll  mx_ll   = numeric_limits<ll> :: max();
    const int mx_int  = numeric_limits<int> :: max();

    const int oo = 0x3f3f3f3f;
    const ll  OO = 0x3f3f3f3f3f3f3f3fll;
    const double eps = 1e-9;
    const int DX[8]={0,1, 0,-1,-1,1,-1, 1};
    const int DY[8]={1,0,-1, 0,-1,1, 1,-1};

const int maxn = 1e5 + 3;
const int mod = 1e9+7;
namespace mod_util {
    using i64 = long long;
    template<class T>
    constexpr T power(T a, i64 b) {
        T res = 1;
        for (; b; b /= 2, a *= a) {
            if (b % 2) {
                res *= a;
            }
        }
        return res;
    }

    template<int P>
    struct MInt {
        i64 x;
        constexpr MInt() : x{} {}
        constexpr MInt(i64 x_input) : x{norm(x_input % getMod())} {}

        static int Mod;
        static MInt power(MInt a, i64 b) {
            return mod_util::power(a, b);
        }
        constexpr static int getMod() {
            if (P > 0) {
                return P;
            } else {
                return Mod;
            }
        }
        constexpr static void setMod(int Mod_) {
            Mod = Mod_;
        }
        constexpr i64 norm(i64 val) const {
            if (val < 0) {
                val += getMod();
            }
            if (val >= getMod()) {
                val -= getMod();
            }
            return val;
        }
        constexpr i64 val() const {
            return x;
        }
        explicit constexpr operator ll() const {
            return x;
        }
        constexpr MInt operator-() const {
            MInt res;
            res.x = norm(getMod() - x);
            return res;
        }
        constexpr MInt inv() const {
            assert(x != 0);
            return power(*this, getMod() - 2);
        }
        constexpr MInt &operator*=(MInt rhs) & {
            x = 1LL * x * rhs.x % getMod();
            return *this;
        }
        constexpr MInt &operator+=(MInt rhs) & {
            x = norm(x + rhs.x);
            return *this;
        }
        constexpr MInt &operator-=(MInt rhs) & {
            x = norm(x - rhs.x);
            return *this;
        }
        constexpr MInt &operator/=(MInt rhs) & {
            return *this *= rhs.inv();
        }
        constexpr MInt &operator^=(MInt rhs) & {
            return *this = power(*this, rhs.x);
        }
        constexpr MInt pow(ll rhs) {
            return *this = power(*this, rhs);
        }
        friend constexpr MInt operator*(MInt lhs, MInt rhs) {
            MInt res = lhs;
            res *= rhs;
            return res;
        }
        friend constexpr MInt operator+(MInt lhs, MInt rhs) {
            MInt res = lhs;
            res += rhs;
            return res;
        }
        friend constexpr MInt operator-(MInt lhs, MInt rhs) {
            MInt res = lhs;
            res -= rhs;
            return res;
        }
        friend constexpr MInt operator/(MInt lhs, MInt rhs) {
            MInt res = lhs;
            res /= rhs;
            return res;
        }
        friend constexpr MInt operator^(MInt lhs, MInt rhs) {
            MInt res = lhs;
            res ^= rhs;
            return res;
        }
        friend constexpr istream &operator>>(istream &is, MInt &a) {
            i64 v;
            is >> v;
            a = MInt(v);
            return is;
        }
        friend constexpr ostream &operator<<(ostream &os, const MInt &a) {
            return os << a.val();
        }
        friend constexpr bool operator==(MInt lhs, MInt rhs) {
            return lhs.val() == rhs.val();
        }
        friend constexpr bool operator!=(MInt lhs, MInt rhs) {
            return lhs.val() != rhs.val();
        }
    };

    template<>
    int MInt<0>::Mod = mod;

    template<int V, int P>
    constexpr MInt<P> CInv = MInt<P>(V).inv();

    constexpr int P = mod;
    using Z = MInt<P>;

    struct Comb {
        int N;
        vector<Z> _fac;
        vector<Z> _invfac;
        vector<Z> _inv;

        Comb() : N{0}, _fac{1}, _invfac{1}, _inv{0} {}
        Comb(int n) : Comb() {
            init(n);
        }

        void init(int m) {
            m = min(m, Z::getMod() - 1);
            if (m <= N) return;
            _fac.resize(m + 1);
            _invfac.resize(m + 1);
            _inv.resize(m + 1);

            for (int i = N + 1; i <= m; i++) {
                _fac[i] = _fac[i - 1] * i;
            }
            _invfac[m] = _fac[m].inv();
            for (int i = m; i > N; i--) {
                _invfac[i - 1] = _invfac[i] * i;
                _inv[i] = _invfac[i] * _fac[i - 1];
            }
            N = m;
        }
        void check_init(int m){
            if (m > N) init(2 * m);
        }
        Z fac(int m) {
            check_init(m);
            return _fac[m];
        }
        Z invfac(int m) {
            check_init(m);
            return _invfac[m];
        }
        Z inv(int m) {
            check_init(m);
            return _inv[m];
        }
        Z binom(int n, int k) { // choose k out of n
            if (n < k || k < 0) return 0;
            return fac(n) * invfac(k) * invfac(n - k);
        }
        Z choose(int k, int n) { // choose k out of n
            return binom(n, k);
        }
    } comb;
}
using Z = mod_util::MInt<mod>;
auto &comb = mod_util::comb;
void build(){
    int n = 801;
    vi dp(n); dp[0]=dp[1]=0;
    fornn(i,2,n) dp[i] = 1 + dp[__builtin_popcount(i)];
    forn(i, n){
        int to = __builtin_popcount(i);
        debug3(i, to, dp[i]);
    }
}
class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        int n = sz(s);
        vi cost(n+1); cost[1]=0;
        debug2(n, s);
        fornn(i,2,n+1) cost[i] = 1 + cost[__builtin_popcount(i)];
        auto dp = vv(n+1, 2, n+1, Z(0));
        auto vis = vv(n+1, 2, n+1, 0);
        auto go = yf([&](auto f, int rem, int eq, int i) -> Z {
            if(rem < 0) return 0;
            if(i == n) {
                if(rem > 0) return 0;
                if(eq == 1) return 0;
                return 1;
            }
            auto &ans = dp[rem][eq][i]; if(vis[rem][eq][i]++) return ans;
            if(eq){
                if(s[i] == '1'){
                    ans += f(rem-1, eq, i+1); // 1
                    ans += f(rem-0, 0, i+1); // 0
                } else { // = 0
                    // cant be higher; ans += f(rem-1, eq, i+1); // 1; 
                    ans += f(rem-0, eq, i+1); // 0
                }
            } else {
                ans += f(rem-1, eq, i+1); // 1
                ans += f(rem-0, eq, i+1); // 0
                // if(s[i] == '1'){
                //     ans += f(rem-1, eq, i+1); // 1
                //     ans += f(rem-0, eq, i+1); // 0
                // } else { // = 0
                //     ans += f(rem-1, eq, i+1); // 1; 
                //     ans += f(rem-0, eq, i+1); // 0
                // }
            }
            return ans;
        });
        Z ans = 0;
        fornn(on, 1, n+1) if(cost[on] < k) {
            auto val = go(on, 1, 0);
            debug3(on, cost[on], val);
            ans += val;
        }
        return int(ans.val());
    }
};

#ifdef LOCAL_RUN
void _solve(){
    Solution sol;
    string s; int k; cin >> s >> k;
    out(sol.countKReducibleNumbers(s, k));
}


/*************************************************************************/
int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    //cout.precision(15);
    // return 0;
    build();
    while(cin.peek() == 32 or cin.peek() == 10) cin.get();
    while(cin.peek() != EOF){
        _solve();
        while(cin.peek() == 32 or cin.peek() == 10) cin.get();
    }
}
#endif
",1448257295
Jose Coves,jcoves,168,3646,cpp,"
#ifdef LOCAL_RUN
#include ""debug_leet.h""
    #else
    #define trace(...) ;
    #define dbg(...) ;
    #define dbgc(...) ;
    #define debug(x) ;
    #define debuga(a, n) ;
    #define debug2(x, y) ;
    #define debug3(x, y, z) ;
    #define debug4(x, y, z, w) ;
    #define debug5(a,b,c,d,e) ;
    #define lassert(x) ;
    #define dassert(x, ...) ;
    int recur_depth = 0; bool rec_indent = true;
    const bool isLocal = false;
    template <typename Arg, typename... Args>
    void display(TreeNode* root) {}
    #endif

    #define pb push_back
    #define eb emplace_back
    #define popb pop_back
    #define all(v) begin(v), end(v)
    #define rall(v) (v).rbegin(),(v).rend()
    #define make_unique(v) (v).erase(unique(all(v)), (v).end())
    #define sz(c) ((int) c.size())
    #define forn(i,n) for(auto i=(n)-(n);i<(n);i++)
    #define fornn(i,s,n) for(auto i=(n)-(n)+(s);i<(n);i++)
    #define forb(i,n) for(auto i=(n)-1;i>=0;i--)
    #define forbn(i,s,n) for(auto i=(n)-1;i>=(s);i--)
    #define forit(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)
    #define mem(a,b) memset(a,b,sizeof(a))
    #define abs(x) (((x) < 0) ? -(x) : (x))
    #define sqr(x) ((x) * (x))
    #define sqrt(x) sqrt(abs(x))
    #define has(c,x) (c.find(x) != c.end())
    #define pw(x) (1LL << (x))
    #define ibit(x,i) (((x) >> (i)) & 1)
    #define data(v) v.data(), sz(v) // vi -> vai
    #define gtime() ((double(clock()) - 0)/CLOCKS_PER_SEC)

    typedef stringstream sstr;
    typedef long long ll;
    typedef long double ld;
    typedef pair<int, int> pii;
    typedef pair<ll,ll> pll;
    typedef pair<ld,ld> pdd;
    typedef vector<int> vi;
    typedef vector<ll> vll;
    typedef vector<pii> vpii;
    typedef vector<vi> vvi;
    typedef vector<vll> vvll;
    typedef valarray<int> vai;
    template <class T>
    using min_pq = priority_queue<T, vector<T>, greater<T>>;
    template <class T>
    using vc = vector<T>;
    template <class T>
    using vvc = vector<vc<T>>;
    template <class T>
    using vvvc = vector<vvc<T>>;
    template <class T>
    using vvvvc = vector<vvvc<T>>;
    template <class T>
    using vvvvvc = vector<vvvvc<T>>;

    template<class F>
    struct y_comb{
        F f;
        template<class T> explicit y_comb(T &&f_in): f(forward<T>(f_in)){ }
        template<class ...Args> decltype(auto) operator()(Args &&...args){ return f(ref(*this), forward<Args>(args)...); }
    };
    template<class F>
    decltype(auto) yf(F &&f){
        return y_comb<decay_t<F>>(forward<F>(f));
    }

    inline int ni(){ int x; cin >> x;   return x; }
    inline ll  nl() { ll  x; cin >> x; return x; }

    template <class T> void mmin(T& a, const T& b) {
        a = (a) < (b) ? (a) : (b);
    }
    template <class T> void mmax(T& a, const T& b) {
        a = (a) > (b) ? (a) : (b);
    }
    template <class T> int LB(vc<T> &a, T x){
        return int(lower_bound(all(a), x) - a.begin());
    }
    template <class T> int UB(vc<T> &a, T x){
        return int(upper_bound(all(a), x) - a.begin());
    }
    template <class T> T MAX(vc<T> &a, int l=0, int r=-1){
        if(r < 0) r = sz(a);
        return *max_element(a.begin()+l, a.begin()+r);
    }
    template <class T> T MIN(vc<T> &a, int l=0, int r=-1){
        if(r < 0) r = sz(a);
        return *min_element(a.begin()+l, a.begin()+r);
    }
    template <class T> auto vv(int d1, T x){
        return vc<T>(d1, x);
    }
    template <class T> auto vv(int d1, int d2, T x){
        return vc<vc<T>>(d1, vc<T>(d2, x));
    }
    template <class T> auto vv(int d1, int d2, int d3, T x){
        return vc<vc<vc<T>>>(d1, vv(d2, d3, x));
    }
    template <class T> auto vv(int d1, int d2, int d3, int d4, T x){
        return vc<vc<vc<vc<T>>>>(d1, vv(d2, d3, d4, x));
    }
    void outv(auto &v){
        for(auto &x: v) {cout<< x <<"" "";} cout<<endl;
    }
    void rvec(int &n, auto &v){
        cin >> n; v.resize(n); for(auto &x: v) cin >> (x);
    }
    template <typename Arg, typename... Args>
    void read(Arg&& arg, Args&&... args){
        cin >> std::forward<Arg>(arg); using expander = int[];
        (void)expander{0, (void(cin >> std::forward<Args>(args)),0)...};
    }
    template <typename Arg, typename... Args>
    void out(Arg&& arg, Args&&... args){
        cout << std::forward<Arg>(arg); using expander = int[];
        (void)expander{0, (void(cout << "" "" << std::forward<Args>(args)),0)...};
        cout << endl;
    }
    template <class Integer, class F>
    Integer find_first_false(Integer l, Integer r, F&& f) {
        --l; // ++r;
        while (r - l > 1) {
            Integer m = midpoint(l, r);
            if (f(m)) l = m;
            else r = m;
        }
        return r;
    }
    template <class Integer, class F>
    Integer find_last_true(Integer l, Integer r, F &&f) {
        return find_first_false(l, r, [&f](Integer i) { return f(i); }) - 1;
    }
    template <class Integer, class F>
    Integer find_first_true(Integer l, Integer r, F &&f) {
        return find_first_false(l, r, [&f](Integer i) { return !f(i); });
    }
    auto init = []() {
        ios::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL); return 'c';
    }();

    ll pwr(ll base, ll p, ll mod){
        ll ans=1; while(p) {if(p&1) ans=(ans*base)%mod;
            base=(base*base)%mod; p/=2;}
        return ans;
    }
    ll gcd(ll a, ll b) {  return b == 0 ? a : gcd(b,a%b); }
    ll lcm(ll a, ll b) {  return a*(b/gcd(a,b)); }

    const long double PI = (long double)(3.1415926535897932384626433832795);
    const ll  mx_ll   = numeric_limits<ll> :: max();
    const int mx_int  = numeric_limits<int> :: max();

    const int oo = 0x3f3f3f3f;
    const ll  OO = 0x3f3f3f3f3f3f3f3fll;
    const double eps = 1e-9;
    const int DX[8]={0,1, 0,-1,-1,1,-1, 1};
    const int DY[8]={1,0,-1, 0,-1,1, 1,-1};

const int maxn = 1e5 + 3;
const int mod = 1e9+7;
namespace mod_util {
    using i64 = long long;
    template<class T>
    constexpr T power(T a, i64 b) {
        T res = 1;
        for (; b; b /= 2, a *= a) {
            if (b % 2) {
                res *= a;
            }
        }
        return res;
    }

    template<int P>
    struct MInt {
        i64 x;
        constexpr MInt() : x{} {}
        constexpr MInt(i64 x_input) : x{norm(x_input % getMod())} {}

        static int Mod;
        static MInt power(MInt a, i64 b) {
            return mod_util::power(a, b);
        }
        constexpr static int getMod() {
            if (P > 0) {
                return P;
            } else {
                return Mod;
            }
        }
        constexpr static void setMod(int Mod_) {
            Mod = Mod_;
        }
        constexpr i64 norm(i64 val) const {
            if (val < 0) {
                val += getMod();
            }
            if (val >= getMod()) {
                val -= getMod();
            }
            return val;
        }
        constexpr i64 val() const {
            return x;
        }
        explicit constexpr operator ll() const {
            return x;
        }
        constexpr MInt operator-() const {
            MInt res;
            res.x = norm(getMod() - x);
            return res;
        }
        constexpr MInt inv() const {
            assert(x != 0);
            return power(*this, getMod() - 2);
        }
        constexpr MInt &operator*=(MInt rhs) & {
            x = 1LL * x * rhs.x % getMod();
            return *this;
        }
        constexpr MInt &operator+=(MInt rhs) & {
            x = norm(x + rhs.x);
            return *this;
        }
        constexpr MInt &operator-=(MInt rhs) & {
            x = norm(x - rhs.x);
            return *this;
        }
        constexpr MInt &operator/=(MInt rhs) & {
            return *this *= rhs.inv();
        }
        constexpr MInt &operator^=(MInt rhs) & {
            return *this = power(*this, rhs.x);
        }
        constexpr MInt pow(ll rhs) {
            return *this = power(*this, rhs);
        }
        friend constexpr MInt operator*(MInt lhs, MInt rhs) {
            MInt res = lhs;
            res *= rhs;
            return res;
        }
        friend constexpr MInt operator+(MInt lhs, MInt rhs) {
            MInt res = lhs;
            res += rhs;
            return res;
        }
        friend constexpr MInt operator-(MInt lhs, MInt rhs) {
            MInt res = lhs;
            res -= rhs;
            return res;
        }
        friend constexpr MInt operator/(MInt lhs, MInt rhs) {
            MInt res = lhs;
            res /= rhs;
            return res;
        }
        friend constexpr MInt operator^(MInt lhs, MInt rhs) {
            MInt res = lhs;
            res ^= rhs;
            return res;
        }
        friend constexpr istream &operator>>(istream &is, MInt &a) {
            i64 v;
            is >> v;
            a = MInt(v);
            return is;
        }
        friend constexpr ostream &operator<<(ostream &os, const MInt &a) {
            return os << a.val();
        }
        friend constexpr bool operator==(MInt lhs, MInt rhs) {
            return lhs.val() == rhs.val();
        }
        friend constexpr bool operator!=(MInt lhs, MInt rhs) {
            return lhs.val() != rhs.val();
        }
    };

    template<>
    int MInt<0>::Mod = mod;

    template<int V, int P>
    constexpr MInt<P> CInv = MInt<P>(V).inv();

    constexpr int P = mod;
    using Z = MInt<P>;

    struct Comb {
        int N;
        vector<Z> _fac;
        vector<Z> _invfac;
        vector<Z> _inv;

        Comb() : N{0}, _fac{1}, _invfac{1}, _inv{0} {}
        Comb(int n) : Comb() {
            init(n);
        }

        void init(int m) {
            m = min(m, Z::getMod() - 1);
            if (m <= N) return;
            _fac.resize(m + 1);
            _invfac.resize(m + 1);
            _inv.resize(m + 1);

            for (int i = N + 1; i <= m; i++) {
                _fac[i] = _fac[i - 1] * i;
            }
            _invfac[m] = _fac[m].inv();
            for (int i = m; i > N; i--) {
                _invfac[i - 1] = _invfac[i] * i;
                _inv[i] = _invfac[i] * _fac[i - 1];
            }
            N = m;
        }
        void check_init(int m){
            if (m > N) init(2 * m);
        }
        Z fac(int m) {
            check_init(m);
            return _fac[m];
        }
        Z invfac(int m) {
            check_init(m);
            return _invfac[m];
        }
        Z inv(int m) {
            check_init(m);
            return _inv[m];
        }
        Z binom(int n, int k) { // choose k out of n
            if (n < k || k < 0) return 0;
            return fac(n) * invfac(k) * invfac(n - k);
        }
        Z choose(int k, int n) { // choose k out of n
            return binom(n, k);
        }
    } comb;
}
using Z = mod_util::MInt<mod>;
auto &comb = mod_util::comb;
class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& a) {
        int n = sz(a);
        int hi = MAX(a) + 1;
        debug3(n, hi, a);
        // vc<Z> dp(hi);
        vc<Z> cnt(hi), sum(hi);
        for(int x: a){
            cnt[x] += 1;
            sum[x] += x;
            if(x > 0 ){
                cnt[x] += cnt[x-1];
                sum[x] += cnt[x-1] * x + sum[x-1];
            }
            if(x+1 < hi ){
                cnt[x] += cnt[x+1];
                sum[x] += cnt[x+1] * x + sum[x+1];
            }
            debug3(x, cnt[x], sum[x]);
        }
        Z ans = 0;
        forn(i, hi) ans += sum[i];
        return int(ans.val());
    }
};

#ifdef LOCAL_RUN
void _solve(){
    Solution sol;
    vi a; cin >> a;
    out(sol.sumOfGoodSubsequences(a));
}


/*************************************************************************/
int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    //cout.precision(15);
    // return 0;
    while(cin.peek() == 32 or cin.peek() == 10) cin.get();
    while(cin.peek() != EOF){
        _solve();
        while(cin.peek() == 32 or cin.peek() == 10) cin.get();
    }
}
#endif
",1448217249
IphoneX,hahahiehie,169,3612,java,"import java.util.*;

class Utils {
    public static int log2(long n) {
        return 63 - Long.numberOfLeadingZeros(n);
    }

    // nums = ""aaabaaaba"" odd d[1] return [1, 2, 1, 4, 1, 2, 2]
    // d[0] for even, d[1] for odd
    public static int[][] manacher(String s) {
        int n = s.length();
        int[] d1 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; ++i) {
            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s.charAt(i - k) == s.charAt(i + k)) k++;
            d1[i] = k;
            if (i + k - 1 > r) {
                l = i - k + 1;
                r = i + k - 1;
            }
        }

        int[] d0 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : Math.min(d0[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s.charAt(i - k - 1) == s.charAt(i + k)) {
                k++;
            }
            d0[i] = k;
            if (i + k - 1 > r) {
                l = i - k;
                r = i + k - 1;
            }
        }
        return new int[][]{d0, d1};
    }

    // generate primes that is <= n
    public static int[] genPrimes(int n) {
        if (n <= 1) return new int[0];
        boolean[] isComp = new boolean[n + 1];
        int len = 0;
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                len++;
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                }
            }
        }
        int[] ans = new int[len];
        for (int i = 2, j = 0; i <= n; i++) {
            if (!isComp[i]) {
                ans[j++] = i;
            }
        }
        return ans;
    }

    // int[0] = primeFactor, int[1] = count of that primeFactor
    // NOTE: factors[0] and factors[1] are empty list.
    public static List<int[]>[] genPrimeFactors(int n) {
        List<int[]>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            factors[i] = new ArrayList<>();
        }
        boolean[] isComp = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                factors[i].add(new int[]{i, 1});
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                    int t = j, count = 0;
                    while (t % i == 0) {
                        count++;
                        t /= i;
                    }
                    factors[j].add(new int[]{i, count});
                }
            }
        }
        return factors;
    }

    // generate factors (not prime factors), factors[0] is empty list.
    public static List<Integer>[] genFactors(int n) {
        List<Integer>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) factors[i] = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j += i) {
                factors[j].add(i);
            }
        }
        return factors;
    }

    public static int lowerBound(int[] a, int target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(int[] a, int target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(long[] a, long target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(long[] a, long target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static long or(int x, int y) {
        return ((long) x << 32) | ((long) y << 32 >>> 32);
    }

    // k = 0...nums.length - 1
    // After calling this function, nums[k] is the k-th number.
    public static int kthNumber(int[] nums, int k) {
        return kthNumberHelper(nums, k, 0, nums.length - 1);
    }

    // end is inclusive (0 to nums.length - 1)
    private static int kthNumberHelper(int[] nums, int K, int start, int end) {
        if (start == end) return nums[start];
        int i = partition(nums, start, end);
        return K <= i ? kthNumberHelper(nums, K, start, i) : kthNumberHelper(nums, K, i + 1, end);
    }

    // end is inclusive (0 to nums.length - 1)
    public static int partition(int[] nums, int start, int end) {
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && nums[i] < pivot) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && pivot < nums[j]) j--;
            if (i < j) nums[i++] = nums[j];
        }

        // pos is the final position for pivot.
        nums[i] = pivot;
        return i;
    }

    public static void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    // partition nums into 3 parts [smaller than pivot, equal to pivot, larger than pivot]
    public static void partition3(int[] nums, int pivot) {
        int n = nums.length;
        int l = 0, r = n - 1;
        for (int i = 0; i <= r; i++) {
            if (nums[i] < pivot) {
                swap(nums, l++, i);
            } else if (nums[i] > pivot) {
                swap(nums, r--, i--);
            }
        }
    }

    // end is inclusive
    public static void reverse(int[] nums, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    }

    // Return false if next permutation is not available. (nums is not changed for this case)
    public static boolean nextPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] >= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] > nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // Return false if previous permutation is not available. (nums is not changed for this case)
    public static boolean prevPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] <= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] < nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }


    // a, b could be negative
    // remainder >= 0
    // return [a / b, a % b]
    public static int[] divMod(int a, int b) {
        int r = a % b;
        int c = a / b;
        if (r < 0) {
            r += Math.abs(b);
            c++;
        }
        return new int[]{c, r};
    }

    public static List<Integer> negativeBase(int n, int base) {
        List<Integer> digits = new ArrayList<>();
        if (n == 0) {
            digits.add(0);
            return digits;
        }
        while (n != 0) {
            // t[0] = n / base
            // t[1] = n % base;
            int[] t = divMod(n, base);
            digits.add(t[1]);
            n = t[0];
        }
        Collections.reverse(digits);
        return digits;
    }

    // (a ^ b) % MOD
    public static long powMod(long a, long b, long MOD) {
        long res = 1L;
        a %= MOD; // In case a * a is overflow
        while (b > 0) {
            if ((b & 1) != 0) res = (res * a) % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    public static long[][] genCombination(int n) {
        long[][] C = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        return C;
    }

    public static long[][] genPermutation(int n) {
        long[][] P = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
        return P;
    }

    public static long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }

    public static int[] preprocessLog2(int n) { // from log2(0) .... log2(n) inclusive
        int[] lg = new int[n + 1];
        for (int k = 0, i = 1; i <= n; lg[i++] = k - 1) {
            while ((1 << k) <= i) {
                k++;
            }
        }
        return lg;
    }

    public static long max(long[] nums) {
        long ret = Long.MIN_VALUE;
        for (long v : nums) ret = Math.max(ret, v);
        return ret;
    }

    public static int max(int[] nums) {
        int ret = Integer.MIN_VALUE;
        for (int v : nums) ret = Math.max(ret, v);
        return ret;
    }
}

// Tested by leetcode 1163
class SuffixArray {
    int[] s;
    int[] SA; // SA[i] => index of the i-th ranked suffix
    int[] rank; // rank[i] => the rank of i-th suffix, SA[rank[i]] == i
    int[] height; // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).

    private int[][] d;
    private int n;
    private int[] lg;

    private int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    private static int[] stringToIntArray(String str) {
        int[] nums = new int[str.length()];
        for (int i = 0; i < str.length(); i++) nums[i] = str.charAt(i);
        return nums;
    }

    public SuffixArray(String str) {
        this(str, true);
    }

    public SuffixArray(String str, boolean toBuildRMQ) {
        this(stringToIntArray(str), toBuildRMQ);
    }

    public SuffixArray(int[] nums) {
        this(nums, true);
    }

    public SuffixArray(int[] nums, boolean toBuildRMQ) {
        this.s = nums;
        this.n = nums.length;
        this.SA = new int[n];
        this.rank = new int[n];
        suffixSort(s);
        if (toBuildRMQ) {
            this.height = new int[n];
            this.d = new int[log2(n) + 1][n];
            this.lg = new int[n + 1];
            buildHeight();
            buildRMQ();
        }
    }

    // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).
    // ?? s[n] = 0 or s[n] = -INF.
    private void buildHeight() {
        int i, j, h;
        height[0] = 0;
        for (i = 0; i < n; i++)
            rank[SA[i]] = i;
        for (h = i = 0; i < n; i++)
            if (rank[i] > 0) {
                j = SA[rank[i] - 1];
                while (i + h < n && j + h < n && s[i + h] == s[j + h]) ++h;
                height[rank[i]] = h;
                if (h > 0) --h;
            }
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    private void buildRMQ() {
        int i, j, k;
        for (i = 0; i < n; i++)
            d[0][i] = height[i];
        for (j = 1; (1 << j) <= n; j++)
            for (i = 0; i + (1 << j) <= n; i++)
                d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
        for (lg[0] = k = 0, i = 1; i <= n; lg[i++] = k - 1)
            while ((1 << k) <= i) k++;
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    public int LCP(int i, int j) {
        if (i == j) return n - SA[i];
        if (i > j) {
            int t = i;
            i = j;
            j = t;
        }
        int k = lg[j - (++i) + 1];
        return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }

    // LCPIndex(i, j) = LCP(s[i], s[j])
    public int LCPIndex(int i, int j) {
        return LCP(rank[i], rank[j]);
    }

    private void sortIndex(int[] nums, int start, int end) {
        if (start >= end) return;
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && s[nums[i]] < s[pivot]) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && s[pivot] < s[nums[j]]) j--;
            if (i < j) nums[i++] = nums[j];
        }
        nums[i] = pivot; // index i is the final position for pivot.
        sortIndex(nums, start, i - 1);
        sortIndex(nums, i + 1, end);
    }

    private void suffixSort(int[] s) {
        int[] count = new int[n], t;
        int[] nSA = new int[n];
        int[] nRank = new int[n];
//        Integer[] tempArray = new Integer[n];
//        for (int x = 0; x < n; x++) tempArray[x] = x;
//        Arrays.sort(tempArray, (a, b) -> Integer.compare(s[a], s[b]));
//        for (int x = 0; x < n; x++) SA[x] = tempArray[x];
        int i, k;
        int minV = s[0], maxV = s[0];
        for (i = 1; i < n; i++) {
            minV = Math.min(minV, s[i]);
            maxV = Math.max(maxV, s[i]);
        }
        if ((long) maxV - minV + 1 <= (long) n) { // radix sort if alphabet size is small
            for (i = 0; i < n; i++) count[s[i] - minV]++;
            for (i = minV + 1; i <= maxV; i++) count[i - minV] += count[i - minV - 1];
            for (i = n - 1; i >= 0; i--) SA[--count[s[i] - minV]] = i;
        } else {
            for (i = 0; i < n; i++) SA[i] = i;
            sortIndex(SA, 0, n - 1);
        }
        for (rank[SA[0]] = 0, i = 1; i < n; i++) {
            rank[SA[i]] = (s[SA[i]] != s[SA[i - 1]]) ? rank[SA[i - 1]] + 1 : rank[SA[i - 1]];
        }
        for (k = 1; k < n && rank[SA[n - 1]] < n - 1; k <<= 1) {
            for (i = 0; i < n; i++) count[rank[SA[i]]] = i + 1;
            for (i = n - 1; i >= 0; i--) if (SA[i] >= k) nSA[--count[rank[SA[i] - k]]] = SA[i] - k;
            for (i = n - k; i < n; i++) nSA[--count[rank[i]]] = i;
            t = SA;
            SA = nSA;
            nSA = t;
            for (nRank[SA[0]] = 0, i = 1; i < n; i++) {
                nRank[SA[i]] = (SA[i] + k >= n || SA[i - 1] + k >= n || rank[SA[i]] != rank[SA[i - 1]] || rank[SA[i] + k] != rank[SA[i - 1] + k]) ? nRank[SA[i - 1]] + 1 : nRank[SA[i - 1]];
            }
            t = rank;
            rank = nRank;
            nRank = t;
        }
    }
}

class Combination {
    long[] factorial;
    long[] inverseFactorial;
    long MOD;

    // O(maxSize) for preprocessing
    // MOD must be prime
    public Combination(int maxSize, long MOD) {
        factorial = new long[maxSize + 1];
        inverseFactorial = new long[maxSize + 1];
        factorial[0] = 1;
        inverseFactorial[0] = 1;
        this.MOD = MOD;
        for (int i = 1; i <= maxSize; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
            inverseFactorial[i] = inverse(factorial[i]);
        }
    }

    // x, y are long[1]
    // ax + by = gcd(a, b)
    private long extGcd(long a, long b, long[] x, long[] y) {
        if (b == 0) {
            x[0] = 1;
            y[0] = 0;
            return a;
        } else {
            long r = extGcd(b, a % b, y, x);
            y[0] -= x[0] * (a / b);
            return r;
        }
    }

    // (a * x) % MOD = 1
    // x is the inverse element
    public long inverse(long a) {
        long[] x = new long[1], y = new long[1];
        extGcd(a, MOD, x, y);
        return (x[0] % MOD + MOD) % MOD;
    }

    // m >= n
    // O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        else if (m == n) return factorial[m];
            //return factorial[m] * inverse(factorial[m - n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD;
    }

    // m >= n
    // O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
            //return factorial[m] * inverse(factorial[m - n]) % MOD * inverse(factorial[n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD * inverseFactorial[n] % MOD;
    }
}

class CombinationNoMod {

    long[][] C;
    long[][] P;

    public CombinationNoMod(int maxSize) {
        C = new long[maxSize + 1][maxSize + 1];
        P = new long[maxSize + 1][maxSize + 1];
        int m = C.length;
        int n = C[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
    }

    // m >= n. O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        return P[m][n];
    }

    // m >= n. O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
        return C[m][n];
    }
}

class Fraction {
    long n, d; // n / d (d != 0)

    public Fraction(long n, long d) {
        if (d == 0) {
            this.n = Long.MAX_VALUE;
            this.d = 1;
            return;
        }
        long g = gcd(Math.abs(n), Math.abs(d));
        this.n = n / g;
        this.d = d / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    public void add(Fraction other) {
        long numerator = this.n * other.d + this.d * other.n;
        long denominator = this.d * other.d;
        long g = gcd(Math.abs(numerator), Math.abs(denominator));
        this.n = numerator / g;
        this.d = denominator / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    @Override
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof Fraction) {
            Fraction anotherObject = (Fraction) anObject;
            return n == anotherObject.n && d == anotherObject.d;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return (int) (n * 31 + d);
    }

    private long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }
}

class UnionFind {
    int[] parent;
    int[] sz;

    // from 0 ... n - 1
    public UnionFind(int n) {
        parent = new int[n];
        sz = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public void clear() {
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public int find(int x) {
        //return parent[x] == x ? x : (parent[x] = find(parent[x]));
        if (parent[x] == x) return x;
        int px = x;
        while (px != parent[px]) px = parent[px];
        while (x != px) {
            int next = parent[x];
            parent[x] = px;
            x = next;
        }
        return px;
    }

    // px is the final parent
    public boolean union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return false;
        parent[py] = px;
        sz[px] += sz[py];
        return true;
    }

    public int size(int x) {
        return sz[find(x)];
    }

    public UnionFind clone() {
        UnionFind cloned = new UnionFind(parent.length);
        for (int i = 0; i < parent.length; i++) {
            cloned.parent[i] = parent[i];
            cloned.sz[i] = sz[i];
        }
        return cloned;
    }
}

class Trie {
    static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        boolean isWord = false;
        long count = 0L;
    }

    TrieNode root = new TrieNode();

    public void add(String word) {
        add(word, 1L);
    }

    public void remove(String word) {
        add(word, -1L);
    }

    private void add(String word, long count) {
        TrieNode cur = root;
        cur.count += count;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) cur.next[c] = new TrieNode();
            cur = cur.next[c];
            cur.count += count;
        }
        cur.isWord = true;
    }

    public boolean contains(String word) {
        TrieNode cur = root;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null || cur.next[c].count <= 0L) return false;
            cur = cur.next[c];
            //if (cur.isWord) return true;
        }
        return cur.isWord;
    }
}

// Tested by Leetcode 1707 and Leetcode 1803
class TrieBinary {
    static class TrieNode {
        TrieNode[] next = new TrieNode[2];
        long count;
    }

    private TrieNode root;
    private int numOfBits;

    public TrieBinary(int numOfBits) { // normally 31 for int and 63 for long
        this.numOfBits = numOfBits;
        this.root = new TrieNode();
    }

    public void add(long v) {
        add(v, 1L);
    }

    public void remove(long v) { // Tested by Leetcode 1938
        add(v, -1L);
    }

    public void add(long v, long count) {
        TrieNode cur = root;
        root.count += count;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null) cur.next[b] = new TrieNode();
            cur = cur.next[b];
            cur.count += count;
        }
    }

    // Tested by Leetcode 1707
    public long xorMax(long v) {
        TrieNode cur = root;
        long key = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[1 - b] != null && cur.next[1 - b].count > 0) {
                cur = cur.next[1 - b];
                key |= (1L - b) << i;
            } else {
                cur = cur.next[b];
                key |= (long) b << i;
            }
        }
        return key ^ v;
    }

    public boolean contains(long v) {
        TrieNode cur = root;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null || cur.next[b].count <= 0) return false;
            cur = cur.next[b];
        }
        return true;
    }

    // Tested by Leetcode 1803
    // count(x ^ v <= limit)
    public long xorLessOrEqualCount(long v, long limit) {
        if (limit < 0) return 0;
        TrieNode cur = root;
        long ans = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int bitLimit = ((limit >>> i) & 1) == 0 ? 0 : 1;
            int bitV = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (bitLimit == 1) {
                ans += (cur.next[bitV] != null ? cur.next[bitV].count : 0);
            }
            cur = cur.next[bitV ^ bitLimit];
            if (cur == null) break;
            if (i == 0) ans += cur.count;
        }
        return ans;
    }
}

// Lazy execution example is in https://leetcode.com/submissions/detail/1034182539/
// Refer to AlgorithmCompilation.java

// [Template] Classic Segment Tree (Range Sum), used for Template
class ClassicSegmentTree { // For Range Sum
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final int L, R;

    public ClassicSegmentTree(int[] input) {
        L = 0;
        R = input.length - 1;
        root = new TreeNode();
        build(root, L, R, input);
    }

    private void build(TreeNode root, int l, int r, int[] input) {
        if (l == r) {
            root.sum = input[l];
            return;
        }
        int m = (l + r) >> 1;
        root.left = new TreeNode();
        root.right = new TreeNode();
        build(root.left, l, m, input);
        build(root.right, m + 1, r, input);
        root.sum = root.left.sum + root.right.sum;
    }

    public void set(int index, int value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, int L, int R, int index, int value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        int M = L + ((R - L) >> 1);
        if (index <= M) {
            set(root.left, L, M, index, value);
        } else {
            set(root.right, M + 1, R, index, value);
        }
        root.sum = root.left.sum + root.right.sum;
    }

    // Sum[queryL...queryR] inclusive
    public long query(int queryL, int queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, int L, int R, int queryL, int queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        int M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 307
class DynamicSegmentTreeRangeSum {
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeSum(long l, long r) {
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return sum(cur);
    }

    public void add(long index, long value) {
        set(index, get(index) + value);
    }

    private long sum(TreeNode node) {
        return node == null ? 0L : node.sum;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.sum = sum(root.left) + sum(root.right);
    }

    // Sum[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        long M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 239, 2926
class DynamicSegmentTreeRangeMax {
    class TreeNode {
        TreeNode left, right;
        long max = Long.MIN_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMax(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return max(cur);
    }

    private long max(TreeNode node) {
        return node == null ? Long.MIN_VALUE : node.max;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.max = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.max = Math.max(max(root.left), max(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MIN_VALUE;
        if (queryL <= L && R <= queryR) return root.max;
        long M = L + ((R - L) >> 1);
        return Math.max(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class DynamicSegmentTreeRangeMin {
    class TreeNode {
        TreeNode left, right;
        long min = Long.MAX_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMin(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return min(cur);
    }

    private long min(TreeNode node) {
        return node == null ? Long.MAX_VALUE : node.min;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.min = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.min = Math.min(min(root.left), min(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MAX_VALUE;
        if (queryL <= L && R <= queryR) return root.min;
        long M = L + ((R - L) >> 1);
        return Math.min(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class BinaryIndexTree {
    private long[] c;
    private int n;

    // NOTE: index is from 1 to n. (NOT 0 ... n - 1)
    public BinaryIndexTree(int n) {
        this.n = n;
        this.c = new long[n + 1];
    }

    // Add value to position k, k is from 1 to n.
    public void add(int k, long value) {
        while (k <= n) {
            c[k] += value;
            k += (k & (k ^ (k - 1)));
        }
    }

    // k is from 1 to n.
    public long getSum(int k) {
        long sum = 0;
        while (k > 0) {
            sum += c[k];
            k -= (k & (k ^ (k - 1)));
        }
        return sum;
    }
}

class RangeSum {
    BinaryIndexTree tree;
    int start;

    // [low, high] inclusive
    public RangeSum(int low, int high) {
        start = low;
        tree = new BinaryIndexTree(high - low + 1);
    }

    public void add(int index, long value) {
        tree.add(index - start + 1, value);
    }

    public long get(int index) {
        return tree.getSum(index - start + 1) - tree.getSum(index - start);
    }

    public void set(int index, long value) {
        tree.add(index - start + 1, value - get(index));
    }

    // [l, r] inclusive
    public long getSum(int l, int r) {
        return tree.getSum(r - start + 1) - tree.getSum(l - start);
    }
}

class RangeMax {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMax(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MIN_VALUE);
    }

    public RangeMax(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.max(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMax(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MIN_VALUE, resr = Long.MIN_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.max(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.max(t[--r], resr);
        }
        return Math.max(resl, resr);
    }
}

class RangeMin {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMin(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MAX_VALUE);
    }

    public RangeMin(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.min(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMin(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MAX_VALUE, resr = Long.MAX_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.min(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.min(t[--r], resr);
        }
        return Math.min(resl, resr);
    }
}

// Including topological sort.
class GraphIntegerFaster {
    public List<Integer>[] adj;

    public GraphIntegerFaster(int n) {
        adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    // directed edge x -> y
    public void link(int x, int y) {
        adj[x].add(y);
    }

    public List<Integer> getChildren(int x) {
        return adj[x];
    }

    private static final int TEMPORARY = 1;
    private static final int PERMANENT = 2;

    // x -> y means x should be processed before y
    // The input is a directed graph.
    // 1. return null, means there is a cycle inside the graph, or the input is
    // invalid.
    // 2. return List<Node> as the result.
    public List<Integer> topologicalSort() {
        //Map<E, Integer> vst = new HashMap<>();
        int n = adj.length;
        int[] vst = new int[n];
        List<Integer> result = new ArrayList<>();
        for (int x = 0; x < n; x++) {
            if (!topologicalSort(x, vst, result)) {
                return null;
            }
        }
        Collections.reverse(result);
        return result;
    }

    private boolean topologicalSort(int root, int[] vst, List<Integer> result) {
        if (vst[root] == PERMANENT) {
            return true;
        }
        if (vst[root] == TEMPORARY) { // found cycle
            return false;
        }

        vst[root] = TEMPORARY;
        for (int child : getChildren(root)) {
            if (!topologicalSort(child, vst, result)) {
                return false;
            }
        }
        result.add(root);
        vst[root] = PERMANENT;
        return true;
    }
}

class DijkstraLongFaster {
    public static class Edge {
        int to;
        long w;

        public Edge(int to, long w) {
            this.to = to;
            this.w = w;
        }
    }

    public static final long INF = Long.MAX_VALUE / 4;
    public List<Edge>[] adj;

    public DijkstraLongFaster(int n) {
        this.adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    public void link(int x, int y, long w) {
        adj[x].add(new Edge(y, w));
    }

    public long[] shortestPath(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
        q.add(new Edge(src, 0));
        dist[src] = 0;

        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (vst[cur.to]) continue;
            int u = cur.to;
            long w = cur.w;
            vst[u] = true;

            for (Edge e : adj[u]) {
                if (!vst[e.to] && dist[e.to] > w + e.w) {
                    dist[e.to] = w + e.w;
                    q.add(new Edge(e.to, dist[e.to]));
                }
            }
        }
        return dist;
    }

    // NOTE: w of each edge must be the same.
    public long[] bfs(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        Queue<Integer> q = new ArrayDeque<>();
        q.add(src);
        dist[src] = 0;
        vst[src] = true;

        while (!q.isEmpty()) {
            int u = q.poll();
            long w = dist[u];
            for (Edge e : adj[u]) {
                if (!vst[e.to]) {
                    dist[e.to] = w + e.w;
                    vst[e.to] = true;
                    q.add(e.to);
                }
            }
        }
        return dist;
    }
}

class TreapSet<E> {
    private class Node {
        E key;
        int priority, count, total;
        Node left, right, pnt;

        public Node(E key, int priority, Node pnt) {
            this.key = key;
            this.priority = priority;
            this.pnt = pnt;
            this.count = 1;
            this.total = 1;
        }
    }

    private static final Random RANDOM = new Random();
    private final Comparator<? super E> comparator;
    private Node root;

    public TreapSet(Comparator<? super E> comparator) {
        this.comparator = comparator;
    }

    public boolean isEmpty() {
        return root == null;
    }

    public void clear() {
        root = null;
    }

    public int size() {
        return root == null ? 0 : root.total;
    }

    private int leftRank(Node p) {
        return p.left != null ? p.left.total : 0;
    }

    private int rightRank(Node p) {
        return p.right != null ? p.right.total : 0;
    }

    private void rotateLeft(Node x) {
        Node y = x.right;
        if ((x.right = y.left) != null) y.left.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.left) x.pnt.left = y;
        else x.pnt.right = y;
        y.left = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    private void rotateRight(Node x) {
        Node y = x.left;
        if ((x.left = y.right) != null) y.right.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.right) x.pnt.right = y;
        else x.pnt.left = y;
        y.right = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    public void add(E key) {
        if (root == null) {
            root = new Node(key, RANDOM.nextInt(), null);
            return;
        }
        Node x = root, p = null;
        while (x != null) {
            ++((p = x).total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                ++(x.count);
                return;
            }
        }

        x = new Node(key, RANDOM.nextInt(), p);
        if (comparator.compare(key, p.key) < 0) p.left = x;
        else p.right = x;
        while ((p = x.pnt) != null && p.priority < x.priority) {
            if (p.left == x) rotateRight(p);
            else rotateLeft(p);
        }
    }

    public void remove(E key) {
        Node x = root, p = null;
        while (x != null) {
            --(x.total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                if (--(x.count) > 0) return;
                break;
            }
        }
        if (x == null) return;
        while (x.left != null || x.right != null) {
            if (x.left == null || (x.right != null && x.right.priority > x.left.priority)) {
                rotateLeft(x);
            } else {
                rotateRight(x);
            }
        }
        if ((p = x.pnt) != null) {
            if (p.left == x) p.left = null;
            else p.right = null;
        } else {
            root = null;
        }
        // delete x;
    }

    // number of elements smaller than key
    public int lowerCount(E key) {
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                sum += leftRank(x) + x.count;
                x = x.right;
            } else {
                sum += leftRank(x);
                break;
            }
        }
        return sum;
    }

    // number of elements larger than key
    public int higherCount(E key) {
        //return size() - lowerCount(key) - count(key);
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp > 0) x = x.right;
            else if (cmp < 0) {
                sum += rightRank(x) + x.count;
                x = x.left;
            } else {
                sum += rightRank(x);
                break;
            }
        }
        return sum;
    }

    public int index(E key) {
        return lowerCount(key);
    }

    public E get(int index) // index = 0 ... size - 1
    {
        Node p = root;
        ++index;
        while (true) {
            int t = leftRank(p);
            if (index <= t) p = p.left;
            else {
                if ((index -= t + p.count) <= 0) break;
                p = p.right;
            }
        }
        return p.key;
    }

    public int count(E key) {
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                x = x.right;
            } else {
                return x.count;
            }
        }
        return 0;
    }

    public E first() {
        if (root == null) return null;
        Node x = root;
        while (x.left != null) {
            x = x.left;
        }
        return x.key;
    }

    public E last() {
        if (root == null) return null;
        Node x = root;
        while (x.right != null) {
            x = x.right;
        }
        return x.key;
    }

    public boolean contains(E key) {
        return count(key) > 0;
    }

    public E ceiling(E key) {
        int id = lowerCount(key);
        return id >= size() ? null : get(id);
    }

    public E floor(E key) {
        int id = size() - higherCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E lower(E key) {
        int id = lowerCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E higher(E key) {
        int id = size() - higherCount(key);
        return id >= size() ? null : get(id);
    }

    // return the first index whose value >= target
    // if this value doesn't exist, return index = size()
    public int lowerBound(E target) {
        return lowerCount(target);
    }

    // return the first index whose value > target
    // if this value doesn't exist, return index = size()
    public int upperBound(E target) {
        return size() - higherCount(target);
    }

    public List<E> keys() {
        List<E> list = new ArrayList<>();
        inorder(root, list);
        return list;
    }

    private void inorder(Node x, List<E> list) {
        if (x == null) return;
        inorder(x.left, list);
        list.add(x.key);
        inorder(x.right, list);
    }
}

class ArraySum {
    long[] sum;
    int n;

    // nums index starts from 0 to nums.length - 1;
    public ArraySum(int[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    public ArraySum(long[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    // [l, r], index starts from 0
    public long getSum(int l, int r) {
        // error handling
        if (l > r || !(l >= 0 && l < n && r >= 0 && r < n)) return 0L;
        return sum[r + 1] - sum[l];
    }
}

class TwoDArraySum {
    int[][] sum;
    int m, n;

    // nums index starts from 0
    public TwoDArraySum(final int[][] nums) {
        m = nums.length;
        n = nums[0].length;
        sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + nums[i - 1][j - 1];
            }
        }
    }

    // [(x1, y1), (x2, y2)], index starts from 0
    // x1 <= x2 and y1 <= y2
    public int getSum(int x1, int y1, int x2, int y2) {
        if (!(x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && x2 >= 0 && x2 < m && y2 >= 0 && y2 < n) || x1 > x2 || y1 > y2)
            return 0;
        return sum[x2 + 1][y2 + 1] - sum[x2 + 1][y1] - sum[x1][y2 + 1] + sum[x1][y1];
    }
}

class ArrayUtils {
    static void fill(int[] array, int defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(int[][] array, int defaultValue) {
        for (int[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(int[][][] array, int defaultValue) {
        for (int[][] a2 : array) {
            for (int[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(int[][][][] array, int defaultValue) {
        for (int[][][] a3 : array) {
            for (int[][] a2 : a3) {
                for (int[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(int[][][][][] array, int defaultValue) {
        for (int[][][][] a4 : array) {
            for (int[][][] a3 : a4) {
                for (int[][] a2 : a3) {
                    for (int[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(int[][][][][][] array, int defaultValue) {
        for (int[][][][][] a5 : array) {
            for (int[][][][] a4 : a5) {
                for (int[][][] a3 : a4) {
                    for (int[][] a2 : a3) {
                        for (int[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }

    static void fill(long[] array, long defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(long[][] array, long defaultValue) {
        for (long[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(long[][][] array, long defaultValue) {
        for (long[][] a2 : array) {
            for (long[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(long[][][][] array, long defaultValue) {
        for (long[][][] a3 : array) {
            for (long[][] a2 : a3) {
                for (long[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(long[][][][][] array, long defaultValue) {
        for (long[][][][] a4 : array) {
            for (long[][][] a3 : a4) {
                for (long[][] a2 : a3) {
                    for (long[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(long[][][][][][] array, long defaultValue) {
        for (long[][][][][] a5 : array) {
            for (long[][][][] a4 : a5) {
                for (long[][][] a3 : a4) {
                    for (long[][] a2 : a3) {
                        for (long[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }
}

class CharacterUtils {
    static boolean[] vowel = new boolean[128];

    static {
        vowel['a'] = vowel['e'] = vowel['i'] = vowel['o'] = vowel['u'] = true;
        vowel['A'] = vowel['E'] = vowel['I'] = vowel['O'] = vowel['U'] = true;
    }

    static boolean isVowel(char ch) {
        return vowel[ch];
    }

    static boolean isLetter(char ch) {
        return ((ch - 'a') >= 0 && (ch - 'a') < 26) ||
                ((ch - 'A') >= 0 && (ch - 'A') < 26);
    }

    static boolean isLowerCase(char ch) {
        return (ch - 'a') >= 0 && (ch - 'a') < 26;
    }

    static boolean isUpperCase(char ch) {
        return (ch - 'A') >= 0 && (ch - 'A') < 26;
    }

    static boolean isDigit(char ch) {
        return (ch - '0') >= 0 && (ch - '0') <= 9;
    }
}

class DoubleUtils {
    private static final double EPS = 1e-8;

    public static int compare(double a, double b) {
        if (a - b > EPS) return 1;
        else if (a - b < -EPS) return -1;
        else return 0;
    }

    public static boolean isInteger(double a) {
        return compare(floor(a), a) == 0;
    }

    public static double floor(double a) {
        return Math.floor(a + EPS);
    }

    public static double ceil(double a) {
        return Math.ceil(a - EPS);
    }
}

class MatrixUtils {
    static final long MOD = 1_000_000_007L;

    // matrix[n][n], matrix[i][i] = 1
    static long[][] genIdentityMatrix(int n) {
        long[][] matrix = new long[n][n];
        for (int i = 0; i < n; i++) matrix[i][i] = 1;
        return matrix;
    }

    static long[][] multiply(long[][] a, long[][] b, long MOD) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]) % MOD;
                }
            }
        }
        return res;
    }

    static long[][] multiply(long[][] a, long[][] b) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]);
                }
            }
        }
        return res;
    }

    // a^b % MOD
    static long[][] powMod(long[][] a, long b, long MOD) {
        int n = a.length;
        long[][] res = genIdentityMatrix(n);
        while (b > 0) {
            if ((b & 1) != 0) res = multiply(res, a, MOD);
            a = multiply(a, a, MOD);
            b >>= 1;
        }
        return res;
    }

    static void print(long[][] matrix) {
        for (int i = 0; i < matrix.length; i++) {
            System.out.println(Arrays.toString(matrix[i]));
        }
    }
}

class IntegerUtils {
    static long[] power10 = new long[19]; // 10^i

    static {
        power10[0] = 1L;
        for (int i = 1; i < power10.length; i++) {
            power10[i] = power10[i - 1] * 10;
        }
    }

    // swap index i and j of integer (long) num. i == 0 means the lowest position.
    static long swapDigit(long num, int i, int j) {
        if (i == j) return num;
        long di = num / power10[i] % 10L;
        long dj = num / power10[j] % 10L;
        return num - di * power10[i] - dj * power10[j] + dj * power10[i] + di * power10[j];
    }
}

class StringUtils {
    // This function is deprecated, please hash(int l, int r) in class StableStringHash or StringHash
    // rolling hash of substrings of 's' with length == k
    // long[pos] = hash(s.substring(pos, pos + k))
    public static long[] rollingHash(String s, int k) {
        long[] ans = new long[s.length() - k + 1];
        int seed1 = 31;
        int seed2 = 131;
        int h1 = 0, h2 = 0, power1 = 1, power2 = 1;
        for (int i = 0; i < k; i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);

            power1 *= seed1;
            power2 *= seed2;
        }

        ans[0] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        for (int i = k; i < s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i) - power1 * s.charAt(i - k);
            h2 = h2 * seed2 + s.charAt(i) - power2 * s.charAt(i - k);
            ans[i - k + 1] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        }

        return ans;
    }

    public static int[] kmpNext(String s) {
        int n = s.length();
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s.charAt(i) != s.charAt(k)) k = next[k - 1];
            if (s.charAt(i) == s.charAt(k)) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(String s, String p) {
        int[] next = kmpNext(p);
        int n = s.length();
        int m = p.length();
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p.charAt(j) != s.charAt(i)) {
                j = next[j - 1];
            }
            if (p.charAt(j) == s.charAt(i)) j++;
            if (j == m) return true;
        }
        return false;
    }

    public static int[] kmpNext(int[] s) {
        int n = s.length;
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s[i] != s[k]) k = next[k - 1];
            if (s[i] == s[k]) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(int[] s, int[] p) {
        int[] next = kmpNext(p);
        int n = s.length;
        int m = p.length;
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p[j] != s[i]) {
                j = next[j - 1];
            }
            if (p[j] == s[i]) j++;
            if (j == m) return true;
        }
        return false;
    }

    // Z[i] = longest length of common prefix of str[0 ... n - 1] and str[i ... n - 1]
    // Tested by LC2223, LC459
    public static int[] zFunction(String str) {
        int n = str.length();
        int[] Z = new int[n];
        // [L,R] makes a window which matches with prefix of s
        int L = 0, R = 0;
        Z[0] = n;
        for (int i = 1; i < n; ++i) {
            if (i > R) {
                L = R = i;
                while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                Z[i] = R - L;
                R--;
            } else {
                int k = i - L;
                if (Z[k] < R - i + 1) {
                    Z[i] = Z[k];
                } else {
                    L = i;
                    while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                    Z[i] = R - L;
                    R--;
                }
            }
        }
        return Z;
    }
}

// Better to use this when length of string >= 2^11
class StringHash {
    static class SingleStringHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleStringHash(String s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length();
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s.charAt(i - 1)) % MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleStringHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L;

    public StringHash(String s) {
        hash1 = new SingleStringHash(s, SEED1, MOD);
        hash2 = new SingleStringHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(String s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length(); i++) {
            h1 = (h1 * SEED1 + s.charAt(i)) % MOD;
            h2 = (h2 * SEED2 + s.charAt(i)) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(char[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class IntegerArrayHash {
    static class SingleIntegerArrayHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleIntegerArrayHash(int[] s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length;
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s[i - 1]) % MOD;
                if (h[i] < 0) h[i] += MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleIntegerArrayHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L; // or 1_000_000_123L

    public IntegerArrayHash(int[] s) {
        hash1 = new SingleIntegerArrayHash(s, SEED1, MOD);
        hash2 = new SingleIntegerArrayHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(int[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(List<Integer> s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.size(); i++) {
            h1 = (h1 * SEED1 + s.get(i)) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s.get(i)) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class RMQ { // NOTE!!! query return index, not value
    // tested by LC 1438,239
    final long[] a; // input data array copy
    int[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQ(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQ(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new int[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = i;
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = a[d[j - 1][i]] >= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                } else {
                    d[j][i] = a[d[j - 1][i]] <= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                }
    }

    // i <= j, and index starts from 0.
    public int query(int i, int j) { // NOTE!!! return index, not value
        int k = log2[j - i + 1];
        if (useMax) return a[d[k][i]] >= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
        else return a[d[k][i]] <= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
    }
}

class RMQValue { // NOTE!!! query return value, not index
    final long[] a; // input data array copy
    long[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQValue(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQValue(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new long[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = a[i];
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = Math.max(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                } else {
                    d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                }
    }

    // i <= j, and index starts from 0.
    public long query(int i, int j) {
        int k = log2[j - i + 1];
        if (useMax) return Math.max(d[k][i], d[k][j - (1 << k) + 1]);
        else return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }
}

// Tested by 2827
// Similar: 1012, 2376, 902, 2719, 2801, 357, 1215, 1397
class DigitDP {
    static final boolean ENABLE_DEBUG_MODE = false; // TODO: set it to true if you want to print more debug info
    static final long UNSET = -1;
    // dp[isStart][hasLimit][pos] | [odd][even][r]
    // (isStart, hasLimit, pos) is generic, (odd, even, r) is use case specific
    long[][][][][][] dp;
    int K;

    public long digitDP(long num, int k) {
        String numString = String.valueOf(num); // TODO
        this.dp = new long[2][2][numString.length()][numString.length() + 1][numString.length() + 1][k];
        this.K = k;

        if (ENABLE_DEBUG_MODE) System.out.println(""num = "" + numString);
        ArrayUtils.fill(dp, UNSET);
        long ans = dfs(new StringBuilder(), numString, 1, 1, 0, 0, 0, 0);
        if (ENABLE_DEBUG_MODE) System.out.println(""---------------------\n"");
        return ans;
    }

    long dfs(StringBuilder curResult, String s, int isStart, int hasLimit, int pos, int odd, int even, int r) {
        if (pos == s.length()) {
            if (isStart == 1) return 0; // NOTE: special check for num == 0. TODO
            if (r == 0 && odd == even) { // TODO
                if (ENABLE_DEBUG_MODE) System.out.println(""result = "" + curResult);
                return 1;
            } else {
                return 0;
            }
        }
        if (dp[isStart][hasLimit][pos][odd][even][r] != UNSET) return dp[isStart][hasLimit][pos][odd][even][r];

        int start = 0;
        int end = (hasLimit == 1) ? s.charAt(pos) - '0' : 9; // TODO: check if it is binary string or not

        long ans = 0;
        for (int digit = start; digit <= end; digit++) {
            if (isStart == 1 && digit == 0) { // NOTE: handle leading zeros
                // [0, 999..9]
                // [0， 10^(len(s) - pos - 1) - 1]
                ans += dfs(new StringBuilder(), s, 1, 0, pos + 1, 0, 0, 0);
                continue;
            }
            int newHasLimit = (hasLimit == 1 && digit == s.charAt(pos) - '0') ? 1 : 0;

            int newOdd = odd + (digit % 2); // TODO
            int newEven = even + (digit % 2 == 0 ? 1 : 0); // TODO
            int newR = (isStart == 1 ? digit % this.K : (r * 10 + digit) % this.K); // TODO;

            if (ENABLE_DEBUG_MODE) curResult.append(digit);
            ans += dfs(curResult, s, 0, newHasLimit, pos + 1, newOdd, newEven, newR);
            if (ENABLE_DEBUG_MODE) curResult.deleteCharAt(curResult.length() - 1);

        }
        return dp[isStart][hasLimit][pos][odd][even][r] = ans;
    }
}

class Printer {
    static boolean ENABLE_LOCAL_PRINT = false;

    static void println(String x) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.println(x);
    }

    static void printf(String format, Object... args) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.printf(format, args);
    }
}


public class Solution {
    private static final int INF = 1_000_000_001;
    private static final long MOD = 1_000_000_007L;

    private static final int UNSET = -131;
    // 4 neighbors
    private static final int[] DX = {-1, 0, 1, 0}; // up, right, down, left
    private static final int[] DY = {0, 1, 0, -1};

    // 8 neighbors
    //    private static final int[] DX = {-1, -1, 0, 1, 1,  1, 0,  -1};
    //    private static final int[] DY = {0,   1, 1, 1, 0, -1, -1, -1};

    // knight
    //    private static final int[] DX = {-2, -2, -1, 1, 2, 2, 1, -1};
    //    private static final int[] DY = {-1, 1, 2, 2, 1, -1, -2, -2};

    boolean check(int[] next, int limit) {
        int n = next.length;
        for (int i = 0; i < n; i++) {
            int l1 = next[i] - i + 1;
            int l2 = (i + limit < n ? next[i + limit] - (i + limit) + 1 : -1);
            if (l1 >= limit && l2 >= limit) return true;
        }
        return false;
    }

    public int maxIncreasingSubarrays(List<Integer> nums) {
        int n = nums.size();
        int[] next = new int[n];

        for (int i = 0; i < n; ) {
            int j = i + 1;
            while (j < n && nums.get(j) > nums.get(j - 1)) j++;

            for (int k = i; k < j; k++) {
                next[k] = j - 1;
            }
            i = j;
        }

        int ans = 0;
        int low = 1;
        int high = n;
        while (low <= high) {
            int mid = (low + high) / 2;
            if (check(next, mid)) {
                ans = mid;
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        return ans;
    }

    public boolean hasIncreasingSubarrays(List<Integer> nums, int KK) {
        int n = nums.size();
        int[] next = new int[n];

        for (int i = 0; i < n; ) {
            int j = i + 1;
            while (j < n && nums.get(j) > nums.get(j - 1)) j++;

            for (int k = i; k < j; k++) {
                next[k] = j - 1;
            }
            i = j;
        }

        return check(next, KK);
    }


    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        Printer.ENABLE_LOCAL_PRINT = true;
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */





        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        System.out.println((System.currentTimeMillis() - startTime) + ""ms"");
    }
}",1448189174
IphoneX,hahahiehie,169,3619,java,"import java.util.*;

class Utils {
    public static int log2(long n) {
        return 63 - Long.numberOfLeadingZeros(n);
    }

    // nums = ""aaabaaaba"" odd d[1] return [1, 2, 1, 4, 1, 2, 2]
    // d[0] for even, d[1] for odd
    public static int[][] manacher(String s) {
        int n = s.length();
        int[] d1 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; ++i) {
            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s.charAt(i - k) == s.charAt(i + k)) k++;
            d1[i] = k;
            if (i + k - 1 > r) {
                l = i - k + 1;
                r = i + k - 1;
            }
        }

        int[] d0 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : Math.min(d0[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s.charAt(i - k - 1) == s.charAt(i + k)) {
                k++;
            }
            d0[i] = k;
            if (i + k - 1 > r) {
                l = i - k;
                r = i + k - 1;
            }
        }
        return new int[][]{d0, d1};
    }

    // generate primes that is <= n
    public static int[] genPrimes(int n) {
        if (n <= 1) return new int[0];
        boolean[] isComp = new boolean[n + 1];
        int len = 0;
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                len++;
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                }
            }
        }
        int[] ans = new int[len];
        for (int i = 2, j = 0; i <= n; i++) {
            if (!isComp[i]) {
                ans[j++] = i;
            }
        }
        return ans;
    }

    // int[0] = primeFactor, int[1] = count of that primeFactor
    // NOTE: factors[0] and factors[1] are empty list.
    public static List<int[]>[] genPrimeFactors(int n) {
        List<int[]>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            factors[i] = new ArrayList<>();
        }
        boolean[] isComp = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                factors[i].add(new int[]{i, 1});
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                    int t = j, count = 0;
                    while (t % i == 0) {
                        count++;
                        t /= i;
                    }
                    factors[j].add(new int[]{i, count});
                }
            }
        }
        return factors;
    }

    // generate factors (not prime factors), factors[0] is empty list.
    public static List<Integer>[] genFactors(int n) {
        List<Integer>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) factors[i] = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j += i) {
                factors[j].add(i);
            }
        }
        return factors;
    }

    public static int lowerBound(int[] a, int target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(int[] a, int target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(long[] a, long target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(long[] a, long target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static long or(int x, int y) {
        return ((long) x << 32) | ((long) y << 32 >>> 32);
    }

    // k = 0...nums.length - 1
    // After calling this function, nums[k] is the k-th number.
    public static int kthNumber(int[] nums, int k) {
        return kthNumberHelper(nums, k, 0, nums.length - 1);
    }

    // end is inclusive (0 to nums.length - 1)
    private static int kthNumberHelper(int[] nums, int K, int start, int end) {
        if (start == end) return nums[start];
        int i = partition(nums, start, end);
        return K <= i ? kthNumberHelper(nums, K, start, i) : kthNumberHelper(nums, K, i + 1, end);
    }

    // end is inclusive (0 to nums.length - 1)
    public static int partition(int[] nums, int start, int end) {
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && nums[i] < pivot) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && pivot < nums[j]) j--;
            if (i < j) nums[i++] = nums[j];
        }

        // pos is the final position for pivot.
        nums[i] = pivot;
        return i;
    }

    public static void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    // partition nums into 3 parts [smaller than pivot, equal to pivot, larger than pivot]
    public static void partition3(int[] nums, int pivot) {
        int n = nums.length;
        int l = 0, r = n - 1;
        for (int i = 0; i <= r; i++) {
            if (nums[i] < pivot) {
                swap(nums, l++, i);
            } else if (nums[i] > pivot) {
                swap(nums, r--, i--);
            }
        }
    }

    // end is inclusive
    public static void reverse(int[] nums, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    }

    // Return false if next permutation is not available. (nums is not changed for this case)
    public static boolean nextPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] >= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] > nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // Return false if previous permutation is not available. (nums is not changed for this case)
    public static boolean prevPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] <= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] < nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }


    // a, b could be negative
    // remainder >= 0
    // return [a / b, a % b]
    public static int[] divMod(int a, int b) {
        int r = a % b;
        int c = a / b;
        if (r < 0) {
            r += Math.abs(b);
            c++;
        }
        return new int[]{c, r};
    }

    public static List<Integer> negativeBase(int n, int base) {
        List<Integer> digits = new ArrayList<>();
        if (n == 0) {
            digits.add(0);
            return digits;
        }
        while (n != 0) {
            // t[0] = n / base
            // t[1] = n % base;
            int[] t = divMod(n, base);
            digits.add(t[1]);
            n = t[0];
        }
        Collections.reverse(digits);
        return digits;
    }

    // (a ^ b) % MOD
    public static long powMod(long a, long b, long MOD) {
        long res = 1L;
        a %= MOD; // In case a * a is overflow
        while (b > 0) {
            if ((b & 1) != 0) res = (res * a) % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    public static long[][] genCombination(int n) {
        long[][] C = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        return C;
    }

    public static long[][] genPermutation(int n) {
        long[][] P = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
        return P;
    }

    public static long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }

    public static int[] preprocessLog2(int n) { // from log2(0) .... log2(n) inclusive
        int[] lg = new int[n + 1];
        for (int k = 0, i = 1; i <= n; lg[i++] = k - 1) {
            while ((1 << k) <= i) {
                k++;
            }
        }
        return lg;
    }

    public static long max(long[] nums) {
        long ret = Long.MIN_VALUE;
        for (long v : nums) ret = Math.max(ret, v);
        return ret;
    }

    public static int max(int[] nums) {
        int ret = Integer.MIN_VALUE;
        for (int v : nums) ret = Math.max(ret, v);
        return ret;
    }
}

// Tested by leetcode 1163
class SuffixArray {
    int[] s;
    int[] SA; // SA[i] => index of the i-th ranked suffix
    int[] rank; // rank[i] => the rank of i-th suffix, SA[rank[i]] == i
    int[] height; // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).

    private int[][] d;
    private int n;
    private int[] lg;

    private int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    private static int[] stringToIntArray(String str) {
        int[] nums = new int[str.length()];
        for (int i = 0; i < str.length(); i++) nums[i] = str.charAt(i);
        return nums;
    }

    public SuffixArray(String str) {
        this(str, true);
    }

    public SuffixArray(String str, boolean toBuildRMQ) {
        this(stringToIntArray(str), toBuildRMQ);
    }

    public SuffixArray(int[] nums) {
        this(nums, true);
    }

    public SuffixArray(int[] nums, boolean toBuildRMQ) {
        this.s = nums;
        this.n = nums.length;
        this.SA = new int[n];
        this.rank = new int[n];
        suffixSort(s);
        if (toBuildRMQ) {
            this.height = new int[n];
            this.d = new int[log2(n) + 1][n];
            this.lg = new int[n + 1];
            buildHeight();
            buildRMQ();
        }
    }

    // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).
    // ?? s[n] = 0 or s[n] = -INF.
    private void buildHeight() {
        int i, j, h;
        height[0] = 0;
        for (i = 0; i < n; i++)
            rank[SA[i]] = i;
        for (h = i = 0; i < n; i++)
            if (rank[i] > 0) {
                j = SA[rank[i] - 1];
                while (i + h < n && j + h < n && s[i + h] == s[j + h]) ++h;
                height[rank[i]] = h;
                if (h > 0) --h;
            }
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    private void buildRMQ() {
        int i, j, k;
        for (i = 0; i < n; i++)
            d[0][i] = height[i];
        for (j = 1; (1 << j) <= n; j++)
            for (i = 0; i + (1 << j) <= n; i++)
                d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
        for (lg[0] = k = 0, i = 1; i <= n; lg[i++] = k - 1)
            while ((1 << k) <= i) k++;
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    public int LCP(int i, int j) {
        if (i == j) return n - SA[i];
        if (i > j) {
            int t = i;
            i = j;
            j = t;
        }
        int k = lg[j - (++i) + 1];
        return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }

    // LCPIndex(i, j) = LCP(s[i], s[j])
    public int LCPIndex(int i, int j) {
        return LCP(rank[i], rank[j]);
    }

    private void sortIndex(int[] nums, int start, int end) {
        if (start >= end) return;
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && s[nums[i]] < s[pivot]) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && s[pivot] < s[nums[j]]) j--;
            if (i < j) nums[i++] = nums[j];
        }
        nums[i] = pivot; // index i is the final position for pivot.
        sortIndex(nums, start, i - 1);
        sortIndex(nums, i + 1, end);
    }

    private void suffixSort(int[] s) {
        int[] count = new int[n], t;
        int[] nSA = new int[n];
        int[] nRank = new int[n];
//        Integer[] tempArray = new Integer[n];
//        for (int x = 0; x < n; x++) tempArray[x] = x;
//        Arrays.sort(tempArray, (a, b) -> Integer.compare(s[a], s[b]));
//        for (int x = 0; x < n; x++) SA[x] = tempArray[x];
        int i, k;
        int minV = s[0], maxV = s[0];
        for (i = 1; i < n; i++) {
            minV = Math.min(minV, s[i]);
            maxV = Math.max(maxV, s[i]);
        }
        if ((long) maxV - minV + 1 <= (long) n) { // radix sort if alphabet size is small
            for (i = 0; i < n; i++) count[s[i] - minV]++;
            for (i = minV + 1; i <= maxV; i++) count[i - minV] += count[i - minV - 1];
            for (i = n - 1; i >= 0; i--) SA[--count[s[i] - minV]] = i;
        } else {
            for (i = 0; i < n; i++) SA[i] = i;
            sortIndex(SA, 0, n - 1);
        }
        for (rank[SA[0]] = 0, i = 1; i < n; i++) {
            rank[SA[i]] = (s[SA[i]] != s[SA[i - 1]]) ? rank[SA[i - 1]] + 1 : rank[SA[i - 1]];
        }
        for (k = 1; k < n && rank[SA[n - 1]] < n - 1; k <<= 1) {
            for (i = 0; i < n; i++) count[rank[SA[i]]] = i + 1;
            for (i = n - 1; i >= 0; i--) if (SA[i] >= k) nSA[--count[rank[SA[i] - k]]] = SA[i] - k;
            for (i = n - k; i < n; i++) nSA[--count[rank[i]]] = i;
            t = SA;
            SA = nSA;
            nSA = t;
            for (nRank[SA[0]] = 0, i = 1; i < n; i++) {
                nRank[SA[i]] = (SA[i] + k >= n || SA[i - 1] + k >= n || rank[SA[i]] != rank[SA[i - 1]] || rank[SA[i] + k] != rank[SA[i - 1] + k]) ? nRank[SA[i - 1]] + 1 : nRank[SA[i - 1]];
            }
            t = rank;
            rank = nRank;
            nRank = t;
        }
    }
}

class Combination {
    long[] factorial;
    long[] inverseFactorial;
    long MOD;

    // O(maxSize) for preprocessing
    // MOD must be prime
    public Combination(int maxSize, long MOD) {
        factorial = new long[maxSize + 1];
        inverseFactorial = new long[maxSize + 1];
        factorial[0] = 1;
        inverseFactorial[0] = 1;
        this.MOD = MOD;
        for (int i = 1; i <= maxSize; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
            inverseFactorial[i] = inverse(factorial[i]);
        }
    }

    // x, y are long[1]
    // ax + by = gcd(a, b)
    private long extGcd(long a, long b, long[] x, long[] y) {
        if (b == 0) {
            x[0] = 1;
            y[0] = 0;
            return a;
        } else {
            long r = extGcd(b, a % b, y, x);
            y[0] -= x[0] * (a / b);
            return r;
        }
    }

    // (a * x) % MOD = 1
    // x is the inverse element
    public long inverse(long a) {
        long[] x = new long[1], y = new long[1];
        extGcd(a, MOD, x, y);
        return (x[0] % MOD + MOD) % MOD;
    }

    // m >= n
    // O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        else if (m == n) return factorial[m];
            //return factorial[m] * inverse(factorial[m - n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD;
    }

    // m >= n
    // O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
            //return factorial[m] * inverse(factorial[m - n]) % MOD * inverse(factorial[n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD * inverseFactorial[n] % MOD;
    }
}

class CombinationNoMod {

    long[][] C;
    long[][] P;

    public CombinationNoMod(int maxSize) {
        C = new long[maxSize + 1][maxSize + 1];
        P = new long[maxSize + 1][maxSize + 1];
        int m = C.length;
        int n = C[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
    }

    // m >= n. O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        return P[m][n];
    }

    // m >= n. O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
        return C[m][n];
    }
}

class Fraction {
    long n, d; // n / d (d != 0)

    public Fraction(long n, long d) {
        if (d == 0) {
            this.n = Long.MAX_VALUE;
            this.d = 1;
            return;
        }
        long g = gcd(Math.abs(n), Math.abs(d));
        this.n = n / g;
        this.d = d / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    public void add(Fraction other) {
        long numerator = this.n * other.d + this.d * other.n;
        long denominator = this.d * other.d;
        long g = gcd(Math.abs(numerator), Math.abs(denominator));
        this.n = numerator / g;
        this.d = denominator / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    @Override
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof Fraction) {
            Fraction anotherObject = (Fraction) anObject;
            return n == anotherObject.n && d == anotherObject.d;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return (int) (n * 31 + d);
    }

    private long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }
}

class UnionFind {
    int[] parent;
    int[] sz;

    // from 0 ... n - 1
    public UnionFind(int n) {
        parent = new int[n];
        sz = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public void clear() {
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public int find(int x) {
        //return parent[x] == x ? x : (parent[x] = find(parent[x]));
        if (parent[x] == x) return x;
        int px = x;
        while (px != parent[px]) px = parent[px];
        while (x != px) {
            int next = parent[x];
            parent[x] = px;
            x = next;
        }
        return px;
    }

    // px is the final parent
    public boolean union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return false;
        parent[py] = px;
        sz[px] += sz[py];
        return true;
    }

    public int size(int x) {
        return sz[find(x)];
    }

    public UnionFind clone() {
        UnionFind cloned = new UnionFind(parent.length);
        for (int i = 0; i < parent.length; i++) {
            cloned.parent[i] = parent[i];
            cloned.sz[i] = sz[i];
        }
        return cloned;
    }
}

class Trie {
    static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        boolean isWord = false;
        long count = 0L;
    }

    TrieNode root = new TrieNode();

    public void add(String word) {
        add(word, 1L);
    }

    public void remove(String word) {
        add(word, -1L);
    }

    private void add(String word, long count) {
        TrieNode cur = root;
        cur.count += count;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) cur.next[c] = new TrieNode();
            cur = cur.next[c];
            cur.count += count;
        }
        cur.isWord = true;
    }

    public boolean contains(String word) {
        TrieNode cur = root;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null || cur.next[c].count <= 0L) return false;
            cur = cur.next[c];
            //if (cur.isWord) return true;
        }
        return cur.isWord;
    }
}

// Tested by Leetcode 1707 and Leetcode 1803
class TrieBinary {
    static class TrieNode {
        TrieNode[] next = new TrieNode[2];
        long count;
    }

    private TrieNode root;
    private int numOfBits;

    public TrieBinary(int numOfBits) { // normally 31 for int and 63 for long
        this.numOfBits = numOfBits;
        this.root = new TrieNode();
    }

    public void add(long v) {
        add(v, 1L);
    }

    public void remove(long v) { // Tested by Leetcode 1938
        add(v, -1L);
    }

    public void add(long v, long count) {
        TrieNode cur = root;
        root.count += count;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null) cur.next[b] = new TrieNode();
            cur = cur.next[b];
            cur.count += count;
        }
    }

    // Tested by Leetcode 1707
    public long xorMax(long v) {
        TrieNode cur = root;
        long key = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[1 - b] != null && cur.next[1 - b].count > 0) {
                cur = cur.next[1 - b];
                key |= (1L - b) << i;
            } else {
                cur = cur.next[b];
                key |= (long) b << i;
            }
        }
        return key ^ v;
    }

    public boolean contains(long v) {
        TrieNode cur = root;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null || cur.next[b].count <= 0) return false;
            cur = cur.next[b];
        }
        return true;
    }

    // Tested by Leetcode 1803
    // count(x ^ v <= limit)
    public long xorLessOrEqualCount(long v, long limit) {
        if (limit < 0) return 0;
        TrieNode cur = root;
        long ans = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int bitLimit = ((limit >>> i) & 1) == 0 ? 0 : 1;
            int bitV = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (bitLimit == 1) {
                ans += (cur.next[bitV] != null ? cur.next[bitV].count : 0);
            }
            cur = cur.next[bitV ^ bitLimit];
            if (cur == null) break;
            if (i == 0) ans += cur.count;
        }
        return ans;
    }
}

// Lazy execution example is in https://leetcode.com/submissions/detail/1034182539/
// Refer to AlgorithmCompilation.java

// [Template] Classic Segment Tree (Range Sum), used for Template
class ClassicSegmentTree { // For Range Sum
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final int L, R;

    public ClassicSegmentTree(int[] input) {
        L = 0;
        R = input.length - 1;
        root = new TreeNode();
        build(root, L, R, input);
    }

    private void build(TreeNode root, int l, int r, int[] input) {
        if (l == r) {
            root.sum = input[l];
            return;
        }
        int m = (l + r) >> 1;
        root.left = new TreeNode();
        root.right = new TreeNode();
        build(root.left, l, m, input);
        build(root.right, m + 1, r, input);
        root.sum = root.left.sum + root.right.sum;
    }

    public void set(int index, int value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, int L, int R, int index, int value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        int M = L + ((R - L) >> 1);
        if (index <= M) {
            set(root.left, L, M, index, value);
        } else {
            set(root.right, M + 1, R, index, value);
        }
        root.sum = root.left.sum + root.right.sum;
    }

    // Sum[queryL...queryR] inclusive
    public long query(int queryL, int queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, int L, int R, int queryL, int queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        int M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 307
class DynamicSegmentTreeRangeSum {
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeSum(long l, long r) {
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return sum(cur);
    }

    public void add(long index, long value) {
        set(index, get(index) + value);
    }

    private long sum(TreeNode node) {
        return node == null ? 0L : node.sum;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.sum = sum(root.left) + sum(root.right);
    }

    // Sum[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        long M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 239, 2926
class DynamicSegmentTreeRangeMax {
    class TreeNode {
        TreeNode left, right;
        long max = Long.MIN_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMax(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return max(cur);
    }

    private long max(TreeNode node) {
        return node == null ? Long.MIN_VALUE : node.max;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.max = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.max = Math.max(max(root.left), max(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MIN_VALUE;
        if (queryL <= L && R <= queryR) return root.max;
        long M = L + ((R - L) >> 1);
        return Math.max(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class DynamicSegmentTreeRangeMin {
    class TreeNode {
        TreeNode left, right;
        long min = Long.MAX_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMin(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return min(cur);
    }

    private long min(TreeNode node) {
        return node == null ? Long.MAX_VALUE : node.min;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.min = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.min = Math.min(min(root.left), min(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MAX_VALUE;
        if (queryL <= L && R <= queryR) return root.min;
        long M = L + ((R - L) >> 1);
        return Math.min(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class BinaryIndexTree {
    private long[] c;
    private int n;

    // NOTE: index is from 1 to n. (NOT 0 ... n - 1)
    public BinaryIndexTree(int n) {
        this.n = n;
        this.c = new long[n + 1];
    }

    // Add value to position k, k is from 1 to n.
    public void add(int k, long value) {
        while (k <= n) {
            c[k] += value;
            k += (k & (k ^ (k - 1)));
        }
    }

    // k is from 1 to n.
    public long getSum(int k) {
        long sum = 0;
        while (k > 0) {
            sum += c[k];
            k -= (k & (k ^ (k - 1)));
        }
        return sum;
    }
}

class RangeSum {
    BinaryIndexTree tree;
    int start;

    // [low, high] inclusive
    public RangeSum(int low, int high) {
        start = low;
        tree = new BinaryIndexTree(high - low + 1);
    }

    public void add(int index, long value) {
        tree.add(index - start + 1, value);
    }

    public long get(int index) {
        return tree.getSum(index - start + 1) - tree.getSum(index - start);
    }

    public void set(int index, long value) {
        tree.add(index - start + 1, value - get(index));
    }

    // [l, r] inclusive
    public long getSum(int l, int r) {
        return tree.getSum(r - start + 1) - tree.getSum(l - start);
    }
}

class RangeMax {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMax(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MIN_VALUE);
    }

    public RangeMax(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.max(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMax(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MIN_VALUE, resr = Long.MIN_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.max(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.max(t[--r], resr);
        }
        return Math.max(resl, resr);
    }
}

class RangeMin {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMin(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MAX_VALUE);
    }

    public RangeMin(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.min(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMin(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MAX_VALUE, resr = Long.MAX_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.min(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.min(t[--r], resr);
        }
        return Math.min(resl, resr);
    }
}

// Including topological sort.
class GraphIntegerFaster {
    public List<Integer>[] adj;

    public GraphIntegerFaster(int n) {
        adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    // directed edge x -> y
    public void link(int x, int y) {
        adj[x].add(y);
    }

    public List<Integer> getChildren(int x) {
        return adj[x];
    }

    private static final int TEMPORARY = 1;
    private static final int PERMANENT = 2;

    // x -> y means x should be processed before y
    // The input is a directed graph.
    // 1. return null, means there is a cycle inside the graph, or the input is
    // invalid.
    // 2. return List<Node> as the result.
    public List<Integer> topologicalSort() {
        //Map<E, Integer> vst = new HashMap<>();
        int n = adj.length;
        int[] vst = new int[n];
        List<Integer> result = new ArrayList<>();
        for (int x = 0; x < n; x++) {
            if (!topologicalSort(x, vst, result)) {
                return null;
            }
        }
        Collections.reverse(result);
        return result;
    }

    private boolean topologicalSort(int root, int[] vst, List<Integer> result) {
        if (vst[root] == PERMANENT) {
            return true;
        }
        if (vst[root] == TEMPORARY) { // found cycle
            return false;
        }

        vst[root] = TEMPORARY;
        for (int child : getChildren(root)) {
            if (!topologicalSort(child, vst, result)) {
                return false;
            }
        }
        result.add(root);
        vst[root] = PERMANENT;
        return true;
    }
}

class DijkstraLongFaster {
    public static class Edge {
        int to;
        long w;

        public Edge(int to, long w) {
            this.to = to;
            this.w = w;
        }
    }

    public static final long INF = Long.MAX_VALUE / 4;
    public List<Edge>[] adj;

    public DijkstraLongFaster(int n) {
        this.adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    public void link(int x, int y, long w) {
        adj[x].add(new Edge(y, w));
    }

    public long[] shortestPath(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
        q.add(new Edge(src, 0));
        dist[src] = 0;

        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (vst[cur.to]) continue;
            int u = cur.to;
            long w = cur.w;
            vst[u] = true;

            for (Edge e : adj[u]) {
                if (!vst[e.to] && dist[e.to] > w + e.w) {
                    dist[e.to] = w + e.w;
                    q.add(new Edge(e.to, dist[e.to]));
                }
            }
        }
        return dist;
    }

    // NOTE: w of each edge must be the same.
    public long[] bfs(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        Queue<Integer> q = new ArrayDeque<>();
        q.add(src);
        dist[src] = 0;
        vst[src] = true;

        while (!q.isEmpty()) {
            int u = q.poll();
            long w = dist[u];
            for (Edge e : adj[u]) {
                if (!vst[e.to]) {
                    dist[e.to] = w + e.w;
                    vst[e.to] = true;
                    q.add(e.to);
                }
            }
        }
        return dist;
    }
}

class TreapSet<E> {
    private class Node {
        E key;
        int priority, count, total;
        Node left, right, pnt;

        public Node(E key, int priority, Node pnt) {
            this.key = key;
            this.priority = priority;
            this.pnt = pnt;
            this.count = 1;
            this.total = 1;
        }
    }

    private static final Random RANDOM = new Random();
    private final Comparator<? super E> comparator;
    private Node root;

    public TreapSet(Comparator<? super E> comparator) {
        this.comparator = comparator;
    }

    public boolean isEmpty() {
        return root == null;
    }

    public void clear() {
        root = null;
    }

    public int size() {
        return root == null ? 0 : root.total;
    }

    private int leftRank(Node p) {
        return p.left != null ? p.left.total : 0;
    }

    private int rightRank(Node p) {
        return p.right != null ? p.right.total : 0;
    }

    private void rotateLeft(Node x) {
        Node y = x.right;
        if ((x.right = y.left) != null) y.left.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.left) x.pnt.left = y;
        else x.pnt.right = y;
        y.left = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    private void rotateRight(Node x) {
        Node y = x.left;
        if ((x.left = y.right) != null) y.right.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.right) x.pnt.right = y;
        else x.pnt.left = y;
        y.right = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    public void add(E key) {
        if (root == null) {
            root = new Node(key, RANDOM.nextInt(), null);
            return;
        }
        Node x = root, p = null;
        while (x != null) {
            ++((p = x).total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                ++(x.count);
                return;
            }
        }

        x = new Node(key, RANDOM.nextInt(), p);
        if (comparator.compare(key, p.key) < 0) p.left = x;
        else p.right = x;
        while ((p = x.pnt) != null && p.priority < x.priority) {
            if (p.left == x) rotateRight(p);
            else rotateLeft(p);
        }
    }

    public void remove(E key) {
        Node x = root, p = null;
        while (x != null) {
            --(x.total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                if (--(x.count) > 0) return;
                break;
            }
        }
        if (x == null) return;
        while (x.left != null || x.right != null) {
            if (x.left == null || (x.right != null && x.right.priority > x.left.priority)) {
                rotateLeft(x);
            } else {
                rotateRight(x);
            }
        }
        if ((p = x.pnt) != null) {
            if (p.left == x) p.left = null;
            else p.right = null;
        } else {
            root = null;
        }
        // delete x;
    }

    // number of elements smaller than key
    public int lowerCount(E key) {
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                sum += leftRank(x) + x.count;
                x = x.right;
            } else {
                sum += leftRank(x);
                break;
            }
        }
        return sum;
    }

    // number of elements larger than key
    public int higherCount(E key) {
        //return size() - lowerCount(key) - count(key);
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp > 0) x = x.right;
            else if (cmp < 0) {
                sum += rightRank(x) + x.count;
                x = x.left;
            } else {
                sum += rightRank(x);
                break;
            }
        }
        return sum;
    }

    public int index(E key) {
        return lowerCount(key);
    }

    public E get(int index) // index = 0 ... size - 1
    {
        Node p = root;
        ++index;
        while (true) {
            int t = leftRank(p);
            if (index <= t) p = p.left;
            else {
                if ((index -= t + p.count) <= 0) break;
                p = p.right;
            }
        }
        return p.key;
    }

    public int count(E key) {
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                x = x.right;
            } else {
                return x.count;
            }
        }
        return 0;
    }

    public E first() {
        if (root == null) return null;
        Node x = root;
        while (x.left != null) {
            x = x.left;
        }
        return x.key;
    }

    public E last() {
        if (root == null) return null;
        Node x = root;
        while (x.right != null) {
            x = x.right;
        }
        return x.key;
    }

    public boolean contains(E key) {
        return count(key) > 0;
    }

    public E ceiling(E key) {
        int id = lowerCount(key);
        return id >= size() ? null : get(id);
    }

    public E floor(E key) {
        int id = size() - higherCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E lower(E key) {
        int id = lowerCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E higher(E key) {
        int id = size() - higherCount(key);
        return id >= size() ? null : get(id);
    }

    // return the first index whose value >= target
    // if this value doesn't exist, return index = size()
    public int lowerBound(E target) {
        return lowerCount(target);
    }

    // return the first index whose value > target
    // if this value doesn't exist, return index = size()
    public int upperBound(E target) {
        return size() - higherCount(target);
    }

    public List<E> keys() {
        List<E> list = new ArrayList<>();
        inorder(root, list);
        return list;
    }

    private void inorder(Node x, List<E> list) {
        if (x == null) return;
        inorder(x.left, list);
        list.add(x.key);
        inorder(x.right, list);
    }
}

class ArraySum {
    long[] sum;
    int n;

    // nums index starts from 0 to nums.length - 1;
    public ArraySum(int[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    public ArraySum(long[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    // [l, r], index starts from 0
    public long getSum(int l, int r) {
        // error handling
        if (l > r || !(l >= 0 && l < n && r >= 0 && r < n)) return 0L;
        return sum[r + 1] - sum[l];
    }
}

class TwoDArraySum {
    int[][] sum;
    int m, n;

    // nums index starts from 0
    public TwoDArraySum(final int[][] nums) {
        m = nums.length;
        n = nums[0].length;
        sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + nums[i - 1][j - 1];
            }
        }
    }

    // [(x1, y1), (x2, y2)], index starts from 0
    // x1 <= x2 and y1 <= y2
    public int getSum(int x1, int y1, int x2, int y2) {
        if (!(x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && x2 >= 0 && x2 < m && y2 >= 0 && y2 < n) || x1 > x2 || y1 > y2)
            return 0;
        return sum[x2 + 1][y2 + 1] - sum[x2 + 1][y1] - sum[x1][y2 + 1] + sum[x1][y1];
    }
}

class ArrayUtils {
    static void fill(int[] array, int defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(int[][] array, int defaultValue) {
        for (int[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(int[][][] array, int defaultValue) {
        for (int[][] a2 : array) {
            for (int[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(int[][][][] array, int defaultValue) {
        for (int[][][] a3 : array) {
            for (int[][] a2 : a3) {
                for (int[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(int[][][][][] array, int defaultValue) {
        for (int[][][][] a4 : array) {
            for (int[][][] a3 : a4) {
                for (int[][] a2 : a3) {
                    for (int[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(int[][][][][][] array, int defaultValue) {
        for (int[][][][][] a5 : array) {
            for (int[][][][] a4 : a5) {
                for (int[][][] a3 : a4) {
                    for (int[][] a2 : a3) {
                        for (int[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }

    static void fill(long[] array, long defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(long[][] array, long defaultValue) {
        for (long[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(long[][][] array, long defaultValue) {
        for (long[][] a2 : array) {
            for (long[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(long[][][][] array, long defaultValue) {
        for (long[][][] a3 : array) {
            for (long[][] a2 : a3) {
                for (long[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(long[][][][][] array, long defaultValue) {
        for (long[][][][] a4 : array) {
            for (long[][][] a3 : a4) {
                for (long[][] a2 : a3) {
                    for (long[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(long[][][][][][] array, long defaultValue) {
        for (long[][][][][] a5 : array) {
            for (long[][][][] a4 : a5) {
                for (long[][][] a3 : a4) {
                    for (long[][] a2 : a3) {
                        for (long[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }
}

class CharacterUtils {
    static boolean[] vowel = new boolean[128];

    static {
        vowel['a'] = vowel['e'] = vowel['i'] = vowel['o'] = vowel['u'] = true;
        vowel['A'] = vowel['E'] = vowel['I'] = vowel['O'] = vowel['U'] = true;
    }

    static boolean isVowel(char ch) {
        return vowel[ch];
    }

    static boolean isLetter(char ch) {
        return ((ch - 'a') >= 0 && (ch - 'a') < 26) ||
                ((ch - 'A') >= 0 && (ch - 'A') < 26);
    }

    static boolean isLowerCase(char ch) {
        return (ch - 'a') >= 0 && (ch - 'a') < 26;
    }

    static boolean isUpperCase(char ch) {
        return (ch - 'A') >= 0 && (ch - 'A') < 26;
    }

    static boolean isDigit(char ch) {
        return (ch - '0') >= 0 && (ch - '0') <= 9;
    }
}

class DoubleUtils {
    private static final double EPS = 1e-8;

    public static int compare(double a, double b) {
        if (a - b > EPS) return 1;
        else if (a - b < -EPS) return -1;
        else return 0;
    }

    public static boolean isInteger(double a) {
        return compare(floor(a), a) == 0;
    }

    public static double floor(double a) {
        return Math.floor(a + EPS);
    }

    public static double ceil(double a) {
        return Math.ceil(a - EPS);
    }
}

class MatrixUtils {
    static final long MOD = 1_000_000_007L;

    // matrix[n][n], matrix[i][i] = 1
    static long[][] genIdentityMatrix(int n) {
        long[][] matrix = new long[n][n];
        for (int i = 0; i < n; i++) matrix[i][i] = 1;
        return matrix;
    }

    static long[][] multiply(long[][] a, long[][] b, long MOD) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]) % MOD;
                }
            }
        }
        return res;
    }

    static long[][] multiply(long[][] a, long[][] b) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]);
                }
            }
        }
        return res;
    }

    // a^b % MOD
    static long[][] powMod(long[][] a, long b, long MOD) {
        int n = a.length;
        long[][] res = genIdentityMatrix(n);
        while (b > 0) {
            if ((b & 1) != 0) res = multiply(res, a, MOD);
            a = multiply(a, a, MOD);
            b >>= 1;
        }
        return res;
    }

    static void print(long[][] matrix) {
        for (int i = 0; i < matrix.length; i++) {
            System.out.println(Arrays.toString(matrix[i]));
        }
    }
}

class IntegerUtils {
    static long[] power10 = new long[19]; // 10^i

    static {
        power10[0] = 1L;
        for (int i = 1; i < power10.length; i++) {
            power10[i] = power10[i - 1] * 10;
        }
    }

    // swap index i and j of integer (long) num. i == 0 means the lowest position.
    static long swapDigit(long num, int i, int j) {
        if (i == j) return num;
        long di = num / power10[i] % 10L;
        long dj = num / power10[j] % 10L;
        return num - di * power10[i] - dj * power10[j] + dj * power10[i] + di * power10[j];
    }
}

class StringUtils {
    // This function is deprecated, please hash(int l, int r) in class StableStringHash or StringHash
    // rolling hash of substrings of 's' with length == k
    // long[pos] = hash(s.substring(pos, pos + k))
    public static long[] rollingHash(String s, int k) {
        long[] ans = new long[s.length() - k + 1];
        int seed1 = 31;
        int seed2 = 131;
        int h1 = 0, h2 = 0, power1 = 1, power2 = 1;
        for (int i = 0; i < k; i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);

            power1 *= seed1;
            power2 *= seed2;
        }

        ans[0] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        for (int i = k; i < s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i) - power1 * s.charAt(i - k);
            h2 = h2 * seed2 + s.charAt(i) - power2 * s.charAt(i - k);
            ans[i - k + 1] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        }

        return ans;
    }

    public static int[] kmpNext(String s) {
        int n = s.length();
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s.charAt(i) != s.charAt(k)) k = next[k - 1];
            if (s.charAt(i) == s.charAt(k)) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(String s, String p) {
        int[] next = kmpNext(p);
        int n = s.length();
        int m = p.length();
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p.charAt(j) != s.charAt(i)) {
                j = next[j - 1];
            }
            if (p.charAt(j) == s.charAt(i)) j++;
            if (j == m) return true;
        }
        return false;
    }

    public static int[] kmpNext(int[] s) {
        int n = s.length;
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s[i] != s[k]) k = next[k - 1];
            if (s[i] == s[k]) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(int[] s, int[] p) {
        int[] next = kmpNext(p);
        int n = s.length;
        int m = p.length;
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p[j] != s[i]) {
                j = next[j - 1];
            }
            if (p[j] == s[i]) j++;
            if (j == m) return true;
        }
        return false;
    }

    // Z[i] = longest length of common prefix of str[0 ... n - 1] and str[i ... n - 1]
    // Tested by LC2223, LC459
    public static int[] zFunction(String str) {
        int n = str.length();
        int[] Z = new int[n];
        // [L,R] makes a window which matches with prefix of s
        int L = 0, R = 0;
        Z[0] = n;
        for (int i = 1; i < n; ++i) {
            if (i > R) {
                L = R = i;
                while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                Z[i] = R - L;
                R--;
            } else {
                int k = i - L;
                if (Z[k] < R - i + 1) {
                    Z[i] = Z[k];
                } else {
                    L = i;
                    while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                    Z[i] = R - L;
                    R--;
                }
            }
        }
        return Z;
    }
}

// Better to use this when length of string >= 2^11
class StringHash {
    static class SingleStringHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleStringHash(String s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length();
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s.charAt(i - 1)) % MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleStringHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L;

    public StringHash(String s) {
        hash1 = new SingleStringHash(s, SEED1, MOD);
        hash2 = new SingleStringHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(String s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length(); i++) {
            h1 = (h1 * SEED1 + s.charAt(i)) % MOD;
            h2 = (h2 * SEED2 + s.charAt(i)) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(char[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class IntegerArrayHash {
    static class SingleIntegerArrayHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleIntegerArrayHash(int[] s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length;
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s[i - 1]) % MOD;
                if (h[i] < 0) h[i] += MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleIntegerArrayHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L; // or 1_000_000_123L

    public IntegerArrayHash(int[] s) {
        hash1 = new SingleIntegerArrayHash(s, SEED1, MOD);
        hash2 = new SingleIntegerArrayHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(int[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(List<Integer> s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.size(); i++) {
            h1 = (h1 * SEED1 + s.get(i)) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s.get(i)) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class RMQ { // NOTE!!! query return index, not value
    // tested by LC 1438,239
    final long[] a; // input data array copy
    int[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQ(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQ(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new int[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = i;
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = a[d[j - 1][i]] >= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                } else {
                    d[j][i] = a[d[j - 1][i]] <= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                }
    }

    // i <= j, and index starts from 0.
    public int query(int i, int j) { // NOTE!!! return index, not value
        int k = log2[j - i + 1];
        if (useMax) return a[d[k][i]] >= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
        else return a[d[k][i]] <= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
    }
}

class RMQValue { // NOTE!!! query return value, not index
    final long[] a; // input data array copy
    long[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQValue(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQValue(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new long[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = a[i];
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = Math.max(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                } else {
                    d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                }
    }

    // i <= j, and index starts from 0.
    public long query(int i, int j) {
        int k = log2[j - i + 1];
        if (useMax) return Math.max(d[k][i], d[k][j - (1 << k) + 1]);
        else return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }
}

// Tested by 2827
// Similar: 1012, 2376, 902, 2719, 2801, 357, 1215, 1397
class DigitDP {
    static final boolean ENABLE_DEBUG_MODE = false; // TODO: set it to true if you want to print more debug info
    static final long UNSET = -1;
    // dp[isStart][hasLimit][pos] | [odd][even][r]
    // (isStart, hasLimit, pos) is generic, (odd, even, r) is use case specific
    long[][][][][][] dp;
    int K;

    public long digitDP(long num, int k) {
        String numString = String.valueOf(num); // TODO
        this.dp = new long[2][2][numString.length()][numString.length() + 1][numString.length() + 1][k];
        this.K = k;

        if (ENABLE_DEBUG_MODE) System.out.println(""num = "" + numString);
        ArrayUtils.fill(dp, UNSET);
        long ans = dfs(new StringBuilder(), numString, 1, 1, 0, 0, 0, 0);
        if (ENABLE_DEBUG_MODE) System.out.println(""---------------------\n"");
        return ans;
    }

    long dfs(StringBuilder curResult, String s, int isStart, int hasLimit, int pos, int odd, int even, int r) {
        if (pos == s.length()) {
            if (isStart == 1) return 0; // NOTE: special check for num == 0. TODO
            if (r == 0 && odd == even) { // TODO
                if (ENABLE_DEBUG_MODE) System.out.println(""result = "" + curResult);
                return 1;
            } else {
                return 0;
            }
        }
        if (dp[isStart][hasLimit][pos][odd][even][r] != UNSET) return dp[isStart][hasLimit][pos][odd][even][r];

        int start = 0;
        int end = (hasLimit == 1) ? s.charAt(pos) - '0' : 9; // TODO: check if it is binary string or not

        long ans = 0;
        for (int digit = start; digit <= end; digit++) {
            if (isStart == 1 && digit == 0) { // NOTE: handle leading zeros
                // [0, 999..9]
                // [0， 10^(len(s) - pos - 1) - 1]
                ans += dfs(new StringBuilder(), s, 1, 0, pos + 1, 0, 0, 0);
                continue;
            }
            int newHasLimit = (hasLimit == 1 && digit == s.charAt(pos) - '0') ? 1 : 0;

            int newOdd = odd + (digit % 2); // TODO
            int newEven = even + (digit % 2 == 0 ? 1 : 0); // TODO
            int newR = (isStart == 1 ? digit % this.K : (r * 10 + digit) % this.K); // TODO;

            if (ENABLE_DEBUG_MODE) curResult.append(digit);
            ans += dfs(curResult, s, 0, newHasLimit, pos + 1, newOdd, newEven, newR);
            if (ENABLE_DEBUG_MODE) curResult.deleteCharAt(curResult.length() - 1);

        }
        return dp[isStart][hasLimit][pos][odd][even][r] = ans;
    }
}

class Printer {
    static boolean ENABLE_LOCAL_PRINT = false;

    static void println(String x) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.println(x);
    }

    static void printf(String format, Object... args) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.printf(format, args);
    }
}


public class Solution {
    private static final int INF = 1_000_000_001;
    private static final long MOD = 1_000_000_007L;

    private static final int UNSET = -131;
    // 4 neighbors
    private static final int[] DX = {-1, 0, 1, 0}; // up, right, down, left
    private static final int[] DY = {0, 1, 0, -1};

    // 8 neighbors
    //    private static final int[] DX = {-1, -1, 0, 1, 1,  1, 0,  -1};
    //    private static final int[] DY = {0,   1, 1, 1, 0, -1, -1, -1};

    // knight
    //    private static final int[] DX = {-2, -2, -1, 1, 2, 2, 1, -1};
    //    private static final int[] DY = {-1, 1, 2, 2, 1, -1, -2, -2};

    boolean check(int[] next, int limit) {
        int n = next.length;
        for (int i = 0; i < n; i++) {
            int l1 = next[i] - i + 1;
            int l2 = (i + limit < n ? next[i + limit] - (i + limit) + 1 : -1);
            if (l1 >= limit && l2 >= limit) return true;
        }
        return false;
    }

    public int maxIncreasingSubarrays(List<Integer> nums) {
        int n = nums.size();
        int[] next = new int[n];

        for (int i = 0; i < n; ) {
            int j = i + 1;
            while (j < n && nums.get(j) > nums.get(j - 1)) j++;

            for (int k = i; k < j; k++) {
                next[k] = j - 1;
            }
            i = j;
        }

        int ans = 0;
        int low = 1;
        int high = n;
        while (low <= high) {
            int mid = (low + high) / 2;
            if (check(next, mid)) {
                ans = mid;
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        return ans;
    }


    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        Printer.ENABLE_LOCAL_PRINT = true;
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */





        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        System.out.println((System.currentTimeMillis() - startTime) + ""ms"");
    }
}",1448187575
IphoneX,hahahiehie,169,3631,java,"import java.util.*;

class Utils {
    public static int log2(long n) {
        return 63 - Long.numberOfLeadingZeros(n);
    }

    // nums = ""aaabaaaba"" odd d[1] return [1, 2, 1, 4, 1, 2, 2]
    // d[0] for even, d[1] for odd
    public static int[][] manacher(String s) {
        int n = s.length();
        int[] d1 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; ++i) {
            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s.charAt(i - k) == s.charAt(i + k)) k++;
            d1[i] = k;
            if (i + k - 1 > r) {
                l = i - k + 1;
                r = i + k - 1;
            }
        }

        int[] d0 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : Math.min(d0[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s.charAt(i - k - 1) == s.charAt(i + k)) {
                k++;
            }
            d0[i] = k;
            if (i + k - 1 > r) {
                l = i - k;
                r = i + k - 1;
            }
        }
        return new int[][]{d0, d1};
    }

    // generate primes that is <= n
    public static int[] genPrimes(int n) {
        if (n <= 1) return new int[0];
        boolean[] isComp = new boolean[n + 1];
        int len = 0;
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                len++;
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                }
            }
        }
        int[] ans = new int[len];
        for (int i = 2, j = 0; i <= n; i++) {
            if (!isComp[i]) {
                ans[j++] = i;
            }
        }
        return ans;
    }

    // int[0] = primeFactor, int[1] = count of that primeFactor
    // NOTE: factors[0] and factors[1] are empty list.
    public static List<int[]>[] genPrimeFactors(int n) {
        List<int[]>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            factors[i] = new ArrayList<>();
        }
        boolean[] isComp = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                factors[i].add(new int[]{i, 1});
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                    int t = j, count = 0;
                    while (t % i == 0) {
                        count++;
                        t /= i;
                    }
                    factors[j].add(new int[]{i, count});
                }
            }
        }
        return factors;
    }

    // generate factors (not prime factors), factors[0] is empty list.
    public static List<Integer>[] genFactors(int n) {
        List<Integer>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) factors[i] = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j += i) {
                factors[j].add(i);
            }
        }
        return factors;
    }

    public static int lowerBound(int[] a, int target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(int[] a, int target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(long[] a, long target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(long[] a, long target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static long or(int x, int y) {
        return ((long) x << 32) | ((long) y << 32 >>> 32);
    }

    // k = 0...nums.length - 1
    // After calling this function, nums[k] is the k-th number.
    public static int kthNumber(int[] nums, int k) {
        return kthNumberHelper(nums, k, 0, nums.length - 1);
    }

    // end is inclusive (0 to nums.length - 1)
    private static int kthNumberHelper(int[] nums, int K, int start, int end) {
        if (start == end) return nums[start];
        int i = partition(nums, start, end);
        return K <= i ? kthNumberHelper(nums, K, start, i) : kthNumberHelper(nums, K, i + 1, end);
    }

    // end is inclusive (0 to nums.length - 1)
    public static int partition(int[] nums, int start, int end) {
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && nums[i] < pivot) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && pivot < nums[j]) j--;
            if (i < j) nums[i++] = nums[j];
        }

        // pos is the final position for pivot.
        nums[i] = pivot;
        return i;
    }

    public static void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    // partition nums into 3 parts [smaller than pivot, equal to pivot, larger than pivot]
    public static void partition3(int[] nums, int pivot) {
        int n = nums.length;
        int l = 0, r = n - 1;
        for (int i = 0; i <= r; i++) {
            if (nums[i] < pivot) {
                swap(nums, l++, i);
            } else if (nums[i] > pivot) {
                swap(nums, r--, i--);
            }
        }
    }

    // end is inclusive
    public static void reverse(int[] nums, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    }

    // Return false if next permutation is not available. (nums is not changed for this case)
    public static boolean nextPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] >= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] > nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // Return false if previous permutation is not available. (nums is not changed for this case)
    public static boolean prevPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] <= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] < nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }


    // a, b could be negative
    // remainder >= 0
    // return [a / b, a % b]
    public static int[] divMod(int a, int b) {
        int r = a % b;
        int c = a / b;
        if (r < 0) {
            r += Math.abs(b);
            c++;
        }
        return new int[]{c, r};
    }

    public static List<Integer> negativeBase(int n, int base) {
        List<Integer> digits = new ArrayList<>();
        if (n == 0) {
            digits.add(0);
            return digits;
        }
        while (n != 0) {
            // t[0] = n / base
            // t[1] = n % base;
            int[] t = divMod(n, base);
            digits.add(t[1]);
            n = t[0];
        }
        Collections.reverse(digits);
        return digits;
    }

    // (a ^ b) % MOD
    public static long powMod(long a, long b, long MOD) {
        long res = 1L;
        a %= MOD; // In case a * a is overflow
        while (b > 0) {
            if ((b & 1) != 0) res = (res * a) % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    public static long[][] genCombination(int n) {
        long[][] C = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        return C;
    }

    public static long[][] genPermutation(int n) {
        long[][] P = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
        return P;
    }

    public static long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }

    public static int[] preprocessLog2(int n) { // from log2(0) .... log2(n) inclusive
        int[] lg = new int[n + 1];
        for (int k = 0, i = 1; i <= n; lg[i++] = k - 1) {
            while ((1 << k) <= i) {
                k++;
            }
        }
        return lg;
    }

    public static long max(long[] nums) {
        long ret = Long.MIN_VALUE;
        for (long v : nums) ret = Math.max(ret, v);
        return ret;
    }

    public static int max(int[] nums) {
        int ret = Integer.MIN_VALUE;
        for (int v : nums) ret = Math.max(ret, v);
        return ret;
    }
}

// Tested by leetcode 1163
class SuffixArray {
    int[] s;
    int[] SA; // SA[i] => index of the i-th ranked suffix
    int[] rank; // rank[i] => the rank of i-th suffix, SA[rank[i]] == i
    int[] height; // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).

    private int[][] d;
    private int n;
    private int[] lg;

    private int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    private static int[] stringToIntArray(String str) {
        int[] nums = new int[str.length()];
        for (int i = 0; i < str.length(); i++) nums[i] = str.charAt(i);
        return nums;
    }

    public SuffixArray(String str) {
        this(str, true);
    }

    public SuffixArray(String str, boolean toBuildRMQ) {
        this(stringToIntArray(str), toBuildRMQ);
    }

    public SuffixArray(int[] nums) {
        this(nums, true);
    }

    public SuffixArray(int[] nums, boolean toBuildRMQ) {
        this.s = nums;
        this.n = nums.length;
        this.SA = new int[n];
        this.rank = new int[n];
        suffixSort(s);
        if (toBuildRMQ) {
            this.height = new int[n];
            this.d = new int[log2(n) + 1][n];
            this.lg = new int[n + 1];
            buildHeight();
            buildRMQ();
        }
    }

    // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).
    // ?? s[n] = 0 or s[n] = -INF.
    private void buildHeight() {
        int i, j, h;
        height[0] = 0;
        for (i = 0; i < n; i++)
            rank[SA[i]] = i;
        for (h = i = 0; i < n; i++)
            if (rank[i] > 0) {
                j = SA[rank[i] - 1];
                while (i + h < n && j + h < n && s[i + h] == s[j + h]) ++h;
                height[rank[i]] = h;
                if (h > 0) --h;
            }
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    private void buildRMQ() {
        int i, j, k;
        for (i = 0; i < n; i++)
            d[0][i] = height[i];
        for (j = 1; (1 << j) <= n; j++)
            for (i = 0; i + (1 << j) <= n; i++)
                d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
        for (lg[0] = k = 0, i = 1; i <= n; lg[i++] = k - 1)
            while ((1 << k) <= i) k++;
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    public int LCP(int i, int j) {
        if (i == j) return n - SA[i];
        if (i > j) {
            int t = i;
            i = j;
            j = t;
        }
        int k = lg[j - (++i) + 1];
        return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }

    // LCPIndex(i, j) = LCP(s[i], s[j])
    public int LCPIndex(int i, int j) {
        return LCP(rank[i], rank[j]);
    }

    private void sortIndex(int[] nums, int start, int end) {
        if (start >= end) return;
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && s[nums[i]] < s[pivot]) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && s[pivot] < s[nums[j]]) j--;
            if (i < j) nums[i++] = nums[j];
        }
        nums[i] = pivot; // index i is the final position for pivot.
        sortIndex(nums, start, i - 1);
        sortIndex(nums, i + 1, end);
    }

    private void suffixSort(int[] s) {
        int[] count = new int[n], t;
        int[] nSA = new int[n];
        int[] nRank = new int[n];
//        Integer[] tempArray = new Integer[n];
//        for (int x = 0; x < n; x++) tempArray[x] = x;
//        Arrays.sort(tempArray, (a, b) -> Integer.compare(s[a], s[b]));
//        for (int x = 0; x < n; x++) SA[x] = tempArray[x];
        int i, k;
        int minV = s[0], maxV = s[0];
        for (i = 1; i < n; i++) {
            minV = Math.min(minV, s[i]);
            maxV = Math.max(maxV, s[i]);
        }
        if ((long) maxV - minV + 1 <= (long) n) { // radix sort if alphabet size is small
            for (i = 0; i < n; i++) count[s[i] - minV]++;
            for (i = minV + 1; i <= maxV; i++) count[i - minV] += count[i - minV - 1];
            for (i = n - 1; i >= 0; i--) SA[--count[s[i] - minV]] = i;
        } else {
            for (i = 0; i < n; i++) SA[i] = i;
            sortIndex(SA, 0, n - 1);
        }
        for (rank[SA[0]] = 0, i = 1; i < n; i++) {
            rank[SA[i]] = (s[SA[i]] != s[SA[i - 1]]) ? rank[SA[i - 1]] + 1 : rank[SA[i - 1]];
        }
        for (k = 1; k < n && rank[SA[n - 1]] < n - 1; k <<= 1) {
            for (i = 0; i < n; i++) count[rank[SA[i]]] = i + 1;
            for (i = n - 1; i >= 0; i--) if (SA[i] >= k) nSA[--count[rank[SA[i] - k]]] = SA[i] - k;
            for (i = n - k; i < n; i++) nSA[--count[rank[i]]] = i;
            t = SA;
            SA = nSA;
            nSA = t;
            for (nRank[SA[0]] = 0, i = 1; i < n; i++) {
                nRank[SA[i]] = (SA[i] + k >= n || SA[i - 1] + k >= n || rank[SA[i]] != rank[SA[i - 1]] || rank[SA[i] + k] != rank[SA[i - 1] + k]) ? nRank[SA[i - 1]] + 1 : nRank[SA[i - 1]];
            }
            t = rank;
            rank = nRank;
            nRank = t;
        }
    }
}

class Combination {
    long[] factorial;
    long[] inverseFactorial;
    long MOD;

    // O(maxSize) for preprocessing
    // MOD must be prime
    public Combination(int maxSize, long MOD) {
        factorial = new long[maxSize + 1];
        inverseFactorial = new long[maxSize + 1];
        factorial[0] = 1;
        inverseFactorial[0] = 1;
        this.MOD = MOD;
        for (int i = 1; i <= maxSize; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
            inverseFactorial[i] = inverse(factorial[i]);
        }
    }

    // x, y are long[1]
    // ax + by = gcd(a, b)
    private long extGcd(long a, long b, long[] x, long[] y) {
        if (b == 0) {
            x[0] = 1;
            y[0] = 0;
            return a;
        } else {
            long r = extGcd(b, a % b, y, x);
            y[0] -= x[0] * (a / b);
            return r;
        }
    }

    // (a * x) % MOD = 1
    // x is the inverse element
    public long inverse(long a) {
        long[] x = new long[1], y = new long[1];
        extGcd(a, MOD, x, y);
        return (x[0] % MOD + MOD) % MOD;
    }

    // m >= n
    // O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        else if (m == n) return factorial[m];
            //return factorial[m] * inverse(factorial[m - n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD;
    }

    // m >= n
    // O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
            //return factorial[m] * inverse(factorial[m - n]) % MOD * inverse(factorial[n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD * inverseFactorial[n] % MOD;
    }
}

class CombinationNoMod {

    long[][] C;
    long[][] P;

    public CombinationNoMod(int maxSize) {
        C = new long[maxSize + 1][maxSize + 1];
        P = new long[maxSize + 1][maxSize + 1];
        int m = C.length;
        int n = C[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
    }

    // m >= n. O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        return P[m][n];
    }

    // m >= n. O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
        return C[m][n];
    }
}

class Fraction {
    long n, d; // n / d (d != 0)

    public Fraction(long n, long d) {
        if (d == 0) {
            this.n = Long.MAX_VALUE;
            this.d = 1;
            return;
        }
        long g = gcd(Math.abs(n), Math.abs(d));
        this.n = n / g;
        this.d = d / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    public void add(Fraction other) {
        long numerator = this.n * other.d + this.d * other.n;
        long denominator = this.d * other.d;
        long g = gcd(Math.abs(numerator), Math.abs(denominator));
        this.n = numerator / g;
        this.d = denominator / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    @Override
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof Fraction) {
            Fraction anotherObject = (Fraction) anObject;
            return n == anotherObject.n && d == anotherObject.d;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return (int) (n * 31 + d);
    }

    private long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }
}

class UnionFind {
    int[] parent;
    int[] sz;

    // from 0 ... n - 1
    public UnionFind(int n) {
        parent = new int[n];
        sz = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public void clear() {
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public int find(int x) {
        //return parent[x] == x ? x : (parent[x] = find(parent[x]));
        if (parent[x] == x) return x;
        int px = x;
        while (px != parent[px]) px = parent[px];
        while (x != px) {
            int next = parent[x];
            parent[x] = px;
            x = next;
        }
        return px;
    }

    // px is the final parent
    public boolean union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return false;
        parent[py] = px;
        sz[px] += sz[py];
        return true;
    }

    public int size(int x) {
        return sz[find(x)];
    }

    public UnionFind clone() {
        UnionFind cloned = new UnionFind(parent.length);
        for (int i = 0; i < parent.length; i++) {
            cloned.parent[i] = parent[i];
            cloned.sz[i] = sz[i];
        }
        return cloned;
    }
}

class Trie {
    static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        boolean isWord = false;
        long count = 0L;
    }

    TrieNode root = new TrieNode();

    public void add(String word) {
        add(word, 1L);
    }

    public void remove(String word) {
        add(word, -1L);
    }

    private void add(String word, long count) {
        TrieNode cur = root;
        cur.count += count;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) cur.next[c] = new TrieNode();
            cur = cur.next[c];
            cur.count += count;
        }
        cur.isWord = true;
    }

    public boolean contains(String word) {
        TrieNode cur = root;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null || cur.next[c].count <= 0L) return false;
            cur = cur.next[c];
            //if (cur.isWord) return true;
        }
        return cur.isWord;
    }
}

// Tested by Leetcode 1707 and Leetcode 1803
class TrieBinary {
    static class TrieNode {
        TrieNode[] next = new TrieNode[2];
        long count;
    }

    private TrieNode root;
    private int numOfBits;

    public TrieBinary(int numOfBits) { // normally 31 for int and 63 for long
        this.numOfBits = numOfBits;
        this.root = new TrieNode();
    }

    public void add(long v) {
        add(v, 1L);
    }

    public void remove(long v) { // Tested by Leetcode 1938
        add(v, -1L);
    }

    public void add(long v, long count) {
        TrieNode cur = root;
        root.count += count;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null) cur.next[b] = new TrieNode();
            cur = cur.next[b];
            cur.count += count;
        }
    }

    // Tested by Leetcode 1707
    public long xorMax(long v) {
        TrieNode cur = root;
        long key = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[1 - b] != null && cur.next[1 - b].count > 0) {
                cur = cur.next[1 - b];
                key |= (1L - b) << i;
            } else {
                cur = cur.next[b];
                key |= (long) b << i;
            }
        }
        return key ^ v;
    }

    public boolean contains(long v) {
        TrieNode cur = root;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null || cur.next[b].count <= 0) return false;
            cur = cur.next[b];
        }
        return true;
    }

    // Tested by Leetcode 1803
    // count(x ^ v <= limit)
    public long xorLessOrEqualCount(long v, long limit) {
        if (limit < 0) return 0;
        TrieNode cur = root;
        long ans = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int bitLimit = ((limit >>> i) & 1) == 0 ? 0 : 1;
            int bitV = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (bitLimit == 1) {
                ans += (cur.next[bitV] != null ? cur.next[bitV].count : 0);
            }
            cur = cur.next[bitV ^ bitLimit];
            if (cur == null) break;
            if (i == 0) ans += cur.count;
        }
        return ans;
    }
}

// Lazy execution example is in https://leetcode.com/submissions/detail/1034182539/
// Refer to AlgorithmCompilation.java

// [Template] Classic Segment Tree (Range Sum), used for Template
class ClassicSegmentTree { // For Range Sum
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final int L, R;

    public ClassicSegmentTree(int[] input) {
        L = 0;
        R = input.length - 1;
        root = new TreeNode();
        build(root, L, R, input);
    }

    private void build(TreeNode root, int l, int r, int[] input) {
        if (l == r) {
            root.sum = input[l];
            return;
        }
        int m = (l + r) >> 1;
        root.left = new TreeNode();
        root.right = new TreeNode();
        build(root.left, l, m, input);
        build(root.right, m + 1, r, input);
        root.sum = root.left.sum + root.right.sum;
    }

    public void set(int index, int value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, int L, int R, int index, int value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        int M = L + ((R - L) >> 1);
        if (index <= M) {
            set(root.left, L, M, index, value);
        } else {
            set(root.right, M + 1, R, index, value);
        }
        root.sum = root.left.sum + root.right.sum;
    }

    // Sum[queryL...queryR] inclusive
    public long query(int queryL, int queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, int L, int R, int queryL, int queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        int M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 307
class DynamicSegmentTreeRangeSum {
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeSum(long l, long r) {
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return sum(cur);
    }

    public void add(long index, long value) {
        set(index, get(index) + value);
    }

    private long sum(TreeNode node) {
        return node == null ? 0L : node.sum;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.sum = sum(root.left) + sum(root.right);
    }

    // Sum[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        long M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 239, 2926
class DynamicSegmentTreeRangeMax {
    class TreeNode {
        TreeNode left, right;
        long max = Long.MIN_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMax(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return max(cur);
    }

    private long max(TreeNode node) {
        return node == null ? Long.MIN_VALUE : node.max;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.max = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.max = Math.max(max(root.left), max(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MIN_VALUE;
        if (queryL <= L && R <= queryR) return root.max;
        long M = L + ((R - L) >> 1);
        return Math.max(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class DynamicSegmentTreeRangeMin {
    class TreeNode {
        TreeNode left, right;
        long min = Long.MAX_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMin(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return min(cur);
    }

    private long min(TreeNode node) {
        return node == null ? Long.MAX_VALUE : node.min;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.min = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.min = Math.min(min(root.left), min(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MAX_VALUE;
        if (queryL <= L && R <= queryR) return root.min;
        long M = L + ((R - L) >> 1);
        return Math.min(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class BinaryIndexTree {
    private long[] c;
    private int n;

    // NOTE: index is from 1 to n. (NOT 0 ... n - 1)
    public BinaryIndexTree(int n) {
        this.n = n;
        this.c = new long[n + 1];
    }

    // Add value to position k, k is from 1 to n.
    public void add(int k, long value) {
        while (k <= n) {
            c[k] += value;
            k += (k & (k ^ (k - 1)));
        }
    }

    // k is from 1 to n.
    public long getSum(int k) {
        long sum = 0;
        while (k > 0) {
            sum += c[k];
            k -= (k & (k ^ (k - 1)));
        }
        return sum;
    }
}

class RangeSum {
    BinaryIndexTree tree;
    int start;

    // [low, high] inclusive
    public RangeSum(int low, int high) {
        start = low;
        tree = new BinaryIndexTree(high - low + 1);
    }

    public void add(int index, long value) {
        tree.add(index - start + 1, value);
    }

    public long get(int index) {
        return tree.getSum(index - start + 1) - tree.getSum(index - start);
    }

    public void set(int index, long value) {
        tree.add(index - start + 1, value - get(index));
    }

    // [l, r] inclusive
    public long getSum(int l, int r) {
        return tree.getSum(r - start + 1) - tree.getSum(l - start);
    }
}

class RangeMax {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMax(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MIN_VALUE);
    }

    public RangeMax(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.max(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMax(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MIN_VALUE, resr = Long.MIN_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.max(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.max(t[--r], resr);
        }
        return Math.max(resl, resr);
    }
}

class RangeMin {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMin(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MAX_VALUE);
    }

    public RangeMin(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.min(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMin(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MAX_VALUE, resr = Long.MAX_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.min(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.min(t[--r], resr);
        }
        return Math.min(resl, resr);
    }
}

// Including topological sort.
class GraphIntegerFaster {
    public List<Integer>[] adj;

    public GraphIntegerFaster(int n) {
        adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    // directed edge x -> y
    public void link(int x, int y) {
        adj[x].add(y);
    }

    public List<Integer> getChildren(int x) {
        return adj[x];
    }

    private static final int TEMPORARY = 1;
    private static final int PERMANENT = 2;

    // x -> y means x should be processed before y
    // The input is a directed graph.
    // 1. return null, means there is a cycle inside the graph, or the input is
    // invalid.
    // 2. return List<Node> as the result.
    public List<Integer> topologicalSort() {
        //Map<E, Integer> vst = new HashMap<>();
        int n = adj.length;
        int[] vst = new int[n];
        List<Integer> result = new ArrayList<>();
        for (int x = 0; x < n; x++) {
            if (!topologicalSort(x, vst, result)) {
                return null;
            }
        }
        Collections.reverse(result);
        return result;
    }

    private boolean topologicalSort(int root, int[] vst, List<Integer> result) {
        if (vst[root] == PERMANENT) {
            return true;
        }
        if (vst[root] == TEMPORARY) { // found cycle
            return false;
        }

        vst[root] = TEMPORARY;
        for (int child : getChildren(root)) {
            if (!topologicalSort(child, vst, result)) {
                return false;
            }
        }
        result.add(root);
        vst[root] = PERMANENT;
        return true;
    }
}

class DijkstraLongFaster {
    public static class Edge {
        int to;
        long w;

        public Edge(int to, long w) {
            this.to = to;
            this.w = w;
        }
    }

    public static final long INF = Long.MAX_VALUE / 4;
    public List<Edge>[] adj;

    public DijkstraLongFaster(int n) {
        this.adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    public void link(int x, int y, long w) {
        adj[x].add(new Edge(y, w));
    }

    public long[] shortestPath(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
        q.add(new Edge(src, 0));
        dist[src] = 0;

        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (vst[cur.to]) continue;
            int u = cur.to;
            long w = cur.w;
            vst[u] = true;

            for (Edge e : adj[u]) {
                if (!vst[e.to] && dist[e.to] > w + e.w) {
                    dist[e.to] = w + e.w;
                    q.add(new Edge(e.to, dist[e.to]));
                }
            }
        }
        return dist;
    }

    // NOTE: w of each edge must be the same.
    public long[] bfs(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        Queue<Integer> q = new ArrayDeque<>();
        q.add(src);
        dist[src] = 0;
        vst[src] = true;

        while (!q.isEmpty()) {
            int u = q.poll();
            long w = dist[u];
            for (Edge e : adj[u]) {
                if (!vst[e.to]) {
                    dist[e.to] = w + e.w;
                    vst[e.to] = true;
                    q.add(e.to);
                }
            }
        }
        return dist;
    }
}

class TreapSet<E> {
    private class Node {
        E key;
        int priority, count, total;
        Node left, right, pnt;

        public Node(E key, int priority, Node pnt) {
            this.key = key;
            this.priority = priority;
            this.pnt = pnt;
            this.count = 1;
            this.total = 1;
        }
    }

    private static final Random RANDOM = new Random();
    private final Comparator<? super E> comparator;
    private Node root;

    public TreapSet(Comparator<? super E> comparator) {
        this.comparator = comparator;
    }

    public boolean isEmpty() {
        return root == null;
    }

    public void clear() {
        root = null;
    }

    public int size() {
        return root == null ? 0 : root.total;
    }

    private int leftRank(Node p) {
        return p.left != null ? p.left.total : 0;
    }

    private int rightRank(Node p) {
        return p.right != null ? p.right.total : 0;
    }

    private void rotateLeft(Node x) {
        Node y = x.right;
        if ((x.right = y.left) != null) y.left.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.left) x.pnt.left = y;
        else x.pnt.right = y;
        y.left = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    private void rotateRight(Node x) {
        Node y = x.left;
        if ((x.left = y.right) != null) y.right.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.right) x.pnt.right = y;
        else x.pnt.left = y;
        y.right = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    public void add(E key) {
        if (root == null) {
            root = new Node(key, RANDOM.nextInt(), null);
            return;
        }
        Node x = root, p = null;
        while (x != null) {
            ++((p = x).total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                ++(x.count);
                return;
            }
        }

        x = new Node(key, RANDOM.nextInt(), p);
        if (comparator.compare(key, p.key) < 0) p.left = x;
        else p.right = x;
        while ((p = x.pnt) != null && p.priority < x.priority) {
            if (p.left == x) rotateRight(p);
            else rotateLeft(p);
        }
    }

    public void remove(E key) {
        Node x = root, p = null;
        while (x != null) {
            --(x.total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                if (--(x.count) > 0) return;
                break;
            }
        }
        if (x == null) return;
        while (x.left != null || x.right != null) {
            if (x.left == null || (x.right != null && x.right.priority > x.left.priority)) {
                rotateLeft(x);
            } else {
                rotateRight(x);
            }
        }
        if ((p = x.pnt) != null) {
            if (p.left == x) p.left = null;
            else p.right = null;
        } else {
            root = null;
        }
        // delete x;
    }

    // number of elements smaller than key
    public int lowerCount(E key) {
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                sum += leftRank(x) + x.count;
                x = x.right;
            } else {
                sum += leftRank(x);
                break;
            }
        }
        return sum;
    }

    // number of elements larger than key
    public int higherCount(E key) {
        //return size() - lowerCount(key) - count(key);
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp > 0) x = x.right;
            else if (cmp < 0) {
                sum += rightRank(x) + x.count;
                x = x.left;
            } else {
                sum += rightRank(x);
                break;
            }
        }
        return sum;
    }

    public int index(E key) {
        return lowerCount(key);
    }

    public E get(int index) // index = 0 ... size - 1
    {
        Node p = root;
        ++index;
        while (true) {
            int t = leftRank(p);
            if (index <= t) p = p.left;
            else {
                if ((index -= t + p.count) <= 0) break;
                p = p.right;
            }
        }
        return p.key;
    }

    public int count(E key) {
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                x = x.right;
            } else {
                return x.count;
            }
        }
        return 0;
    }

    public E first() {
        if (root == null) return null;
        Node x = root;
        while (x.left != null) {
            x = x.left;
        }
        return x.key;
    }

    public E last() {
        if (root == null) return null;
        Node x = root;
        while (x.right != null) {
            x = x.right;
        }
        return x.key;
    }

    public boolean contains(E key) {
        return count(key) > 0;
    }

    public E ceiling(E key) {
        int id = lowerCount(key);
        return id >= size() ? null : get(id);
    }

    public E floor(E key) {
        int id = size() - higherCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E lower(E key) {
        int id = lowerCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E higher(E key) {
        int id = size() - higherCount(key);
        return id >= size() ? null : get(id);
    }

    // return the first index whose value >= target
    // if this value doesn't exist, return index = size()
    public int lowerBound(E target) {
        return lowerCount(target);
    }

    // return the first index whose value > target
    // if this value doesn't exist, return index = size()
    public int upperBound(E target) {
        return size() - higherCount(target);
    }

    public List<E> keys() {
        List<E> list = new ArrayList<>();
        inorder(root, list);
        return list;
    }

    private void inorder(Node x, List<E> list) {
        if (x == null) return;
        inorder(x.left, list);
        list.add(x.key);
        inorder(x.right, list);
    }
}

class ArraySum {
    long[] sum;
    int n;

    // nums index starts from 0 to nums.length - 1;
    public ArraySum(int[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    public ArraySum(long[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    // [l, r], index starts from 0
    public long getSum(int l, int r) {
        // error handling
        if (l > r || !(l >= 0 && l < n && r >= 0 && r < n)) return 0L;
        return sum[r + 1] - sum[l];
    }
}

class TwoDArraySum {
    int[][] sum;
    int m, n;

    // nums index starts from 0
    public TwoDArraySum(final int[][] nums) {
        m = nums.length;
        n = nums[0].length;
        sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + nums[i - 1][j - 1];
            }
        }
    }

    // [(x1, y1), (x2, y2)], index starts from 0
    // x1 <= x2 and y1 <= y2
    public int getSum(int x1, int y1, int x2, int y2) {
        if (!(x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && x2 >= 0 && x2 < m && y2 >= 0 && y2 < n) || x1 > x2 || y1 > y2)
            return 0;
        return sum[x2 + 1][y2 + 1] - sum[x2 + 1][y1] - sum[x1][y2 + 1] + sum[x1][y1];
    }
}

class ArrayUtils {
    static void fill(int[] array, int defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(int[][] array, int defaultValue) {
        for (int[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(int[][][] array, int defaultValue) {
        for (int[][] a2 : array) {
            for (int[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(int[][][][] array, int defaultValue) {
        for (int[][][] a3 : array) {
            for (int[][] a2 : a3) {
                for (int[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(int[][][][][] array, int defaultValue) {
        for (int[][][][] a4 : array) {
            for (int[][][] a3 : a4) {
                for (int[][] a2 : a3) {
                    for (int[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(int[][][][][][] array, int defaultValue) {
        for (int[][][][][] a5 : array) {
            for (int[][][][] a4 : a5) {
                for (int[][][] a3 : a4) {
                    for (int[][] a2 : a3) {
                        for (int[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }

    static void fill(long[] array, long defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(long[][] array, long defaultValue) {
        for (long[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(long[][][] array, long defaultValue) {
        for (long[][] a2 : array) {
            for (long[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(long[][][][] array, long defaultValue) {
        for (long[][][] a3 : array) {
            for (long[][] a2 : a3) {
                for (long[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(long[][][][][] array, long defaultValue) {
        for (long[][][][] a4 : array) {
            for (long[][][] a3 : a4) {
                for (long[][] a2 : a3) {
                    for (long[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(long[][][][][][] array, long defaultValue) {
        for (long[][][][][] a5 : array) {
            for (long[][][][] a4 : a5) {
                for (long[][][] a3 : a4) {
                    for (long[][] a2 : a3) {
                        for (long[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }
}

class CharacterUtils {
    static boolean[] vowel = new boolean[128];

    static {
        vowel['a'] = vowel['e'] = vowel['i'] = vowel['o'] = vowel['u'] = true;
        vowel['A'] = vowel['E'] = vowel['I'] = vowel['O'] = vowel['U'] = true;
    }

    static boolean isVowel(char ch) {
        return vowel[ch];
    }

    static boolean isLetter(char ch) {
        return ((ch - 'a') >= 0 && (ch - 'a') < 26) ||
                ((ch - 'A') >= 0 && (ch - 'A') < 26);
    }

    static boolean isLowerCase(char ch) {
        return (ch - 'a') >= 0 && (ch - 'a') < 26;
    }

    static boolean isUpperCase(char ch) {
        return (ch - 'A') >= 0 && (ch - 'A') < 26;
    }

    static boolean isDigit(char ch) {
        return (ch - '0') >= 0 && (ch - '0') <= 9;
    }
}

class DoubleUtils {
    private static final double EPS = 1e-8;

    public static int compare(double a, double b) {
        if (a - b > EPS) return 1;
        else if (a - b < -EPS) return -1;
        else return 0;
    }

    public static boolean isInteger(double a) {
        return compare(floor(a), a) == 0;
    }

    public static double floor(double a) {
        return Math.floor(a + EPS);
    }

    public static double ceil(double a) {
        return Math.ceil(a - EPS);
    }
}

class MatrixUtils {
    static final long MOD = 1_000_000_007L;

    // matrix[n][n], matrix[i][i] = 1
    static long[][] genIdentityMatrix(int n) {
        long[][] matrix = new long[n][n];
        for (int i = 0; i < n; i++) matrix[i][i] = 1;
        return matrix;
    }

    static long[][] multiply(long[][] a, long[][] b, long MOD) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]) % MOD;
                }
            }
        }
        return res;
    }

    static long[][] multiply(long[][] a, long[][] b) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]);
                }
            }
        }
        return res;
    }

    // a^b % MOD
    static long[][] powMod(long[][] a, long b, long MOD) {
        int n = a.length;
        long[][] res = genIdentityMatrix(n);
        while (b > 0) {
            if ((b & 1) != 0) res = multiply(res, a, MOD);
            a = multiply(a, a, MOD);
            b >>= 1;
        }
        return res;
    }

    static void print(long[][] matrix) {
        for (int i = 0; i < matrix.length; i++) {
            System.out.println(Arrays.toString(matrix[i]));
        }
    }
}

class IntegerUtils {
    static long[] power10 = new long[19]; // 10^i

    static {
        power10[0] = 1L;
        for (int i = 1; i < power10.length; i++) {
            power10[i] = power10[i - 1] * 10;
        }
    }

    // swap index i and j of integer (long) num. i == 0 means the lowest position.
    static long swapDigit(long num, int i, int j) {
        if (i == j) return num;
        long di = num / power10[i] % 10L;
        long dj = num / power10[j] % 10L;
        return num - di * power10[i] - dj * power10[j] + dj * power10[i] + di * power10[j];
    }
}

class StringUtils {
    // This function is deprecated, please hash(int l, int r) in class StableStringHash or StringHash
    // rolling hash of substrings of 's' with length == k
    // long[pos] = hash(s.substring(pos, pos + k))
    public static long[] rollingHash(String s, int k) {
        long[] ans = new long[s.length() - k + 1];
        int seed1 = 31;
        int seed2 = 131;
        int h1 = 0, h2 = 0, power1 = 1, power2 = 1;
        for (int i = 0; i < k; i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);

            power1 *= seed1;
            power2 *= seed2;
        }

        ans[0] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        for (int i = k; i < s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i) - power1 * s.charAt(i - k);
            h2 = h2 * seed2 + s.charAt(i) - power2 * s.charAt(i - k);
            ans[i - k + 1] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        }

        return ans;
    }

    public static int[] kmpNext(String s) {
        int n = s.length();
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s.charAt(i) != s.charAt(k)) k = next[k - 1];
            if (s.charAt(i) == s.charAt(k)) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(String s, String p) {
        int[] next = kmpNext(p);
        int n = s.length();
        int m = p.length();
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p.charAt(j) != s.charAt(i)) {
                j = next[j - 1];
            }
            if (p.charAt(j) == s.charAt(i)) j++;
            if (j == m) return true;
        }
        return false;
    }

    public static int[] kmpNext(int[] s) {
        int n = s.length;
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s[i] != s[k]) k = next[k - 1];
            if (s[i] == s[k]) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(int[] s, int[] p) {
        int[] next = kmpNext(p);
        int n = s.length;
        int m = p.length;
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p[j] != s[i]) {
                j = next[j - 1];
            }
            if (p[j] == s[i]) j++;
            if (j == m) return true;
        }
        return false;
    }

    // Z[i] = longest length of common prefix of str[0 ... n - 1] and str[i ... n - 1]
    // Tested by LC2223, LC459
    public static int[] zFunction(String str) {
        int n = str.length();
        int[] Z = new int[n];
        // [L,R] makes a window which matches with prefix of s
        int L = 0, R = 0;
        Z[0] = n;
        for (int i = 1; i < n; ++i) {
            if (i > R) {
                L = R = i;
                while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                Z[i] = R - L;
                R--;
            } else {
                int k = i - L;
                if (Z[k] < R - i + 1) {
                    Z[i] = Z[k];
                } else {
                    L = i;
                    while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                    Z[i] = R - L;
                    R--;
                }
            }
        }
        return Z;
    }
}

// Better to use this when length of string >= 2^11
class StringHash {
    static class SingleStringHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleStringHash(String s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length();
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s.charAt(i - 1)) % MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleStringHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L;

    public StringHash(String s) {
        hash1 = new SingleStringHash(s, SEED1, MOD);
        hash2 = new SingleStringHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(String s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length(); i++) {
            h1 = (h1 * SEED1 + s.charAt(i)) % MOD;
            h2 = (h2 * SEED2 + s.charAt(i)) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(char[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class IntegerArrayHash {
    static class SingleIntegerArrayHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleIntegerArrayHash(int[] s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length;
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s[i - 1]) % MOD;
                if (h[i] < 0) h[i] += MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleIntegerArrayHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L; // or 1_000_000_123L

    public IntegerArrayHash(int[] s) {
        hash1 = new SingleIntegerArrayHash(s, SEED1, MOD);
        hash2 = new SingleIntegerArrayHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(int[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(List<Integer> s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.size(); i++) {
            h1 = (h1 * SEED1 + s.get(i)) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s.get(i)) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class RMQ { // NOTE!!! query return index, not value
    // tested by LC 1438,239
    final long[] a; // input data array copy
    int[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQ(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQ(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new int[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = i;
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = a[d[j - 1][i]] >= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                } else {
                    d[j][i] = a[d[j - 1][i]] <= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                }
    }

    // i <= j, and index starts from 0.
    public int query(int i, int j) { // NOTE!!! return index, not value
        int k = log2[j - i + 1];
        if (useMax) return a[d[k][i]] >= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
        else return a[d[k][i]] <= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
    }
}

class RMQValue { // NOTE!!! query return value, not index
    final long[] a; // input data array copy
    long[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQValue(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQValue(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new long[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = a[i];
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = Math.max(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                } else {
                    d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                }
    }

    // i <= j, and index starts from 0.
    public long query(int i, int j) {
        int k = log2[j - i + 1];
        if (useMax) return Math.max(d[k][i], d[k][j - (1 << k) + 1]);
        else return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }
}

// Tested by 2827
// Similar: 1012, 2376, 902, 2719, 2801, 357, 1215, 1397
class DigitDP {
    static final boolean ENABLE_DEBUG_MODE = false; // TODO: set it to true if you want to print more debug info
    static final long UNSET = -1;
    // dp[isStart][hasLimit][pos] | [odd][even][r]
    // (isStart, hasLimit, pos) is generic, (odd, even, r) is use case specific
    long[][][][][][] dp;
    int K;

    public long digitDP(long num, int k) {
        String numString = String.valueOf(num); // TODO
        this.dp = new long[2][2][numString.length()][numString.length() + 1][numString.length() + 1][k];
        this.K = k;

        if (ENABLE_DEBUG_MODE) System.out.println(""num = "" + numString);
        ArrayUtils.fill(dp, UNSET);
        long ans = dfs(new StringBuilder(), numString, 1, 1, 0, 0, 0, 0);
        if (ENABLE_DEBUG_MODE) System.out.println(""---------------------\n"");
        return ans;
    }

    long dfs(StringBuilder curResult, String s, int isStart, int hasLimit, int pos, int odd, int even, int r) {
        if (pos == s.length()) {
            if (isStart == 1) return 0; // NOTE: special check for num == 0. TODO
            if (r == 0 && odd == even) { // TODO
                if (ENABLE_DEBUG_MODE) System.out.println(""result = "" + curResult);
                return 1;
            } else {
                return 0;
            }
        }
        if (dp[isStart][hasLimit][pos][odd][even][r] != UNSET) return dp[isStart][hasLimit][pos][odd][even][r];

        int start = 0;
        int end = (hasLimit == 1) ? s.charAt(pos) - '0' : 9; // TODO: check if it is binary string or not

        long ans = 0;
        for (int digit = start; digit <= end; digit++) {
            if (isStart == 1 && digit == 0) { // NOTE: handle leading zeros
                // [0, 999..9]
                // [0， 10^(len(s) - pos - 1) - 1]
                ans += dfs(new StringBuilder(), s, 1, 0, pos + 1, 0, 0, 0);
                continue;
            }
            int newHasLimit = (hasLimit == 1 && digit == s.charAt(pos) - '0') ? 1 : 0;

            int newOdd = odd + (digit % 2); // TODO
            int newEven = even + (digit % 2 == 0 ? 1 : 0); // TODO
            int newR = (isStart == 1 ? digit % this.K : (r * 10 + digit) % this.K); // TODO;

            if (ENABLE_DEBUG_MODE) curResult.append(digit);
            ans += dfs(curResult, s, 0, newHasLimit, pos + 1, newOdd, newEven, newR);
            if (ENABLE_DEBUG_MODE) curResult.deleteCharAt(curResult.length() - 1);

        }
        return dp[isStart][hasLimit][pos][odd][even][r] = ans;
    }
}

class Printer {
    static boolean ENABLE_LOCAL_PRINT = false;

    static void println(String x) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.println(x);
    }

    static void printf(String format, Object... args) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.printf(format, args);
    }
}


public class Solution {
    private static final int INF = 1_000_000_001;
    private static final long MOD = 1_000_000_007L;

    private static final int UNSET = -131;
    // 4 neighbors
    private static final int[] DX = {-1, 0, 1, 0}; // up, right, down, left
    private static final int[] DY = {0, 1, 0, -1};

    // 8 neighbors
    //    private static final int[] DX = {-1, -1, 0, 1, 1,  1, 0,  -1};
    //    private static final int[] DY = {0,   1, 1, 1, 0, -1, -1, -1};

    // knight
    //    private static final int[] DX = {-2, -2, -1, 1, 2, 2, 1, -1};
    //    private static final int[] DY = {-1, 1, 2, 2, 1, -1, -2, -2};

    static final int L = 1000;
    static int[] steps = new int[L];

    static {
        steps[1] = 0;
        for (int i = 2; i < L; i++) {
            int bitCount = Integer.bitCount(i);
            //if (bitCount > 1) {
            steps[i] = steps[bitCount] + 1;
            //}
        }
    }

    static Combination comb = new Combination(L, MOD);

    public int countKReducibleNumbers(String s, int k) {

        int n = s.length();

        long ans = 0;
        int curCount = 0;
        for (int i = 0; i < n; i++) {
            if (s.charAt(i) == '0') {
                continue;
            }
            int remainCount = n - i - 1;
            for (int j = 0; j <= remainCount; j++) {
                if (curCount + j == 0) continue;
                if (curCount + j == 1) {
                    ans = (ans + comb.C(remainCount, j)) % MOD;
                } else if (steps[curCount + j] + 1 <= k) {
                    ans = (ans + comb.C(remainCount, j)) % MOD;
                }
            }
            curCount++;
        }
        return (int) ans;
    }


    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        Printer.ENABLE_LOCAL_PRINT = true;
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */

//
//        System.out.println(new Solution().countKReducibleNumbers(""111100100100100100011111010000"", 5));
//
//// 16219592

        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        System.out.println((System.currentTimeMillis() - startTime) + ""ms"");
    }
}",1448257627
IphoneX,hahahiehie,169,3646,java,"import java.util.*;

class Utils {
    public static int log2(long n) {
        return 63 - Long.numberOfLeadingZeros(n);
    }

    // nums = ""aaabaaaba"" odd d[1] return [1, 2, 1, 4, 1, 2, 2]
    // d[0] for even, d[1] for odd
    public static int[][] manacher(String s) {
        int n = s.length();
        int[] d1 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; ++i) {
            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s.charAt(i - k) == s.charAt(i + k)) k++;
            d1[i] = k;
            if (i + k - 1 > r) {
                l = i - k + 1;
                r = i + k - 1;
            }
        }

        int[] d0 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : Math.min(d0[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s.charAt(i - k - 1) == s.charAt(i + k)) {
                k++;
            }
            d0[i] = k;
            if (i + k - 1 > r) {
                l = i - k;
                r = i + k - 1;
            }
        }
        return new int[][]{d0, d1};
    }

    // generate primes that is <= n
    public static int[] genPrimes(int n) {
        if (n <= 1) return new int[0];
        boolean[] isComp = new boolean[n + 1];
        int len = 0;
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                len++;
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                }
            }
        }
        int[] ans = new int[len];
        for (int i = 2, j = 0; i <= n; i++) {
            if (!isComp[i]) {
                ans[j++] = i;
            }
        }
        return ans;
    }

    // int[0] = primeFactor, int[1] = count of that primeFactor
    // NOTE: factors[0] and factors[1] are empty list.
    public static List<int[]>[] genPrimeFactors(int n) {
        List<int[]>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            factors[i] = new ArrayList<>();
        }
        boolean[] isComp = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                factors[i].add(new int[]{i, 1});
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                    int t = j, count = 0;
                    while (t % i == 0) {
                        count++;
                        t /= i;
                    }
                    factors[j].add(new int[]{i, count});
                }
            }
        }
        return factors;
    }

    // generate factors (not prime factors), factors[0] is empty list.
    public static List<Integer>[] genFactors(int n) {
        List<Integer>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) factors[i] = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j += i) {
                factors[j].add(i);
            }
        }
        return factors;
    }

    public static int lowerBound(int[] a, int target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(int[] a, int target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(long[] a, long target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(long[] a, long target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static long or(int x, int y) {
        return ((long) x << 32) | ((long) y << 32 >>> 32);
    }

    // k = 0...nums.length - 1
    // After calling this function, nums[k] is the k-th number.
    public static int kthNumber(int[] nums, int k) {
        return kthNumberHelper(nums, k, 0, nums.length - 1);
    }

    // end is inclusive (0 to nums.length - 1)
    private static int kthNumberHelper(int[] nums, int K, int start, int end) {
        if (start == end) return nums[start];
        int i = partition(nums, start, end);
        return K <= i ? kthNumberHelper(nums, K, start, i) : kthNumberHelper(nums, K, i + 1, end);
    }

    // end is inclusive (0 to nums.length - 1)
    public static int partition(int[] nums, int start, int end) {
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && nums[i] < pivot) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && pivot < nums[j]) j--;
            if (i < j) nums[i++] = nums[j];
        }

        // pos is the final position for pivot.
        nums[i] = pivot;
        return i;
    }

    public static void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    // partition nums into 3 parts [smaller than pivot, equal to pivot, larger than pivot]
    public static void partition3(int[] nums, int pivot) {
        int n = nums.length;
        int l = 0, r = n - 1;
        for (int i = 0; i <= r; i++) {
            if (nums[i] < pivot) {
                swap(nums, l++, i);
            } else if (nums[i] > pivot) {
                swap(nums, r--, i--);
            }
        }
    }

    // end is inclusive
    public static void reverse(int[] nums, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    }

    // Return false if next permutation is not available. (nums is not changed for this case)
    public static boolean nextPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] >= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] > nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // Return false if previous permutation is not available. (nums is not changed for this case)
    public static boolean prevPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] <= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] < nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }


    // a, b could be negative
    // remainder >= 0
    // return [a / b, a % b]
    public static int[] divMod(int a, int b) {
        int r = a % b;
        int c = a / b;
        if (r < 0) {
            r += Math.abs(b);
            c++;
        }
        return new int[]{c, r};
    }

    public static List<Integer> negativeBase(int n, int base) {
        List<Integer> digits = new ArrayList<>();
        if (n == 0) {
            digits.add(0);
            return digits;
        }
        while (n != 0) {
            // t[0] = n / base
            // t[1] = n % base;
            int[] t = divMod(n, base);
            digits.add(t[1]);
            n = t[0];
        }
        Collections.reverse(digits);
        return digits;
    }

    // (a ^ b) % MOD
    public static long powMod(long a, long b, long MOD) {
        long res = 1L;
        a %= MOD; // In case a * a is overflow
        while (b > 0) {
            if ((b & 1) != 0) res = (res * a) % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    public static long[][] genCombination(int n) {
        long[][] C = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        return C;
    }

    public static long[][] genPermutation(int n) {
        long[][] P = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
        return P;
    }

    public static long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }

    public static int[] preprocessLog2(int n) { // from log2(0) .... log2(n) inclusive
        int[] lg = new int[n + 1];
        for (int k = 0, i = 1; i <= n; lg[i++] = k - 1) {
            while ((1 << k) <= i) {
                k++;
            }
        }
        return lg;
    }

    public static long max(long[] nums) {
        long ret = Long.MIN_VALUE;
        for (long v : nums) ret = Math.max(ret, v);
        return ret;
    }

    public static int max(int[] nums) {
        int ret = Integer.MIN_VALUE;
        for (int v : nums) ret = Math.max(ret, v);
        return ret;
    }
}

// Tested by leetcode 1163
class SuffixArray {
    int[] s;
    int[] SA; // SA[i] => index of the i-th ranked suffix
    int[] rank; // rank[i] => the rank of i-th suffix, SA[rank[i]] == i
    int[] height; // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).

    private int[][] d;
    private int n;
    private int[] lg;

    private int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    private static int[] stringToIntArray(String str) {
        int[] nums = new int[str.length()];
        for (int i = 0; i < str.length(); i++) nums[i] = str.charAt(i);
        return nums;
    }

    public SuffixArray(String str) {
        this(str, true);
    }

    public SuffixArray(String str, boolean toBuildRMQ) {
        this(stringToIntArray(str), toBuildRMQ);
    }

    public SuffixArray(int[] nums) {
        this(nums, true);
    }

    public SuffixArray(int[] nums, boolean toBuildRMQ) {
        this.s = nums;
        this.n = nums.length;
        this.SA = new int[n];
        this.rank = new int[n];
        suffixSort(s);
        if (toBuildRMQ) {
            this.height = new int[n];
            this.d = new int[log2(n) + 1][n];
            this.lg = new int[n + 1];
            buildHeight();
            buildRMQ();
        }
    }

    // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).
    // ?? s[n] = 0 or s[n] = -INF.
    private void buildHeight() {
        int i, j, h;
        height[0] = 0;
        for (i = 0; i < n; i++)
            rank[SA[i]] = i;
        for (h = i = 0; i < n; i++)
            if (rank[i] > 0) {
                j = SA[rank[i] - 1];
                while (i + h < n && j + h < n && s[i + h] == s[j + h]) ++h;
                height[rank[i]] = h;
                if (h > 0) --h;
            }
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    private void buildRMQ() {
        int i, j, k;
        for (i = 0; i < n; i++)
            d[0][i] = height[i];
        for (j = 1; (1 << j) <= n; j++)
            for (i = 0; i + (1 << j) <= n; i++)
                d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
        for (lg[0] = k = 0, i = 1; i <= n; lg[i++] = k - 1)
            while ((1 << k) <= i) k++;
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    public int LCP(int i, int j) {
        if (i == j) return n - SA[i];
        if (i > j) {
            int t = i;
            i = j;
            j = t;
        }
        int k = lg[j - (++i) + 1];
        return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }

    // LCPIndex(i, j) = LCP(s[i], s[j])
    public int LCPIndex(int i, int j) {
        return LCP(rank[i], rank[j]);
    }

    private void sortIndex(int[] nums, int start, int end) {
        if (start >= end) return;
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && s[nums[i]] < s[pivot]) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && s[pivot] < s[nums[j]]) j--;
            if (i < j) nums[i++] = nums[j];
        }
        nums[i] = pivot; // index i is the final position for pivot.
        sortIndex(nums, start, i - 1);
        sortIndex(nums, i + 1, end);
    }

    private void suffixSort(int[] s) {
        int[] count = new int[n], t;
        int[] nSA = new int[n];
        int[] nRank = new int[n];
//        Integer[] tempArray = new Integer[n];
//        for (int x = 0; x < n; x++) tempArray[x] = x;
//        Arrays.sort(tempArray, (a, b) -> Integer.compare(s[a], s[b]));
//        for (int x = 0; x < n; x++) SA[x] = tempArray[x];
        int i, k;
        int minV = s[0], maxV = s[0];
        for (i = 1; i < n; i++) {
            minV = Math.min(minV, s[i]);
            maxV = Math.max(maxV, s[i]);
        }
        if ((long) maxV - minV + 1 <= (long) n) { // radix sort if alphabet size is small
            for (i = 0; i < n; i++) count[s[i] - minV]++;
            for (i = minV + 1; i <= maxV; i++) count[i - minV] += count[i - minV - 1];
            for (i = n - 1; i >= 0; i--) SA[--count[s[i] - minV]] = i;
        } else {
            for (i = 0; i < n; i++) SA[i] = i;
            sortIndex(SA, 0, n - 1);
        }
        for (rank[SA[0]] = 0, i = 1; i < n; i++) {
            rank[SA[i]] = (s[SA[i]] != s[SA[i - 1]]) ? rank[SA[i - 1]] + 1 : rank[SA[i - 1]];
        }
        for (k = 1; k < n && rank[SA[n - 1]] < n - 1; k <<= 1) {
            for (i = 0; i < n; i++) count[rank[SA[i]]] = i + 1;
            for (i = n - 1; i >= 0; i--) if (SA[i] >= k) nSA[--count[rank[SA[i] - k]]] = SA[i] - k;
            for (i = n - k; i < n; i++) nSA[--count[rank[i]]] = i;
            t = SA;
            SA = nSA;
            nSA = t;
            for (nRank[SA[0]] = 0, i = 1; i < n; i++) {
                nRank[SA[i]] = (SA[i] + k >= n || SA[i - 1] + k >= n || rank[SA[i]] != rank[SA[i - 1]] || rank[SA[i] + k] != rank[SA[i - 1] + k]) ? nRank[SA[i - 1]] + 1 : nRank[SA[i - 1]];
            }
            t = rank;
            rank = nRank;
            nRank = t;
        }
    }
}

class Combination {
    long[] factorial;
    long[] inverseFactorial;
    long MOD;

    // O(maxSize) for preprocessing
    // MOD must be prime
    public Combination(int maxSize, long MOD) {
        factorial = new long[maxSize + 1];
        inverseFactorial = new long[maxSize + 1];
        factorial[0] = 1;
        inverseFactorial[0] = 1;
        this.MOD = MOD;
        for (int i = 1; i <= maxSize; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
            inverseFactorial[i] = inverse(factorial[i]);
        }
    }

    // x, y are long[1]
    // ax + by = gcd(a, b)
    private long extGcd(long a, long b, long[] x, long[] y) {
        if (b == 0) {
            x[0] = 1;
            y[0] = 0;
            return a;
        } else {
            long r = extGcd(b, a % b, y, x);
            y[0] -= x[0] * (a / b);
            return r;
        }
    }

    // (a * x) % MOD = 1
    // x is the inverse element
    public long inverse(long a) {
        long[] x = new long[1], y = new long[1];
        extGcd(a, MOD, x, y);
        return (x[0] % MOD + MOD) % MOD;
    }

    // m >= n
    // O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        else if (m == n) return factorial[m];
            //return factorial[m] * inverse(factorial[m - n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD;
    }

    // m >= n
    // O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
            //return factorial[m] * inverse(factorial[m - n]) % MOD * inverse(factorial[n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD * inverseFactorial[n] % MOD;
    }
}

class CombinationNoMod {

    long[][] C;
    long[][] P;

    public CombinationNoMod(int maxSize) {
        C = new long[maxSize + 1][maxSize + 1];
        P = new long[maxSize + 1][maxSize + 1];
        int m = C.length;
        int n = C[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
    }

    // m >= n. O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        return P[m][n];
    }

    // m >= n. O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
        return C[m][n];
    }
}

class Fraction {
    long n, d; // n / d (d != 0)

    public Fraction(long n, long d) {
        if (d == 0) {
            this.n = Long.MAX_VALUE;
            this.d = 1;
            return;
        }
        long g = gcd(Math.abs(n), Math.abs(d));
        this.n = n / g;
        this.d = d / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    public void add(Fraction other) {
        long numerator = this.n * other.d + this.d * other.n;
        long denominator = this.d * other.d;
        long g = gcd(Math.abs(numerator), Math.abs(denominator));
        this.n = numerator / g;
        this.d = denominator / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    @Override
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof Fraction) {
            Fraction anotherObject = (Fraction) anObject;
            return n == anotherObject.n && d == anotherObject.d;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return (int) (n * 31 + d);
    }

    private long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }
}

class UnionFind {
    int[] parent;
    int[] sz;

    // from 0 ... n - 1
    public UnionFind(int n) {
        parent = new int[n];
        sz = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public void clear() {
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public int find(int x) {
        //return parent[x] == x ? x : (parent[x] = find(parent[x]));
        if (parent[x] == x) return x;
        int px = x;
        while (px != parent[px]) px = parent[px];
        while (x != px) {
            int next = parent[x];
            parent[x] = px;
            x = next;
        }
        return px;
    }

    // px is the final parent
    public boolean union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return false;
        parent[py] = px;
        sz[px] += sz[py];
        return true;
    }

    public int size(int x) {
        return sz[find(x)];
    }

    public UnionFind clone() {
        UnionFind cloned = new UnionFind(parent.length);
        for (int i = 0; i < parent.length; i++) {
            cloned.parent[i] = parent[i];
            cloned.sz[i] = sz[i];
        }
        return cloned;
    }
}

class Trie {
    static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        boolean isWord = false;
        long count = 0L;
    }

    TrieNode root = new TrieNode();

    public void add(String word) {
        add(word, 1L);
    }

    public void remove(String word) {
        add(word, -1L);
    }

    private void add(String word, long count) {
        TrieNode cur = root;
        cur.count += count;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) cur.next[c] = new TrieNode();
            cur = cur.next[c];
            cur.count += count;
        }
        cur.isWord = true;
    }

    public boolean contains(String word) {
        TrieNode cur = root;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null || cur.next[c].count <= 0L) return false;
            cur = cur.next[c];
            //if (cur.isWord) return true;
        }
        return cur.isWord;
    }
}

// Tested by Leetcode 1707 and Leetcode 1803
class TrieBinary {
    static class TrieNode {
        TrieNode[] next = new TrieNode[2];
        long count;
    }

    private TrieNode root;
    private int numOfBits;

    public TrieBinary(int numOfBits) { // normally 31 for int and 63 for long
        this.numOfBits = numOfBits;
        this.root = new TrieNode();
    }

    public void add(long v) {
        add(v, 1L);
    }

    public void remove(long v) { // Tested by Leetcode 1938
        add(v, -1L);
    }

    public void add(long v, long count) {
        TrieNode cur = root;
        root.count += count;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null) cur.next[b] = new TrieNode();
            cur = cur.next[b];
            cur.count += count;
        }
    }

    // Tested by Leetcode 1707
    public long xorMax(long v) {
        TrieNode cur = root;
        long key = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[1 - b] != null && cur.next[1 - b].count > 0) {
                cur = cur.next[1 - b];
                key |= (1L - b) << i;
            } else {
                cur = cur.next[b];
                key |= (long) b << i;
            }
        }
        return key ^ v;
    }

    public boolean contains(long v) {
        TrieNode cur = root;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null || cur.next[b].count <= 0) return false;
            cur = cur.next[b];
        }
        return true;
    }

    // Tested by Leetcode 1803
    // count(x ^ v <= limit)
    public long xorLessOrEqualCount(long v, long limit) {
        if (limit < 0) return 0;
        TrieNode cur = root;
        long ans = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int bitLimit = ((limit >>> i) & 1) == 0 ? 0 : 1;
            int bitV = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (bitLimit == 1) {
                ans += (cur.next[bitV] != null ? cur.next[bitV].count : 0);
            }
            cur = cur.next[bitV ^ bitLimit];
            if (cur == null) break;
            if (i == 0) ans += cur.count;
        }
        return ans;
    }
}

// Lazy execution example is in https://leetcode.com/submissions/detail/1034182539/
// Refer to AlgorithmCompilation.java

// [Template] Classic Segment Tree (Range Sum), used for Template
class ClassicSegmentTree { // For Range Sum
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final int L, R;

    public ClassicSegmentTree(int[] input) {
        L = 0;
        R = input.length - 1;
        root = new TreeNode();
        build(root, L, R, input);
    }

    private void build(TreeNode root, int l, int r, int[] input) {
        if (l == r) {
            root.sum = input[l];
            return;
        }
        int m = (l + r) >> 1;
        root.left = new TreeNode();
        root.right = new TreeNode();
        build(root.left, l, m, input);
        build(root.right, m + 1, r, input);
        root.sum = root.left.sum + root.right.sum;
    }

    public void set(int index, int value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, int L, int R, int index, int value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        int M = L + ((R - L) >> 1);
        if (index <= M) {
            set(root.left, L, M, index, value);
        } else {
            set(root.right, M + 1, R, index, value);
        }
        root.sum = root.left.sum + root.right.sum;
    }

    // Sum[queryL...queryR] inclusive
    public long query(int queryL, int queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, int L, int R, int queryL, int queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        int M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 307
class DynamicSegmentTreeRangeSum {
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeSum(long l, long r) {
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return sum(cur);
    }

    public void add(long index, long value) {
        set(index, get(index) + value);
    }

    private long sum(TreeNode node) {
        return node == null ? 0L : node.sum;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.sum = sum(root.left) + sum(root.right);
    }

    // Sum[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        long M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 239, 2926
class DynamicSegmentTreeRangeMax {
    class TreeNode {
        TreeNode left, right;
        long max = Long.MIN_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMax(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return max(cur);
    }

    private long max(TreeNode node) {
        return node == null ? Long.MIN_VALUE : node.max;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.max = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.max = Math.max(max(root.left), max(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MIN_VALUE;
        if (queryL <= L && R <= queryR) return root.max;
        long M = L + ((R - L) >> 1);
        return Math.max(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class DynamicSegmentTreeRangeMin {
    class TreeNode {
        TreeNode left, right;
        long min = Long.MAX_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMin(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return min(cur);
    }

    private long min(TreeNode node) {
        return node == null ? Long.MAX_VALUE : node.min;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.min = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.min = Math.min(min(root.left), min(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MAX_VALUE;
        if (queryL <= L && R <= queryR) return root.min;
        long M = L + ((R - L) >> 1);
        return Math.min(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class BinaryIndexTree {
    private long[] c;
    private int n;

    // NOTE: index is from 1 to n. (NOT 0 ... n - 1)
    public BinaryIndexTree(int n) {
        this.n = n;
        this.c = new long[n + 1];
    }

    // Add value to position k, k is from 1 to n.
    public void add(int k, long value) {
        while (k <= n) {
            c[k] += value;
            k += (k & (k ^ (k - 1)));
        }
    }

    // k is from 1 to n.
    public long getSum(int k) {
        long sum = 0;
        while (k > 0) {
            sum += c[k];
            k -= (k & (k ^ (k - 1)));
        }
        return sum;
    }
}

class RangeSum {
    BinaryIndexTree tree;
    int start;

    // [low, high] inclusive
    public RangeSum(int low, int high) {
        start = low;
        tree = new BinaryIndexTree(high - low + 1);
    }

    public void add(int index, long value) {
        tree.add(index - start + 1, value);
    }

    public long get(int index) {
        return tree.getSum(index - start + 1) - tree.getSum(index - start);
    }

    public void set(int index, long value) {
        tree.add(index - start + 1, value - get(index));
    }

    // [l, r] inclusive
    public long getSum(int l, int r) {
        return tree.getSum(r - start + 1) - tree.getSum(l - start);
    }
}

class RangeMax {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMax(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MIN_VALUE);
    }

    public RangeMax(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.max(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMax(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MIN_VALUE, resr = Long.MIN_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.max(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.max(t[--r], resr);
        }
        return Math.max(resl, resr);
    }
}

class RangeMin {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMin(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MAX_VALUE);
    }

    public RangeMin(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.min(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMin(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MAX_VALUE, resr = Long.MAX_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.min(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.min(t[--r], resr);
        }
        return Math.min(resl, resr);
    }
}

// Including topological sort.
class GraphIntegerFaster {
    public List<Integer>[] adj;

    public GraphIntegerFaster(int n) {
        adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    // directed edge x -> y
    public void link(int x, int y) {
        adj[x].add(y);
    }

    public List<Integer> getChildren(int x) {
        return adj[x];
    }

    private static final int TEMPORARY = 1;
    private static final int PERMANENT = 2;

    // x -> y means x should be processed before y
    // The input is a directed graph.
    // 1. return null, means there is a cycle inside the graph, or the input is
    // invalid.
    // 2. return List<Node> as the result.
    public List<Integer> topologicalSort() {
        //Map<E, Integer> vst = new HashMap<>();
        int n = adj.length;
        int[] vst = new int[n];
        List<Integer> result = new ArrayList<>();
        for (int x = 0; x < n; x++) {
            if (!topologicalSort(x, vst, result)) {
                return null;
            }
        }
        Collections.reverse(result);
        return result;
    }

    private boolean topologicalSort(int root, int[] vst, List<Integer> result) {
        if (vst[root] == PERMANENT) {
            return true;
        }
        if (vst[root] == TEMPORARY) { // found cycle
            return false;
        }

        vst[root] = TEMPORARY;
        for (int child : getChildren(root)) {
            if (!topologicalSort(child, vst, result)) {
                return false;
            }
        }
        result.add(root);
        vst[root] = PERMANENT;
        return true;
    }
}

class DijkstraLongFaster {
    public static class Edge {
        int to;
        long w;

        public Edge(int to, long w) {
            this.to = to;
            this.w = w;
        }
    }

    public static final long INF = Long.MAX_VALUE / 4;
    public List<Edge>[] adj;

    public DijkstraLongFaster(int n) {
        this.adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    public void link(int x, int y, long w) {
        adj[x].add(new Edge(y, w));
    }

    public long[] shortestPath(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
        q.add(new Edge(src, 0));
        dist[src] = 0;

        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (vst[cur.to]) continue;
            int u = cur.to;
            long w = cur.w;
            vst[u] = true;

            for (Edge e : adj[u]) {
                if (!vst[e.to] && dist[e.to] > w + e.w) {
                    dist[e.to] = w + e.w;
                    q.add(new Edge(e.to, dist[e.to]));
                }
            }
        }
        return dist;
    }

    // NOTE: w of each edge must be the same.
    public long[] bfs(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        Queue<Integer> q = new ArrayDeque<>();
        q.add(src);
        dist[src] = 0;
        vst[src] = true;

        while (!q.isEmpty()) {
            int u = q.poll();
            long w = dist[u];
            for (Edge e : adj[u]) {
                if (!vst[e.to]) {
                    dist[e.to] = w + e.w;
                    vst[e.to] = true;
                    q.add(e.to);
                }
            }
        }
        return dist;
    }
}

class TreapSet<E> {
    private class Node {
        E key;
        int priority, count, total;
        Node left, right, pnt;

        public Node(E key, int priority, Node pnt) {
            this.key = key;
            this.priority = priority;
            this.pnt = pnt;
            this.count = 1;
            this.total = 1;
        }
    }

    private static final Random RANDOM = new Random();
    private final Comparator<? super E> comparator;
    private Node root;

    public TreapSet(Comparator<? super E> comparator) {
        this.comparator = comparator;
    }

    public boolean isEmpty() {
        return root == null;
    }

    public void clear() {
        root = null;
    }

    public int size() {
        return root == null ? 0 : root.total;
    }

    private int leftRank(Node p) {
        return p.left != null ? p.left.total : 0;
    }

    private int rightRank(Node p) {
        return p.right != null ? p.right.total : 0;
    }

    private void rotateLeft(Node x) {
        Node y = x.right;
        if ((x.right = y.left) != null) y.left.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.left) x.pnt.left = y;
        else x.pnt.right = y;
        y.left = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    private void rotateRight(Node x) {
        Node y = x.left;
        if ((x.left = y.right) != null) y.right.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.right) x.pnt.right = y;
        else x.pnt.left = y;
        y.right = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    public void add(E key) {
        if (root == null) {
            root = new Node(key, RANDOM.nextInt(), null);
            return;
        }
        Node x = root, p = null;
        while (x != null) {
            ++((p = x).total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                ++(x.count);
                return;
            }
        }

        x = new Node(key, RANDOM.nextInt(), p);
        if (comparator.compare(key, p.key) < 0) p.left = x;
        else p.right = x;
        while ((p = x.pnt) != null && p.priority < x.priority) {
            if (p.left == x) rotateRight(p);
            else rotateLeft(p);
        }
    }

    public void remove(E key) {
        Node x = root, p = null;
        while (x != null) {
            --(x.total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                if (--(x.count) > 0) return;
                break;
            }
        }
        if (x == null) return;
        while (x.left != null || x.right != null) {
            if (x.left == null || (x.right != null && x.right.priority > x.left.priority)) {
                rotateLeft(x);
            } else {
                rotateRight(x);
            }
        }
        if ((p = x.pnt) != null) {
            if (p.left == x) p.left = null;
            else p.right = null;
        } else {
            root = null;
        }
        // delete x;
    }

    // number of elements smaller than key
    public int lowerCount(E key) {
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                sum += leftRank(x) + x.count;
                x = x.right;
            } else {
                sum += leftRank(x);
                break;
            }
        }
        return sum;
    }

    // number of elements larger than key
    public int higherCount(E key) {
        //return size() - lowerCount(key) - count(key);
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp > 0) x = x.right;
            else if (cmp < 0) {
                sum += rightRank(x) + x.count;
                x = x.left;
            } else {
                sum += rightRank(x);
                break;
            }
        }
        return sum;
    }

    public int index(E key) {
        return lowerCount(key);
    }

    public E get(int index) // index = 0 ... size - 1
    {
        Node p = root;
        ++index;
        while (true) {
            int t = leftRank(p);
            if (index <= t) p = p.left;
            else {
                if ((index -= t + p.count) <= 0) break;
                p = p.right;
            }
        }
        return p.key;
    }

    public int count(E key) {
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                x = x.right;
            } else {
                return x.count;
            }
        }
        return 0;
    }

    public E first() {
        if (root == null) return null;
        Node x = root;
        while (x.left != null) {
            x = x.left;
        }
        return x.key;
    }

    public E last() {
        if (root == null) return null;
        Node x = root;
        while (x.right != null) {
            x = x.right;
        }
        return x.key;
    }

    public boolean contains(E key) {
        return count(key) > 0;
    }

    public E ceiling(E key) {
        int id = lowerCount(key);
        return id >= size() ? null : get(id);
    }

    public E floor(E key) {
        int id = size() - higherCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E lower(E key) {
        int id = lowerCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E higher(E key) {
        int id = size() - higherCount(key);
        return id >= size() ? null : get(id);
    }

    // return the first index whose value >= target
    // if this value doesn't exist, return index = size()
    public int lowerBound(E target) {
        return lowerCount(target);
    }

    // return the first index whose value > target
    // if this value doesn't exist, return index = size()
    public int upperBound(E target) {
        return size() - higherCount(target);
    }

    public List<E> keys() {
        List<E> list = new ArrayList<>();
        inorder(root, list);
        return list;
    }

    private void inorder(Node x, List<E> list) {
        if (x == null) return;
        inorder(x.left, list);
        list.add(x.key);
        inorder(x.right, list);
    }
}

class ArraySum {
    long[] sum;
    int n;

    // nums index starts from 0 to nums.length - 1;
    public ArraySum(int[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    public ArraySum(long[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    // [l, r], index starts from 0
    public long getSum(int l, int r) {
        // error handling
        if (l > r || !(l >= 0 && l < n && r >= 0 && r < n)) return 0L;
        return sum[r + 1] - sum[l];
    }
}

class TwoDArraySum {
    int[][] sum;
    int m, n;

    // nums index starts from 0
    public TwoDArraySum(final int[][] nums) {
        m = nums.length;
        n = nums[0].length;
        sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + nums[i - 1][j - 1];
            }
        }
    }

    // [(x1, y1), (x2, y2)], index starts from 0
    // x1 <= x2 and y1 <= y2
    public int getSum(int x1, int y1, int x2, int y2) {
        if (!(x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && x2 >= 0 && x2 < m && y2 >= 0 && y2 < n) || x1 > x2 || y1 > y2)
            return 0;
        return sum[x2 + 1][y2 + 1] - sum[x2 + 1][y1] - sum[x1][y2 + 1] + sum[x1][y1];
    }
}

class ArrayUtils {
    static void fill(int[] array, int defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(int[][] array, int defaultValue) {
        for (int[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(int[][][] array, int defaultValue) {
        for (int[][] a2 : array) {
            for (int[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(int[][][][] array, int defaultValue) {
        for (int[][][] a3 : array) {
            for (int[][] a2 : a3) {
                for (int[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(int[][][][][] array, int defaultValue) {
        for (int[][][][] a4 : array) {
            for (int[][][] a3 : a4) {
                for (int[][] a2 : a3) {
                    for (int[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(int[][][][][][] array, int defaultValue) {
        for (int[][][][][] a5 : array) {
            for (int[][][][] a4 : a5) {
                for (int[][][] a3 : a4) {
                    for (int[][] a2 : a3) {
                        for (int[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }

    static void fill(long[] array, long defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(long[][] array, long defaultValue) {
        for (long[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(long[][][] array, long defaultValue) {
        for (long[][] a2 : array) {
            for (long[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(long[][][][] array, long defaultValue) {
        for (long[][][] a3 : array) {
            for (long[][] a2 : a3) {
                for (long[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(long[][][][][] array, long defaultValue) {
        for (long[][][][] a4 : array) {
            for (long[][][] a3 : a4) {
                for (long[][] a2 : a3) {
                    for (long[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(long[][][][][][] array, long defaultValue) {
        for (long[][][][][] a5 : array) {
            for (long[][][][] a4 : a5) {
                for (long[][][] a3 : a4) {
                    for (long[][] a2 : a3) {
                        for (long[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }
}

class CharacterUtils {
    static boolean[] vowel = new boolean[128];

    static {
        vowel['a'] = vowel['e'] = vowel['i'] = vowel['o'] = vowel['u'] = true;
        vowel['A'] = vowel['E'] = vowel['I'] = vowel['O'] = vowel['U'] = true;
    }

    static boolean isVowel(char ch) {
        return vowel[ch];
    }

    static boolean isLetter(char ch) {
        return ((ch - 'a') >= 0 && (ch - 'a') < 26) ||
                ((ch - 'A') >= 0 && (ch - 'A') < 26);
    }

    static boolean isLowerCase(char ch) {
        return (ch - 'a') >= 0 && (ch - 'a') < 26;
    }

    static boolean isUpperCase(char ch) {
        return (ch - 'A') >= 0 && (ch - 'A') < 26;
    }

    static boolean isDigit(char ch) {
        return (ch - '0') >= 0 && (ch - '0') <= 9;
    }
}

class DoubleUtils {
    private static final double EPS = 1e-8;

    public static int compare(double a, double b) {
        if (a - b > EPS) return 1;
        else if (a - b < -EPS) return -1;
        else return 0;
    }

    public static boolean isInteger(double a) {
        return compare(floor(a), a) == 0;
    }

    public static double floor(double a) {
        return Math.floor(a + EPS);
    }

    public static double ceil(double a) {
        return Math.ceil(a - EPS);
    }
}

class MatrixUtils {
    static final long MOD = 1_000_000_007L;

    // matrix[n][n], matrix[i][i] = 1
    static long[][] genIdentityMatrix(int n) {
        long[][] matrix = new long[n][n];
        for (int i = 0; i < n; i++) matrix[i][i] = 1;
        return matrix;
    }

    static long[][] multiply(long[][] a, long[][] b, long MOD) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]) % MOD;
                }
            }
        }
        return res;
    }

    static long[][] multiply(long[][] a, long[][] b) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]);
                }
            }
        }
        return res;
    }

    // a^b % MOD
    static long[][] powMod(long[][] a, long b, long MOD) {
        int n = a.length;
        long[][] res = genIdentityMatrix(n);
        while (b > 0) {
            if ((b & 1) != 0) res = multiply(res, a, MOD);
            a = multiply(a, a, MOD);
            b >>= 1;
        }
        return res;
    }

    static void print(long[][] matrix) {
        for (int i = 0; i < matrix.length; i++) {
            System.out.println(Arrays.toString(matrix[i]));
        }
    }
}

class IntegerUtils {
    static long[] power10 = new long[19]; // 10^i

    static {
        power10[0] = 1L;
        for (int i = 1; i < power10.length; i++) {
            power10[i] = power10[i - 1] * 10;
        }
    }

    // swap index i and j of integer (long) num. i == 0 means the lowest position.
    static long swapDigit(long num, int i, int j) {
        if (i == j) return num;
        long di = num / power10[i] % 10L;
        long dj = num / power10[j] % 10L;
        return num - di * power10[i] - dj * power10[j] + dj * power10[i] + di * power10[j];
    }
}

class StringUtils {
    // This function is deprecated, please hash(int l, int r) in class StableStringHash or StringHash
    // rolling hash of substrings of 's' with length == k
    // long[pos] = hash(s.substring(pos, pos + k))
    public static long[] rollingHash(String s, int k) {
        long[] ans = new long[s.length() - k + 1];
        int seed1 = 31;
        int seed2 = 131;
        int h1 = 0, h2 = 0, power1 = 1, power2 = 1;
        for (int i = 0; i < k; i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);

            power1 *= seed1;
            power2 *= seed2;
        }

        ans[0] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        for (int i = k; i < s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i) - power1 * s.charAt(i - k);
            h2 = h2 * seed2 + s.charAt(i) - power2 * s.charAt(i - k);
            ans[i - k + 1] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        }

        return ans;
    }

    public static int[] kmpNext(String s) {
        int n = s.length();
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s.charAt(i) != s.charAt(k)) k = next[k - 1];
            if (s.charAt(i) == s.charAt(k)) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(String s, String p) {
        int[] next = kmpNext(p);
        int n = s.length();
        int m = p.length();
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p.charAt(j) != s.charAt(i)) {
                j = next[j - 1];
            }
            if (p.charAt(j) == s.charAt(i)) j++;
            if (j == m) return true;
        }
        return false;
    }

    public static int[] kmpNext(int[] s) {
        int n = s.length;
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s[i] != s[k]) k = next[k - 1];
            if (s[i] == s[k]) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(int[] s, int[] p) {
        int[] next = kmpNext(p);
        int n = s.length;
        int m = p.length;
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p[j] != s[i]) {
                j = next[j - 1];
            }
            if (p[j] == s[i]) j++;
            if (j == m) return true;
        }
        return false;
    }

    // Z[i] = longest length of common prefix of str[0 ... n - 1] and str[i ... n - 1]
    // Tested by LC2223, LC459
    public static int[] zFunction(String str) {
        int n = str.length();
        int[] Z = new int[n];
        // [L,R] makes a window which matches with prefix of s
        int L = 0, R = 0;
        Z[0] = n;
        for (int i = 1; i < n; ++i) {
            if (i > R) {
                L = R = i;
                while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                Z[i] = R - L;
                R--;
            } else {
                int k = i - L;
                if (Z[k] < R - i + 1) {
                    Z[i] = Z[k];
                } else {
                    L = i;
                    while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                    Z[i] = R - L;
                    R--;
                }
            }
        }
        return Z;
    }
}

// Better to use this when length of string >= 2^11
class StringHash {
    static class SingleStringHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleStringHash(String s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length();
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s.charAt(i - 1)) % MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleStringHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L;

    public StringHash(String s) {
        hash1 = new SingleStringHash(s, SEED1, MOD);
        hash2 = new SingleStringHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(String s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length(); i++) {
            h1 = (h1 * SEED1 + s.charAt(i)) % MOD;
            h2 = (h2 * SEED2 + s.charAt(i)) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(char[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class IntegerArrayHash {
    static class SingleIntegerArrayHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleIntegerArrayHash(int[] s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length;
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s[i - 1]) % MOD;
                if (h[i] < 0) h[i] += MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleIntegerArrayHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L; // or 1_000_000_123L

    public IntegerArrayHash(int[] s) {
        hash1 = new SingleIntegerArrayHash(s, SEED1, MOD);
        hash2 = new SingleIntegerArrayHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(int[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(List<Integer> s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.size(); i++) {
            h1 = (h1 * SEED1 + s.get(i)) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s.get(i)) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class RMQ { // NOTE!!! query return index, not value
    // tested by LC 1438,239
    final long[] a; // input data array copy
    int[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQ(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQ(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new int[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = i;
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = a[d[j - 1][i]] >= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                } else {
                    d[j][i] = a[d[j - 1][i]] <= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                }
    }

    // i <= j, and index starts from 0.
    public int query(int i, int j) { // NOTE!!! return index, not value
        int k = log2[j - i + 1];
        if (useMax) return a[d[k][i]] >= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
        else return a[d[k][i]] <= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
    }
}

class RMQValue { // NOTE!!! query return value, not index
    final long[] a; // input data array copy
    long[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQValue(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQValue(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new long[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = a[i];
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = Math.max(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                } else {
                    d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                }
    }

    // i <= j, and index starts from 0.
    public long query(int i, int j) {
        int k = log2[j - i + 1];
        if (useMax) return Math.max(d[k][i], d[k][j - (1 << k) + 1]);
        else return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }
}

// Tested by 2827
// Similar: 1012, 2376, 902, 2719, 2801, 357, 1215, 1397
class DigitDP {
    static final boolean ENABLE_DEBUG_MODE = false; // TODO: set it to true if you want to print more debug info
    static final long UNSET = -1;
    // dp[isStart][hasLimit][pos] | [odd][even][r]
    // (isStart, hasLimit, pos) is generic, (odd, even, r) is use case specific
    long[][][][][][] dp;
    int K;

    public long digitDP(long num, int k) {
        String numString = String.valueOf(num); // TODO
        this.dp = new long[2][2][numString.length()][numString.length() + 1][numString.length() + 1][k];
        this.K = k;

        if (ENABLE_DEBUG_MODE) System.out.println(""num = "" + numString);
        ArrayUtils.fill(dp, UNSET);
        long ans = dfs(new StringBuilder(), numString, 1, 1, 0, 0, 0, 0);
        if (ENABLE_DEBUG_MODE) System.out.println(""---------------------\n"");
        return ans;
    }

    long dfs(StringBuilder curResult, String s, int isStart, int hasLimit, int pos, int odd, int even, int r) {
        if (pos == s.length()) {
            if (isStart == 1) return 0; // NOTE: special check for num == 0. TODO
            if (r == 0 && odd == even) { // TODO
                if (ENABLE_DEBUG_MODE) System.out.println(""result = "" + curResult);
                return 1;
            } else {
                return 0;
            }
        }
        if (dp[isStart][hasLimit][pos][odd][even][r] != UNSET) return dp[isStart][hasLimit][pos][odd][even][r];

        int start = 0;
        int end = (hasLimit == 1) ? s.charAt(pos) - '0' : 9; // TODO: check if it is binary string or not

        long ans = 0;
        for (int digit = start; digit <= end; digit++) {
            if (isStart == 1 && digit == 0) { // NOTE: handle leading zeros
                // [0, 999..9]
                // [0， 10^(len(s) - pos - 1) - 1]
                ans += dfs(new StringBuilder(), s, 1, 0, pos + 1, 0, 0, 0);
                continue;
            }
            int newHasLimit = (hasLimit == 1 && digit == s.charAt(pos) - '0') ? 1 : 0;

            int newOdd = odd + (digit % 2); // TODO
            int newEven = even + (digit % 2 == 0 ? 1 : 0); // TODO
            int newR = (isStart == 1 ? digit % this.K : (r * 10 + digit) % this.K); // TODO;

            if (ENABLE_DEBUG_MODE) curResult.append(digit);
            ans += dfs(curResult, s, 0, newHasLimit, pos + 1, newOdd, newEven, newR);
            if (ENABLE_DEBUG_MODE) curResult.deleteCharAt(curResult.length() - 1);

        }
        return dp[isStart][hasLimit][pos][odd][even][r] = ans;
    }
}

class Printer {
    static boolean ENABLE_LOCAL_PRINT = false;

    static void println(String x) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.println(x);
    }

    static void printf(String format, Object... args) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.printf(format, args);
    }
}


public class Solution {
    private static final int INF = 1_000_000_001;
    private static final long MOD = 1_000_000_007L;

    private static final int UNSET = -131;
    // 4 neighbors
    private static final int[] DX = {-1, 0, 1, 0}; // up, right, down, left
    private static final int[] DY = {0, 1, 0, -1};

    // 8 neighbors
    //    private static final int[] DX = {-1, -1, 0, 1, 1,  1, 0,  -1};
    //    private static final int[] DY = {0,   1, 1, 1, 0, -1, -1, -1};

    // knight
    //    private static final int[] DX = {-2, -2, -1, 1, 2, 2, 1, -1};
    //    private static final int[] DY = {-1, 1, 2, 2, 1, -1, -2, -2};

    public int sumOfGoodSubsequences(int[] nums) {
        final int L = Utils.max(nums);
        int n = nums.length;
        long[] count = new long[L + 1];
        long[] sum = new long[L + 1];

        long ans = 0;
        for (int i = 0; i < n; i++) {
            int v = nums[i];
            long prevSum = 0;
            long prevCount = 0;
            if (v - 1 >= 0) {

                //prevSum = (prevSum + sum[v - 1] + count[v - 1] * v) % MOD;
                //prevCount = (prevCount + count[v - 1]);
                ans = (ans + sum[v - 1] + count[v - 1] * v) % MOD;
                sum[v] = (sum[v] + sum[v - 1] + count[v - 1] * v) % MOD;
                count[v] = (count[v] + count[v - 1]);

            }
            if (v + 1 <= L) {
                ans = (ans + sum[v + 1] + count[v + 1] * v) % MOD;
                sum[v] = (sum[v] + sum[v + 1] + count[v + 1] * v) % MOD;
                count[v] = (count[v] + count[v + 1]);
            }
            
            ans = (ans + v) % MOD;
            sum[v] = (sum[v] + v) %MOD;
            count[v] = (count[v] + 1) % MOD;
        }
        return (int) ans;
    }


    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        Printer.ENABLE_LOCAL_PRINT = true;
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */





        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        System.out.println((System.currentTimeMillis() - startTime) + ""ms"");
    }
}",1448212261
otto,_otto,170,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        
        def ok(idx):
            tmp = nums[idx: idx + 2 * k]
            #print(tmp)
            if len(tmp) < 2 * k:
                return False
            for i in range(1, k):
                if tmp[i] - tmp[i - 1] <= 0:
                    return False
            for i in range(k + 1, 2 * k):
                if tmp[i] - tmp[i - 1] <= 0:
                    return False
            return True
        for i in range(n):
            if ok(i):
                return True
        return False",1448182374
otto,_otto,170,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        
        n = len(nums)
        lo = 1
        hi = n // 2
        tmp = [1] * n
        for i in range(n - 2, -1, -1):
            if nums[i] < nums[i + 1]:
                tmp[i] = tmp[i + 1] + 1
            else:
                tmp[i] = 1
                    
        while lo < hi:
            mid = hi - (hi - lo) // 2
            ok = False
            for a in range(n - 2 * mid + 1):
                if tmp[a] >= mid and tmp[a + mid] >= mid:
                    ok = True
            if ok:
                lo = mid
            else:
                hi = mid - 1
        return lo",1448192372
otto,_otto,170,3631,python3,"f = [100] * 801
f[1] = 0
for i in range(2, 801):
    f[i] = 1 + f[i.bit_count()]
class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        if s == '0': return 0
        n = len(s)
        MOD = int(1e9 + 7)
        @cache
        def dfs(pos, cnt, up, started):
            if pos == n:
                return int(started and (not up) and (1 + f[cnt]) <= k)
            ans = 0
            max_digit = int(s[pos]) if up else 1
            for digit in range(0, max_digit + 1):
                new_ok = up and (digit == max_digit)
                ok = started or (digit == 1)
                new_cnt = cnt + digit if ok else cnt
                ans += dfs(pos + 1, new_cnt, new_ok, ok)
                ans %= MOD
            return ans
        ans = dfs(0, 0, True, False) % MOD
        dfs.cache_clear()
        return ans",1448257706
otto,_otto,170,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        MOD = int(1e9 + 7)
        cnt = defaultdict(int)
        sm = defaultdict(int)
        ans = 0

        for num in nums:
            curr = num
            fuck = 1
            if (num - 1) in cnt:
                curr += sm[num - 1] + cnt[num - 1] * num
                curr %= MOD
                fuck += cnt[num - 1]
                fuck %= MOD

            if (num + 1) in cnt:
                curr += sm[num + 1] + cnt[num + 1] * num
                curr %= MOD
                fuck += cnt[num + 1]
                fuck %= MOD


            sm[num] += curr
            cnt[num] += fuck
            sm[num] %= MOD
            cnt[num] %= MOD

            ans += curr
            ans %= MOD

        return ans",1448213780
Md Abedin,MdAbedin,172,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        return any(all(a < b for a,b in pairwise(nums[i:i+k])) and all(a < b for a,b in pairwise(nums[i+k:i+2*k])) for i in range(len(nums)-2*k+1))",1448181368
Md Abedin,MdAbedin,172,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        ss = [1]
        p = -1
        ans = 1
        
        for a,b in pairwise(nums):
            if b > a:
                ss.append(ss[-1]+1)
            else:
                p = ss[-1]
                ss.append(1)

            ans = max(ans,min(ss[-1],p),ss[-1]//2)

        return ans",1448186037
Md Abedin,MdAbedin,172,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        mod = 10**9+7
        dp = [0]*(len(s)+1)
        eq = 0
        
        for c in s:
            dp2 = [0]*(len(s)+1)
            
            if c == ""1"":
                eq += 1
                dp2[eq-1] += 1
                dp2[eq-1] %= mod

            for i in range(len(dp)):
                for i2 in [i,i+1]:
                    if i2 == len(dp2): continue
                    dp2[i2] += dp[i]
                    dp2[i2] %= mod
            
            dp = dp2

        ans = 0
        
        for b in range(1,len(dp)):
            b2 = b
            for _ in range(k-1): b2 = b2.bit_count()
            
            if b2 == 1:
                ans += dp[b]
                ans %= mod

        return ans",1448265322
Md Abedin,MdAbedin,172,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        mod = 10**9+7
        dp1 = Counter()
        dp2 = Counter()
        ans = 0

        for num in nums:
            ans += dp2[num+1]+dp2[num-1] + num*(dp1[num+1]+dp1[num-1]+1)
            ans %= mod
            dp2[num] += dp2[num+1]+dp2[num-1] + num*(dp1[num+1]+dp1[num-1]+1)
            dp2[num] %= mod
            dp1[num] += dp1[num+1]+dp1[num-1]+1
            dp1[num] %= mod

        return ans",1448203332
Ritik Rathor,ritik_369,174,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
      int n = nums.size() , ans = 0 ; 
      vector < int > rig(n + 3 , 0) ; 
      vector < int > lef(n + 3 , 0) ; 
      for(int i = 1 ; i <= n ; i += 1)
      {
         int h = nums[i-1] ; 
         if(i == 1)
         {
            lef[i] = 1 ; 
            continue ; 
         }
         lef[i] = 1 ; 
         if(nums[(i-1)-1] < h)
         {
            lef[i] = lef[i-1] + 1 ; 
         }
      }

      for(int i = n ; i >= 1 ; i -= 1)
      {
         int h = nums[i-1] ; 
         if(i == n)
         {
            rig[i] = 1 ; 
            continue ; 
         }
         rig[i] = 1 ; 
         if(nums[(i + 1)-1] > h)
         {
            rig[i] = rig[i+1] + 1 ; 
         }
      }
      for(int i = 1 ; i + 1 <= n ; i += 1)
      {
         ans = max(ans , min(lef[i] , rig[i + 1])) ; 
      }
      
      return ans>=k ; 
    }
};",1448263710
Ritik Rathor,ritik_369,174,3619,cpp,"

class Solution 
{
public:
   int maxIncreasingSubarrays(vector<int>& nums)
   {
      int n = nums.size() , ans = 0 ; 
      vector < int > rig(n + 3 , 0) ; 
      vector < int > lef(n + 3 , 0) ; 
      for(int i = 1 ; i <= n ; i += 1)
      {
         int h = nums[i-1] ; 
         if(i == 1)
         {
            lef[i] = 1 ; 
            continue ; 
         }
         lef[i] = 1 ; 
         if(nums[(i-1)-1] < h)
         {
            lef[i] = lef[i-1] + 1 ; 
         }
      }

      for(int i = n ; i >= 1 ; i -= 1)
      {
         int h = nums[i-1] ; 
         if(i == n)
         {
            rig[i] = 1 ; 
            continue ; 
         }
         rig[i] = 1 ; 
         if(nums[(i + 1)-1] > h)
         {
            rig[i] = rig[i+1] + 1 ; 
         }
      }
      for(int i = 1 ; i + 1 <= n ; i += 1)
      {
         ans = max(ans , min(lef[i] , rig[i + 1])) ; 
      }
      
      return ans ; 
   }
};
",1448263883
Ritik Rathor,ritik_369,174,3631,cpp,"#define bpc __builtin_popcount

int dp2[801][6] ; 
int ok(int n , int k)
{
   if(n == 1)return 1 ; 
   if(k <= 0)return 0 ;  
   if(dp2[n][k] != -1)return dp2[n][k] ; 
   return dp2[n][k] = ok(bpc(n) , k-1) ; 
}
vector < int > arr ; 

string ss ; 
int here = 0 ; 
const int N = 802 ; 
const int mod = 1e9 + 7;
int dp[N + 2][N + 2][2] ; 
int f(int idx , int t , int ct)
{
   if(idx == ss.size())
   {
      if(t)return 0 ; 
      return arr[ct] ; 
   }
   int  & res = dp[idx][ct][t] ; 
   if(res != -1)return res ; 
   res = 0 ; 
   int h = ((t)?((ss[idx]) - '0'):1) ; 
   for(int i = 0 ; i <= h ; i += 1)
   {
      int nt = (t & (i == h)) ; 
      res = (1ll * res + 1ll * f(idx + 1 , nt , ct + i)) % mod ; 
   }
   return res ; 
}

class Solution 
{
public:
   int countKReducibleNumbers(string s, int k) 
   {
      memset(dp , -1 , sizeof(dp)) ; 
      memset(dp2 , -1 , sizeof(dp2)) ; 
      arr = vector < int > (801 , 0) ; 
      for(int i = 0 ; i <= 800 ; i += 1)
         arr[i]=ok(i , k-1) ;
      ss = s ; 
      return f(0 , 1 , 0) ; 
   }
};",1448265416
Ritik Rathor,ritik_369,174,3646,cpp,"const int N = 1e5 , mod = 1e9 + 7 ; 
class Solution 
{
public:
   int sumOfGoodSubsequences(vector<int>& nums)
   {
      vector < long long > dp(1e5 + 10 , 0) ; 
      vector < long long > dp2(1e5 + 10 , 0) ; 

      for(int i = (int)nums.size()-1 ; i >= 0 ; i -= 1)
      {
         int h = nums[i] ; 
         dp2[h] = (dp2[h] + 1) % mod ; 
         dp2[h] = (1ll * dp2[h] + 1ll * dp2[h + 1]) % mod ; 
         if(h-1 >= 0)dp2[h] = (1ll * dp2[h] + 1ll * dp2[h - 1]) % mod ; 
         dp[h] = (dp[h] + h) % mod ; 
         dp[h] = ((1ll * dp[h] + 1ll * dp[h + 1]) % mod + (1ll * h * dp2[h + 1]) % mod) % mod ; 
         if(h-1 >= 0)dp[h] = ((1ll * dp[h]  + 1ll * dp[h - 1]) % mod + (1ll * h * dp2[h - 1]) % mod) % mod ; 
      }
      long long res = 0 ; 
      for(auto a : dp)
      {
         res = (1ll * res + 1ll * a) % mod ; 
      }
      return (int)res ; 
   }
};",1448264427
Hachieii,Hachieii,175,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
      const int n = nums.size();
      vector<int> a(n + 1);
      
      for (int i = 2; i <= n; ++i) {
        a[i] = nums[i - 1] > nums[i - 2];
        a[i] += a[i - 1];
      }

      for (int i = 1; i + k * 2 - 1 <= n; ++i) {
        const int sum1 = a[i + k - 1] - a[i];
        const int sum2 = a[i + k * 2 - 1] - a[i + k];
        if (sum1 == sum2 && sum1 == k - 1) return true;
      }

      return false;
    }
};",1448183925
Hachieii,Hachieii,175,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
      const int n = nums.size();
      vector<int> a(n + 1);
      
      for (int i = 2; i <= n; ++i) {
        a[i] = nums[i - 1] > nums[i - 2];
        a[i] += a[i - 1];
      }

      int l = 1, r = n;

      while (l < r) {
        const int k = (l + r) >> 1;
        bool ok = false;
        
        for (int i = 1; i + k * 2 - 1 <= n; ++i) {
          const int sum1 = a[i + k - 1] - a[i];
          const int sum2 = a[i + k * 2 - 1] - a[i + k];
          if (sum1 == sum2 && sum1 == k - 1) {
            ok = true;
            break;
          }
        }

        if (ok) l = k + 1;
        else r = k;
      }

      return l - 1;
    }
};",1448187220
Hachieii,Hachieii,175,3631,cpp,"const int mod = 1e9 + 7;
int dp[800 + 10][2][800 + 10];

class Solution {
private:
  vector<int> mark;
public:
    Solution(): mark(800 + 10) { ; }

    int get(int i) {
      int res = 0;
      while (i != 1) {
        ++res;
        i = __builtin_popcount(i);
      }
      return res;
    }

    void init(int k) {
      for (int i = 1; i <= 800; ++i) {
        int cnt = 1;
        cnt += get(i);
        mark[i] = cnt <= k;
      }
    }

    int dfs (string& s, int i, bool ok, int tot) {
      if (i >= s.size()) {
        return ok && mark[tot];
      }

      if (dp[i][ok][tot] != -1) return dp[i][ok][tot];

      int res = 0;
      const int mx = ok ? 1 : s[i] - '0';
      
      for (int c = 0; c <= mx; ++c) {
        const bool nxtOk = ok || c < mx;
        res = (res + dfs(s, i + 1, nxtOk, tot + (c == 1))) % mod;
      }

      return dp[i][ok][tot] = res;
    }

    int countKReducibleNumbers(string s, int k) {
      init(k);
      memset(dp, -1, sizeof dp);
      return dfs(s, 0, 0, 0);
    }
};",1448208557
Hachieii,Hachieii,175,3646,cpp,"const int mxn = 1e5 + 10;
long long cnt[mxn];
long long sum[mxn];
const int mod = 1e9 + 7;

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        memset(cnt, 0, sizeof cnt);
        memset(sum, 0, sizeof sum);

        long long res = 0;

        for (int v: nums) {
          ++v;
          cnt[v] = (cnt[v] + cnt[v - 1] + cnt[v + 1] + 1) % mod;
          sum[v] = (sum[v] + sum[v - 1] + sum[v + 1] + 1LL * (v - 1) * (cnt[v - 1] + cnt[v + 1] + 1) % mod) % mod;
          res = (res + sum[v - 1] + sum[v + 1] + 1LL * (v - 1) * (cnt[v - 1] + cnt[v + 1] + 1) % mod) % mod;
        }
        return res;
    }
};",1448243217
panshane56,panshane56,176,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> pref(n, 1), suf(n, 1);

        for (int i = 1; i < n; i++) {
            if (nums[i] > nums[i - 1]) {
                pref[i] = pref[i - 1] + 1;
            }
        }

        for (int i = n - 2; i >= 0; i--) {
            if (nums[i] < nums[i + 1]) {
                suf[i] = suf[i + 1] + 1;
            }
        }

        int ans = 0;
        for (int i = 1; i < n; i++) {
            ans = max(ans, min(pref[i - 1], suf[i]));
        }
        return ans >= k;
    }
};",1448221746
panshane56,panshane56,176,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> pref(n, 1), suf(n, 1);

        for (int i = 1; i < n; i++) {
            if (nums[i] > nums[i - 1]) {
                pref[i] = pref[i - 1] + 1;
            }
        }

        for (int i = n - 2; i >= 0; i--) {
            if (nums[i] < nums[i + 1]) {
                suf[i] = suf[i + 1] + 1;
            }
        }

        int ans = 0;
        for (int i = 1; i < n; i++) {
            ans = max(ans, min(pref[i - 1], suf[i]));
        }
        return ans;
    }
};",1448220361
panshane56,panshane56,176,3631,cpp,"class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        if (s.size() == 1 && (s[0] == '1' || s[0] == '0')) {
            return 0;
        }

        const int MOD = 1e9 + 7;

        int n = s.size();
        vector<int> f(n + 1, 1);
        for (int i = 2; i <= n; i++) {
            auto tmp = i;
            while (tmp != 1) {
                f[i]++;
                tmp = __builtin_popcount(tmp);
            }
        }

        vector<vector<int>> dp(n, vector<int>(n + 1, 0));
        int high1 = 1;
        for (int i = 1; i < n; i++) {
            // all 0
            dp[i][1] = 1;

            // upper bound
            if (s[i] == '1') {
                dp[i][high1] = (dp[i][high1] + 1) % MOD;
                high1++;
            }

            // other
            for (int x = 0; x <= n; x++) {
                dp[i][x] = (dp[i][x] + dp[i - 1][x]) % MOD;
                if (x)
                    dp[i][x] = (dp[i][x] + dp[i - 1][x - 1]) % MOD;
            }
        }

        int ans = 0;
        for (int i = 1; i <= n; i++) {
            if (f[i] <= k) {
                ans = (ans + dp[n - 1][i]) % MOD;
            }
        }
        return ans;
    }
};",1448265702
panshane56,panshane56,176,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(std::vector<int>& numbers) {
        std::unordered_map<int, long long> countMap, sumMap;
        int MODULO = 1E9 + 7;
        
        for (int i = 0; i < numbers.size(); ++i) {
            int current = numbers[i];

            countMap[current] = (countMap[current + 1] + countMap[current - 1] +
                                 1 + countMap[current]) %
                                MODULO;
            sumMap[current] =
                (sumMap[current + 1] + sumMap[current - 1] +
                 countMap[current + 1] * current +
                 +countMap[current - 1] * current + sumMap[current] + current) %
                MODULO;
        }
        
        int result = 0;
        for (auto& pii : sumMap) {
            result = (result + pii.second) % MODULO;
        }

        return result;
    }
};",1448210076
Wen-Chieh Tung,WJTung,178,3612,cpp,"class Solution {
 public:
  bool hasIncreasingSubarrays(vector<int>& nums, int k) {
    for (int i = 0; i + k * 2 <= nums.size(); ++i) {
      bool ok = true;
      for (int j = i; j + 1 < i + k; ++j) {
        if (!(nums[j + 1] > nums[j])) {
          ok = false;
        }
      }
      for (int j = i + k; j + 1 < i + k * 2; ++j) {
        if (!(nums[j + 1] > nums[j])) {
          ok = false;
        }
      }
      if (ok) {
        return true;
      }
    }
    return false;
  }
};",1448184036
Wen-Chieh Tung,WJTung,178,3619,cpp,"class Solution {
 public:
  int maxIncreasingSubarrays(vector<int>& nums) {
    vector<int> L(nums.size(), 1);
    int cur = 0;
    for (int i = 0; i < nums.size(); ++i) {
      ++cur;
      if (i + 1 == nums.size() || nums[i + 1] <= nums[i]) { 
        for (int j = i; j >= i + 1 - cur; --j) {
          L[j] = i - j + 1;
        }
        cur = 0;
      }
    }
    int ans = 1;
    for (int i = 0; i < nums.size(); ++i) {
      // cout << i << "": "" << L[i] << endl; 
      ans = max(L[i] / 2, ans);
      int start2 = i + L[i];
      if (start2 < nums.size() && L[start2] >= L[i]) {
        ans = max(L[i], ans);
      }
    }
    return ans;
  }
};",1448200914
Wen-Chieh Tung,WJTung,178,3631,cpp,"class Solution {
 public:
  const int MOD = 1E9 + 7;

  int T(int cur) {
    if (cur == 1) {
      return 0;
    }
    return 1 + T(__builtin_popcount(cur));
  }

  int countKReducibleNumbers(string s, int k) {
    // W[num one] = number of ways to be smaller than s with num one '1'
    vector<int> W(s.length() + 1, 0);
    int prefix_count = 0;
    for (int i = 0; i < s.length(); ++i) {
      vector<int> nextW(s.length() + 1, 0);

      if (i > 0) {
        // start here
        nextW[1] = (nextW[1] + 1) % MOD;
        // prefix + 0
        if (s[i] == '1') {
          nextW[prefix_count] = (nextW[prefix_count] + 1) % MOD;
        }
      }
      
      // add 0
      for (int j = 0; j <= s.length(); ++j) {
        nextW[j] = (nextW[j] + W[j]) % MOD;
      }
      // add 1
      for (int j = 0; j < s.length(); ++j) {
        nextW[j + 1] = (nextW[j + 1] + W[j]) % MOD;
      }

      if (s[i] == '1') {
        ++prefix_count;
      }

      W = move(nextW);
    }

    long long ans = 0;
    for (int i = 1; i <= s.length(); ++i) {
      if (W[i] > 0 && T(i) <= k - 1) {
        ans = (ans + W[i]) % MOD;
      }
    }
    return ans;
  }
};",1448258758
Wen-Chieh Tung,WJTung,178,3646,cpp,"class Solution {
 public:
  const long long MOD = 1E9 + 7;

  int sumOfGoodSubsequences(vector<int>& nums) {
    vector<pair<int, long long>> count_and_sum(100'001, pair<int, long long>(0, 0));
    for (int num : nums) {
      // starting here
      count_and_sum[num].first = (count_and_sum[num].first + 1) % MOD;
      count_and_sum[num].second = (count_and_sum[num].second + num) % MOD;
      // continue from num - 1
      if (num - 1 >= 0) {
        count_and_sum[num].first = (count_and_sum[num].first + count_and_sum[num - 1].first) % MOD;
        long long A = count_and_sum[num - 1].second + static_cast<long long>(num) * count_and_sum[num - 1].first;
        count_and_sum[num].second = (count_and_sum[num].second + A) % MOD;
      }
      // continue from num + 1
      if (num + 1 <= 100'000) {
        count_and_sum[num].first = (count_and_sum[num].first + count_and_sum[num + 1].first) % MOD;
        long long A = count_and_sum[num + 1].second + static_cast<long long>(num) * count_and_sum[num + 1].first;
        count_and_sum[num].second = (count_and_sum[num].second + A) % MOD;
      }
    }
    long long ans = 0;
    for (int i = 0; i <= 100'000; ++i) {
      ans = (ans + count_and_sum[i].second) % MOD;
    }
    return ans;
  }
};",1448224486
xlx2,xlx2,180,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        for i in range(n-2*k+1):
            if all(a < b for a,b in itertools.pairwise(nums[i:i+k])) and all(a < b for a,b in itertools.pairwise(nums[i+k:i+2*k])):
                return True
        return False",1448219324
xlx2,xlx2,180,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        f = [0] * n
        j = 0
        for i in range(n):
            j = max(j, i)
            while j+1 < n and nums[j] < nums[j+1]:
                j += 1
            f[i] = j-i+1
        
        g = []
        cnt = 0
        for i in range(n):
            if cnt:
                cnt -= 1
                continue
            g.append(f[i])
            cnt = f[i] - 1
        
        x = max((min(a,b) for a,b in itertools.pairwise(g)), default=0)
        return max(x, max(g) // 2)",1448218949
xlx2,xlx2,180,3631,python3,"N = 801
g = [math.inf] * N
g[1] = 0
for i in range(2, N):
    g[i] = 1 + g[i.bit_count()]


class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        M = 10**9 + 7
        n = len(s)
        if s.count('1') == 0: return 0
        @cache
        def f(i, eq, c):
            hi = int(s[i]) if eq else 1
            ans = 0
            if i == n-1:
                if c == 0:
                    if eq and hi == 1:
                        pass
                    else:
                        ans += (hi == 1)
                else:
                    for j in range(hi+1):
                        if eq and j == hi: continue
                        ans += (g[c+j] < k)
                return ans % M
            for j in range(hi+1):
                ans += f(i+1, eq and j == hi, c+j)
            return ans % M
        
        return f(0, 1, 0)",1448267110
xlx2,xlx2,180,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        M = 10**9 + 7
        n = len(nums)
        d = defaultdict(int)
        c = defaultdict(int)
        ans = 0
        for i,v in enumerate(nums):
            s = (v + d[v-1] + d[v+1] + v * (c[v-1] + c[v+1])) % M
            ans += s
            ans %= M
            # print(i, v, s, d, ans)
            c[v] += 1 + c[v-1] + c[v+1]
            c[v] %= M
            d[v] += s
            d[v] %= M
        return ans % M",1448218641
VILLANOVA_ECON,VILLANOVA_ECON,181,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        
        def check(arr):
            if len(set(arr)) == len(arr) and arr == sorted(arr):
                return True
            return False
        
        for i in range(len(nums)):
            zeb = nums[i:i+2*k]
            if len(zeb) != 2*k:
                break
            if check(zeb[:k]) and check(zeb[k:]):
                return True
        return False
        
                    ",1448184402
VILLANOVA_ECON,VILLANOVA_ECON,181,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        
        pref = [0]
        for i in range(1,len(nums)):
            if nums[i] > nums[i-1]:
                pref.append(pref[-1]+1)
            else:
                pref.append(pref[-1])
        # print
        # pref = list(itertools.accumulate(pref))
        
        #print(pref)
        def check(k):
            for i in range(len(pref)):
                if i+2*k > len(pref):
                    break
                #print(i,k,((pref[i+k-1]-pref[i]) == k-1) and ((pref[i+2*k-1]-pref[i+k]) == k-1))
                if ((pref[i+k-1]-pref[i]) == k-1) and ((pref[i+2*k-1]-pref[i+k]) == k-1):
                    return True
            return False
        
        l = 1
        r = len(nums)//2
        best_ans = 1
        while l <= r:
            mid = l +(r-l)//2
            if check(mid):
                best_ans = mid
                l = mid+1
            else:
                r= mid-1
        return best_ans",1448196069
VILLANOVA_ECON,VILLANOVA_ECON,181,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        modulo = 10** 9 + 7
        @lru_cache(None)
        def brute1(x):
            z = 0
            tt = k-1
            while x != 1 and tt > 0:
                x = bin(x).count(""1"")
                z += 1
                tt -= 1
            return int(x == 1)
        
        @lru_cache(None)
        def recur_fn(i,count,below):
            if i == len(s):
                if not below or count == 0:
                    return 0
                #print(count,below)
                return brute1(count)
            elif below:
                res = recur_fn(i+1,count+1,below) + recur_fn(i+1,count,below)
                if res >= modulo:
                    res %= modulo
                return res
            else:
                if s[i] == ""0"":
                    return recur_fn(i+1,count,below)
                else:
                    res = recur_fn(i+1,count+1,below) + recur_fn(i+1,count,True)
                    if res >= modulo:
                        res %= modulo
                    return res
        result =  recur_fn(0,0,False)%modulo
        recur_fn.cache_clear()
        return result
                
                ",1448252717
VILLANOVA_ECON,VILLANOVA_ECON,181,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        modulo = 10**9 + 7
        
        hash_table = {}
        
        
        dp = [0]*(max(nums)+10)
        dp_count = [0]*(max(nums)+10)
        
        for i,x in enumerate(nums):
            dp[x] += x
            dp_count[x] += 1
            if x-1 >= 0:
                dp[x] += (dp[x-1]) + x * dp_count[x-1]
                dp_count[x] += dp_count[x-1]
                if dp[x] >= modulo:
                    dp[x] %= modulo
            if x+1 < len(dp):
                dp[x] += (dp[x+1]) + x * dp_count[x+1]
                dp_count[x] += dp_count[x+1]
                if dp[x] >= modulo:
                    dp[x] %= modulo
            if dp[x] >= modulo:
                dp[x] %= modulo
            #print(dp,dp_count)
        #print(dp)
        #print(dp)
        #print(dp_count)
        ans = 0
        for x in dp:
            ans += x
            if ans >= modulo:
                ans %= modulo
        return ans",1448218503
Ajay Singh Deopa,singh_deopa,182,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = (int) nums.size();

        for (int i = 0; i <= n - k - k; i++) {
            bool can = true;
            
            for (int j = 1; j < k; j++) {
                if (nums[i + j] <= nums[i + j - 1]) {
                    can = false;
                    break;
                }
            }

            if (!can) continue;

            for (int j = 1; j < k; j++) {
                if (nums[i + k + j] <= nums[i + k + j - 1]) {
                    can = false;
                    break;
                }
            }

            if (can) {
                return true;
            }
        }

        return false;
    }
};",1448184789
Ajay Singh Deopa,singh_deopa,182,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = (int) nums.size();
        vector<int> suf(n);

        for (int i = n - 1; i >= 0; i--) {
            suf[i] = 1;

            if (i != n - 1 && nums[i] < nums[i + 1]) {
                suf[i] += suf[i + 1];
            }
        }

        int pre = 1;
        int res = 1;

        for (int i = 1; i < n - 1; i++) {
            if (nums[i] > nums[i - 1]) {
                pre++;
            }
            else {
                pre = 1;
            }

            res = max(res, min(pre, suf[i + 1]));
        }

        return res;
    }
};",1448191108
Ajay Singh Deopa,singh_deopa,182,3631,cpp,"typedef long long ll;

class Solution {
    void brute(string& s, int k) {
        int n = (int) s.size();
        ll val = 0;

        for (int i = 0; i < n; i++) {
            if (s[i] == '1') {
                val |= (1 << n - i - 1);
            }
        }

        vector<int> dp(val + 1, 0);
        int cnt = 0;

        for (int i = 1; i < val; i++) {
            if (i == 1) {
                dp[i] = 0;
            }
            else {
                dp[i] = 1 + dp[__builtin_popcount(i)];
            }

            if (dp[i] <= k) {
                cnt++;
            }
        }

        cout << s << "" "" << cnt << endl;
    }
public:
    int countKReducibleNumbers(string s, int k) {
        // brute(s, k);
        int n = (int) s.size();
        long long mod = 1000000007;
        vector<int> dp(n + 1, 0);

        for (int i = 2; i <= n; i++) {
            int bits = __builtin_popcount(i);
            dp[i] = 1 + dp[bits];
            // cout << i << "" "" << dp[i] << endl;
        }

        vector<vector<ll>> comb(n + 1, vector<ll>(n + 1, 0));

        for (int i = 0; i <= n; i++) {
            comb[i][i] = comb[i][0] = 1;

            for (int j = 1; j < i; j++) {
                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod;
            }
        }

        // for (auto a: comb) {
        //     for (auto b: a) cout << b << "" "" ;
        //     cout << endl;
        // }

        ll res = 0;
        
        for (int i = 1; i < n; i++) {
            for (int j = 1; j <= i; j++) {
                if (1 + dp[j] > k) continue;

                ll val = comb[i - 1][j - 1];
                res = (res + val) % mod;
            }
        }

        int ones = 1;

        for (int i = 1; i < n; i++) {
            if (s[i] == '0') continue;

            int rem = n - i - 1;

            for (int j = 0; j <= rem; j++) {
                if (1 + dp[ones + j] > k) {
                    continue;
                }

                res = (res + comb[rem][j]) % mod;
            }

            ones++;
        }

        return (int) res;
    }
};",1448260231
Ajay Singh Deopa,singh_deopa,182,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int n = (int) nums.size();
        long long mod = 1000000007;
        int mx = *max_element(nums.begin(), nums.end()) + 2;
        vector<long long> cnt(mx), sum(mx);

        for (int& i: nums) {
            cnt[i] = (cnt[i] + 1) % mod;
            sum[i] = (sum[i] + i) % mod;
            
            for (int d: {1, -1}) {
                int val = i + d;

                if (val < 0 || cnt[val] == 0) {
                    continue;
                }

                cnt[i] = (cnt[i] + cnt[val]) % mod;
                sum[i] = (sum[i] + sum[val] + 1LL * i * cnt[val] % mod) % mod;
            }
        }

        long long res = 0;

        for (int i = 0; i < mx; i++) {
            if (cnt[i] == 0) continue;

            res = (res + sum[i]) % mod;
            // cout << i << "" "" << cnt[i] << "" "" << sum[i] << endl;
        }

        return (int) res;
    }
};",1448218316
Thien-Phuoc Phung,phungthienphuoc,185,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n=len(nums)
        left=[0]*n
        for i in range(1,n):
            if nums[i]>nums[i-1]:
                left[i]=left[i-1]
            else:
                left[i]=i
        for i in range(2*k-1,n):
            if left[i]<=i-k+1 and left[i-k]<=i-2*k+1:
                return True
        return False",1448182815
Thien-Phuoc Phung,phungthienphuoc,185,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n=len(nums)
        left=[0]*n
        for i in range(1,n):
            if nums[i]>nums[i-1]:
                left[i]=left[i-1]
            else:
                left[i]=i
        
        def check(k):
            for i in range(2*k-1,n):
                if left[i]<=i-k+1 and left[i-k]<=i-2*k+1:
                    return True
            return False
        
        l,r=1,n//2
        while l<r:
            m=(l+r+1)//2
            if check(m):
                l=m
            else:
                r=m-1
        return l",1448191956
Thien-Phuoc Phung,phungthienphuoc,185,3631,python3,"mod=10**9+7

pre=[0]*801
for i in range(2,801):
    pre[i]=pre[i.bit_count()]+1

f=[1]*801
v=[1]*801
for i in range(2,801):
    f[i]=f[i-1]*i%mod
    v[i]=v[i-1]*pow(i,mod-2,mod)%mod

c=lambda n,k:f[n]*v[k]%mod*v[n-k]%mod
    
class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        d=0
        n=len(s)
        count=[0]*(n+1)
        for i,x in enumerate(s):
            if x=='1':
                for j in range(n-i):
                    count[j+d]=(c(n-i-1,j)+count[j+d])%mod
                d+=1
        res=0
        for i in range(1,n+1):
            if pre[i]<=k-1:
                res=(res+count[i])%mod
        return res",1448253045
Thien-Phuoc Phung,phungthienphuoc,185,3646,python3,"mod=10**9+7
class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        n=len(nums)
        s,d=defaultdict(int),defaultdict(int)
        for i,x in enumerate(nums):
            s[x]=(s[x]+x*(1+d[x-1]+d[x+1])+s[x-1]+s[x+1])%mod
            d[x]=(d[x]+1+d[x-1]+d[x+1])%mod
        return sum(s.values())%mod",1448202643
u50UoHd3Oy,u50UoHd3Oy,187,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        for (int i = 0; i < n; i++) {
            if (i + 2 * k - 1 < n){
                int j = i + 1;
                int ok = 1;
                while (j <= i + k - 1){
                    if (nums[j] <= nums[j - 1]) {
                        ok = 0;
                        break;
                    }
                    j++;
                }
                j++;
                while (j <= i + 2 * k - 1) {
                    if (nums[j] <= nums[j - 1]) {
                        ok = 0;
                        break;
                    }
                    j++;
                }

                if (ok) {
                    return true;
                }
            }
        }

        return false;
    }
};",1448192219
u50UoHd3Oy,u50UoHd3Oy,187,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> cnt(n, 1);
        int ans = 0;
        for (int i = 1; i < n; i++) {
            if (nums[i - 1] < nums[i]) {
                cnt[i] = cnt[i - 1] + 1;
            }
            ans = max(ans, cnt[i] / 2);
            if (i - cnt[i] >= 0) {
                ans = max(ans, min(cnt[i], cnt[i - cnt[i]]));
            }
        }

        return ans;
    }
};",1448206114
u50UoHd3Oy,u50UoHd3Oy,187,3631,cpp,"class Solution {
public:
    int binary_power(int num, int pow) {
        int result = 1;
        while (pow) {
            if (pow % 2) {
                result = (1LL * result * num) % mod;
            }
            num = (1LL * num * num) % mod;
            pow /= 2;
        }

        return result;
    }

    void initFactorial(int n) {
        factorial.assign(n + 1, 1);
        inv_factorial.assign(n + 1, 1);

        for (int i = 1; i <= n; i++) {
            factorial[i] = (1LL * factorial[i - 1] * i) % mod;
            inv_factorial[i] = (1LL * inv_factorial[i - 1] * binary_power(i, mod - 2)) % mod;
        }
    }

    int ncr(int n, int r) {
        if (r > n) {
            return 0;
        }

        int ans = factorial[n];
        ans = (1LL * ans * inv_factorial[r]) % mod;
        ans = (1LL * ans * inv_factorial[n - r]) % mod;

        return ans;
    }

    int countKReducibleNumbers(string s, int k) {
        int n = s.size();

        initFactorial(n);
        
        vector<int> minC(n + 1, 0);
        for (int i = 2; i <= n; i++) {
            int ti = i;
            int sc = 0;
            while (ti) {
                if (ti % 2) sc++;
                ti /= 2;
            }

            minC[i] = 1 + minC[sc];
        }

        int cur1 = 0;
        int ans = 0;
        for (int i = 0; i < n; i++) {
            if (s[i] == '1') {
                int rem = n - (i + 1);
                for (int sb = 0; sb <= n; sb++) {
                    if (cur1 + sb <= n && minC[cur1 + sb] + 1 <= k) {
                        ans = (ans + ncr(rem, sb)) % mod;
                    }
                }
                
                cur1++;
            }
        }

        ans = (ans - 1 + mod) % mod; 

        return ans;
    }
private:
    int mod = (int)(1e9 + 7);
    vector<int> factorial;
    vector<int> inv_factorial;
};",1448267968
u50UoHd3Oy,u50UoHd3Oy,187,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int max_num = *max_element(nums.begin(), nums.end());
        vector<long> dp(max_num + 1, 0);
        vector<long> sum(max_num + 1, 0);
        for (int i = 0; i < nums.size(); i++) {
            dp[nums[i]] = (dp[nums[i]] + 1) % mod;
            sum[nums[i]] = (sum[nums[i]] + nums[i]) % mod;
            if (nums[i] - 1 >= 0) {
                dp[nums[i]] = (dp[nums[i] - 1] + dp[nums[i]]) % mod;
                sum[nums[i]] = (
                    sum[nums[i]] 
                  + (1LL * dp[nums[i] - 1] * nums[i]) % mod
                  + sum[nums[i] - 1]
                ) % mod;
            }
            if (nums[i] + 1 <= max_num) {
                dp[nums[i]] = (dp[nums[i] + 1] + dp[nums[i]]) % mod;
                sum[nums[i]] = (
                    sum[nums[i]] 
                  + (1LL * dp[nums[i] + 1] * nums[i]) % mod
                  + sum[nums[i] + 1]
                ) % mod;
            }
        }

        int ans = 0;
        for (int i = 0; i <= max_num; i++) {
            ans = (ans + sum[i]) % mod;
        }

        return ans;
    }
private:
    const int mod = (int)(1e9 + 7);
};",1448230649
lozy219,lozy219,191,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        vector<int> diff;
        for (int i=1; i<nums.size(); ++i) {
            if (nums[i]>nums[i-1]) {
                diff.push_back(1);
            } else {
                diff.push_back(0);
            }
        }
        // cout << ""0 "";
        vector<int> psum(nums.size(), 0);
        for (int i=0; i<nums.size()-1; ++i) {
            psum[i+1]=psum[i]+diff[i];
            // cout << psum[i+1] << "" "";
        }
        // cout << endl;
        for (int i=k-1; i+k<nums.size(); ++i) {
            if (((psum[i]-psum[i-k+1])==k-1) && ((psum[i+k]-psum[i+1])==k-1)) {
                return true;
            }
        }
        return false;
    }
};",1448188574
lozy219,lozy219,191,3619,cpp,"class Solution {
public:
    bool gao(int k, vector<int>& nums, vector<int>& psum) {
        for (int i=k-1; i+k<nums.size(); ++i) {
            if (((psum[i]-psum[i-k+1])==k-1) && ((psum[i+k]-psum[i+1])==k-1)) {
                return true;
            }
        }
        return false;
    }
    int maxIncreasingSubarrays(vector<int>& nums) {
        vector<int> diff;
        for (int i=1; i<nums.size(); ++i) {
            if (nums[i]>nums[i-1]) {
                diff.push_back(1);
            } else {
                diff.push_back(0);
            }
        }
        vector<int> psum(nums.size(), 0);
        for (int i=0; i<nums.size()-1; ++i) {
            psum[i+1]=psum[i]+diff[i];
        }
        int left=1, right=nums.size();
        while (left<right) {
            int mid=(left+right+1)/2;
            if (gao(mid, nums, psum)) {
                left=mid;
            } else {
                right=mid-1;
            }
        }
        return left;
    }
};",1448193295
lozy219,lozy219,191,3631,cpp,"#define ll long long
vector<ll> fact;

class Solution {
    const ll MOD=1000000007;
public:
    template <typename T>
    T modpow(T base, T exp, T modulus) {
      base %= modulus;
      T result = 1;
      while (exp > 0) {
        if (exp & 1) result = (result * base) % modulus;
        base = (base * base) % modulus;
        exp >>= 1;
      }
      return result;
    }

    ll ncr(ll n, ll r) {
      ll top = fact[n];
      ll bot = fact[n-r]*fact[r]%MOD;

      return top*modpow(bot, MOD-2, MOD)%MOD;
    }

    int countKReducibleNumbers(string s, int k) {
        if (fact.size()==0) {
            fact=vector<ll>(805, 1);
            for (int i=1; i<805; ++i) {
                fact[i] = i*fact[i-1]%MOD;
            }
        }
        vector<int> dp(805, 0);
        for (int i=2; i<805; ++i) {
            dp[i]=dp[__builtin_popcount(i)]+1;
        }
        dp[0]=0x3f3f3f3f;
        long long res=0;
        int cur=0;
        for (int i=0; i<s.size(); ++i) {
            if (s[i]=='1') {
                // set this bit to '0' and count the rest
                int rem=s.size()-1-i;
                for (int j=0; j<=rem; ++j) {
                    int cnt=cur+j;
                    if (dp[cnt]+1<=k) {
                        res=(res+ncr(rem, j))%MOD;
                    }
                }
                cur++;
            }
        }
        return res;
    }
};",1448253977
lozy219,lozy219,191,3646,cpp,"class Solution {
    const int MOD=1000000007;
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        vector<long long> dpn(100005, 0);
        vector<long long> dpc(100005, 0);
        for (int i: nums) {
            if (i==0) {
                dpn[i]=(dpn[i]+(dpn[i+1]+i*dpc[i+1]%MOD))%MOD;
                dpc[i]=(dpc[i]+dpc[i+1])%MOD;
                dpn[i]=(dpn[i]+i)%MOD;
                dpc[i]=(dpc[i]+1)%MOD;
            } else {
                dpn[i]=(dpn[i]+(dpn[i-1]+dpn[i+1]+i*(dpc[i-1]+dpc[i+1])%MOD))%MOD;
                dpc[i]=(dpc[i]+dpc[i-1]+dpc[i+1])%MOD;
                dpn[i]=(dpn[i]+i)%MOD;
                dpc[i]=(dpc[i]+1)%MOD;
            }
        }
        int res=0;
        for (int i=0; i<100005; ++i) {
            res=(res+dpn[i])%MOD;
        }
        return res;
    }
};",1448211002
andy-lc,andy-lc,192,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        psum = [0]*len(nums)
        for i in range(1, len(nums)):
            psum[i] = psum[i-1] + (1 if nums[i] > nums[i-1] else 0)
        for i in range(len(nums)-2*k+1):
            if psum[i+k-1]-psum[i] == k-1 and psum[i+k+k-1]-psum[i+k] == k-1:
                return True
        return False",1448183006
andy-lc,andy-lc,192,3619,python3,"class Solution:
    def hasIncreasingSubarrays(self, psum: List[int], k: int) -> bool:
        for i in range(len(psum)-2*k+1):
            if psum[i+k-1]-psum[i] == k-1 and psum[i+k+k-1]-psum[i+k] == k-1:
                return True
        return False
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        psum = [0]*len(nums)
        for i in range(1, len(nums)):
            psum[i] = psum[i-1] + (1 if nums[i] > nums[i-1] else 0)
        L = 0
        R = len(nums)-1
        while L < R:
            M = L+(R-L+1)//2
            if self.hasIncreasingSubarrays(psum,M):
                L = M
            else:
                R = M-1
        return L",1448185533
andy-lc,andy-lc,192,3631,cpp,"#include <bits/stdc++.h>
#pragma GCC optimize(2)
#define rep(i, a, b) for (int i = (a); i < (b); ++i)
#define rep_(i, a, b) for (int i = (a); i > (b); --i)
#define CEIL_DIV(a, b) ((b) == 0 ? 0 : (((a) >= 0) ? ((a) + (b) - 1) / (b) : (a) / (b)))
#define FLOOR_DIV(a, b) (((a) / (b)) - ((a) % (b) != 0 && (((a) < 0) != ((b) < 0))))
#define mst(x, a) memset(x, a, sizeof(x))
#define all(a) begin(a), end(a)
#define lowbit(x) ((x) & (-(x)))
#define bitcnt(x) (__builtin_popcountll(x))
#define se second
#define fi first
#define pb push_back
#define maxe max_element
#define mine min_element
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<ll, ll> pll;
typedef pair<int, ll> pil;
typedef pair<int, int> pii;
typedef vector<int> vi;
typedef vector<ll> vll;
typedef vector<vi> vvi;
constexpr static int dirs[4][2] = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};
constexpr static int inf = 0x3f3f3f3f;
constexpr static int mod = 1e9 + 7;
const ll infl = 0x3f3f3f3f3f3f3f3fll;
template<class T> bool chmax(T &a, T b) {
    if (a >= b) return false;
    a = b; return true;
}
template<class T> bool chmin(T &a, T b) {
    if (a <= b) return false;
    a = b; return true;
}
template<class T> bool chsum(T &a, T b) {
    a = (a + b + mod) % mod;
    return false;
}

const int MAX_X = 800;

vi precompute_steps(int max_x){
    vi step(max_x + 1, 0);
    step[1] = 0;
    rep(x, 2, max_x + 1){
        int pop = bitcnt(x);
        if(pop <= max_x){
            step[x] = 1 + step[pop];
        }
        else{
            step[x] = 1 + step[max_x];
        }
    }
    return step;
}

vi STEPs = precompute_steps(MAX_X);

class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        vi bits;
        int L = s.size();
        bits.reserve(L);
        for(char c : s){
            bits.pb(c - '0');
        }
        
        vector<vi> dp_prev(L+1, vi(2, 0));
        dp_prev[0][1] = 1; 
        
        rep(pos, 0, L){
            vector<vi> dp(L+1, vi(2, 0));
            rep(cnt, 0, L+1){
                rep(t, 0, 2){
                    if(dp_prev[cnt][t] == 0){
                        continue;
                    }
                    int max_bit = (t ? bits[pos] : 1);
                    // Try placing both 0 and 1
                    rep(bit, 0, 2){
                        if(bit > max_bit){
                            continue;
                        }
                        int new_t = (t && (bit == max_bit)) ? 1 : 0;
                        int new_cnt = cnt + bit;
                        if(new_cnt > L){
                            continue;
                        }
                        dp[new_cnt][new_t] = (dp[new_cnt][new_t] + dp_prev[cnt][t]) % mod;
                    }
                }
            }
            dp_prev = dp;
        }
        
        vi cnt(L+1, 0);
        rep(c, 1, L+1){
            cnt[c] = (dp_prev[c][0] + dp_prev[c][1]) % mod;
        }
        
        ll res = 0;
        rep(x, 1, L+1){
            if(x <= MAX_X){
                if(STEPs[x] <= k-1){
                    res = (res + (ll)cnt[x]) % mod;
                }
            }
        }
        
        int x_n = 0;
        rep(i, 0, L){
            x_n += bits[i];
        }
        
        int step_n;
        if(x_n <= MAX_X){
            step_n = 1 + STEPs[x_n];
        }
        else{
            step_n = 1 + STEPs[MAX_X];
        }
        
        if(step_n <= k){
            res = (res - 1 + mod) % mod;
        }
        
        return res;
    }
};
",1448268534
andy-lc,andy-lc,192,3646,python3,"M = 1_000_000_007
class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        count = [0]*(max(nums)+2)
        sesum = [0]*(max(nums)+2)
        for x in nums:
            sesum[x] += ((sesum[x-1]+sesum[x+1])%M+(((count[x-1]+count[x+1])%M+1)*x)%M)%M
            count[x] += (count[x-1]+count[x+1])%M+1
            sesum[x] %= M
            count[x] %= M
        ans = 0
        for s in sesum:
            ans += s
            ans %= M
        return ans",1448195808
ninja_master2002,ninja_master2002,193,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int i=0;
        int n=nums.size();
        vector<int>ans(n,1);
        while(i<n){
            int j=i+1;
            while(j<n && nums[j]>nums[j-1]){
                ans[j]=(j-i+1);
                j++;
            }
            i=j;
        }
        // for(auto it:ans){
        //     cout<<it<<"" "";
        // }
        // cout<<endl;
        int maxi=1;
        for(int i=0;i<n-1;i++){
            if(ans[i]>maxi){
                int si=maxi+1,ei=ans[i],ans1=-1;
                if(i+maxi+1>=n)continue;
                // if(i==4){
                //     cout<<maxi<<endl;
                // }
                while(si<=ei){
                    int mid=si+(ei-si)/2;
                    if(i+mid<n && ans[i+mid]-ans[i+1]>=(mid-1)){
                        ans1=mid;
                        si=mid+1;
                    }
                    else{
                        ei=mid-1;
                    }
                }
                maxi=max(maxi,ans1);
            }
        }
        return maxi>=k;
    }
};",1448201299
ninja_master2002,ninja_master2002,193,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int i=0;
        int n=nums.size();
        vector<int>ans(n,1);
        while(i<n){
            int j=i+1;
            while(j<n && nums[j]>nums[j-1]){
                ans[j]=(j-i+1);
                j++;
            }
            i=j;
        }
        // for(auto it:ans){
        //     cout<<it<<"" "";
        // }
        // cout<<endl;
        int maxi=1;
        for(int i=0;i<n-1;i++){
            if(ans[i]>maxi){
                int si=maxi+1,ei=ans[i],ans1=-1;
                if(i+maxi+1>=n)continue;
                // if(i==4){
                //     cout<<maxi<<endl;
                // }
                while(si<=ei){
                    int mid=si+(ei-si)/2;
                    if(i+mid<n && ans[i+mid]-ans[i+1]>=(mid-1)){
                        ans1=mid;
                        si=mid+1;
                    }
                    else{
                        ei=mid-1;
                    }
                }
                maxi=max(maxi,ans1);
            }
        }
        return maxi;
    }
};",1448198148
ninja_master2002,ninja_master2002,193,3631,cpp,"const int MOD = 1e9+7;
template<const int mod>
struct mint {
    int val;
    constexpr mint(long long x = 0) : val((x % mod + mod) % mod) {}
    explicit operator int() const { return val; }
    mint& operator+=(const mint &b) { val += b.val; val -= mod * (val >= mod); return *this; }
    mint& operator-=(const mint &b) { val -= b.val; val += mod * (val < 0); return *this; }
    mint& operator*=(const mint &b) { val = 1ll * val * b.val % mod; return *this; }
    mint& operator/=(const mint &b) { return *this *= b.inv(); }
    mint inv() const { int x = 1, y = 0, t; for(int a=val, b=mod; b; swap(a, b), swap(x, y)) t = a/b, a -= t * b, x -= t * y; return mint(x); }
    mint power(int b) const { mint a = *this, res(1); for(; b; a *= a, b /= 2)  if(b & 1) res *= a; return res; }
    mint operator-() const { return val == 0 ? 0 : mod - val; }
    mint& operator++() { val = val == mod - 1 ? 0 : val + 1; return *this; }
    mint& operator--() { val = val == 0 ? mod - 1 : val - 1; return *this; }
    mint operator++(int32_t) { mint before = *this; ++*this; return before; }
    mint operator--(int32_t) { mint before = *this; --*this; return before; }
    friend mint operator+(const mint &a, const mint &b) {return mint(a) += b;}
    friend mint operator-(const mint &a, const mint &b) {return mint(a) -= b;}
    friend mint operator*(const mint &a, const mint &b) {return mint(a) *= b;}
    friend mint operator/(const mint &a, const mint &b) {return mint(a) /= b;}
    friend bool operator==(const mint &a, const mint &b) {return a.val == b.val;}
    friend bool operator!=(const mint &a, const mint &b) {return a.val != b.val;}
    friend bool operator<(const mint &a, const mint &b) {return a.val < b.val;}
    friend istream& operator>>(istream &in, mint &a) {return in >> a.val;}
    friend ostream& operator<<(ostream &os, const mint &a) {return os << a.val;}
};
using Mint = mint<MOD>;
 
namespace comb {
    int n(0);
    vector<Mint> _fac{1}, _invfac{1}, _inv{0};
    void init(int m) {
        m = min (m, MOD - 1);
        if (m <= n) return;
        _fac.resize(m + 1); _invfac.resize(m + 1); _inv.resize(m + 1);
        for (int i = n + 1; i <= m; i++) _fac[i] = _fac[i - 1] * i;
        _invfac[m] = _fac[m].inv();
        for (int i = m; i > n; i--) _invfac[i - 1] = _invfac[i] * i, _inv[i] = _invfac[i] * _fac[i - 1];
        n = m;
    }
    Mint fac(int m) { if (m > n) init(2 * m); return _fac[m]; }
    Mint invfac(int m) { if (m > n) init(2 * m); return _invfac[m]; }
    Mint inv(int m) { if (m > n) init(2 * m); return _inv[m]; }
    Mint ncr(int n, int r) { if (n < r || r < 0) return 0; return fac(n) * invfac(r) * invfac(n - r); }
}
using comb::fac; using comb::invfac; using comb::inv; using comb::ncr;
class Solution {
    #define ll long long
public:
    int countKReducibleNumbers(string s, int k) {
        vector<Mint>ans(801,0);
        ans[2]=1;
        ans[1]=0;
        ans[0]=10;
        for(int i=3;i<=800;i++){
            int d=__builtin_popcount(i);
            ans[i]=ans[d]+1;
        }
        // for(int i=0;i<=9;i++){
        //     cout<<ans[i]<<"" "";
        // }
        // cout<<endl;
        if(s==""1""){
            return 0;
        }
        int n=s.size();
        vector<ll>cnt(n);
        for(int i=0;i<n;i++){
            cnt[i]=(s[i]=='1');
            if(i)cnt[i]+=cnt[i-1];
        }
        Mint res=0;
        // cout<<res<<endl;
        // res++;
        for(int i=0;i<n;i++){
            if(s[i]=='0')continue;
            ll rem=n-i-1;
            ll t=cnt[i]-1;
            if(rem+t==0)continue;
            for(ll j=0;j<=rem;j++){
                if((int)ans[j+t]+1<=k){
                    // if(i==0){
                    //     cout<<j<<"" hello ""<<rem<<endl;
                    // }
                    Mint temp=ncr(rem,j);
                    
                    res+=temp;
                    // cout<<temp<<"" ""<<res<<endl;
                }
                // cout<<endl;
                
            }
            // cout<<res<<endl;
        }
        return (int)res;
        
        
        
    }
};",1448268796
ninja_master2002,ninja_master2002,193,3646,cpp,"class Solution {
    #define ll long long
    #define mod (ll)(1e9+7);    
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int n=nums.size();
        int maxi=*max_element(nums.begin(),nums.end());
        vector<ll>dp(maxi+1,0);
        dp[nums[0]]=nums[0];
        map<ll,ll>mp;
        mp[nums[0]]+=1;
        for(int i=1;i<n;i++){
            dp[nums[i]]+=nums[i];
            mp[nums[i]]++;
            dp[nums[i]]%=mod;
            
            if(nums[i]>0){
                ll temp=mp[nums[i]-1];
                temp%=mod;
                ll ans1=temp*nums[i];
                ans1%=mod;
                ans1+=dp[nums[i]-1];
                ans1%=mod;
                dp[nums[i]]+=ans1;
                dp[nums[i]]%=mod;
                mp[nums[i]]+=temp;
            }
            if(nums[i]<maxi){
                ll temp=mp[nums[i]+1];
                temp%=mod;
                ll ans1=temp*nums[i];
                ans1%=mod;
                ans1+=dp[nums[i]+1];
                ans1%=mod;
                dp[nums[i]]+=ans1;
                dp[nums[i]]%=mod;
                mp[nums[i]]+=temp;
            }
            // cout<<dp[nums[i]]<<"" "";
        }
        // cout<<endl;
        ll ans=0;
        for(int i=0;i<=maxi;i++){
            // cout<<dp[i]<<"" "";
            ans+=dp[i];
            ans%=mod;
        }
        // cout<<endl;
        return (int)ans;
    }
};",1448223454
w0w0,w0w0,194,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        prv = -inf
        cnt = 0
        for i in range(n):
            if nums[i] > prv:
                cnt += 1
            else:
                cnt = 1
            prv = nums[i]
            if cnt >= k:
                if n - i - 1 < k:
                    break
                flag = True
                for j in range(i + 2, i + k + 1):
                    if nums[j] <= nums[j - 1]:
                        flag = False
                        break

                if flag:
                    return True

        return False",1448186859
w0w0,w0w0,194,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        prv = -inf
        cnt = 0
        res = []
        for i in range(n):
            if nums[i] > prv:
                cnt += 1
            else:
                cnt = 1
            prv = nums[i]
            res.append(cnt)

        ans = 0
        n = len(nums)
        prv = 0
        for i in range(n):
            if res[i] == 1:
                prv = res[i - 1] if i else 0
            ans = max(ans, res[i] // 2, min(prv, res[i]))
        return ans",1448199772
w0w0,w0w0,194,3631,python3,"MOD = 10 ** 9 + 7

class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        n = len(s)

        def valid(x, k):
            if x == 1:
                return True
            if k == 0:
                return False

            y = bin(x)[2:].count(""1"")
            return valid(y, k - 1)

        @cache
        def dfs(i, j, tight):
            if j == 0:
                return 1
            if n - i < j:
                return 0

            if tight:
                end = int(s[i])
            else:
                end = 1

            res = 0
            for b in range(end + 1):
                res += dfs(i + 1, j - b, tight and b == end)
                res %= MOD
            return res

        ans = 0
        for x in range(1, n + 1):
            if valid(x, k - 1):
                ans += dfs(0, x, True)
                ans %= MOD

        if valid(s.count(""1""), k - 1):
            ans -= 1
            ans %= MOD

        return ans",1448254485
w0w0,w0w0,194,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        MOD = 10 ** 9 + 7
        n = len(nums)
        cnt = defaultdict(int)
        val = defaultdict(int)
        ans = 0
        for i in range(n):
            cnt[nums[i]] += cnt[nums[i] - 1] + cnt[nums[i] + 1] + 1
            cnt[nums[i]] %= MOD
            val[nums[i]] += val[nums[i] - 1] + val[nums[i] + 1] + (cnt[nums[i] - 1] + cnt[nums[i] + 1] + 1) * nums[i]
            val[nums[i]] %= MOD
            ans += val[nums[i] - 1] + val[nums[i] + 1] + (cnt[nums[i] - 1] + cnt[nums[i] + 1] + 1) * nums[i]
            ans %= MOD

        return ans",1448220961
kasi nathan,kasinathansj,198,3612,java,"class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        for(int i = 0 ; i <= nums.size()-2*k ; i++){
            int s1 = -1001;
            int e1 = -1001;
            boolean is = true;
            for(int j = 0 ; j < k ; j++){
                if(nums.get(i+j)<=s1)is = false;
                if(nums.get(i+k+j)<=e1)is = false;
                s1 = nums.get(i+j);
                e1 = nums.get(i+k+j);
            }
            if(is)return is;
        }
        return false;
    }
}",1448184909
kasi nathan,kasinathansj,198,3619,java,"class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        int pree[] = new int[nums.size()];
        int m = Integer.MAX_VALUE;
        int pre = 0;
        int c = 0;
        int ans = 1;
        for(int i = nums.size()-1 ; i >= 0 ; i--){
            if(nums.get(i)<m){
                c++;
                ans = Math.max(ans , Math.min(c , pre));
                ans = Math.max(ans , c/2);
            }else{
                pre = c;
                c = 1;
            }
            m = nums.get(i);
            pree[i] = c;
        }
        // System.out.println(Arrays.toString(pree));
        return ans;
    }
}",1448197467
kasi nathan,kasinathansj,198,3631,java,"class Solution {
    int k;
    int dp[][][];
    int mod = (int)1e9+7;
    public int countKReducibleNumbers(String s, int k) {
        this.k = k;
        dp = new int[s.length()+1][s.length()+1][2];
        for(int a[][] : dp)
            for(int b[] : a)
                Arrays.fill(b,-1);
        return count(0,0,0,s);
    }
    private int count(int c , int i , int ok ,String s){
        if(i==s.length()){
            if(ok==1)return isK(c);
            return 0;
        }
        if(dp[c][i][ok]!=-1)return dp[c][i][ok];
        int ans = 0;
        if(ok == 1){
            ans += count(c+1 , i+1,ok,s);
            ans %= mod;
            ans += count(c , i+1,ok,s);
            ans %= mod;
        }else{
            if(s.charAt(i)=='0'){
                ans += count(c,i+1,ok,s);
                ans %= mod;
            }else{
                ans += count(c,i+1,1,s);
                ans %= mod;
                ans += count(c+1,i+1,ok,s);
                ans %= mod;
            }
        }
        return dp[c][i][ok] = ans;
    }
    private int isK(int c){
        // System.out.println(c);
        for(int i = 1 ; i < k ; i++){
            int cnt = 0;
            while(c>0){
                c = c&(c-1);
                cnt++;
            }
            c = cnt;
            if(c==1)return 1;
        }
        
        if(c==1)return 1;
        return 0;
    }
}",1448255617
kasi nathan,kasinathansj,198,3646,java,"class Solution {
    int mod = (int)1e9+7;
    public int sumOfGoodSubsequences(int[] nums) {
        HashMap<Integer,Integer> hm = new HashMap<Integer,Integer>();
        HashMap<Integer,Integer> cnt = new HashMap<Integer,Integer>();
        for(int i : nums){
            int sum1 = hm.getOrDefault(i-1,-1);
            int sum2 = hm.getOrDefault(i+1,-1);
            int c1 = cnt.getOrDefault(i-1,-1);            
            int c2 = cnt.getOrDefault(i+1,-1);
            if(sum1!=-1){
                hm.merge(i,(int)((sum1+i*1l*c1)%mod),Integer::sum);
                hm.put(i,hm.get(i)%mod);
                cnt.merge(i,c1,Integer::sum);
                cnt.put(i,cnt.get(i)%mod);
            }
            if(sum2!=-1){
                hm.merge(i,(int)((sum2+i*1l*c2)%mod),Integer::sum);
                hm.put(i,hm.get(i)%mod);
                cnt.merge(i,c2,Integer::sum);
                cnt.put(i,cnt.get(i)%mod);
            }
            hm.merge(i,i,Integer::sum);
            hm.put(i,hm.get(i)%mod);
            cnt.merge(i,1,Integer::sum);
            cnt.put(i,cnt.get(i)%mod);
        }
        int sum = 0;
        for(int i : hm.values()){
            sum += i;
            sum %= mod;
        }
        return sum;
    }
}",1448232055
TulasiRaj,TulasiRaj,200,3612,java,"class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        int n = nums.size();
        int dp[] = new int[nums.size()];
        dp[n-1]=1; int max = 0;
        for(int i=n-2;i>=0;i--)
        {
            if(nums.get(i+1)>nums.get(i)) {
                dp[i] = dp[i+1]+1;
            }
            else dp[i] = 1;
            max = Math.max(max,dp[i]/2);
        }
        if(max>=k) return true;
        for(int i=0;i<n;i++)
        {
            if(dp[i]==k&&i+dp[i]<n) {
               if(dp[i+dp[i]]>=dp[i])
               {
                   return true;
               }
            }
        }
        return false;
    }
}",1448194767
TulasiRaj,TulasiRaj,200,3619,java,"class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        int n = nums.size();
        int dp[] = new int[nums.size()];
        dp[n-1]=1; int max = 0;
        for(int i=n-2;i>=0;i--)
        {
            if(nums.get(i+1)>nums.get(i)) {
                dp[i] = dp[i+1]+1;
            }
            else dp[i] = 1;
            max = Math.max(max,dp[i]/2);
        }
        for(int i=0;i<n;i++)
        {
            if(i+dp[i]<n) {
               if(dp[i+dp[i]]>=dp[i])
               {
                   max = Math.max(max,dp[i]);
               }
            }
        }
        return max;
    }
}",1448186737
TulasiRaj,TulasiRaj,200,3631,java,"class Solution {
    static int mod = 1000000007;
    static int dp[][][];
    public int countKReducibleNumbers(String s, int k) {
        int n = s.length();
        dp = new int[n][n+1][2];
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<=n;j++)
            {
                Arrays.fill(dp[i][j],-1);
            }
        }
        return f(s,n,0,1,0,k);
    }
    public int f(String s,int n, int i,int d,int set,int k)
    {
        if(i==n)
        {
            if(set>0&&d==0) {
                if(helper(set,k-1)) return 1;
            }
            return 0;
        }
        if(dp[i][set][d]!=-1) return dp[i][set][d];
        int val = s.charAt(i)-'0';
        int cnt1 = f(s,n,i+1,(d==1&&val==0)?1:0,set,k);
        int cnt2 = 0;
        if(d==0||val==1)
        {
           cnt2 = f(s,n,i+1,(d==1&&val==1)?1:0,set+1,k);
        }
        return dp[i][set][d] = (cnt1+cnt2)%mod;
    }
    public boolean helper(int n,int k)
    {
        int cnt = 0;
        while(n>1)
        {
           n =Integer.bitCount(n);
           cnt++;
           if(cnt>k) return false; 
        }
        return true;
    }
}",1448263013
TulasiRaj,TulasiRaj,200,3646,java,"class Solution {
    static long mod = 1000000007;
    public int sumOfGoodSubsequences(int[] nums) {
        int n = nums.length;
        long dp[] = new long[100006];
        long cnt[] = new long[100006];
        long sum = 0l;
        for(int i=0;i<n;i++)
        {
            int k = nums[i];
            if(k-1>=0)
            {
                dp[k] = dp[k]+ (dp[k-1]+ (cnt[k-1]*nums[i])%mod)%mod;
                dp[k]%=mod;
                cnt[k]+=cnt[k-1];
                cnt[k]%=mod;
            }
            if(k+1<=100005)
            {
                dp[k] = dp[k]+ (dp[k+1]+ (cnt[k+1]*nums[i])%mod)%mod;
                dp[k]%=mod;
                cnt[k]+=cnt[k+1];
                cnt[k]%=mod;
            }
            dp[k] = dp[k]+k;
            dp[k]%=mod;
            cnt[k] = cnt[k]+1;
            cnt[k]%=mod;
        }
        for(int i=0;i<=100005;i++) {
            sum = sum+dp[i];
            sum%=mod;
        }
        return (int)sum;
    }
}",1448234563
uday0506,udayk2977,202,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
    
    if (2 * k > n) {
        return false;
    }

    vector<int> inc_len(n, 1); 
    for (int i = n - 2; i >= 0; --i) {
        if (nums[i] < nums[i + 1]) {
            inc_len[i] = inc_len[i + 1] + 1;
        } else {
            inc_len[i] = 1;
        }
    }
    
    for (int a = 0; a + 2 * k <= n; ++a) {

        if (inc_len[a] >= k && inc_len[a + k] >= k) {
            return true;
        }
    }
    
    return false;
    }
};",1448191785
uday0506,udayk2977,202,3619,cpp,"class Solution {
public:
    vector<int> get_inc(const vector<int>& nums){
        int n = nums.size();
        vector<int> inc(n,1);
        for(int i=n-2;i>=0;i--){
            if(nums[i]<nums[i+1]) inc[i]=inc[i+1]+1;
        }
        return inc;
    }

    bool check_k(const vector<int>& inc, int k){
        int n = inc.size();
        for(int i=0;i + 2*k <=n;i++) if(inc[i]>=k && inc[i+k]>=k) return true;
        return false;
    }
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n=nums.size();
        vector<int> inc = get_inc(nums);
        int l=1, r=n/2, res=0;
        while(l<=r){
            int m = l + (r-l)/2;
            if(check_k(inc, m)){ res=m; l=m+1;}
            else r=m-1;
        }
        return res;
    }
};",1448201599
uday0506,udayk2977,202,3631,cpp,"#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int M = 1e9+7;

class Solution {
public:
    ll memo[801][801][2][2];
    int f[801];
    bool C[801];
    string s;
    int k;
    
    string sub_one(string s){
        int n = s.size()-1;
        while(n >=0 && s[n]=='0'){
            s[n]='1';
            n--;
        }
        if(n >=0){
            s[n]='0';
        }
        else{
            s=""0"";
        }
        return s;
    }
    
    ll dp(int p, int c, int t, int st){
        if(p == s.size()){
            if(!st) return 0;
            return C[c] ? 1 : 0;
        }
        if(memo[p][c][t][st] != -1) return memo[p][c][t][st];
        int lim = t ? (s[p]-'0') : 1;
        ll res = 0;
        for(int b = 0; b <= lim; b++){
            int nt = t && (b == lim);
            int ns = st || (b != 0);
            int nc = ns ? c + b : 0;
            res = (res + dp(p + 1, nc, nt, ns)) % M;
        }
        return memo[p][c][t][st] = res;
    }
    
    int countKReducibleNumbers(string S, int K){
        s = sub_one(S);
        k = K;
        f[1] = 0;
        for(int c = 2; c <= 800; c++) f[c] = 1 + f[__builtin_popcount(c)];
        for(int c = 1; c <= 800; c++) C[c] = (f[c] <= k - 1);
        memset(memo, -1, sizeof(memo));
        return dp(0, 0, 1, 0);
    }
};",1448233819
uday0506,udayk2977,202,3646,cpp,"#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int M = 1e9+7;

class Solution {
public:
    ll calc(int x, const vector<ll>& c, const vector<ll>& s, int shift) {
        ll tmp = x;
        if(x > 0) tmp = (tmp + (x * c[x - 1 + shift]) % M + s[x - 1 + shift]) % M;
        if(x + 1 + shift < c.size()) tmp = (tmp + (x * c[x + 1 + shift]) % M + s[x + 1 + shift]) % M;
        return tmp;
    }

    void update(int x, ll tmp, vector<ll>& c, vector<ll>& s, int shift) {
        s[x + shift] = (s[x + shift] + tmp) % M;
        c[x + shift] = (c[x + shift] + ((x > 0) ? c[x - 1 + shift] : 0) + ((x + 1 + shift < c.size()) ? c[x + 1 + shift] : 0) + 1) % M;
    }

    int sumOfGoodSubsequences(vector<int>& nums) {
        if(nums.empty()) return 0;
        
        int min_x = *min_element(nums.begin(), nums.end());
        int max_x = *max_element(nums.begin(), nums.end());
        int shift = (min_x <= 0) ? 1 - min_x : 0;
        
        vector<ll> c(max_x + shift + 2, 0), s(max_x + shift + 2, 0);
        ll total = 0;
        
        for(auto x : nums){
            ll tmp = calc(x, c, s, shift);
            update(x, tmp, c, s, shift);
            total = (total + tmp) % M;
        }
        
        return static_cast<int>(total);
    }
};
",1448211671
jason7708,jason7708,203,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size(), i = 0, pre = 0;
        while(i < n) {
            int st = i++;
            while(i < n && nums[i] > nums[i-1]) {
                i++;
            }
            int len = i - st;
            if(pre >= k && len >= k || len >= 2 * k) {
                return true;
            }
            pre = len;
        }
        return false;
    }
};",1448182492
jason7708,jason7708,203,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size(), i = 0, pre = 0;
        int ans = 0;
        while(i < n) {
            int st = i++;
            while(i < n && nums[i] > nums[i-1]) {
                i++;
            }
            int len = i - st;
            ans = max(ans, min(pre, len));
            ans = max(ans, len / 2);
            pre = len;
        }
        return ans;
    }
};",1448185402
jason7708,jason7708,203,3631,cpp,"class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        constexpr int mod = 1e9 + 7;
        int m = s.size();
        // int m = 800;

        vector<int> t(m+1, 0);
        t[0] = INT_MAX / 2;
        for(int i=2; i<=m; i++) {
            int pop_c = std::popcount(static_cast<unsigned int>(i));
            t[i] = t[pop_c] + 1;
        }
        vector<vector<int>> dp(m, vector<int>(m+1, -1));
        auto dfs = [&] (auto&& dfs, int i, int j, bool is_limit) ->int {
            if(i == m) {
                return !is_limit && (t[j] + 1) <= k;
            }
            if(dp[i][j] != -1 && !is_limit) {
                return dp[i][j];
            }
            char up = is_limit ? s[i] : '1';
            int res = 0;
            for(char c='0'; c<=up; c++) {
                auto r = dfs(dfs, i+1, j + (c - '0'), is_limit && c == up);
                // cout << i << ' ' << j + (c - '0') << ' ' << r << '\n';
                // res = (res + dfs(dfs, i+1, j + (c - '0'), is_limit && c == up)) % mod;
                res = (res + r) % mod;
            }
            if(!is_limit)
                dp[i][j] = res;
            return res;
        };
        
        return dfs(dfs, 0, 0, true);
    }
};",1448264019
jason7708,jason7708,203,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        constexpr int mod = 1e9 + 7;
        int n = nums.size();

        unordered_map<int, long long> dp, sum;
        for(int i=0; i<n; i++) {
            // (dp[nums[i]-1] * nums[i] % mod + sum[nums[i]-1]) % mod
            // (dp[nums[i]+1] * nums[i] % mod + sum[nums[i]+1]) % mod
            // nums[i]
            sum[nums[i]] = ((((dp[nums[i]-1] * nums[i] % mod + sum[nums[i]-1]) % mod + 
                            (dp[nums[i]+1] * nums[i] % mod + sum[nums[i]+1]) % mod) % mod + 
                            nums[i]) % mod + sum[nums[i]]) % mod;
            dp[nums[i]] = (dp[nums[i]] + (1 + (dp[nums[i] - 1] + dp[nums[i] + 1]) % mod) % mod) % mod;
            // cout << sum[nums[i]] << ' ' << dp[nums[i]] << '\n';
        }
        int ans = 0;
        for(const auto& [num, s] : sum) {
            ans = (ans + s) % mod;
        }
        return ans;
    }
};",1448214730
Brian Ahaneku,Ruvxei,207,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        for i in range(n - 2 * k + 3):
            if i + 2 * k - 1 >= n:
                return False
            fail = False
            for j in range(i + 1, i + k):
                if nums[j] <= nums[j - 1]:
                    fail = True
                    break
            if fail:
                continue
            for j in range(i + k + 1, i + 2 * k):
                if nums[j] <= nums[j - 1]:
                    fail = True
                    break
            if not fail:
                return True
        return False",1448183931
Brian Ahaneku,Ruvxei,207,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        dp = [1 for _ in range(n)]
        for i in range(n - 2, -1, -1):
            if nums[i] < nums[i + 1]:
                dp[i] = 1 + dp[i + 1]
        l = 1
        r = n // 2
        ans = 1
        while l <= r:
            m = (l + r) // 2
            success = False
            for i in range(n):
                if i + m >= n:
                    break
                if dp[i] >= m and dp[i + m] >= m:
                    success = True
                    break
            if success:
                l = m + 1
                ans = max(ans, m)
            else:
                r = m - 1
        return ans
                    
                ",1448195090
Brian Ahaneku,Ruvxei,207,3631,python3,"MOD = 10**9 + 7
class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        m = len(s)
        reduce = [False for _ in range(m + 1)]
        for i in range(1, m + 1):
            num = i
            tries = 0
            while num >= 1 and tries < k - 1:
                x = num
                cnt = 0
                while x > 0:
                    cnt += x & 1
                    x //= 2
                num = cnt
                tries += 1
            
            if num == 1:
                reduce[i] = True
        ans = 0
        for length in range(1, m):
            for numBits in range(1, length + 1):
                if reduce[numBits]:
                    ans = (ans + math.comb(length - 1, numBits - 1)) % MOD
        ones = 1
        for i in range(1, m):
            if s[i] == '1':
                for numBits in range((m - 1) - (i + 1) + 1 + 1):
                    if reduce[numBits + ones]:
                        ans = (ans + math.comb((m - 1) - (i + 1) + 1, numBits)) % MOD
                    
                ones += 1
                
        return ans
                    
                ",1448257954
Brian Ahaneku,Ruvxei,207,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        MOD = 10**9 + 7
        n = len(nums)
        total = defaultdict(int)
        sub = defaultdict(int)
        dp = [0 for _ in range(n + 1)]
        for i in range(n - 1, -1, -1):
            dp[i] = (nums[i] * ((sub[nums[i] + 1]) + (sub[nums[i] - 1]) + 1) + total[nums[i] + 1] + total[nums[i] - 1]) % MOD
            total[nums[i]] = (total[nums[i]] + dp[i]) % MOD
            sub[nums[i]] = sub[nums[i]] + sub[nums[i] + 1] + sub[nums[i] - 1] + 1
        return sum(dp) % MOD
        ",1448219377
hellotestabc,hellotestabc,208,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        for (int i = 0; i < nums.size() - 2 * k + 1; i++) {
            bool ok = true;
            
            for (int j = i; j < i + k - 1; j++) {
                // cout << ""first "" << j << endl;
                if (nums[j] < nums[j + 1]) {
                    
                } else {
                    ok = false;
                    break;
                }
            }

            for (int j = i + k; j < i + k + k - 1; j++) {
                // cout << ""second "" << j << endl;
                if (nums[j] < nums[j + 1]) {
                    
                } else {
                    ok = false;
                }
            }

            if (ok) {
                return ok;
            }
        }

        return false;
    }
};",1448182746
hellotestabc,hellotestabc,208,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        vector<int> arr(nums.size());
        arr[0] = 1;

        for (int i = 1; i < nums.size(); i++) {
            if (nums[i] > nums[i - 1]) {
                arr[i] = arr[i - 1] + 1;
            } else {
                arr[i] = 1;
            }
        }

        int low = 1;
        int high = nums.size();
        int best = 0;
        
        while (low <= high) {
            int mid = (low + high) / 2;

            bool ok = false;

            for (int i = 0; i < arr.size() - mid; i++) {
                if (arr[i] >= mid && arr[i + mid] >= mid) {
                    ok = true;
                    break;
                }
            }

            if (ok) {
                best = max(best, mid);
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }

        return best;
    }
};",1448194570
hellotestabc,hellotestabc,208,3631,cpp,"class Solution {
public:
    static constexpr int mod = 1e9 + 7;

    int traverse(int index, const string& s, bool leading, const int k, int setbits, vector<vector<vector<int>>>& dp) {
        if (index >= s.size()) {
            int val = setbits;
            
            for (int i = 0; i < k - 1; i++) {
                val = __builtin_popcount(val); 
            }

            return val == 1;
        }

        if (dp[index][leading][setbits] != -1) {
            return dp[index][leading][setbits];
        }

        // lets say we add a zero
        int total = 0;

        if (leading) {
            if (s[index] == '1') {
                total = (total + traverse(index + 1, s, leading, k, setbits + 1, dp)) % mod;
                total = (total + traverse(index + 1, s, false, k, setbits, dp)) % mod;
            } else {
                total = (total + traverse(index + 1, s, true, k, setbits, dp)) % mod;
            }   
        } else {
            total = (total + traverse(index + 1, s, false, k, setbits + 1, dp)) % mod;
            total = (total + traverse(index + 1, s, false, k, setbits, dp)) % mod;
        }

        return dp[index][leading][setbits] = total % mod;
    }

    int countKReducibleNumbers(string s, int k) {
        string lower = s;

        for (int i = lower.size() - 1; i >= 0; i--) {
            if (lower[i] == '1') {
                lower[i] = '0';
                break;
            } else {
                lower[i] = '1';
            }
        }

        while (lower[0] == '0') {
            lower = lower.substr(1, lower.size() - 1);
        }

        vector<vector<vector<int>>> dp(s.size(), vector<vector<int>>(2, vector<int>(s.size() + 1, -1)));

        return traverse(0, lower, true, k, 0, dp);
    }
};",1448258228
hellotestabc,hellotestabc,208,3646,cpp,"class Solution {
public:
    static constexpr int mod = 1e9 + 7;

    int sumOfGoodSubsequences(vector<int>& nums) {
        unordered_map<int, int> counts;
        unordered_map<int, int> totals;

        long long total = 0;

        for (long long i : nums) {
            int count = 1;
            long long sum = i;

            if (counts.contains(i - 1)) {
                count = (count + counts[i - 1]) % mod;
                sum = (sum % mod + totals[i - 1] % mod + (counts[i - 1] * i) % mod) % mod;
            }
            if (counts.contains(i + 1)) {
                count = (count + counts[i + 1]) % mod;
                sum = (sum % mod + totals[i + 1] % mod + (counts[i + 1] * i) % mod) % mod;
            }

            counts[i] = (counts[i] + count) % mod;
            totals[i] = (totals[i] + sum) % mod;

            total = (total + sum) % mod;
        }

        return total;
    }
};",1448223445
garyjhu,garyjhu,217,3612,java,"import java.util.List;

class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        int n = nums.size();
        for (int i = 0; i + k + k <= n; i++) {
            boolean flag = true;
            for (int j = i + 1; j < i + k; j++) {
                if (nums.get(j) <= nums.get(j - 1)) {
                    flag = false;
                    break;
                }
            }
            for (int j = i + k + 1; j < i + k + k; j++) {
                if (nums.get(j) <= nums.get(j - 1)) {
                    flag = false;
                    break;
                }
            }
            if (flag) return true;
        }
        return false;
    }
}
",1448183079
garyjhu,garyjhu,217,3619,java,"import java.util.List;

class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        int n = nums.size();
        int start = 0;
        int[] max = new int[n];
        for (int i = 1; i <= n; i++) {
            if (i < n && nums.get(i) > nums.get(i - 1)) continue;
            while (start < i) {
                max[start] = i;
                start++;
            }
        }
        int lo = 1, hi = n / 2;
        while (lo <= hi) {
            int mid = (lo + hi) / 2;
            boolean flag = false;
            for (int i = 0; i + mid + mid <= n; i++) {
                if (max[i] >= i + mid && max[i + mid] >= i + mid + mid) {
                    flag = true;
                    break;
                }
            }
            if (flag) lo = mid + 1;
            else hi = mid - 1;
        }
        return hi;
    }
}
",1448192567
garyjhu,garyjhu,217,3631,java,"import java.util.ArrayList;

class Solution {
    static ModIntFactory factory = new ModIntFactory(1_000_000_007);
    static int[] aux;
    String s;
    int k, n;
    public int countKReducibleNumbers(String s, int k) {
        if (aux == null) init();
        this.s = s;
        this.k = k;
        n = s.length();
        ModIntFactory.ModInt res = factory.create(0);
        int count = 0;
        for (int i = 0; i < n; i++) {
            if (s.charAt(i) == '0') continue;
            for (int j = 0; j <= n - 1 - i; j++) {
                if (aux[count + j] < k) {
                    res.addAsg(factory.combination(n - 1 - i, j));
//                    System.out.println(i + "" "" + j + "" "" + res);
                }
            }
            if (count == 0) {
                res.subAsg(1);
            }
//            System.out.println(i + "" "" + res);
            count++;
        }
        return res.value;
    }

    private static void init() {
        aux = new int[801];
        for (int i = 2; i <= 800; i++) aux[i] = aux[Integer.bitCount(i)] + 1;
    }

    static class ModIntFactory {
        private final ModArithmetic ma;
        private final int mod;

        private final boolean usesMontgomery;
        private final ModArithmetic.ModArithmeticMontgomery maMontgomery;

        private ArrayList<Integer> factorial;

        public ModIntFactory(int mod) {
            this.ma = ModArithmetic.of(mod);
            this.usesMontgomery = ma instanceof ModArithmetic.ModArithmeticMontgomery;
            this.maMontgomery = usesMontgomery ? (ModArithmetic.ModArithmeticMontgomery) ma : null;
            this.mod = mod;

            this.factorial = new ArrayList<>();
        }

        public ModInt create(long value) {
            if ((value %= mod) < 0) value += mod;
            if (usesMontgomery) {
                return new ModInt(maMontgomery.generate(value));
            } else {
                return new ModInt((int) value);
            }
        }

        private void prepareFactorial(int max){
            factorial.ensureCapacity(max+1);
            if(factorial.size()==0) factorial.add(1);
            if (usesMontgomery) {
                for(int i=factorial.size(); i<=max; i++){
                    factorial.add(ma.mul(factorial.get(i-1), maMontgomery.generate(i)));
                }
            } else {
                for(int i=factorial.size(); i<=max; i++){
                    factorial.add(ma.mul(factorial.get(i-1), i));
                }
            }
        }

        public ModInt factorial(int i){
            prepareFactorial(i);
            return create(factorial.get(i));
        }

        public ModInt permutation(int n, int r){
            if(n < 0 || r < 0 || n < r) return create(0);
            prepareFactorial(n);
            return create(ma.div(factorial.get(n), factorial.get(r)));
        }
        public ModInt combination(int n, int r){
            if(n < 0 || r < 0 || n < r) return create(0);
            prepareFactorial(n);
            return create(ma.div(factorial.get(n), ma.mul(factorial.get(r),factorial.get(n-r))));
        }

        public int getMod() {
            return mod;
        }

        public class ModInt {
            private int value;
            private ModInt(int value) {
                this.value = value;
            }
            public int mod() {
                return mod;
            }
            public int value() {
                if (usesMontgomery) {
                    return maMontgomery.reduce(value);
                }
                return value;
            }
            public ModInt add(ModInt mi) {
                return new ModInt(ma.add(value, mi.value));
            }
            public ModInt add(ModInt mi1, ModInt mi2) {
                return new ModInt(ma.add(value, mi1.value)).addAsg(mi2);
            }
            public ModInt add(ModInt mi1, ModInt mi2, ModInt mi3) {
                return new ModInt(ma.add(value, mi1.value)).addAsg(mi2).addAsg(mi3);
            }
            public ModInt add(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {
                return new ModInt(ma.add(value, mi1.value)).addAsg(mi2).addAsg(mi3).addAsg(mi4);
            }
            public ModInt add(ModInt mi1, ModInt... mis) {
                ModInt mi = add(mi1);
                for (ModInt m : mis) mi.addAsg(m);
                return mi;
            }
            public ModInt add(long mi) {
                return new ModInt(ma.add(value, ma.remainder(mi)));
            }
            public ModInt sub(ModInt mi) {
                return new ModInt(ma.sub(value, mi.value));
            }
            public ModInt sub(long mi) {
                return new ModInt(ma.sub(value, ma.remainder(mi)));
            }
            public ModInt mul(ModInt mi) {
                return new ModInt(ma.mul(value, mi.value));
            }
            public ModInt mul(ModInt mi1, ModInt mi2) {
                return new ModInt(ma.mul(value, mi1.value)).mulAsg(mi2);
            }
            public ModInt mul(ModInt mi1, ModInt mi2, ModInt mi3) {
                return new ModInt(ma.mul(value, mi1.value)).mulAsg(mi2).mulAsg(mi3);
            }
            public ModInt mul(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {
                return new ModInt(ma.mul(value, mi1.value)).mulAsg(mi2).mulAsg(mi3).mulAsg(mi4);
            }
            public ModInt mul(ModInt mi1, ModInt... mis) {
                ModInt mi = mul(mi1);
                for (ModInt m : mis) mi.mulAsg(m);
                return mi;
            }
            public ModInt mul(long mi) {
                return new ModInt(ma.mul(value, ma.remainder(mi)));
            }
            public ModInt div(ModInt mi) {
                return new ModInt(ma.div(value, mi.value));
            }
            public ModInt div(long mi) {
                return new ModInt(ma.div(value, ma.remainder(mi)));
            }
            public ModInt inv() {
                return new ModInt(ma.inv(value));
            }
            public ModInt pow(long b) {
                return new ModInt(ma.pow(value, b));
            }
            public ModInt addAsg(ModInt mi) {
                this.value = ma.add(value, mi.value);
                return this;
            }
            public ModInt addAsg(ModInt mi1, ModInt mi2) {
                return addAsg(mi1).addAsg(mi2);
            }
            public ModInt addAsg(ModInt mi1, ModInt mi2, ModInt mi3) {
                return addAsg(mi1).addAsg(mi2).addAsg(mi3);
            }
            public ModInt addAsg(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {
                return addAsg(mi1).addAsg(mi2).addAsg(mi3).addAsg(mi4);
            }
            public ModInt addAsg(ModInt... mis) {
                for (ModInt m : mis) addAsg(m);
                return this;
            }
            public ModInt addAsg(long mi) {
                this.value = ma.add(value, ma.remainder(mi));
                return this;
            }
            public ModInt subAsg(ModInt mi) {
                this.value = ma.sub(value, mi.value);
                return this;
            }
            public ModInt subAsg(long mi) {
                this.value = ma.sub(value, ma.remainder(mi));
                return this;
            }
            public ModInt mulAsg(ModInt mi) {
                this.value = ma.mul(value, mi.value);
                return this;
            }
            public ModInt mulAsg(ModInt mi1, ModInt mi2) {
                return mulAsg(mi1).mulAsg(mi2);
            }
            public ModInt mulAsg(ModInt mi1, ModInt mi2, ModInt mi3) {
                return mulAsg(mi1).mulAsg(mi2).mulAsg(mi3);
            }
            public ModInt mulAsg(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {
                return mulAsg(mi1).mulAsg(mi2).mulAsg(mi3).mulAsg(mi4);
            }
            public ModInt mulAsg(ModInt... mis) {
                for (ModInt m : mis) mulAsg(m);
                return this;
            }
            public ModInt mulAsg(long mi) {
                this.value = ma.mul(value, ma.remainder(mi));
                return this;
            }
            public ModInt divAsg(ModInt mi) {
                this.value = ma.div(value, mi.value);
                return this;
            }
            public ModInt divAsg(long mi) {
                this.value = ma.div(value, ma.remainder(mi));
                return this;
            }
            @Override
            public String toString() {
                return String.valueOf(value());
            }
            @Override
            public boolean equals(Object o) {
                if (o instanceof ModInt) {
                    ModInt mi = (ModInt) o;
                    return mod() == mi.mod() && value() == mi.value();
                }
                return false;
            }
            @Override
            public int hashCode() {
                return (1 * 37 + mod()) * 37 + value();
            }
        }

        private static abstract class ModArithmetic {
            abstract int mod();
            abstract int remainder(long value);
            abstract int add(int a, int b);
            abstract int sub(int a, int b);
            abstract int mul(int a, int b);
            int div(int a, int b) {
                return mul(a, inv(b));
            }
            int inv(int a) {
                int b = mod();
                if (b == 1) return 0;
                long u = 1, v = 0;
                while (b >= 1) {
                    int t = a / b;
                    a -= t * b;
                    int tmp1 = a; a = b; b = tmp1;
                    u -= t * v;
                    long tmp2 = u; u = v; v = tmp2;
                }
                if (a != 1) {
                    throw new ArithmeticException(""divide by zero"");
                }
                return remainder(u);
            }
            int pow(int a, long b) {
                if (b < 0) throw new ArithmeticException(""negative power"");
                int r = 1;
                int x = a;
                while (b > 0) {
                    if ((b & 1) == 1) r = mul(r, x);
                    x = mul(x, x);
                    b >>= 1;
                }
                return r;
            }

            static ModArithmetic of(int mod) {
                if (mod <= 0) {
                    throw new IllegalArgumentException();
                } else if (mod == 1) {
                    return new ModArithmetic1();
                } else if (mod == 2) {
                    return new ModArithmetic2();
                } else if (mod == 998244353) {
                    return new ModArithmetic998244353();
                } else if (mod == 1000000007) {
                    return new ModArithmetic1000000007();
                } else if ((mod & 1) == 1) {
                    return new ModArithmeticMontgomery(mod);
                } else {
                    return new ModArithmeticBarrett(mod);
                }
            }

            private static final class ModArithmetic1 extends ModArithmetic {
                int mod() {return 1;}
                int remainder(long value) {return 0;}
                int add(int a, int b) {return 0;}
                int sub(int a, int b) {return 0;}
                int mul(int a, int b) {return 0;}
                int pow(int a, long b) {return 0;}
            }
            private static final class ModArithmetic2 extends ModArithmetic {
                int mod() {return 2;}
                int remainder(long value) {return (int) (value & 1);}
                int add(int a, int b) {return a ^ b;}
                int sub(int a, int b) {return a ^ b;}
                int mul(int a, int b) {return a & b;}
            }
            private static final class ModArithmetic998244353 extends ModArithmetic {
                private final int mod = 998244353;
                int mod() {
                    return mod;
                }
                int remainder(long value) {
                    return (int) ((value %= mod) < 0 ? value + mod : value);
                }
                int add(int a, int b) {
                    int res = a + b;
                    return res >= mod ? res - mod : res;
                }
                int sub(int a, int b) {
                    int res = a - b;
                    return res < 0 ? res + mod : res;
                }
                int mul(int a, int b) {
                    return (int) (((long) a * b) % mod);
                }
            }
            private static final class ModArithmetic1000000007 extends ModArithmetic {
                private final int mod = 1000000007;
                int mod() {
                    return mod;
                }
                int remainder(long value) {
                    return (int) ((value %= mod) < 0 ? value + mod : value);
                }
                int add(int a, int b) {
                    int res = a + b;
                    return res >= mod ? res - mod : res;
                }
                int sub(int a, int b) {
                    int res = a - b;
                    return res < 0 ? res + mod : res;
                }
                int mul(int a, int b) {
                    return (int) (((long) a * b) % mod);
                }
            }
            private static final class ModArithmeticMontgomery extends ModArithmeticDynamic {
                private final long negInv;
                private final long r2;

                private ModArithmeticMontgomery(int mod) {
                    super(mod);
                    long inv = 0;
                    long s = 1, t = 0;
                    for (int i = 0; i < 32; i++) {
                        if ((t & 1) == 0) {
                            t += mod;
                            inv += s;
                        }
                        t >>= 1;
                        s <<= 1;
                    }
                    long r = (1l << 32) % mod;
                    this.negInv = inv;
                    this.r2 = (r * r) % mod;
                }
                private int generate(long x) {
                    return reduce(x * r2);
                }
                private int reduce(long x) {
                    x = (x + ((x * negInv) & 0xffff_ffffl) * mod) >>> 32;
                    return (int) (x < mod ? x : x - mod);
                }
                @Override
                int remainder(long value) {
                    return generate((value %= mod) < 0 ? value + mod : value);
                }
                @Override
                int mul(int a, int b) {
                    return reduce((long) a * b);
                }
                @Override
                int inv(int a) {
                    return super.inv(reduce(a));
                }
                @Override
                int pow(int a, long b) {
                    return generate(super.pow(a, b));
                }
            }
            private static final class ModArithmeticBarrett extends ModArithmeticDynamic {
                private static final long mask = 0xffff_ffffl;
                private final long mh;
                private final long ml;
                private ModArithmeticBarrett(int mod) {
                    super(mod);
                    /**
                     * m = floor(2^64/mod)
                     * 2^64 = p*mod + q, 2^32 = a*mod + b
                     * => (a*mod + b)^2 = p*mod + q
                     * => p = mod*a^2 + 2ab + floor(b^2/mod)
                     */
                    long a = (1l << 32) / mod;
                    long b = (1l << 32) % mod;
                    long m = a * a * mod + 2 * a * b + (b * b) / mod;
                    mh = m >>> 32;
                    ml = m & mask;
                }
                private int reduce(long x) {
                    long z = (x & mask) * ml;
                    z = (x & mask) * mh + (x >>> 32) * ml + (z >>> 32);
                    z = (x >>> 32) * mh + (z >>> 32);
                    x -= z * mod;
                    return (int) (x < mod ? x : x - mod);
                }
                @Override
                int remainder(long value) {
                    return (int) ((value %= mod) < 0 ? value + mod : value);
                }
                @Override
                int mul(int a, int b) {
                    return reduce((long) a * b);
                }
            }
            private static class ModArithmeticDynamic extends ModArithmetic {
                final int mod;
                ModArithmeticDynamic(int mod) {
                    this.mod = mod;
                }
                int mod() {
                    return mod;
                }
                int remainder(long value) {
                    return (int) ((value %= mod) < 0 ? value + mod : value);
                }
                int add(int a, int b) {
                    int sum = a + b;
                    return sum >= mod ? sum - mod : sum;
                }
                int sub(int a, int b) {
                    int sum = a - b;
                    return sum < 0 ? sum + mod : sum;
                }
                int mul(int a, int b) {
                    return (int) (((long) a * b) % mod);
                }
            }
        }
    }

}
",1448261100
garyjhu,garyjhu,217,3646,java,"import java.util.ArrayList;

class Solution {
    ModIntFactory factory = new ModIntFactory(1_000_000_007);
    public int sumOfGoodSubsequences(int[] nums) {
        int n = nums.length;
        int max = 0;
        for (int num : nums) max = Math.max(max, num);
        ModIntFactory.ModInt[] dp = new ModIntFactory.ModInt[max + 1];
        ModIntFactory.ModInt[] count = new ModIntFactory.ModInt[max + 1];
        for (int i = 0; i <= max; i++) {
            dp[i] = factory.create(0);
            count[i] = factory.create(0);
        }
        for (int i = 0; i < n; i++) {
            dp[nums[i]].addAsg(nums[i]);
            count[nums[i]].addAsg(1);
            if (nums[i] != 0) {
                dp[nums[i]].addAsg(dp[nums[i] - 1].add(count[nums[i] - 1].mul(nums[i])));
                count[nums[i]].addAsg(count[nums[i] - 1]);
            }
            if (nums[i] != max) {
                dp[nums[i]].addAsg(dp[nums[i] + 1].add(count[nums[i] + 1].mul(nums[i])));
                count[nums[i]].addAsg(count[nums[i] + 1]);
            }
//            for (int j = 0; j <= max; j++) System.out.print(dp[j] + "" "");
//            System.out.println();
//            for (int j = 0; j <= max; j++) System.out.print(count[j] + "" "");
//            System.out.println();
        }
//        System.out.println();
        ModIntFactory.ModInt res = factory.create(0);
        for (int i = 0; i <= max; i++) res.addAsg(dp[i]);
        return res.value;
    }

    static class ModIntFactory {
        private final ModArithmetic ma;
        private final int mod;

        private final boolean usesMontgomery;
        private final ModArithmetic.ModArithmeticMontgomery maMontgomery;

        private ArrayList<Integer> factorial;

        public ModIntFactory(int mod) {
            this.ma = ModArithmetic.of(mod);
            this.usesMontgomery = ma instanceof ModArithmetic.ModArithmeticMontgomery;
            this.maMontgomery = usesMontgomery ? (ModArithmetic.ModArithmeticMontgomery) ma : null;
            this.mod = mod;

            this.factorial = new ArrayList<>();
        }

        public ModInt create(long value) {
            if ((value %= mod) < 0) value += mod;
            if (usesMontgomery) {
                return new ModInt(maMontgomery.generate(value));
            } else {
                return new ModInt((int) value);
            }
        }

        private void prepareFactorial(int max){
            factorial.ensureCapacity(max+1);
            if(factorial.size()==0) factorial.add(1);
            if (usesMontgomery) {
                for(int i=factorial.size(); i<=max; i++){
                    factorial.add(ma.mul(factorial.get(i-1), maMontgomery.generate(i)));
                }
            } else {
                for(int i=factorial.size(); i<=max; i++){
                    factorial.add(ma.mul(factorial.get(i-1), i));
                }
            }
        }

        public ModInt factorial(int i){
            prepareFactorial(i);
            return create(factorial.get(i));
        }

        public ModInt permutation(int n, int r){
            if(n < 0 || r < 0 || n < r) return create(0);
            prepareFactorial(n);
            return create(ma.div(factorial.get(n), factorial.get(r)));
        }
        public ModInt combination(int n, int r){
            if(n < 0 || r < 0 || n < r) return create(0);
            prepareFactorial(n);
            return create(ma.div(factorial.get(n), ma.mul(factorial.get(r),factorial.get(n-r))));
        }

        public int getMod() {
            return mod;
        }

        public class ModInt {
            private int value;
            private ModInt(int value) {
                this.value = value;
            }
            public int mod() {
                return mod;
            }
            public int value() {
                if (usesMontgomery) {
                    return maMontgomery.reduce(value);
                }
                return value;
            }
            public ModInt add(ModInt mi) {
                return new ModInt(ma.add(value, mi.value));
            }
            public ModInt add(ModInt mi1, ModInt mi2) {
                return new ModInt(ma.add(value, mi1.value)).addAsg(mi2);
            }
            public ModInt add(ModInt mi1, ModInt mi2, ModInt mi3) {
                return new ModInt(ma.add(value, mi1.value)).addAsg(mi2).addAsg(mi3);
            }
            public ModInt add(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {
                return new ModInt(ma.add(value, mi1.value)).addAsg(mi2).addAsg(mi3).addAsg(mi4);
            }
            public ModInt add(ModInt mi1, ModInt... mis) {
                ModInt mi = add(mi1);
                for (ModInt m : mis) mi.addAsg(m);
                return mi;
            }
            public ModInt add(long mi) {
                return new ModInt(ma.add(value, ma.remainder(mi)));
            }
            public ModInt sub(ModInt mi) {
                return new ModInt(ma.sub(value, mi.value));
            }
            public ModInt sub(long mi) {
                return new ModInt(ma.sub(value, ma.remainder(mi)));
            }
            public ModInt mul(ModInt mi) {
                return new ModInt(ma.mul(value, mi.value));
            }
            public ModInt mul(ModInt mi1, ModInt mi2) {
                return new ModInt(ma.mul(value, mi1.value)).mulAsg(mi2);
            }
            public ModInt mul(ModInt mi1, ModInt mi2, ModInt mi3) {
                return new ModInt(ma.mul(value, mi1.value)).mulAsg(mi2).mulAsg(mi3);
            }
            public ModInt mul(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {
                return new ModInt(ma.mul(value, mi1.value)).mulAsg(mi2).mulAsg(mi3).mulAsg(mi4);
            }
            public ModInt mul(ModInt mi1, ModInt... mis) {
                ModInt mi = mul(mi1);
                for (ModInt m : mis) mi.mulAsg(m);
                return mi;
            }
            public ModInt mul(long mi) {
                return new ModInt(ma.mul(value, ma.remainder(mi)));
            }
            public ModInt div(ModInt mi) {
                return new ModInt(ma.div(value, mi.value));
            }
            public ModInt div(long mi) {
                return new ModInt(ma.div(value, ma.remainder(mi)));
            }
            public ModInt inv() {
                return new ModInt(ma.inv(value));
            }
            public ModInt pow(long b) {
                return new ModInt(ma.pow(value, b));
            }
            public ModInt addAsg(ModInt mi) {
                this.value = ma.add(value, mi.value);
                return this;
            }
            public ModInt addAsg(ModInt mi1, ModInt mi2) {
                return addAsg(mi1).addAsg(mi2);
            }
            public ModInt addAsg(ModInt mi1, ModInt mi2, ModInt mi3) {
                return addAsg(mi1).addAsg(mi2).addAsg(mi3);
            }
            public ModInt addAsg(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {
                return addAsg(mi1).addAsg(mi2).addAsg(mi3).addAsg(mi4);
            }
            public ModInt addAsg(ModInt... mis) {
                for (ModInt m : mis) addAsg(m);
                return this;
            }
            public ModInt addAsg(long mi) {
                this.value = ma.add(value, ma.remainder(mi));
                return this;
            }
            public ModInt subAsg(ModInt mi) {
                this.value = ma.sub(value, mi.value);
                return this;
            }
            public ModInt subAsg(long mi) {
                this.value = ma.sub(value, ma.remainder(mi));
                return this;
            }
            public ModInt mulAsg(ModInt mi) {
                this.value = ma.mul(value, mi.value);
                return this;
            }
            public ModInt mulAsg(ModInt mi1, ModInt mi2) {
                return mulAsg(mi1).mulAsg(mi2);
            }
            public ModInt mulAsg(ModInt mi1, ModInt mi2, ModInt mi3) {
                return mulAsg(mi1).mulAsg(mi2).mulAsg(mi3);
            }
            public ModInt mulAsg(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {
                return mulAsg(mi1).mulAsg(mi2).mulAsg(mi3).mulAsg(mi4);
            }
            public ModInt mulAsg(ModInt... mis) {
                for (ModInt m : mis) mulAsg(m);
                return this;
            }
            public ModInt mulAsg(long mi) {
                this.value = ma.mul(value, ma.remainder(mi));
                return this;
            }
            public ModInt divAsg(ModInt mi) {
                this.value = ma.div(value, mi.value);
                return this;
            }
            public ModInt divAsg(long mi) {
                this.value = ma.div(value, ma.remainder(mi));
                return this;
            }
            @Override
            public String toString() {
                return String.valueOf(value());
            }
            @Override
            public boolean equals(Object o) {
                if (o instanceof ModInt) {
                    ModInt mi = (ModInt) o;
                    return mod() == mi.mod() && value() == mi.value();
                }
                return false;
            }
            @Override
            public int hashCode() {
                return (1 * 37 + mod()) * 37 + value();
            }
        }

        private static abstract class ModArithmetic {
            abstract int mod();
            abstract int remainder(long value);
            abstract int add(int a, int b);
            abstract int sub(int a, int b);
            abstract int mul(int a, int b);
            int div(int a, int b) {
                return mul(a, inv(b));
            }
            int inv(int a) {
                int b = mod();
                if (b == 1) return 0;
                long u = 1, v = 0;
                while (b >= 1) {
                    int t = a / b;
                    a -= t * b;
                    int tmp1 = a; a = b; b = tmp1;
                    u -= t * v;
                    long tmp2 = u; u = v; v = tmp2;
                }
                if (a != 1) {
                    throw new ArithmeticException(""divide by zero"");
                }
                return remainder(u);
            }
            int pow(int a, long b) {
                if (b < 0) throw new ArithmeticException(""negative power"");
                int r = 1;
                int x = a;
                while (b > 0) {
                    if ((b & 1) == 1) r = mul(r, x);
                    x = mul(x, x);
                    b >>= 1;
                }
                return r;
            }

            static ModArithmetic of(int mod) {
                if (mod <= 0) {
                    throw new IllegalArgumentException();
                } else if (mod == 1) {
                    return new ModArithmetic1();
                } else if (mod == 2) {
                    return new ModArithmetic2();
                } else if (mod == 998244353) {
                    return new ModArithmetic998244353();
                } else if (mod == 1000000007) {
                    return new ModArithmetic1000000007();
                } else if ((mod & 1) == 1) {
                    return new ModArithmeticMontgomery(mod);
                } else {
                    return new ModArithmeticBarrett(mod);
                }
            }

            private static final class ModArithmetic1 extends ModArithmetic {
                int mod() {return 1;}
                int remainder(long value) {return 0;}
                int add(int a, int b) {return 0;}
                int sub(int a, int b) {return 0;}
                int mul(int a, int b) {return 0;}
                int pow(int a, long b) {return 0;}
            }
            private static final class ModArithmetic2 extends ModArithmetic {
                int mod() {return 2;}
                int remainder(long value) {return (int) (value & 1);}
                int add(int a, int b) {return a ^ b;}
                int sub(int a, int b) {return a ^ b;}
                int mul(int a, int b) {return a & b;}
            }
            private static final class ModArithmetic998244353 extends ModArithmetic {
                private final int mod = 998244353;
                int mod() {
                    return mod;
                }
                int remainder(long value) {
                    return (int) ((value %= mod) < 0 ? value + mod : value);
                }
                int add(int a, int b) {
                    int res = a + b;
                    return res >= mod ? res - mod : res;
                }
                int sub(int a, int b) {
                    int res = a - b;
                    return res < 0 ? res + mod : res;
                }
                int mul(int a, int b) {
                    return (int) (((long) a * b) % mod);
                }
            }
            private static final class ModArithmetic1000000007 extends ModArithmetic {
                private final int mod = 1000000007;
                int mod() {
                    return mod;
                }
                int remainder(long value) {
                    return (int) ((value %= mod) < 0 ? value + mod : value);
                }
                int add(int a, int b) {
                    int res = a + b;
                    return res >= mod ? res - mod : res;
                }
                int sub(int a, int b) {
                    int res = a - b;
                    return res < 0 ? res + mod : res;
                }
                int mul(int a, int b) {
                    return (int) (((long) a * b) % mod);
                }
            }
            private static final class ModArithmeticMontgomery extends ModArithmeticDynamic {
                private final long negInv;
                private final long r2;

                private ModArithmeticMontgomery(int mod) {
                    super(mod);
                    long inv = 0;
                    long s = 1, t = 0;
                    for (int i = 0; i < 32; i++) {
                        if ((t & 1) == 0) {
                            t += mod;
                            inv += s;
                        }
                        t >>= 1;
                        s <<= 1;
                    }
                    long r = (1l << 32) % mod;
                    this.negInv = inv;
                    this.r2 = (r * r) % mod;
                }
                private int generate(long x) {
                    return reduce(x * r2);
                }
                private int reduce(long x) {
                    x = (x + ((x * negInv) & 0xffff_ffffl) * mod) >>> 32;
                    return (int) (x < mod ? x : x - mod);
                }
                @Override
                int remainder(long value) {
                    return generate((value %= mod) < 0 ? value + mod : value);
                }
                @Override
                int mul(int a, int b) {
                    return reduce((long) a * b);
                }
                @Override
                int inv(int a) {
                    return super.inv(reduce(a));
                }
                @Override
                int pow(int a, long b) {
                    return generate(super.pow(a, b));
                }
            }
            private static final class ModArithmeticBarrett extends ModArithmeticDynamic {
                private static final long mask = 0xffff_ffffl;
                private final long mh;
                private final long ml;
                private ModArithmeticBarrett(int mod) {
                    super(mod);
                    /**
                     * m = floor(2^64/mod)
                     * 2^64 = p*mod + q, 2^32 = a*mod + b
                     * => (a*mod + b)^2 = p*mod + q
                     * => p = mod*a^2 + 2ab + floor(b^2/mod)
                     */
                    long a = (1l << 32) / mod;
                    long b = (1l << 32) % mod;
                    long m = a * a * mod + 2 * a * b + (b * b) / mod;
                    mh = m >>> 32;
                    ml = m & mask;
                }
                private int reduce(long x) {
                    long z = (x & mask) * ml;
                    z = (x & mask) * mh + (x >>> 32) * ml + (z >>> 32);
                    z = (x >>> 32) * mh + (z >>> 32);
                    x -= z * mod;
                    return (int) (x < mod ? x : x - mod);
                }
                @Override
                int remainder(long value) {
                    return (int) ((value %= mod) < 0 ? value + mod : value);
                }
                @Override
                int mul(int a, int b) {
                    return reduce((long) a * b);
                }
            }
            private static class ModArithmeticDynamic extends ModArithmetic {
                final int mod;
                ModArithmeticDynamic(int mod) {
                    this.mod = mod;
                }
                int mod() {
                    return mod;
                }
                int remainder(long value) {
                    return (int) ((value %= mod) < 0 ? value + mod : value);
                }
                int add(int a, int b) {
                    int sum = a + b;
                    return sum >= mod ? sum - mod : sum;
                }
                int sub(int a, int b) {
                    int sum = a - b;
                    return sum < 0 ? sum + mod : sum;
                }
                int mul(int a, int b) {
                    return (int) (((long) a * b) % mod);
                }
            }
        }
    }
}
",1448214685
Bhaskar,vilaparthibhaskar,218,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        for i in range(len(nums)):
            left = True
            if i + (2 * k) - 1 >= len(nums):
                break
            for j in range(i, i + k - 1):
                if nums[j] >= nums[j + 1]:
                    left = False
                    break
            if left == False:
                continue
            right = True
            for j in range(i + k, i + (2 * k) - 1):
                if nums[j] >= nums[j + 1]:
                    right = False
                    break
            if right == False:
                continue
            return True
        return False
        ",1448186068
Bhaskar,vilaparthibhaskar,218,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        l = len(nums)
        dp = [1] * l
        for i in range(l - 2, -1, -1):
            if nums[i] < nums[i + 1]:
                dp[i] = dp[i + 1] + 1
        mx = max(dp) // 2
        for i in range(l):
            left = dp[i]
            right = dp[i + left] if i + left < l else 0
            mx = max(mx, min(left, right))
        return mx
        ",1448195704
Bhaskar,vilaparthibhaskar,218,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        md = (10 ** 9) + 7
        l = len(s)

        fact = [1] * (l + 1)
        inv_fact = [1] * (l + 1)
        
        for i in range(2, l + 1):
            fact[i] = fact[i - 1] * i % md

        inv_fact[l] = pow(fact[l], md - 2, md)
        for i in range(l - 1, 0, -1):
            inv_fact[i] = inv_fact[i + 1] * (i + 1) % md
        inv_fact[0] = 1

        def comb(n, r):
            if r > n or r < 0:
                return 0
            return fact[n] * inv_fact[r] % md * inv_fact[n - r] % md
        
        helper = [float('inf')] * (l + 1)
        helper[0] = float('inf')
        helper[1] = 0
        for i in range(2, l + 1):
            b = bin(i)[2:]
            sm = sum(int(d) for d in b)
            helper[i] = 1 + helper[sm]        
        ans = 0
        hold = 0
        for i in range(l):
            if s[i] == '0':
                continue
            rem = l - i - 1
            for j in range(rem + 1):
                check = hold + j
                if helper[check] < k:
                    ans = (ans + comb(rem, j)) % md
            hold += 1    
        return ans % md

                
                
            
            
        
        ",1448275177
Bhaskar,vilaparthibhaskar,218,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        md = (10 ** 9) + 7
        mx = max(nums)
        dp = [[0 for _ in range(2)] for _ in range(mx + 2)]
        ans = 0
        l = len(nums)
        for i in range(l - 1, -1, -1):
            left_sm = 0
            left_count = 0
            val = nums[i]
            left_sm += dp[val - 1][0] + dp[val - 1][1] * val
            left_count += dp[val - 1][1]
            right_sm = 0
            right_count = 0
            right_sm += dp[val + 1][0] + dp[val + 1][1] * val
            right_count += dp[val + 1][1]
            sm = left_sm + right_sm + val
            count = left_count + right_count + 1
            dp[val][0] += sm
            dp[val][1] += count
        sm = 0
        for i in dp:
            sm += i[0]
        return sm % md
            
        ",1448227133
Sai Krishna,saikrishna17394,219,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();

        for (int i = 0; (i + 2 * k) <= n; i++) {
            bool ok = true;

            for (int j = i + 1; j < (i + k); j++) {
                if (nums[j] <= nums[j - 1]) {
                    ok = false;
                    break;
                }
            }

            for (int j = i + k + 1; j < (i + 2 * k); j++) {
                if (nums[j] <= nums[j - 1]) {
                    ok = false;
                    break;
                }
            }

            if (ok) { return ok; }
        }

        return false;
    }
};",1448183766
Sai Krishna,saikrishna17394,219,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        int ans = 1;
        
        vector<int> dp(n, 1);

        for (int i = n - 2; i >= 0; i--) {
            if (nums[i] < nums[i + 1]) {
                dp[i] = dp[i + 1] + 1;
            }
            else {
                dp[i] = 1;
            }

            ans = max(ans, dp[i] / 2);
        }


        for (int i = 0; i < n; i++) {
            if ((i + dp[i]) < n) {
                if (dp[i + dp[i]] >= dp[i]) {
                    ans = max(ans, dp[i]);
                }
            }
        }

        return ans;
    }
};",1448193522
Sai Krishna,saikrishna17394,219,3631,cpp,"class Solution {
    vector<long long> fac;
    vector<long long> afac;
    long long mod;

    long long ncr(long long n, long long k) {
        if (k > n) { return 0; }

        long long ret = (fac[n] * afac[k]) % mod;
        ret = (ret * afac[n - k]) % mod;

        return ret;
    }

    long long pow(long long n, long long k) {
        long long ret = 1;

        while (k > 0) {
            if (k & 1) {
                ret = (ret * n) % mod;
            }

            n = (n * n) % mod;
            k /= 2;
        }

        return ret;
    }

public:
    int countKReducibleNumbers(string s, int k) {
        int len = s.length();
        
        if (len == 1) { return 0; }

        mod = 1e9 + 7;
        int lim = 801;

        vector<int> dp(lim, 0);
        fac = vector<long long>(lim, 1);
        afac = vector<long long>(lim, 1);

        for (int i = 2; i < lim; i++) {
            fac[i] = ((long long) i * fac[i - 1]) % mod;
        }

        afac[lim - 1] = pow(fac[lim - 1], mod - 2);

        for (int i = lim - 2; i > 1; i--) {
            afac[i] = (afac[i + 1] * (long long)(i + 1)) % mod;
        }
        dp[1] = 1;

        for (int i = 2; i < lim; i++) {
            int sum = 0;
            int num = i;

            while (num > 0) {
                sum += (num % 2);
                num /= 2;
            }

            dp[i] = dp[sum] + 1;
        }

        // fix (len - 1)
        long long ans = 0;
        
        for (int i = 1; i < lim; i++) {
            if (dp[i] <= k) {
                 ans += ncr(len - 1, i);  
                ans %= mod;
            }
        }

        int pref_val = 1;

        for (int i = 1; i < len; i++) {
            if (s[i] == '0') {
                continue;
            }

            // remaining all zeros
            if (dp[pref_val] <= k) {
                ans++;
                ans %= mod;
            }

            for (int j = 1; (j + pref_val) < lim; j++) {
                if (dp[j + pref_val] <= k) {
                    ans += ncr(len - i - 1, j);
                    ans %= mod;                    
                }
            }
            
            pref_val++;
        }
        
        return (int)ans;
    }
};",1448275393
Sai Krishna,saikrishna17394,219,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int mod = 1e9 + 7;
        int lim = 1e5 + 1;
        int n = nums.size();
        
        vector<long long> dp(lim, 0);
        vector<long long> cnt(lim, 0);

        long long ans = 0;
        long long cur;
        
        for (int i = 0; i < n; i++) {
            cur = nums[i];
            cnt[nums[i]]++;

            if ((nums[i] - 1) >= 0) {
                cur += (nums[i] * cnt[nums[i] - 1]) % mod;
                cur += dp[nums[i] - 1];
                cnt[nums[i]] += cnt[nums[i] - 1];
            }
            

            if ((nums[i] + 1) < lim) {
                cur += (nums[i] * cnt[nums[i] + 1]) % mod;
                cur += dp[nums[i] + 1];
                cnt[nums[i]] += cnt[nums[i] + 1];
            }

            cur %= mod;
            ans = (ans + cur) % mod;
            dp[nums[i]] += cur;
            dp[nums[i]] %= mod;
            cnt[nums[i]] %= mod;
        }

        return ans;
    }
};",1448223546
Ayush Saluja,ayuchitsaluja8,220,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> dp(n,1);
        for(int i=1;i<n;++i){
            dp[i] = nums[i-1] < nums[i] ? 1 + dp[i-1] : 1;
        }
        for(int i=2*k-1;i<n;++i){
            if(min(dp[i],dp[i-k])>=k)return true;
        }
        return false;
    }
};",1448186138
Ayush Saluja,ayuchitsaluja8,220,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> dpl(n,1), dpr(n,1);

        for(int i=1;i<n;++i) dpl[i] = nums[i-1] < nums[i] ? 1 + dpl[i-1] : 1;
        for(int i=n-2;i>=0;--i) dpr[i] = nums[i] < nums[i+1] ? 1 + dpr[i+1] : 1;
        int ret =1;
        for(int i=1;i<n;++i){
            ret = max(ret, min(dpl[i-1],dpr[i]));
        }
        return ret;
        
    }
};",1448188810
Ayush Saluja,ayuchitsaluja8,220,3631,cpp,"class Solution {
public:
    static constexpr int mod = 1e9+7;
    int countKReducibleNumbers(string s, int k) {
        int n = s.size();
        vector<int> dp(n+1,0);
        vector<vector<int>> C(n+1,vector<int>(n+1,0));
        for(int i=2;i<=n;++i) dp[i] = 1 + dp[__builtin_popcount(i)];
        for(int i=0;i<=n;++i){
            C[i][0] = 1;
            for(int j=1;j<=i;++j) {
                C[i][j] = ( C[i-1][j-1] + C[i-1][j])%mod;
            }
        }
        int ret=0,one=0;
        for(char c: s)one += c=='1';

        for(int l=1;l<n;++l){
            if(l==1) ++ret;
            else {
                for(int j=1;j<=l;++j)if(1+dp[j]<=k){
                    ret = ( ret + C[l-1][j-1])%mod;
                }
            }
        }

        for(int i=1,x=1;i<n;++i)if(s[i]=='1'){
            int m = n-1-i;
            for(int j=0;j<=m;++j)if(1+dp[x+j]<=k){
                ret = (ret + C[m][j])%mod;
            }
            ++x;
        }
        return ret;
    }
};",1448261478
Ayush Saluja,ayuchitsaluja8,220,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        const int mod = 1e9+7;
        map<int,int> dp,cnt;

        int ret=0;
        for(int d: nums){
            int tcnt = (1 + cnt[d-1] + cnt[d+1])%mod;
            int now = (((1LL*tcnt*d)%mod + dp[d-1])%mod + dp[d+1])%mod;
            ret = ( ret + now)%mod;

            cnt[d] = ( cnt[d] + tcnt)%mod;
            dp[d] = ( dp[d] + now)%mod;
        }
        return ret;
    }
};",1448201304
Sagnik Biswas,SagnikBiswas1049,221,3612,java,"class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        for (int a = 0; a + 2*k <= nums.size(); a++) {
            boolean good = true;
            for (int j = a+1; j < a+k; j++) {
                if (nums.get(j) <= nums.get(j-1)) {
                    good = false;
                }
            }
            
            for (int j = a+k+1; j < a+2*k; j++) {
                if (nums.get(j) <= nums.get(j-1)) {
                    good = false;
                }
            }
            
            
            if (good) return true;
        }
        
        
        return false;
    }
}",1448187154
Sagnik Biswas,SagnikBiswas1049,221,3619,java,"class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        int n = nums.size();
        int lo = 1;
        int hi = n/2;
        
        int[] pref = new int[n+1];
        for (int i = 2; i <= n; i++) {
            pref[i] = pref[i-1];
            if (nums.get(i-1) > nums.get(i-2)) {
                pref[i]++;
            }
        }
        
        while (lo != hi) {
            int mid = (lo + hi + 1)/2;
            if (works(mid, pref, n)) {
                lo = mid;
            } else {
                hi = mid-1;
            }
        }
        
        
        return lo;
    }
    
    public boolean works(int mid, int[] pref, int n) {
        // see if subarrays of size mid work
        for (int i = 1; i + 2*mid-1 <= n; i++) {
            if (pref[i+mid-1] - pref[i] == mid-1) {
                if (pref[i+2*mid-1] - pref[i+mid] == mid-1) {
                    return true;
                }
            }
        }
        
        return false;
    }
}",1448196688
Sagnik Biswas,SagnikBiswas1049,221,3631,java,"class Solution {
    
    public int countKReducibleNumbers(String s, int k) {
        int n = s.length();
        boolean[] valid = new boolean[n+1];
        
        for (int i = 1; i <= n; i++) {
            if (r(i, k-1) == 1) {
                valid[i] = true;
                // System.out.println(i);
            }
        }
        
        // System.out.println("""");
        
        long mod = (long) (1e9 + 7);
        
        /*
        
        
        
        
        */
        
        /*
        dp[i][j]
        how many numbers less than or equal to s[i .... (n-1)] have exactly j bits
        
        */
        
        long[][] choose = new long[n+1][n+1];
        choose[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            choose[i][0] = 1;
            choose[i][i] = 1;
            for (int j = 1; j <= i; j++) {
                choose[i][j] = choose[i-1][j] + choose[i-1][j-1];
                choose[i][j] %= mod;
            }
        }
        
        // print(choose);
        
        long[][] dp = new long[n][n+1];
        long ans = 0;
        
        for (int i = n-1; i >= 0; i--) {
            for (int j = 1; j <= n-i; j++) {
                if (i == n-1) {
                    if (s.charAt(i) == '1') {
                        dp[i][j] = 1;
                    }
                    continue;
                }
                
                if (j == 1) {
                    if (i != n-1) {
                        if (s.charAt(i) == '1') {
                            dp[i][j] = n-i-1;
                        } else {
                            dp[i][j] = dp[i+1][j];
                        }
                    }
                    
                    
                    if (s.charAt(i) == '1') {
                        dp[i][j] += 1;
                        dp[i][j] %= mod;
                    }
                    
                    
                } else {
                    
                    if (i != n-1) {
                        if (s.charAt(i) == '1') {
                            dp[i][j] = choose[n-i-1][j];
                        } else {
                            dp[i][j] = dp[i+1][j];
                        }
                    }
                    
                    if (s.charAt(i) == '1') {
                        dp[i][j] += dp[i+1][j-1];
                        dp[i][j] %= mod;
                    }
                    
                }
                
                // System.out.printf(""dp[%d][%d] = %d\n"", i, j, dp[i][j]);
            }
        }
        
        
        for (int i = 1; i <= n; i++) {
            if (valid[i]) {
                ans += dp[0][i];
                ans %= mod;
            }
        }
        
        int ct = 0;
        for (int i = 0; i < n; i++) {
            if (s.charAt(i) == '1') {
                ct++;
            }
        }
        
        if (r(ct, k-1) == 1) {
            ans += (mod-1);
            ans %= mod;
        }
        
        // System.out.println(""done"");
        
        return (int) ans;
    }
    
    void print(long[][] table) {
        for (int i = 0; i < table.length; i++) {
            for (int j = 0; j < table[i].length; j++) {
                System.out.print(table[i][j] + "" "");
            }
            System.out.println();
        }
    }
    
    public int r(int n, int k) {
        for (int i = 0; i < k; i++) {
            n = Integer.bitCount(n);
        }
        
        return n;
    }
    
    
}",1448261487
Sagnik Biswas,SagnikBiswas1049,221,3646,java,"class Solution {
    public int sumOfGoodSubsequences(int[] nums) {
        /*
        
        dp[i] = number of sequences that the ith element exists in 
        
        R[i] = number of sequences including i where i is the right most element
        R[i] = 1 + R[i-1]
        
        
        
        
        
        */
        
        int n = nums.length;
        
        long[] L = new long[n];
        long[] R = new long[n];
        long[] V = new long[n];
        
        long mod = (long) (1e9 + 7);
        
        for (int i = 0; i < n; i++) {
            V[i] = nums[i];
        }
        
        HashMap<Long, Long> map = new HashMap<Long, Long>();
        
        for (int i = 0; i < n; i++) {
            R[i] = 1;
            
            if (map.containsKey(V[i] - 1)) {
                R[i] += map.get(V[i] - 1);
                R[i] %= mod;
            }
            
            if (map.containsKey(V[i] + 1)) {
                R[i] += map.get(V[i] + 1);
                R[i] %= mod;
            }
            
            if (map.containsKey(V[i])) {
                long nv = map.get(V[i]) + R[i];
                nv %= mod;
                map.put(V[i], nv);
            } else {
                map.put(V[i], R[i]);
            }
        }
        
        map = new HashMap<Long, Long>();
        
        for (int i = n-1; i >= 0; i--) {
            L[i]  = 1;
            
            if (map.containsKey(V[i] - 1)) {
                L[i] += map.get(V[i] - 1);
                L[i] %= mod;
            }
            
            if (map.containsKey(V[i] + 1)) {
                L[i] += map.get(V[i] + 1);
                L[i] %= mod;
            }
            
            if (map.containsKey(V[i])) {
                long nv = map.get(V[i]) + L[i];
                nv %= mod;
                map.put(V[i], nv);
            } else {
                map.put(V[i], L[i]);
            }

        }
        
        
        
        // System.out.println(Arrays.toString(L));
        // System.out.println(Arrays.toString(R));
        
        
        long ans = 0;
        
        
        for (int i = 0; i < n; i++) {
            long tot = L[i] * R[i];
            tot %= mod;
            long cont = tot * V[i];
            cont %= mod;
            ans += cont;
            ans %= mod;
        }
        
        return (int) (ans);
        
    }
}",1448213637
ysahu,ysahu,222,3612,java,"class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        int n = nums.size();
        out: for (int i = 0; i <= n - 2 * k; i++) {
            for (int j = i + 1; j < i + k; j++) {
                if (nums.get(j) <= nums.get(j - 1)) continue out;
            }
            for (int j = i + k + 1; j < i + 2 * k; j++) {
                if (nums.get(j) <= nums.get(j - 1)) continue out;
            }
            return true;
        }
        return false;
    }
}",1448182110
ysahu,ysahu,222,3619,java,"class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        int n = nums.size();
        ArrayList<Integer> v = new ArrayList<>();
        int size = 1;
        for (int i = 1; i < n; i++) {
            if (nums.get(i) > nums.get(i - 1)) size++;
            else {
                v.add(size);
                size = 1;
            }
        }
        v.add(size);

        int best = 0;
        for (int i = 1; i < v.size(); i++) {
            int m = Math.min(v.get(i - 1), v.get(i));
            if (m > best) best = m;
        }

        for (int vx : v) {
            int f = vx / 2;
            if (f > best) best = f;
        }

        return best;
    }
}",1448187356
ysahu,ysahu,222,3631,java,"class Solution {
    public int numSetBits(int c) {
        int cd = 0;
        while (c != 0) {
            cd += c & 1;
            c >>= 1;
        }
        return cd;
    }
    
    public int countKReducibleNumbers(String s, int k) {
        int n = s.length(), p = 1_000_000_007;
        int[] a = new int[n + 1];
        for (int i = 2; i <= n; i++) {
            int c = i;
            while (c != 1) {
                c = numSetBits(c);
                a[i]++;
            }
        }

        int[][] choose = new int[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            choose[i][0] = 1;
            choose[i][i] = 1;
        }

        for (int i = 0; i <= n; i++) {
            for (int j = 1; j < i; j++) {
                choose[i][j] = (choose[i - 1][j] + choose[i - 1][j - 1]) % p;
            }
        }

        int[] b = new int[n + 1];
        int t = 0;
        for (int i = 0; i < n; i++) {
            char c = s.charAt(i);
            if (c == '0') {
                continue;
            } else {
                int e = n - i - 1;
                for (int j = 0; j <= e; j++) {
                    b[t + j] = (b[t + j] + choose[e][j]) % p;
                }
                t++;
            }
        }

        if (k == 1) return b[1];
        k--;
        int out = 0;
        for (int i = 1; i <= n; i++) {
            if (a[i] <= k) out = (out + b[i]) % p;
        }

        return out;
    }
}",1448261548
ysahu,ysahu,222,3646,java,"class Solution {
    public int sumOfGoodSubsequences(int[] nums) {
        int max = 0;
        for (int num : nums) if (num > max) max = num;

        long[] sum = new long[max + 1];
        long[] count = new long[max + 1];

        for (int num : nums) {
            count[num] += 1 + (num == 0 ? 0 : count[num - 1]) +
                (num == max ? 0 : count[num + 1]);
            sum[num] += num + 
                (num == 0 ? 0 : sum[num - 1] + num * count[num - 1]) +
                (num == max ? 0 : sum[num + 1] + num * count[num + 1]);
            count[num] %= 1_000_000_007;
            sum[num] %= 1_000_000_007;
        }

        long t = 0;
        for (long s : sum) t += s;
        return (int) (t % 1_000_000_007);
    }
}",1448200698
Laplace233,Laplace233,223,3612,cpp,"constexpr int N = 250000;
int l[N],r[N];
class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums,int k) {
        int ans = 1;
        int n = nums.size();
        r[n - 1] = 1;
        for(int i = n - 2; i >= 0; i--){
            r[i] = 1;
            if(nums[i] < nums[i + 1]) r[i] += r[i + 1];
        }
        l[0] = 1;
        for(int i = 1; i < n; i++){
            l[i] = 1;
            if(nums[i] > nums[i - 1]) l[i] += l[i - 1];
        }
        for(int i = 0; i < n - 1; i++){
            ans = max(ans,min(l[i],r[i + 1]));
        }
        return (ans >= k);
    }
};",1448199674
Laplace233,Laplace233,223,3619,cpp,"constexpr int N = 250000;
int l[N],r[N];
class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int ans = 1;
        int n = nums.size();
        r[n - 1] = 1;
        for(int i = n - 2; i >= 0; i--){
            r[i] = 1;
            if(nums[i] < nums[i + 1]) r[i] += r[i + 1];
        }
        l[0] = 1;
        for(int i = 1; i < n; i++){
            l[i] = 1;
            if(nums[i] > nums[i - 1]) l[i] += l[i - 1];
        }
        for(int i = 0; i < n - 1; i++){
            ans = max(ans,min(l[i],r[i + 1]));
        }
        return ans;
    }
};",1448198019
Laplace233,Laplace233,223,3631,cpp,"#define ll long long
constexpr ll p = 1e9 + 7;
constexpr int N = 1000;
ll fac[N],inv[N];
class Solution {
public:
    string s;
    int n,k,f[N];
    int pp(int x){
        return __builtin_popcount(x);
    }
    ll mypow(ll x,ll tms){
        ll bas = x, res = 1;
        while(tms){
            if(tms & 1) res = res * bas % p;
            bas = bas * bas % p;
            tms >>= 1;
        }
        return res;
    }
    ll c(ll n,ll m){
        return fac[n] * inv[m] % p * inv[n - m] % p;
    }
    void init(){
        f[0] = 100;
        f[1] = 0;
        for(int i = 2; i < N; i++) f[i] = f[pp(i)] + 1;
        fac[0] = 1;
        for(int i = 1; i < N; i++) fac[i] = i * fac[i - 1] % p;
        inv[N - 1] = mypow(fac[N - 1], p - 2);
        for(int i = N - 2; i >= 0; i--) inv[i] = inv[i + 1] * (i + 1) % p;
    }
    ll dfs(ll sum,ll loc){
        if(loc == n + 1){
            return 0;
        }
        ll tmp = 0;
        if(s[loc] == '1'){
            int r = n - loc;
            for(int i = 0; i <= r; i++){
                if(f[sum + i] + 1 > k) continue;
                tmp += c(r,i);
                tmp %= p;
            }
        }
        tmp += dfs(sum + s[loc] - '0',loc + 1);
        return tmp % p;
    }
    int countKReducibleNumbers(string ss, int tk) {
        init();
        s = ss;
        n = s.length() - 1, k = tk;
        return dfs(0,0);
    }
};",1448261716
Laplace233,Laplace233,223,3646,cpp,"#define ll long long
constexpr int N = 120000;
constexpr ll p = 1e9 + 7;
ll sum[N],num[N],ans;
class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        ans = 0;
        for(int i = 0; i < N; i++) sum[i] = num[i] = 0;
        for(int i = 0; i < nums.size(); i++){
            int k = nums[i];
            if(k != 0) sum[k] += (num[k - 1] + num[k + 1] + 1) * k % p;
            if(k != 0) sum[k] += (sum[k - 1] + sum[k + 1]) % p;
            else sum[k] += sum[k + 1];
            if(k != 0) num[k] += num[k - 1] + num[k + 1] + 1;
            else num[k] += num[k + 1] + 1;
            sum[k] %= p, num[k] %= p;
        }
        for(int i = 0; i < N; i++) ans += sum[i], ans %= p;
        return ans;
    }
};",1448226971
Rohit Meena,Rohit_Meena,224,3612,cpp,"class Solution {
public:
    int get(int l, int r, vector<int> &diff){
        if(l == 0) return diff[r];
        return diff[r]-diff[l-1];
    }
    bool check(int len, vector<int> &diff){
        int n = diff.size();
        len--;
        for(int i = 0;i<n;i++){
            if(i + 2*len >= n) break;
            int lval = get(i, i + len - 1, diff);
            int rval = get(i + len + 1, i + 2*len, diff);
            if(lval == len && rval == len) return true;
        }
        return false;
    }
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        if(k == 1) return true;
        vector<int> diff(n-1);
        for(int i = 1;i<n;i++) diff[i-1] = nums[i] > nums[i-1];
        for(int i = 1;i<n-1;i++) diff[i] += diff[i-1];
        return check(k, diff);
    }
};",1448192744
Rohit Meena,Rohit_Meena,224,3619,cpp,"class Solution {
public:
    int get(int l, int r, vector<int> &diff){
        if(l == 0) return diff[r];
        return diff[r]-diff[l-1];
    }
    bool check(int len, vector<int> &diff){
        int n = diff.size();
        len--;
        for(int i = 0;i<n;i++){
            if(i + 2*len >= n) break;
            int lval = get(i, i + len - 1, diff);
            int rval = get(i + len + 1, i + 2*len, diff);
            if(lval == len && rval == len) return true;
        }
        return false;
    }
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> diff(n-1);
        for(int i = 1;i<n;i++) diff[i-1] = nums[i] > nums[i-1];
        for(int i = 1;i<n-1;i++) diff[i] += diff[i-1];
        int l = 2, r = n/2;
        int ans = 1;
        while(l<=r){
            int mid = l + (r-l)/2;
            if(check(mid, diff)){
                ans = mid;
                l = mid + 1;
            }
            else r = mid -1;
        }
        return ans;
    }
};",1448190389
Rohit Meena,Rohit_Meena,224,3631,cpp,"#define ll long long
class Solution {
public:
    int n, k;
    const int mod = 1e9 + 7;
    int dp[805][805][2];
    bool check(int bits, int kk){
        int x = bits;kk--;
        while(kk--){
            x = __builtin_popcount(x);
        }
        return x == 1;
    }
    int solve(int i, int sum, int tu, string &s){
        if(i == n) return check(sum, k);
        if(dp[i][sum][tu] != -1) return dp[i][sum][tu];
        ll ans = 0;
        if(tu == 0){
            ans += solve(i + 1, sum, tu, s);
            ans += solve(i + 1, sum + 1, tu, s);
        }
        else{
            if(s[i] == '1'){
                ans += solve(i +1 , sum , 0, s);
                ans += solve(i + 1, sum + 1, 1, s);
            }
            else{
                ans += solve(i + 1, sum, 1, s);
            }
        }
        return dp[i][sum][tu] = ans%mod;
    }
    int countKReducibleNumbers(string s, int k) {
        n = s.length();
        this->k = k;
        memset(dp, -1, sizeof(dp));
        
        ll ans = solve(0, 0, 1, s);
        if(check(count(s.begin(), s.end(), '1'), k)) ans--;
        return (ans + mod)%mod;
    }
};",1448261764
Rohit Meena,Rohit_Meena,224,3646,cpp,"class Solution {
public:
    const int mod = 1e9 + 7;
    const int MAXX = 1e5 + 1;
    int sumOfGoodSubsequences(vector<int>& nums) {
        int n = nums.size();
        map<int,int> arr;
        vector<int> dp1(n), dp2(n);
        for(int i = 0;i<n;i++){
            int x = nums[i];
            dp1[i] = (arr[x-1] + arr[x+1] + 1)%mod;
            arr[x] = (arr[x] + dp1[i])%mod;
        }
        arr.clear();
        for(int i = n-1;i>=0;i--){
            int x = nums[i];
            dp2[i] = (arr[x-1] + arr[x+1] + 1)%mod;
            arr[x] = (arr[x] + dp2[i])%mod;
        }
        // for(int i = 0;i<n;i++) cout<<dp1[i]<<"" \n""[i==n-1];
        // for(int i = 0;i<n;i++) cout<<dp2[i]<<"" \n""[i==n-1];
        long long ans = 0;
        for(int i = 0;i<n;i++){
            long long contri = (1LL*dp1[i]*dp2[i])%mod;
            contri = (contri*nums[i])%mod;
            ans = (ans + contri)%mod;
        }
        return ans;
    }
};",1448235140
kavascg,kavascgjmd39,225,3612,cpp,"#define ll long long 
#define vt vector
#define all(a) a.begin(), a.end()
#define rep(i, a, b) for (ll i = a; i < b; i++)
#define repr(i , n, a) for(ll i =n ; i>= a; i--)
#define pi pair
const ll N = 2e5+5;
const ll mod = 1e9+7;
class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
                int n = nums.size();
        vt<int>vals( n , 0);
        vals[0] = 1;
        rep(i , 1 , n){
            vals[i] = 1;
            if(nums[i] > nums[i-1]){
                vals[i] = vals[i-1]+1;
            }
        }
        int res = 0;
        rep(i , 1 , n ){
            if(i >= vals[i]){
            res = max(res, min(vals[i], vals[i-vals[i]]));}
            res = max(res, vals[i]/2);
            
        }
        return res >= k; 
    }
};",1448191428
kavascg,kavascgjmd39,225,3619,cpp,"#define ll long long 
#define vt vector
#define all(a) a.begin(), a.end()
#define rep(i, a, b) for (ll i = a; i < b; i++)
#define repr(i , n, a) for(ll i =n ; i>= a; i--)
#define pi pair
const ll N = 2e5+5;
const ll mod = 1e9+7;
class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vt<int>vals( n , 0);
        vals[0] = 1;
        rep(i , 1 , n){
            vals[i] = 1;
            if(nums[i] > nums[i-1]){
                vals[i] = vals[i-1]+1;
            }
        }
        int res = 0;
        rep(i , 1 , n ){
            if(i >= vals[i]){
            res = max(res, min(vals[i], vals[i-vals[i]]));}
            res = max(res, vals[i]/2);
            
        }
        return res;
    }
};",1448189802
kavascg,kavascgjmd39,225,3631,cpp,"#define ll long long 
#define vt vector
#define all(a) a.begin(), a.end()
#define rep(i, a, b) for (ll i = a; i < b; i++)
#define repr(i , n, a) for(ll i =n ; i>= a; i--)
#define pi pair
const ll N = 2e5+5;
const ll mod = 1e9+7;
class Solution {
public:
    int dp[801][801][2];
    int sol(int i, int tight, string & s, vt<int>&vals,int c  ){
        if(i == s.size()){
            
            return vals[c] && !tight;
        }
        if(dp[i][c][tight] != -1){
            return dp[i][c][tight];
        }
        int res = 0;
        if(tight){
            if(s[i] == '1'){
               res +=  sol(i+1, 1 , s, vals, c+1) % mod; res %= mod;
               res += sol(i+1 , 0 , s, vals, c ) % mod; res %= mod;
            }
            else {
                res += sol(i+1 , 1 , s, vals, c) % mod ; res %= mod;
            }
        }
        else {
            res +=sol(i+1 , 0 , s , vals, c+1) % mod ; res %= mod;;
            res += sol(i+1 , 0 , s, vals, c) % mod; res %= mod;
        }
        return dp[i][c][tight] = res;
    }
    int countKReducibleNumbers(string s, int k) {
     memset(dp , -1 , sizeof(dp));
        k--;
     vt<int>vals(801  , 1); vals[0] = 0;
     rep(i , 1 , 800){
             int x = i;
             int c = 0;
             while(__builtin_popcount(x) != x && c < k){
             x = __builtin_popcount(x);
             c++;
             }
             if(x != 1){
                 vals[i] = 0;
             }
     }
    
     return sol(0 , 1 , s, vals,0);
        
    }
};",1448269603
kavascg,kavascgjmd39,225,3646,cpp,"#define ll long long 
#define vt vector
#define all(a) a.begin(), a.end()
#define rep(i, a, b) for (ll i = a; i < b; i++)
#define repr(i , n, a) for(ll i =n ; i>= a; i--)
#define pi pair
const ll N = 2e5+5;
const ll mod = 1e9+7;
class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int n = nums.size();
        map<int,int>dp;
        map<int,int>ndp;
        rep(i , 0 , nums.size()){
            dp[nums[i]]++; dp[nums[i]] %= mod;
            ndp[nums[i]] += nums[i];
            if(dp.find(nums[i]-1) != dp.end()){
                dp[nums[i]] += dp[nums[i]-1] % mod; dp[nums[i]] %= mod;
                ndp[nums[i]] += ((ll)(dp[nums[i]-1] % mod)*(ll)(nums[i] % mod))%mod;
                  ndp[nums[i]] %= mod;
                ndp[nums[i]] += (ndp[nums[i]-1] % mod);
                ndp[nums[i]] %= mod;
            }
            if(dp.find(nums[i]+1) != dp.end()){
                dp[nums[i]] += dp[nums[i]+1] % mod; dp[nums[i]] %= mod;
                ndp[nums[i]] += ((ll)(dp[nums[i]+1] % mod)*(ll)(nums[i] % mod))%mod;
                ndp[nums[i]] %= mod;
                ndp[nums[i]] += (ndp[nums[i]+1] % mod);
                ndp[nums[i]] %= mod;
            }
        }
         ll res = 0;
         for(auto & x : ndp){
         res  += x.second % mod ; res %= mod;
         }
return res;
    }
};",1448221533
yolo12345,yolo12345,228,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n=nums.size();
        bool f=false;
        int prev=0;
        int i=0;
        while(i<n){
            int j=i;
            while(j+1<n && (nums[j+1]>nums[j])) j++;
            int len=j-i+1;
            if(k*2<=len) f=true;
            if(len>=k && (prev>=k)) f=true;
            prev=len;
            i=j+1;
        }
        return f;
    }
};",1448188897
yolo12345,yolo12345,228,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int ans=0;
        int n=nums.size();
        int prev=0;
        int i=0;
        while(i<n){
            int j=i;
            while(j+1<n && (nums[j+1]>nums[j])) j++;
            int len=j-i+1;
            ans=max(ans,len/2);
            ans=max(ans,min(prev,len));
            prev=len;
            i=j+1;
        }
        return ans;
    }
};",1448185888
yolo12345,yolo12345,228,3631,cpp,"using ll = long long;
const long long md=1e9+7;
vector<long long> fact(805),ifact(805);
long long power(long long x, long long y, long long p){
    long long ans = 1; x = x % p; if (x == 0) return 0; 
    while (y > 0){
        if (y & 1) ans = (ans*x) % p; y = y>>1; x = (x*x) % p;
    }return ans;
}

long long bin(long long a, long long b){
    return ((fact[a]*ifact[a-b]%md)*ifact[b])%md;
}
class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        long long range=801;
        fact[0]=1,ifact[0]=1;
        for(long long i=1;i<=range;i++) fact[i]=(i*fact[i-1])%md;
        ifact[range]=power(fact[range],md-2,md);
        for(long long i=range-1;i>0;i--) ifact[i]=(ifact[i+1]*(i+1))%md;
        vector<ll> ans(801,-1);
        ans[1]=0;
        for(int i=2;i<=800;i++){
            int cnt=0;
            int x=i;
            while(x>0){
                if(x&1) cnt++;
                x=x/2;
            }
            ans[i]=ans[cnt]+1;
            //cout<<ans[i]<<' ';
        }
        ll n=s.length();
        ll res=0;
        for(ll i=1;i<=n;i++){
            ll val=i;
            if(ans[i]<=k-1){
                for(ll j=0;j<n;j++){
                    if(s[j]=='1'){
                        ll rem=n-j-1;
                        if(rem<val-1) break;
                        if(rem>=val) res=(res+bin(rem,val))%md;
                        val--;
                        if(val<=0) { res++;  res%=md; break; }
                    }
                }
            }
            //cout<<res<<' ';
        }
        int tot=0;
        for(int i=0;i<n;i++){
            if(s[i]=='1') tot++;
        }
        if(ans[tot]<=k-1) res--;
        res+=md;
        res%=md;
        
        return res;
    }
};",1448276802
yolo12345,yolo12345,228,3646,cpp,"using ll = long long;
const long long md=1e9+7;
class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        ll ans=0;
        map<ll,ll> mp,cnt;
        int n=nums.size();
        for(int i=0;i<n;i++){
            ll res=nums[i];
            ll tot=0;
            if(mp.count(nums[i]-1)){
                res=(res+mp[nums[i]-1])%md;
                tot+=cnt[nums[i]-1];
            }
            if(mp.count(nums[i]+1)){
                res=(res+mp[nums[i]+1])%md;
                tot+=cnt[nums[i]+1];
            }
            res=(res+(tot*nums[i])%md)%md;
            tot++;
            cnt[nums[i]]+=tot;
            cnt[nums[i]]%=md;
            ans=(ans+res)%md;
            mp[nums[i]]+=res;
            mp[nums[i]]%=md;
            //cout<<ans<<' ';
        }
        ans=ans%md;
        int x=ans;
        return ans;
    }
};",1448209832
chh9976,chh9976,232,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        def check(a):
            for a, b in pairwise(a):
                if b <= a:
                    return False
            return True
        for i in range(len(nums)-2*k+1):
            if check(nums[i:i+k]) and check(nums[i+k:i+2*k]):
                return True
        return False",1448182883
chh9976,chh9976,232,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> pre(n, -1), suf(n, -1);
        {
        int r = 0;
        while(r < nums.size()){
            int prer = r;
            while(r < nums.size() - 1 && nums[r] < nums[r+1]) r++;
            for(int i=prer;i<=r;i++) pre[i] = prer;
            r++;
            prer = r;
        }
        }
        {
        int r = nums.size()-1;
        while(r >= 0){
            int prer = r;
            while(r > 0 && nums[r-1] < nums[r]) r--;
            for(int i=r;i<=prer;i++) suf[i] = prer;
            r--;
            prer = r;
        }
        }
        int ans = -1;
        for(int i=0;i<nums.size()-1;i++){
            ans = max(ans, min(i - pre[i] + 1, suf[i+1] - (i+1) + 1));
        }
        return ans;
    }
};",1448201903
chh9976,chh9976,232,3631,cpp,"
template<int MOD>
struct mint {
  unsigned x;
  mint() : x(0) { }
  mint(signed sig) : x(((sig)%MOD+MOD)%MOD) {}
  mint(signed long long sig) : x(((sig)%MOD+MOD)%MOD) { }
  int get() const { return (int)x; }
  mint pow(long long p) { mint res = 1, a = *this; while (p) { if (p & 1) res *= a; a *= a; p >>= 1; } return res; }
 
  mint &operator+=(mint that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }
  mint &operator-=(mint that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }
  mint &operator*=(mint that) { x = (unsigned long long)x * that.x % MOD; return *this; }
  mint &operator/=(mint that) { return (*this) *= that.pow(MOD - 2); }
 
  mint operator+(mint that) const { return mint(*this) += that; }
  mint operator-(mint that) const { return mint(*this) -= that; }
  mint operator*(mint that) const { return mint(*this) *= that; }
  mint operator/(mint that) const { return mint(*this) /= that; }
  bool operator<(mint that) const { return x < that.x; }
  
  friend mint operator+(int lhs, mint rhs) {return rhs + lhs;}
  friend mint operator-(int lhs, mint rhs) {return mint(lhs) - rhs;}
  friend mint operator*(int lhs, mint rhs) {return rhs * lhs;}
  friend mint operator/(int lhs, mint rhs) {return mint(lhs) / rhs;}

  friend ostream& operator<<(ostream &os, mint a) { os << a.x; return os; }
};
typedef mint<1000000007> mint17;
int MOD = 1e9 + 7;
class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        vector<mint17> bitcnt(s.size()+1), nowcnt(s.size()+1);
        int cntprebit = 0;
        for(auto c:s) cntprebit += c - 48;
        nowcnt[0] = 1;
        for(int i=0;i<s.size();i++){
            cntprebit -= s[s.size()-i-1] - 48;
            if(s[s.size()-i-1] == '1'){
                for(int j=0;j<s.size()-cntprebit+1;j++){
                    bitcnt[j+cntprebit] += nowcnt[j];
                }
            }
            for(int j=s.size();j>0;j--){
                nowcnt[j] += nowcnt[j-1];
            }
        }
        vector<int> step(s.size()+1, 0);
        for(int i=2;i<=s.size();i++){
            step[i] = step[__builtin_popcount(i)] + 1;
        }
        mint17 ans = 0;
        for(int i=1;i<=s.size();i++) if(step[i] + 1 <= k) ans += bitcnt[i];
        return ans.x;
    }
};",1448263849
chh9976,chh9976,232,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int MOD = 1e9 + 7;
        long long ans = 0;
        map<int, long long> c;
        map<int, long long> sz;
        for(int i=0;i<nums.size();i++){
            c[nums[i]] += (0ll + c[nums[i]-1] + c[nums[i]+1]) % MOD;;
            sz[nums[i]] += (sz[nums[i]-1] + sz[nums[i]+1]) % MOD;
            sz[nums[i]]++;
            c[nums[i]] += 1ll * ((sz[nums[i]-1] + sz[nums[i]+1] + 1) % MOD * nums[i]) % MOD;
        }
        for(auto [k, v]:c) ans += v, ans %= MOD;
        return ans % MOD;
    }
};",1448218483
gjp4_,gjp4_,233,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> len(n, 1);
        for(int i=n-2;i>=0;i--) {
            if(nums[i] < nums[i+1])len[i] += len[i+1];
        }
        for(int i=0;i<n-k;i++) {
            if(len[i] >= k && len[i+k] >= k)return true;
        }
        return false;
    }
};",1448182257
gjp4_,gjp4_,233,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> len(n, 1);
        for(int i=n-2;i>=0;i--) {
            if(nums[i] < nums[i+1])len[i] += len[i+1];
        }
        int l = 1, r = n/2, mid;
        while(l < r) {
            mid = (l + r + 1) / 2;
            bool ok = false;
            for(int i=0;i<n-mid;i++) {
                if(len[i]>=mid && len[i+mid] >=mid) {
                    ok = true;
                    break;
                }
            }
            if(ok)l = mid;
            else r = mid-1;
        }
        return l;
    }
};",1448184791
gjp4_,gjp4_,233,3631,cpp,"class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        int n = s.size();
        const int mx = 1e9;
        const long long MOD = 1e9 + 7;
        vector<int> dp(n + 1, 0);
        dp[0] = 1e9;
        for(int i=2;i<n+1;i++) {
            int b = __builtin_popcount(i);
            if(b == i)dp[i] = mx;
            else dp[i] = dp[b] + 1;
            dp[i] = min(mx, dp[i]);
        }
        vector<vector<vector<long long> > > dp1(n, vector<vector<long long> >(2, vector<long long>(n + 1, -1)));
        // cur, cnt // i, bit cnt
        auto dfs = [&](auto &&dfs, int cur, bool isup, int bit) -> long long{
            if(cur == n) {
                return !isup && dp[bit] < k;
            }
            long long &ret = dp1[cur][isup][bit];
            if(ret != -1)return ret;
            ret = 0;
            int up = isup ? s[cur] - '0': 1;
            for(int i=0;i<=up;i++) {
                ret = (ret + dfs(dfs, cur+1, isup && (i == s[cur]-'0'), bit + i)) % MOD;
            }
            return ret;
        };
        return dfs(dfs, 0, 1, 0);
    }
};",1448270978
gjp4_,gjp4_,233,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        const long long MOD = 1e9 + 7;
        int n = nums.size();
        long long ans = 0;
        map<int, long long> mp, cnt;
        
        for(int i=0;i<n;i++) {
            if(mp.find(nums[i] - 1) != mp.end()) {
                long long total = cnt[nums[i]-1] * nums[i] % MOD;
                ans = (ans + ((mp[nums[i]-1] + total) % MOD) % MOD)% MOD;
                mp[nums[i]] += (mp[nums[i]-1] + total) % MOD;
                mp[nums[i]] %= MOD;
                cnt[nums[i]] += cnt[nums[i]-1];
                cnt[nums[i]] %= MOD;
            }
            if(mp.find(nums[i] +1) != mp.end()) {
                long long total = cnt[nums[i] + 1] * nums[i];
                ans += (mp[nums[i]+1] + total) % MOD;
                ans %= MOD;
                mp[nums[i]] += (mp[nums[i]+1] + total) % MOD;
                mp[nums[i]] %= MOD;
                cnt[nums[i]] += cnt[nums[i] + 1];
                cnt[nums[i]] %= MOD;
            }
            mp[nums[i]] += nums[i];
            mp[nums[i]] %= MOD;
            cnt[nums[i]]++;
            cnt[nums[i]] %= MOD;
            ans += nums[i];
            ans %= MOD;
        }
        return ans;
    }
};",1448243423
Eshaan Aggarwal,eshaanagg,234,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& arr, int k) {
        int n = arr.size();
        vector<int> l(n);
        for (int i = 0; i < n; i++) {
            int cnt = 1, st = i;
            while (i + 1 < n && arr[i + 1] > arr[i]) {
                i++;
                cnt++;
            }
            for (int j = st; j <= i; j++) {
                l[j] = cnt;
                cnt--;
            }
        }

        for (int i = 0; i + k < n; i++) if (l[i] >= k && l[i + k] >= k)
            return 1;
        return 0;
    }
};",1448205435
Eshaan Aggarwal,eshaanagg,234,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& arr) {
        int n = arr.size();
        vector<int> l(n);
        
        for (int i = 0; i < n; i++) {
            int cnt = 1, st = i;
            while (i + 1 < n && arr[i + 1] > arr[i]) {
                i++;
                cnt++;
            }
            for (int j = st; j <= i; j++) {
                l[j] = cnt;
                cnt--;
            }
        }

        int ans = 0;
        for (int i = 0; i < n; i++) {
            ans = max(ans, l[i] / 2);
            if (i + l[i] < n && l[i + l[i]] >= l[i])
                ans = max(ans, l[i]);
        }

        return ans;
    }
};",1448226729
Eshaan Aggarwal,eshaanagg,234,3631,cpp,"class Solution {
    bool check(int n, int k) {
        if (n == 1)
            return 1;
        
        for (int i = 1; i < k; i++) {
            int p = __builtin_popcount(n);
            if (p == 1)
                return 1;
            n = p;
        }

        return 0;
    }

    int MOD = 1e9 + 7;

    int get(int idx, int pop, bool eq, string &s, vector<vector<vector<int>>> &dp) {
        if (idx == s.size())
            return pop == 0 && !eq;
        
        if (dp[idx][pop][eq] != -1)
            return dp[idx][pop][eq];

        int ans = 0;
        for (int d = 0; d <= (eq ? s[idx] - '0' : 1); d++) {
            int newEq = eq && (s[idx] - '0' == d);
            int newPop = pop - (d == 1);
            if (newPop >= 0) {
                ans += get(idx + 1, newPop, newEq, s, dp);
                ans %= MOD;
            }
        }

        return dp[idx][pop][eq] = ans;
    }

public:
    int countKReducibleNumbers(string s, int k) {
        int n = s.size();
    
        vector<vector<vector<int>>> dp(n, vector<vector<int>> (n + 1, vector<int> (2, -1)));
        int ans = 0;
        
        for (int i = 0; i <= n; i++) 
            if (check(i, k)) {
                ans += get(0, i, 1, s, dp);
                ans %= MOD;
            }

        return ans;
    }
};",1448264191
Eshaan Aggarwal,eshaanagg,234,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& arr) {
        long long MOD = 1e9 + 7;
        vector<long long> sum(1e5 + 10, 0), cnt(1e5 + 10, 0);

        for (int x: arr) {
            for (int d: {1, -1}) {
                if (x + d >= 0) {
                    cnt[x] += cnt[x + d];
                    cnt[x] %= MOD;
                    sum[x] += sum[x + d] + cnt[x + d] * (long long)x;
                    sum[x] %= MOD;
                }
            }
            
            sum[x] += x;
            sum[x] %= MOD;
            cnt[x]++;
            cnt[x] %= MOD;
        }

        long long ans = accumulate(sum.begin(), sum.end(), 0LL);
        return ans % MOD;
    }
};",1448237896
Abhitrio1110,Abhitrio1110,236,3612,cpp,"class Solution {
public:
    
    bool checkIncreasing(const vector<int>& nums, int start, int k) {
        for (int i = start; i < start + k - 1; ++i) {
            if (nums[i] >= nums[i + 1]) {
                return false;
            }
        }   
        return true;
    }
    
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
    int n = nums.size();

    // Iterate through all possible starting indices of the first subarray
    for (int a = 0; a <= n - 2 * k; ++a) {
        // Check if both subarrays starting at `a` and `a + k` are strictly increasing
        if (checkIncreasing(nums, a, k) && checkIncreasing(nums, a + k, k)) {
            return true;
        }
    }   

        // No such pair found
        return false;
    }

};",1448189044
Abhitrio1110,Abhitrio1110,236,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& v) {
        int n=v.size();
        vector<int>sfx(n,1),pfx(n,1);
        for(int i=n-2;i>=0;i--){
            if(v[i]<v[i+1]){
                sfx[i]+=sfx[i+1];
            }
        }
        //int pfx[n]={1};
        for(int i=1;i<n;i++){
            if(v[i]>v[i-1]){
                pfx[i]+=pfx[i-1];
            }
        }
        int res=1;
        for(int i=0;i+1<n;i++){
            res=max(res,min(pfx[i],sfx[i+1]));
        }
        return res;
        
    }
};",1448206013
Abhitrio1110,Abhitrio1110,236,3631,cpp,"class Solution {
public:
#define setbits(x) __builtin_popcount(x) 

const int N = 1e9 + 7;
unordered_map<int, bool> mp;
vector<vector<vector<int>>>dp;
void fun(int n, int k) {
    //cout<<""Welcome""<<endl;
    mp[0] = false;
    mp[1] = true;
    for (int i = 2; i <= n; i++) {
        int op = 1;
        int num = i;
        while (setbits(num) != 1) {
            op++;
            num = setbits(num);
        }
        if (op < k) {
            mp[i] = true;
        } else {
            mp[i] = false;
        }
        //if(mp[i])cout<<i<<endl;
    }
}
    
    int sol(int i, int j, int limit, vector<int>&v){
        if(i==v.size()){
            return mp[j];
        }
        if(dp[i][j][limit]!=-1) return dp[i][j][limit];
        long long ans=0;
        if(limit==1){
            if(v[i]==0){
                //Only use 0
                ans=(ans+sol(i+1,j,limit,v))%N;
            }
            else{
                //Use 0
                ans=(ans+sol(i+1,j,0,v))%N;
                //Use 1
                ans=(ans+sol(i+1,j+1,limit,v))%N;
            }
        }
        else{
            //Use 0
            ans=(ans+sol(i+1,j,0,v))%N;
            //Use 1
            ans=(ans+sol(i+1,j+1,0,v))%N;
        }
        return dp[i][j][limit]=ans;
    }
    
    
    int countKReducibleNumbers(string s, int k) {
        int n=s.size();
        fun(n+1,k);
        vector<int>v;
        for(auto &i:s){
            v.push_back(i-'0');
        }
        dp.assign(n+1,vector<vector<int>>(n+1,vector<int>(2,-1)));
        long long num=sol(0,0,1, v);
        int cnt=0;
        for(auto &i:v)if(i==1)cnt++;
        if(mp[cnt]) num=(num-1+N)%N;
        return num;
    }
};",1448257069
Abhitrio1110,Abhitrio1110,236,3646,cpp,"class Solution {
public:
    const int N=1e9+7;
    int sumOfGoodSubsequences(vector<int>& v) {
        long long ans=0;
        map<int,int>mp,sum;
        for(int i=0;i<v.size();i++){
            //take v[i]-1
            int k1=v[i]-1;
            long long cnt1=mp[k1]+1;
            long long curr1=(cnt1*v[i])%N;
            ans=(ans+sum[k1]+curr1)%N;
            mp[v[i]]+=cnt1;
            mp[v[i]]%=N;
            sum[v[i]]+=(sum[k1]+curr1)%N;
            sum[v[i]]%=N;
            //take v[i]-1
            int k2=v[i]+1;
            long long cnt2=mp[k2];
            long long curr2=(cnt2*v[i])%N;
            ans=(ans+sum[k2]+curr2)%N;
            mp[v[i]]+=cnt2;
            mp[v[i]]%=N;
            sum[v[i]]+=(sum[k2]+curr2)%N;
            sum[v[i]]%=N;
            //cout<<i<<' '<<sum[v[i]]<<endl;
            //ans=(ans+sum[v[i]])%N;
        }
        return ans;
    }
};",1448225053
Chiefis,Chiefis,237,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        start_k = set()
        curr = 2000
        curr_l = 0 
        for (i, num) in enumerate(nums):
            if num > curr:
                curr = num 
                curr_l += 1 
                if curr_l >= k:
                    start_k.add(i - k + 1)
            else:
                curr = num 
                curr_l = 1 
                if curr_l >= k:
                    start_k.add(i - k + 1)
        for num in start_k:
            if num + k in start_k:
                return True 
        return False
        ",1448188463
Chiefis,Chiefis,237,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        start_k = []
        curr = nums[0] + 1
        curr_l = 0 
        curr_start = 0
        for (i, num) in enumerate(nums):
            if num > curr:
                curr = num 
                curr_l += 1 
            else:
                start_k.append(curr_l)
                curr = num 
                curr_l = 1 
        start_k.append(curr_l)
        best = 0 
        for (i, num) in enumerate(start_k):
            if i < len(start_k) - 1:
                best = max(best, min(num, start_k[i + 1]))
            best = max(best, num//2)
        return best
        ",1448202010
Chiefis,Chiefis,237,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        ops_counts = [0 for i in range(801)]
        for num in range(2, 801):
            count = self.count_one(num)
            ops_counts[num] = ops_counts[count] + 1 
        #print(ops_counts[:10])
        s_list = list(s)
        answer = {}
        result = 0
        quotient = 1000000007
        for i in range(1, 801):
            if ops_counts[i] + 1 <= k:
                result += self.dp(s_list, 0, i, answer)
                result %= quotient 
        return result
        
        
        
    def count_one(self, num: int) -> int:
        bin_num = bin(num)[2:]
        count = 0 
        for c in bin_num:
            if c == '1':
                count += 1 
        return count
    
    def dp(self, s_list, idx, num_ones, answer):
        quotient = 1000000007
        if (idx, num_ones) in answer:
            return answer[(idx, num_ones)]
        if len(s_list) - idx < num_ones:
            result = 0 
        else:
            if num_ones == 0:
                result = 0 
                for i in range(idx, len(s_list)):
                    if s_list[i] == '1':
                        result = 1 
                        break
            elif s_list[idx] == '0':
                result = self.dp(s_list, idx + 1, num_ones, answer)
            else:
                result = self.dp(s_list, idx + 1, num_ones - 1, answer)
                if len(s_list) - idx - 1 >= num_ones:
                    result += math.comb(len(s_list) - idx - 1, num_ones)
        result %= quotient 
        answer[(idx, num_ones)] = result 
        return result",1448278334
Chiefis,Chiefis,237,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        quotient = 1000000007
        seqs = [1 for i in range(len(nums))]
        past_seqs = {}
        for i in range(len(seqs) -1, -1, -1):
            num = nums[i]
            new_sum = nums[i]
            for neighbor in [num + 1, num - 1]:
                if neighbor in past_seqs:
                    (seq_count, seq_sum) = past_seqs[neighbor]
                    seqs[i] += seq_count
                    seqs[i] %= quotient 
                    new_sum += seq_sum
                    new_sum += seq_count * nums[i]
                    new_sum %= quotient
                    
            if num in past_seqs:
                past_count, past_sum = past_seqs[num]
                past_seqs[num] = ((past_count + seqs[i])%quotient, (new_sum + past_sum)%quotient)
            else:
                past_seqs[num] = (seqs[i], new_sum)
        ans = 0 
        for (i, num) in past_seqs.items():
            ans += num[1]
            ans %= quotient 
        return ans",1448233795
Anson Lai,ansonll,239,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        if k > n // 2: 
            return False
        
        dp = [1] * (n)
        for i in range(1, n):
            if nums[i] > nums[i - 1]:
                dp[i] = dp[i - 1] + 1
            if dp[i] >= k and dp[i - k] >= k:
                return True

        return False",1448185682
Anson Lai,ansonll,239,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        
        def check(nums, k):
            n = len(nums)

            dp = [1] * (n)
            for i in range(1, n):
                if nums[i] > nums[i - 1]:
                    dp[i] = dp[i - 1] + 1
                if dp[i] >= k and dp[i - k] >= k:
                    return True

            return False
        
        l, r = 0, len(nums) // 2
        while l < r:
            m = l + (r - l + 1) // 2
            if check(nums, m):
                l = m
            else:
                r = m - 1
        return l
                ",1448189514
Anson Lai,ansonll,239,3631,python3,"

class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        MOD = 10**9 + 7
        n = s
        L = len(n)
        max_cnt = L

        steps = [float('inf')] * (max_cnt + 1)
        for cnt in range(1, max_cnt + 1):
            c = cnt
            stp = 0
            while c != 1:
                c = bin(c).count('1')
                stp += 1
            steps[cnt] = stp

        k_counts = set()
        for cnt in range(1, max_cnt + 1):
            if steps[cnt] + 1 <= k:
                k_counts.add(cnt)

        dp = [ [ [0]*2 for _ in range(L + 2) ] for _ in range(2) ]
        dp[0][0][1] = 1

        for pos in range(L):
            curr_dp = dp[pos % 2]
            next_dp = dp[(pos + 1) % 2]
            for ones in range(L + 1):
                next_dp[ones][0] = 0
                next_dp[ones][1] = 0

            d = int(n[pos])
            for ones in range(L + 1):
                for t in [0, 1]:
                    cnt = curr_dp[ones][t]
                    if cnt == 0:
                        continue
                    max_d = d if t else 1
                    for digit in [0, 1]:
                        if digit > max_d:
                            continue
                        new_ones = ones + digit
                        if new_ones > L:
                            continue
                        new_t = t and (digit == max_d)
                        next_dp[new_ones][new_t] = (next_dp[new_ones][new_t] + cnt) % MOD

        ans = 0
        for ones in range(1, L + 1):
            if ones in k_counts:
                ans += dp[L % 2][ones][0]
                ans += dp[L % 2][ones][1]
                ans %= MOD
        n_ones = n.count('1')
        if n_ones in k_counts:
            ans = (ans - 1 + MOD) % MOD

        return ans",1448250030
Anson Lai,ansonll,239,3646,python3,"MOD = 10**9 + 7
class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        max_num = max(nums) + 2
        count = [0] * max_num
        total = [0] * max_num

        result = 0

        for num in nums:
            new_count = 1
            new_total = num

            for diff in [-1, 1]:
                neighbor = num + diff
                if 0 <= neighbor < max_num and count[neighbor] > 0:
                    new_count = (new_count + count[neighbor]) % MOD
                    new_total = (new_total + total[neighbor] + count[neighbor] * num) % MOD

            count[num] = (count[num] + new_count) % MOD
            total[num] = (total[num] + new_total) % MOD

            result = (result + new_total) % MOD

        return result",1448220443
prashant_kashyap9759,prashant_kashyap9759,240,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n=nums.size();
        vector<int>right(n+1);
        right[n-1]=1;
        for(int i=n-2;i>-1;i--){
            if(nums[i]<nums[i+1])right[i]=1+right[i+1];
            else right[i]=1;
        }
        int left=1;
        for(int i=1;i<n;i++){
            if(right[i]>=k&&left>=k)return 1;
            if(nums[i]>nums[i-1])left++;
            else left=1;
        }
        return 0;
    }
};",1448183991
prashant_kashyap9759,prashant_kashyap9759,240,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n=nums.size();
        vector<int>right(n+1);
        right[n-1]=1;
        for(int i=n-2;i>-1;i--){
            if(nums[i]<nums[i+1])right[i]=1+right[i+1];
            else right[i]=1;
        }
        int left=1, ans=1;
        for(int i=1;i<n;i++){
            ans=max(ans,min(right[i],left));
            if(nums[i]>nums[i-1])left++;
            else left=1;
        }
        return ans;
    }
};
",1448186464
prashant_kashyap9759,prashant_kashyap9759,240,3631,cpp,"class Solution {
public:
    const int q=1e9+7;
    bool vec[801];
    void help(int num,int k){
        int str=num;
        k--;
        while(k>0&&num>1){
            int cnt=0;
            while(num>0){
                cnt+=(num&1);
                num>>=1;
            }
            k--;
            num=cnt;
        }
        vec[str]=(num==1);
    }
        int solve(int idx,int cnt,bool high,string&s,vector<vector<vector<int>>>&dp){
            if(idx>=int(s.size())){
                return vec[cnt];
            }
            if(dp[idx][cnt][high]!=-1)return dp[idx][cnt][high];
            long long ans=0;
            if(high){
                ans=solve(idx+1,cnt+1,high,s,dp);
                ans=((long long)ans+solve(idx+1,cnt,high,s,dp))%q;
            }
            else{
                bool chck=high;
                if(s[idx]=='1')chck=1;
                ans=solve(idx+1,cnt,chck,s,dp);
                if(s[idx]=='1')ans=((long long)ans+solve(idx+1,cnt+1,high,s,dp))%q;
            }
            return dp[idx][cnt][high]=ans;
        }
    int countKReducibleNumbers(string s, int k) {
        int n=s.size();
        int cnt=0;
        for(auto ch:s)cnt+=(ch-'0');
        vector<vector<vector<int>>>dp(n+1,vector<vector<int>>(n+1,vector<int>(2,-1)));
        for(int i=0;i<=n;i++)help(i,k);
        cnt=vec[cnt];
        return solve(0,0,0,s,dp)-cnt;
    }
};",1448271777
prashant_kashyap9759,prashant_kashyap9759,240,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int q=1e9+7;
        unordered_map<int,pair<int,int>>ump;
        long long ans=0;
        for(auto num:nums){
            pair<int,int> total={0,0};
            if(ump.count(num-1))total=ump[num-1];
            if(ump.count(num+1)){
                auto item=ump[num+1];
                total.first=((long long)total.first+item.first)%q;
                total.second=((long long)total.second+item.second)%q;
            }
            long long curr=((long long)total.first+((long long)total.second*1ll*num)%q)%q;
            curr=((long long)curr+num)%q;
            auto item=ump[num];
            auto x=((long long)(total.second+1))%q;
            x=((long long)x+item.second)%q;
            ump[num]={((long long)curr+item.first)%q,x};
                ans=((long long)ans+curr)%q;
        }
        return ans;
    }
};",1448214475
svmh,SupervisorMayHap,243,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)


        def check(arr):
            for i in range(1, len(arr)):
                if arr[i] <= arr[i - 1]:
                    return False
            return True
        
        for i in range(n - 2 * k + 1):
            if check(nums[i:i + k]) and check(nums[i+k:i +k+k]):
                return True

        return False
            ",1448182198
svmh,SupervisorMayHap,243,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        last = 0
        res = 0

        cur = 1
        n = len(nums)
        for i in range(1, n):
            if nums[i] > nums[i-1]:
                cur += 1
            else:
                last = cur
                cur = 1
            res = max(res, cur // 2, min(last, cur))
        return res

        ",1448187250
svmh,SupervisorMayHap,243,3631,python3,"from functools import lru_cache

class Solution:


    def countKReducibleNumbers(self, s: str, k: int) -> int:
        mod = 1000000007
    
        n = len(s)
        dp = {}
        for i in range(1, n + 1):
            cur = i
            count = 0
            while cur > 1:
                cur = bin(cur).count('1')
                count += 1
            dp[i] = count
    
        dp1 = [[0, 0] for _ in range(n + 1)]
        dp1[0][1] = 1
    
        for i in range(n):
            dp2 = [[0, 0] for _ in range(n + 1)]
            for j in range(0, i + 1):
                if dp1[j][0]:
                    new_j = j
                    dp2[new_j][0] = (dp2[new_j][0] + dp1[j][0]) % mod
    
                    new_j = j + 1
                    dp2[new_j][0] = (dp2[new_j][0] + dp1[j][0]) % mod
    
                if dp1[j][1]:
                    flag = int(s[i]) 
                    new_flag = 1 if (0 == flag) else 0
                    dp2[j][new_flag] = (dp2[j][new_flag] + dp1[j][1]) % mod
    
                    if 1 <= flag:
                        new_j = j + 1
                        new_flag = 1 if (1 == flag) else 0
                        dp2[new_j][new_flag] = (dp2[new_j][new_flag] + dp1[j][1]) % mod
            dp1 = dp2 
    
        res = 0
        for i in range(1, n + 1):
            if dp[i] <= k - 1:
                res = (res + dp1[i][0]) % mod
        return res",1448272173
svmh,SupervisorMayHap,243,3646,python3,"from collections import defaultdict


class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        mod = 1000000007
        dp = defaultdict(int)
        cnt = defaultdict(int)
        res = 0
        for num in nums:
            if num - 1 in cnt:
                cnt[num] += cnt[num - 1]
                dp[num] += dp[num - 1] + num * cnt[num - 1]
                res += dp[num - 1] + num * cnt[num - 1]
            if num + 1 in cnt:
                cnt[num] += cnt[num + 1]
                dp[num] += dp[num + 1] + num * cnt[num + 1]
                res += dp[num + 1] + num * cnt[num + 1]
            cnt[num] += 1
            cnt[num] %= mod
    
            dp[num] += num
            dp[num] %= mod
    
            res += num
            res %= mod
            # print(cnt, dp)
        # print(dp)
        return res",1448206244
尾玉,louisfghbvc,244,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        // goal: find two length k
        
        
        int n = nums.size();
        vector<int> arr;
        for (int i = 0, j; i < n; i = j) {
            j = i;
            while (j < n) {
                if (j != i) {
                    if (nums[j] <= nums[j-1]) break;
                }
                j++;
            }
            arr.push_back(j-i);
        }
        
        int ans = 0;
        for (int i = 0; i < arr.size(); ++i) {
            ans = max(ans, arr[i]/2);
            if (i+1 < arr.size()) 
                ans = max(ans, min(arr[i], arr[i+1]));
        }
        return ans >= k;
    }
};",1448230543
尾玉,louisfghbvc,244,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        // goal: find the maximum increasing array such that two subarray is strictly increase
        
        // idea:
        // visited number at most once
        // starting from each smallest number
        // two possible
        // 1. self half
        // 2. min(arr[i], arr[i+1])
        
        int n = nums.size();
        vector<int> arr;
        for (int i = 0, j; i < n; i = j) {
            j = i;
            while (j < n) {
                if (j != i) {
                    if (nums[j] <= nums[j-1]) break;
                }
                j++;
            }
            arr.push_back(j-i);
        }
        
        int ans = 0;
        for (int i = 0; i < arr.size(); ++i) {
            ans = max(ans, arr[i]/2);
            if (i+1 < arr.size()) 
                ans = max(ans, min(arr[i], arr[i+1]));
        }
        return ans;
    }
};",1448230330
尾玉,louisfghbvc,244,3631,cpp,"class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        // goal: count the number such that we can reduce the value to 1 at most k times
        
        // idea: digit dp
        // dp[i][isbound][isZ][cnt]: number of ways, starting from index i, is leading zero
        
        int mod = 1e9+7;
        
        int n = s.size();
        vector dp(n, vector(2, vector(2, vector(n+1, -1))));
        
        auto eval = [&](int x) {
            int cnt = 1;
            while (x != 1) {
                cnt++;
                x = __builtin_popcount(x);
            }   
            return cnt;
        };
        
        auto dfs = [&](auto &self, int i, int isB, int isZ, int cnt) -> int {
            if (i >= n) return (!isZ && eval(cnt) <= k);
            
            auto& res = dp[i][isB][isZ][cnt];
            if (res != -1) return res;
            
            res = 0;
            int b = isB ? s[i]-'0' : 1;
            for (int d = 0; d <= b; ++d) {
                int nB = isB && (d == s[i]-'0');
                int nisZ = isZ && (d == 0);
                // speical case one
                if (i == n-1 && isZ && d == 1)
                    res = (res + 1) % mod;
                else
                    res = (res + self(self, i+1, nB, nisZ, cnt + (d==1))) % mod;
            }
            
            return res;
        };
        
        // check if self is reducible
        int one = count(s.begin(), s.end(), '1');
        // cout << one << endl;
        
        return (dfs(dfs, 0, 1, 1, 0) - (eval(one)<=k) + mod) % mod;
    }
};",1448272311
尾玉,louisfghbvc,244,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        // goal: find the sum of all good subsequence
        // good seq: adj dif by 1
        
        // idea:
        // [1,2,1,1,2]
        //  ^ 1     2
        
        // think about dp
        // do reverse
        // x => try to add previous x-1, 
        // dp[i] += dp[j], a[i]=a[j]-1/a[j]+1
        
        // think distribution
        // [1,2,1,3,1,2]
        //  x will increase a[x-1], a[x+1] sum        
        
        // dp[i]: ending at index i, number of subsequence
        // two dp, first is sum, second is cnt
        
        // 1,2,1
        // [1], s=1,c=1
        // [1,2] [2], s=5,c=2
        // [1,2,1], [2,1], [1], s=5+c*x, c=3
        
        // what is duplicate?
        // [10,10,1,9]
        // [10]
        // [10]
        // [1]
        // [10,9],[10,9],[9]
        
        int mod = 1e9+7;
        unordered_map<int, long> sum, cnt;
        
        long ans = 0;
        for (long x: nums) {
            long prev_sum = sum[x-1] + sum[x+1];
            long prev_cnt = cnt[x-1] + cnt[x+1];
            cnt[x] += prev_cnt+1;
            cnt[x] %= mod;
            
            long add = prev_sum + (prev_cnt+1)*x;
            ans = (ans + add) % mod;
            sum[x] += add;
            sum[x] %= mod;
        }
        return ans;
    }
};",1448238596
Rahul Singh,Pirate-Emperor,246,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& arr, int k) {
        int n=arr.size();
        vector<int> dif;
        int a=0;
        for (int i=0;i<n;i++)
        {
            if (i==0) a++;
            else
            {
                if (arr[i]<=arr[i-1])
                {
                    dif.push_back(a);
                    a=1;
                }
                else a++;
            }
        }
        if (a>0) dif.push_back(a);
        int resu=0;
        int b=0;
        for (int i=0;i<dif.size();i++)
        {
            if (i!=0) resu=max(resu,min(dif[i],dif[i-1]));
            b=max(dif[i],b);
        }
        resu=max(resu,b/2);
        return resu>=k;
}
};",1448198628
Rahul Singh,Pirate-Emperor,246,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& arr) {
        int n=arr.size();
        vector<int> dif;
        int a=0;
        for (int i=0;i<n;i++)
        {
            if (i==0) a++;
            else
            {
                if (arr[i]<=arr[i-1])
                {
                    dif.push_back(a);
                    a=1;
                }
                else a++;
            }
        }
        if (a>0) dif.push_back(a);
        int resu=0;
        int b=0;
        for (int i=0;i<dif.size();i++)
        {
            if (i!=0) resu=max(resu,min(dif[i],dif[i-1]));
            b=max(dif[i],b);
        }
        resu=max(resu,b/2);
        return resu;
    }
};",1448199907
Rahul Singh,Pirate-Emperor,246,3631,cpp,"#define ll long long

class Solution {
public:
    ll MOD = 1e9+7;
    ll qexp(ll a, ll b, ll m) {
        ll res = 1;
        while (b) {
            if (b % 2) res = res * a % m;
            a = a * a % m;
            b /= 2;
        }
        return res;
    }
    vector<ll> fact, invf;

    void precompute(int n) {
        fact.assign(n + 1, 1); 
        for (int i = 1; i <= n; i++) fact[i] = fact[i - 1] * i % MOD;
        invf.assign(n + 1, 1);
        invf[n] = qexp(fact[n], MOD - 2, MOD);
        for (int i = n - 1; i > 0; i--) invf[i] = invf[i + 1] * (i + 1) % MOD;
    }

    ll nCk(int n, int k) {
        if (k < 0 || k > n) return 0;
        return fact[n] * invf[k] % MOD * invf[n - k] % MOD;
    }
    int countKReducibleNumbers(string s, int k) {
        int n = s.size();
        precompute(n+100);
        vector<long long> dp(n+1,0);
        dp[0]=0;
        dp[1]=1;
        for (int i=2;i<=n;i++)
        {
            dp[i] = dp[__builtin_popcount(i)]+1;
        }
        
        long long a=0;
        ll resu=0;
        for (int i=0;i<n;i++)
        {
            if (s[i]=='0') continue;
            for (int j=0;j<n-i;j++)
            {
                long long tem=a+j;
                if (tem<=0) continue;
                if (dp[tem]<=k) 
                {
                    resu = (resu + nCk(n-i-1,j))%MOD;;
                }
            }
            a++;
        }
        
        return resu;
    }
};",1448265742
Rahul Singh,Pirate-Emperor,246,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& arr) {
        int n=arr.size();
        long long MOD=1e9+7,resu=0;
        vector<long long> dp(1e5+10,0),sdp(1e5+10,0);
        for (int i=0;i<n;i++)
        {
            long long tem=0;
            if (arr[i]!=0) 
            {
                dp[arr[i]]=(dp[arr[i]]+dp[arr[i]-1])%MOD;
                sdp[arr[i]]=(sdp[arr[i]]+sdp[arr[i]-1])%MOD;
                tem = (tem+dp[arr[i]-1])%MOD;
            }
            dp[arr[i]]=(dp[arr[i]]+dp[arr[i]+1])%MOD;
            sdp[arr[i]]=(sdp[arr[i]]+sdp[arr[i]+1])%MOD;
            tem = (tem+dp[arr[i]+1]+1)%MOD;
            dp[arr[i]]=(dp[arr[i]]+1)%MOD;
            sdp[arr[i]] = (sdp[arr[i]] + (tem*arr[i])%MOD)%MOD;
        }
        for (int i=0;i<1e5+10;i++)
        {
            resu = (resu + sdp[i])%MOD;
        }
        return  resu;
    }
};",1448225919
Lucky Orb,megurine,247,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, a: List[int], k: int) -> bool:
        n = len(a)
        f1 = [0] * (n + 1)
        f2 = [0] * (n + 2)
        p = -inf
        for i in range(n):
            if a[i] > p:
                f1[i + 1] = f1[i] + 1
            else:
                f1[i + 1] = 1
            p = a[i]
        p = inf
        for i in range(n - 1, -1, -1):
            if a[i] < p:
                f2[i + 1] = f2[i + 2] + 1
            else:
                f2[i + 1] = 1
            p = a[i]
        # print(f1, f2)
        for i in range(n):
            if f1[i + 1] >= k and f2[i + 2] >= k:
                return True
        return False",1448187126
Lucky Orb,megurine,247,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, a: List[int]) -> bool:
        n = len(a)
        f1 = [0] * (n + 1)
        f2 = [0] * (n + 2)
        p = -inf
        for i in range(n):
            if a[i] > p:
                f1[i + 1] = f1[i] + 1
            else:
                f1[i + 1] = 1
            p = a[i]
        p = inf
        for i in range(n - 1, -1, -1):
            if a[i] < p:
                f2[i + 1] = f2[i + 2] + 1
            else:
                f2[i + 1] = 1
            p = a[i]
        lo, hi = 0, n
        while lo < hi:
            mid = (lo + hi + 1) // 2
            for i in range(n):
                if f1[i + 1] >= mid and f2[i + 2] >= mid:
                    lo = mid
                    break
            else:
                hi = mid - 1
        return lo",1448192696
Lucky Orb,megurine,247,3631,python3,"mod = int(1e9 + 7)
class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        m = len(s)
        f = [False] * (m + 1)
        for v in range(1, m + 1):
            vv = v
            op = 1
            while v > 1 and op < k:
                v = v.bit_count()
                op += 1
            f[vv] = op <= k and v == 1
        
        A = list(map(int, s[::-1]))
        mem = {}
        def dfs(pos, pre, rem, is_limit, is_valid):
            if pos < 0:
                return int(is_valid and f[rem])
            if not is_limit and is_valid and (pos, pre, rem) in mem:
                return mem[pos, pre, rem]
            cur = 0
            for x in range(2):
                if not is_limit or A[pos] >= x:
                    cur += dfs(pos - 1, x, rem + x, is_limit and x == A[pos], is_valid or x > 0)
                    cur %= mod
            if not is_limit and is_valid:
                mem[pos, pre, rem] = cur
            return cur
        ans = dfs(len(A) - 1, 0, 0, True, False)
        tmp = s.count('1')
        op = 1
        while tmp > 1 and op < k:
            tmp = tmp.bit_count()
            op += 1
        ans -= op <= k and tmp == 1
        mem.clear()
        return ans % mod
# sol = Solution()
# print(sol.countKReducibleNumbers('1' * 800, 5))
        ",1448251855
Lucky Orb,megurine,247,3646,python3,"mod = int(1e9 + 7)
class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        f1 = Counter() # 以x为结尾的序列的和
        f2 = Counter() # 以x为结尾的序列的数量
        for x in nums:
            v1 = f1[x] + x
            v2 = f2[x] + 1
            if x - 1 in f1:
                v1 += f1[x - 1] + f2[x - 1] * x
                v2 += f2[x - 1]
            if x + 1 in f1:
                v1 += f1[x + 1] + f2[x + 1] * x
                v2 += f2[x + 1]
            f1[x] = v1 % mod
            f2[x] = v2 % mod
        ans = 0
        for x in f1:
            ans += f1[x]
            ans %= mod
        return ans
        ",1448209047
Adithya V,astronom1cal,250,3612,cpp,"#include <iostream>
#include <cstdlib>
#include <ctime>
#include <climits>
#include <numeric>
#include <iomanip>
#include <fstream>
#include <string>
#include <algorithm>
#include <cmath>
#include <bitset>
#include <utility>
#include <array>
#include <vector>
#include <deque>
#include <forward_list>
#include <list>
#include <set>
#include <unordered_set>
#include <map>
#include <unordered_map>
#include <stack>
#include <queue>
#include <functional>
#include <popcntintrin.h>
#include <ext/pb_ds/assoc_container.hpp>

// LLONG_MAX is 9,223,372,036,854,775,807 (19 digits)
// ULLONG_MAX is 18,446,744,073,709,551,615 (20 digits)

using namespace __gnu_pbds;
template <typename T>
using ordered_set = tree<T, null_type, std::less<T>, rb_tree_tag, tree_order_statistics_node_update>;
template <typename T>
using ordered_multiset = tree<std::pair<T, T>, null_type, std::less<std::pair<T, T>>, rb_tree_tag, tree_order_statistics_node_update>;

// use a map to keep track of duplicates in ordered multiset, like 2-1, 2-2, 2-3, and so on

using ll = long long;
using ld = long double;
using namespace std;

class Solution
{
public:
    bool hasIncreasingSubarrays(vector<int> &nums, int k)
    {
        ll n = (ll) nums.size();

        if (k == 1)
        {
            return true;
        }

        for (ll i = 0; i <= n - 2 * k; i++)
        {
            bool ok = true;
            ll j = i + 1;

            while (j < i + k)
            {
                if ((nums[j] <= nums[j - 1]) || (nums[j + k] <= nums[j + k - 1]))
                {
                    ok = false;
                }

                j++;
            }

            if (ok)
            {
                return true;
            }
        }

        return false;
    }
};",1448184059
Adithya V,astronom1cal,250,3619,cpp,"#include <iostream>
#include <cstdlib>
#include <ctime>
#include <climits>
#include <numeric>
#include <iomanip>
#include <fstream>
#include <string>
#include <algorithm>
#include <cmath>
#include <bitset>
#include <utility>
#include <array>
#include <vector>
#include <deque>
#include <forward_list>
#include <list>
#include <set>
#include <unordered_set>
#include <map>
#include <unordered_map>
#include <stack>
#include <queue>
#include <functional>
#include <popcntintrin.h>
#include <ext/pb_ds/assoc_container.hpp>

// LLONG_MAX is 9,223,372,036,854,775,807 (19 digits)
// ULLONG_MAX is 18,446,744,073,709,551,615 (20 digits)

using namespace __gnu_pbds;
template <typename T>
using ordered_set = tree<T, null_type, std::less<T>, rb_tree_tag, tree_order_statistics_node_update>;
template <typename T>
using ordered_multiset = tree<std::pair<T, T>, null_type, std::less<std::pair<T, T>>, rb_tree_tag, tree_order_statistics_node_update>;

// use a map to keep track of duplicates in ordered multiset, like 2-1, 2-2, 2-3, and so on

using ll = long long;
using ld = long double;
using namespace std;

class Solution
{
public:
    int maxIncreasingSubarrays(vector<int> &nums)
    {
        ll n = (ll) nums.size();

        ll cnt = 0;

        vector<ll> len(n, 1);
        ll ans = 1;

        for (ll i = n - 2; i >= 0; i--)
        {
            if (nums[i] < nums[i + 1])
            {
                len[i] = len[i + 1] + 1;
            }

            ans = max(ans, len[i] / 2);

            if (i + len[i] < n && len[i + len[i]] >= len[i])
            {
                ans = max(ans, len[i]);
            }
        }

        return ans;
    }
};",1448198861
Adithya V,astronom1cal,250,3631,cpp,"#include <iostream>
#include <cstdlib>
#include <ctime>
#include <climits>
#include <numeric>
#include <iomanip>
#include <fstream>
#include <string>
#include <algorithm>
#include <cmath>
#include <bitset>
#include <utility>
#include <array>
#include <vector>
#include <deque>
#include <forward_list>
#include <list>
#include <set>
#include <unordered_set>
#include <map>
#include <unordered_map>
#include <stack>
#include <queue>
#include <functional>
#include <popcntintrin.h>
#include <ext/pb_ds/assoc_container.hpp>

// LLONG_MAX is 9,223,372,036,854,775,807 (19 digits)
// ULLONG_MAX is 18,446,744,073,709,551,615 (20 digits)

using namespace __gnu_pbds;
template <typename T>
using ordered_set = tree<T, null_type, std::less<T>, rb_tree_tag, tree_order_statistics_node_update>;
template <typename T>
using ordered_multiset = tree<std::pair<T, T>, null_type, std::less<std::pair<T, T>>, rb_tree_tag, tree_order_statistics_node_update>;

// use a map to keep track of duplicates in ordered multiset, like 2-1, 2-2, 2-3, and so on

using ll = long long;
using ld = long double;
using namespace std;

// Modular Inverse (modinv)

// Given a number a and mod m, consider the equation a * ainv = 1 (mod m)
// Basically (a * ainv) % m = 1
// ainv is the modular inverse of a

// Uses extended euclidean algorithm to find x for a.x + m.y = 1
// then make x positive and take mod
// that gives us the modular inverse of a

// Example: the modular inverse of 3 wrt 7 is 5
// (3 * 5) % 7 = 1
// 15 % 7 = 1

// Works in O(log(min(a, m))) time

pair<ll, ll> extended_euclidean(ll a, ll b)
{
    if (b == 0)
    {
        return {1, 0};
    }

    auto [x, y] = extended_euclidean(b, a % b);

    return {y, x - y * (a / b)};
}

ll modinv(ll a, ll m)
{
    ll x = extended_euclidean(a, m).first;

    return (x % m + m) % m;
}

class Solution
{
public:
    int countKReducibleNumbers(string s, int k)
    {
        ll n = (ll)s.length();

        auto good = [&](ll cnt)
        {
            ll K = k - 1;

            while (K > 0)
            {
                cnt = __builtin_popcount(cnt);
                K--;
            }

            return (cnt == 1);
        };

        vector<ll> fact(n + 1);
        vector<ll> inv_fact(n + 1);

        fact[0] = fact[1] = inv_fact[0] = inv_fact[1] = 1;

        const ll mod = 1e9 + 7;

        for (ll i = 2; i <= n; i++)
        {
            fact[i] = (fact[i - 1] * i) % mod;
            inv_fact[i] = modinv(fact[i], mod);
        }

        auto C = [&](ll N, ll R)
        {
            return ((fact[N] * ((inv_fact[N - R] * inv_fact[R]) % mod)) % mod);
        };

        ll ans = 0;

        for (ll i = 0; i < n; i++)
        {
            if (i == 0)
            {
                ll cnt = 1;

                for (ll k = 1; k < n; k++)
                {
                    if (s[k] == '1')
                    {
                        ll empty = n - k - 1;

                        for (ll j = 0; j <= empty; j++)
                        {
                            if (good(cnt + j))
                            {
                                ans += C(empty, j);
                                ans %= mod;
                            }
                        }

                        cnt++;
                    }
                }
            }

            else
            {
                ll empty = n - i - 1;

                for (ll j = 0; j <= empty; j++)
                {
                    if (good(j + 1))
                    {
                        ans += C(empty, j);
                        ans %= mod;
                    }
                }
            }
        }

        return ans;
    }
};",1448267012
Adithya V,astronom1cal,250,3646,cpp,"#include <iostream>
#include <cstdlib>
#include <ctime>
#include <climits>
#include <numeric>
#include <iomanip>
#include <fstream>
#include <string>
#include <algorithm>
#include <cmath>
#include <bitset>
#include <utility>
#include <array>
#include <vector>
#include <deque>
#include <forward_list>
#include <list>
#include <set>
#include <unordered_set>
#include <map>
#include <unordered_map>
#include <stack>
#include <queue>
#include <functional>
#include <popcntintrin.h>
#include <ext/pb_ds/assoc_container.hpp>

// LLONG_MAX is 9,223,372,036,854,775,807 (19 digits)
// ULLONG_MAX is 18,446,744,073,709,551,615 (20 digits)

using namespace __gnu_pbds;
template <typename T>
using ordered_set = tree<T, null_type, std::less<T>, rb_tree_tag, tree_order_statistics_node_update>;
template <typename T>
using ordered_multiset = tree<std::pair<T, T>, null_type, std::less<std::pair<T, T>>, rb_tree_tag, tree_order_statistics_node_update>;

// use a map to keep track of duplicates in ordered multiset, like 2-1, 2-2, 2-3, and so on

using ll = long long;
using ld = long double;
using namespace std;

class Solution
{
public:
    int sumOfGoodSubsequences(vector<int> &nums)
    {
        ll n = (ll) nums.size();

        ll mx = *max_element(nums.begin(), nums.end());

        vector<ll> cnt(mx + 1, 0);
        vector<ll> sum(mx + 1, 0);

        const ll mod = 1e9 + 7;

        for (ll i = 0; i < n; i++)
        {
            ll x = nums[i] - 1, y = nums[i] + 1;

            if (x >= 0 && x <= mx)
            {
                cnt[nums[i]] += cnt[x];
                cnt[nums[i]] %= mod;

                sum[nums[i]] += (sum[x] + (cnt[x] * nums[i]) % mod) % mod;
                sum[nums[i]] %= mod;
            }

            if (y >= 0 && y <= mx)
            {
                cnt[nums[i]] += cnt[y];
                cnt[nums[i]] %= mod;

                sum[nums[i]] += (sum[y] + (cnt[y] * nums[i]) % mod) % mod;
                sum[nums[i]] %= mod;
            }

            cnt[nums[i]]++;
            sum[nums[i]] += nums[i];
        }

        ll ans = 0;

        for (ll i = 0; i <= mx; i++)
        {
            ans += sum[i];
            ans %= mod;
        }

        return ans;
    }
};",1448224039
Yucheng Dai,Rainingcity,251,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        for(int i = 0; i + 2 * k <= n; i++) {
            bool flag = true;
            for(int j = i + 1; j < i + k; j++) {
                if (nums[j] <= nums[j - 1]) flag = false;
            }
            for(int j = i + k + 1; j < i + 2 * k; j++) {
                if (nums[j] <= nums[j - 1]) flag = false;
            }
            if (flag) return true;
        }
        return false;
    }
};",1448181974
Yucheng Dai,Rainingcity,251,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<pair<int, int>> v{}; // inc segs
        int i = 0;
        while(i < n) {
            int j = i + 1;
            while(j < n && nums[j] > nums[j - 1]) j++;
            v.push_back(make_pair(i, j));
            i = j;
        }
        // for(auto x: v) {
        //     cout << x.first << "" "" << x.second << endl;
        // }
        int ans = 0;
        for(int i = 0; i < v.size(); i++) {
            ans = max(ans, (v[i].second - v[i].first) / 2);
            if (i > 0) {
                ans = max(ans, min(v[i].second - v[i].first, v[i - 1].second - v[i - 1].first));
            }
        }
        return ans;
    }
};",1448192822
Yucheng Dai,Rainingcity,251,3631,cpp,"const int MOD = 1000000007;
int getSB(int x) {
    int res = 0;
    while(x != 0) {
        x -= x & (-x);
        res++;
    }
    return res;
}
void buildC(int C[801][801], int n) {
    C[0][0] = C[1][0] = C[1][1] = 1;
    for(int i = 2; i <= n; i++) {
        C[i][0] = C[i][i] = 1;
        for(int j = 1; j < i; j++) {
            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
        }
    }
}
class Solution {
private:
    int red[801];
    int C[801][801];
    int getFull(int n, int prev, int k) {
        int res = 0;
        for(int i = 0; i <= n; i++) {
            if (red[prev + i] < k) {
                res = (res + C[n][i]) % MOD;
            }
        }
        return res;
    }
public:
    Solution() {
        // build red
        red[0] = 0;
        for(int i = 1; i <= 800; i++) {
            int tmp = i;
            red[i] = 0;
            while(tmp != 1) {
                red[i]++;
                tmp = getSB(tmp);
            }
        }
        // build C
        buildC(C, 800);
    }
    int countKReducibleNumbers(string s, int k) {
        int n = s.length();
        int prev = 0;
        int ans = 0;
        for(int i = 0; i < n; i++) {
            if (s[i] == '1') {
                ans = (ans + getFull(n - i - 1, prev, k)) % MOD;
                prev++;
            }
        }
        return (ans - 1 + MOD) % MOD;
    }
};",1448267071
Yucheng Dai,Rainingcity,251,3646,cpp,"typedef long long ll;
const ll MOD = 1000000007;
class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int mx = 0;
        vector<ll> sums(100100, 0);
        vector<ll> cnts(100100, 0);
        for(int x: nums) {
            x++;
            mx = max(mx, x);
            ll xcnt = 1 + cnts[x - 1] + cnts[x + 1];
            sums[x] = (sums[x] + sums[x - 1] + sums[x + 1] + xcnt * (x - 1)) % MOD;
            cnts[x] = (cnts[x] + xcnt) % MOD;
        }
        ll ans = 0;
        for(int i = 0; i <= mx; i++) {
            ans = (ans + sums[i]) % MOD;
        }
        return (int)ans;
    }
};",1448211015
James Jialun Zhao,frixxxer,252,3612,python3,"class Solution:
    
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        def search_from(nums, k, i):
            last = -10000
            for j in range(k):
                if i + j >= len(nums) or nums[i + j] <= last:
                    return False
                last = nums[i+j]
            return True
        for i in range(len(nums)):
            if search_from(nums, k, i) and search_from(nums, k, i + k):
                return True
        return False",1448184903
James Jialun Zhao,frixxxer,252,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        last = None
        chain = 0
        lisa = [1] * len(nums)
        for i, n in enumerate(nums):
            if last is None or n <= last:
                chain = 1
            else:
                chain += 1
            last = n
            lisa[i] = chain
        lo, hi = 0, len(nums) // 2 + 1
        def check(lisa, k):
            # 0 1 2 3 4 5 6 7 8 9 10
            for i in range(k - 1, len(lisa) - k):
                if lisa[i] >= k and lisa[i + k] >= k:
                    return True
            return False
        while lo < hi:
            mi = (lo + hi) // 2
            val = not check(lisa, mi)
            if not val:
                lo = mi + 1
            else:
                hi = mi
        return lo - 1",1448198838
James Jialun Zhao,frixxxer,252,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        set_bits = s.count(""1"")
        mod = 1_000_000_007

        @cache
        def reducible(n, k):
            if type(n) == int:
                n = bin(n)[2:]
            if n == ""1"":
                return True
            if k == 0 or n == ""0"":
                return False
            else:
                ct = bin(n.count(""1""))[2:]
                return reducible(ct, k-1)

        # for i in range(5):
        #     print(i, reducible(i, k))
        @cache
        def ct_reducible(bits, offset):
            nonlocal k, mod
            if bits < 0:
                z = reducible(offset, k-1)
                o = 0
            elif bits == 0:
                z = reducible(0 + offset, k - 1)
                o = reducible(1 + offset, k - 1)
            else:
                z = ct_reducible(bits - 1, offset)
                o = ct_reducible(bits - 1, offset + 1)
            # print(f""ct_reducible {bits=} {offset=} {(z+o) % mod}"")
            return (z + o) % mod
        summ = 0
        off = 0
        for i, c in enumerate(s):
            bits = len(s) - 1 - i
            if c == ""1"":
                summ = (summ + ct_reducible(bits - 1, off)) % mod
                off += 1
        extras = [reducible(r, k - 1) for r in range(1, set_bits)]
        # print(f""{extras=}"")
        return (summ) % mod
            ",1448280886
James Jialun Zhao,frixxxer,252,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        freq, sums = defaultdict(int), defaultdict(int)
        mod = 1_000_000_007
        for n in nums:
            f_nm1, s_nm1 = freq[n-1], sums[n-1]
            f_np1, s_np1 = freq[n+1], sums[n+1]
            s_nm1 += f_nm1 * n
            s_np1 += f_np1 * n
            sums[n] += (s_nm1 + s_np1 + n) % mod
            freq[n] += (f_nm1 + f_np1 + 1) % mod
        return reduce(lambda acc, x: (acc + x) % mod, sums.values(), 0)",1448211551
icicl,icicl,256,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        for i in range(len(nums)-2*k+1):
            if all(nums[i+j] < nums[i+j+1] and nums[i+j+k] < nums[i+j+k+1] for j in range(k-1)): return True
        return False",1448182004
icicl,icicl,256,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        run = [1]*len(nums)
        for i in range(1,len(nums)):
            if nums[i] > nums[i-1]: run[i] = run[i-1]+1
        l = 1
        r = len(nums)
        while r > l+1:
            m = (l+r)//2
            ok = False
            for i in range(m):
                prev = False
                for j in run[i::m]:
                    if j >= m:
                        if prev: ok = True
                        prev = True
                    else:
                        prev = False
            if ok:
                l = m
            else:
                r = m
        return l
        ",1448194383
icicl,icicl,256,3631,python3,"M = 10**9+7

@lru_cache(maxsize=1024)
def fact(n):
    if n < 2: return 1
    return (fact(n-1)*n)%M

@lru_cache(maxsize=(1<<16))
def ncr(n,r):
    return (fact(n)*pow(fact(r),-1,M)*pow(fact(n-r),-1,M))%M

class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        onepos = []
        result = 0
        for i in range(len(s)):
            if s[-1-i] == '1': onepos.append(i)
        for numbits in range(1,len(s)+1):
            b = numbits
            for _ in range(k-1):
                b = bin(b).count('1')
            if b > 1: continue
            nb = numbits
            m = 1
            for op in onepos[::-1]:
                if op < nb: break
                result += ncr(op, nb)
#                print(nb,op,result)
                nb -= 1
                if nb < 0: break
        return result%(10**9+7)
            ",1448252943
icicl,icicl,256,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        tally = {}
        for i in nums:
            if not i in tally: tally[i] = [0,0]
            tally[i][0] += i
            tally[i][1] += 1
            if i-1 in tally:
                tally[i][0] += tally[i-1][0] + i*tally[i-1][1]
                tally[i][1] += tally[i-1][1]
            if i+1 in tally:
                tally[i][0] += tally[i+1][0] + i*tally[i+1][1]
                tally[i][1] += tally[i+1][1]
#            print(tally)
        return (sum(i[0] for i in tally.values()))%((10**9+7))
                ",1448210051
user9821NM,user9821NM,257,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        
        vector<int>prefix(nums.size());
        
        for(int i = 1; i < nums.size(); i++) {
            prefix[i] = prefix[i - 1] + (nums[i] > nums[i - 1] ? 1 : 0);
        }
        
        for(int i = 0; i + 2 * k - 1 < nums.size(); i++) {
            if((prefix[i + k - 1] - prefix[i] == k - 1) && (prefix[i + 2*k - 1] - prefix[i + k] == k - 1)) {
                return true;
            }
        }
        
        return false;
        
    }
};",1448200562
user9821NM,user9821NM,257,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        
        int left = 1, right = nums.size() / 2, answer = 1;
        
        vector<int>prefix(nums.size());
        
        for(int i = 1; i < nums.size(); i++) {
            prefix[i] = prefix[i - 1] + (nums[i] > nums[i - 1] ? 1 : 0);
        }
            
        auto okay = [&](int k) {
            for(int i = 0; i + 2 * k - 1 < nums.size(); i++) {
                if((prefix[i + k - 1] - prefix[i] == k - 1) && (prefix[i + 2*k - 1] - prefix[i + k] == k - 1)) {
                    return true;
                }
            }
            return false;
        };
        
        while(left <= right) {
            int mid = (left + right) / 2;
            if(okay(mid)) answer = mid, left = mid + 1;
            else right = mid - 1;
        }
        
        return answer;
    }
};",1448204760
user9821NM,user9821NM,257,3631,cpp,"class Solution {
public:
    const int N = 800 + 1;
    const int MOD = 1e9 + 7;
    
    int countKReducibleNumbers(string s, int k) {
        vector<int>isReducible(N);
        
        auto reduce = [&](int n, int len, auto &&self) -> int {
            if(n == 1) return (len < k);
            return self(__builtin_popcount(n), len + 1, self);
        };
        
        for(int i = 1; i < N; i++) {
            isReducible[i] = reduce(i, 0, reduce);
        }
        
        vector<vector<vector<int>>>dp(s.size(), vector<vector<int>>(s.size() + 1, vector<int>(2, -1)));
        
        auto f = [&](int index, int sum, int isBound, auto self) -> int {    
            if(index == s.size()) {
                return (isBound == false && isReducible[sum]);
            }
            
            if(dp[index][sum][isBound] != -1) return dp[index][sum][isBound];
            
            int one = self(index + 1, sum + 1, (isBound && s[index] == '1'), self);
            int zero = self(index + 1, sum + 0, (isBound && s[index] == '0'), self);
                        
            return dp[index][sum][isBound] = (zero + (isBound && s[index] == '0' ? 0 : one)) % MOD;
        };
        
        return f(0, 0, 1, f);
    }
};",1448268051
user9821NM,user9821NM,257,3646,cpp,"class Solution {
public:
    const int MOD = 1e9 + 7;
    const int N = 1e5 + 1;
    
    int sumOfGoodSubsequences(vector<int>& nums) {
        vector<pair<int,int>>dp(N);
        
        auto contribution = [&](int value) -> pair<int,int> {
            if(value >= N || value < 0) return {0, 0};
            return dp[value];
        };
        
        for(int i = 0; i < nums.size(); i++) {
            pair<int,int>plusOne = contribution(nums[i] + 1);
            pair<int,int>minusOne = contribution(nums[i] - 1);
            
            dp[nums[i]].first += (1 + plusOne.first + minusOne.first) % MOD; 
            dp[nums[i]].second += (nums[i] + (1ll * nums[i] * plusOne.first + 1ll * plusOne.second) % MOD + 
                                    (1ll * nums[i] * minusOne.first + 1ll * minusOne.second) % MOD) % MOD; 
            dp[nums[i]].first %= MOD; dp[nums[i]].second %= MOD;            
        }
        
        int answer = 0;
        for(auto &i : dp) answer = (answer + i.second) % MOD;
        return answer;
    }
};",1448232024
Aaryadeep,aaryadeep21122003,258,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& a, int k) {
        int n = a.size();
        vector<int> pre(n);
        pre[0] = 1;
        int ans = 0, prev = 0;
        for(int i=1;i<n;i++) {
            if(a[i]>a[i-1]) pre[i] = pre[i-1] + 1;
            else pre[i] = 1, prev = pre[i-1];
            ans = max(ans, pre[i]/2);
            ans = max(ans, min(pre[i], prev));
        }
        return ans >= k;
    }
};",1448190190
Aaryadeep,aaryadeep21122003,258,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& a) {
        int n = a.size();
        vector<int> pre(n);
        pre[0] = 1;
        int ans = 0, prev = 0;
        for(int i=1;i<n;i++) {
            if(a[i]>a[i-1]) pre[i] = pre[i-1] + 1;
            else pre[i] = 1, prev = pre[i-1];
            ans = max(ans, pre[i]/2);
            ans = max(ans, min(pre[i], prev));
        }
        return ans;
    }
};",1448187369
Aaryadeep,aaryadeep21122003,258,3631,cpp,"#define ll long long

class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        vector<ll> ways(805);
        const int mod = 1e9 + 7;
        auto add = [&](ll x, ll y) {
            return (x%mod + y%mod) % mod;
        };
        
        int n = s.size();
        int cnt = 0;
        for(int i=0;i<n;i++) {
            vector<ll> nways(805);
            if(s[i]=='1') {
                for(int j=0;j<=800;j++) {
                    nways[j] = add(nways[j], ways[j]);
                    if(j>0) nways[j] = add(nways[j], ways[j-1]);
                }
                nways[cnt] = add(nways[cnt], 1);
                cnt++;
            }
            else {
                for(int j=0;j<=800;j++) {
                    nways[j] = add(nways[j], ways[j]);
                    if(j>0) nways[j] = add(nways[j], ways[j-1]);
                }
            }
            ways = nways;
        }
        // ways[cnt] = add(ways[cnt], 1);

        auto sbits = [](int x) {
            int res = 0;
            for(int i=0;i<12;i++) {
                if(x&(1<<i)) res++;
            }
            return res;
        };

        ll ans = 0;
        
        for(int x=1;x<=800;x++) {
            int kk = k-1, val = x;
            while(kk) {
                val = sbits(val);
                kk--;
            }
            if(val==1) ans = add(ans, ways[x]); 
        }
        return ans;
    }
};",1448275089
Aaryadeep,aaryadeep21122003,258,3646,cpp,"#define ll long long

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& a) {
        const int mod = 1e9 + 7;
        int n = a.size();

        auto add = [&](ll x, ll y) {
            return (x%mod + y%mod) % mod;
        };
        
        map<int, ll> sum, ways;
        ll ans = 0;
        for(auto x: a) {
            //ans = add(ans, sum[x-1]);
            // ans = add(ans, ways[x-1]*x);
            sum[x] = add(sum[x], sum[x-1]);
            sum[x] = add(sum[x], ways[x-1]*x);
            ways[x] = add(ways[x], ways[x-1]);

            sum[x] = add(sum[x], sum[x+1]);
            sum[x] = add(sum[x], ways[x+1]*x);
            ways[x] = add(ways[x], ways[x+1]);

            sum[x] = add(sum[x], x);
            ways[x] = add(ways[x], 1);
        } 
        for(auto [x,y]: sum) {
            ans = add(ans, y);
        }
        return ans;
    }
};",1448228738
xy-li,xy-li,260,3612,python3,"from functools import cache
class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        @cache
        def check_increasing_subarray(i, k):
            # print(nums[i+1:i+k+1])
            if k == 1:
                return True
            for j in range(i + 1, i + k):
                if nums[j] <= nums[j - 1]:
                    return False
            return True
        
        for i in range(len(nums) - 2*k+1):
            # print(nums[i:i+k], nums[i+k:i+2*k],check_increasing_subarray(i, k), check_increasing_subarray(i + k, k))
            if check_increasing_subarray(i, k) and check_increasing_subarray(i + k, k):
                return True
        return False",1448187946
xy-li,xy-li,260,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        last = 0
        res = 1
        segs = []
        for i in range(n):
            if i > 0 and nums[i] <= nums[i - 1]:
                segs.append((i - last))
                last = i
        segs.append(n - last)
        res = segs[0]//2
        for i in range(1, len(segs)):
            res = max(res, segs[i]//2, min(segs[i], segs[i - 1]))
        return res",1448206400
xy-li,xy-li,260,3631,python3,"from collections import Counter
from functools import cache
M = 10**9 + 7
N = 800

frac = [1]
for i in range(1, N+1):
    frac.append(frac[-1] * i % M)

inv = [pow(num, -1, M) for num in frac]


@cache
def f(num):
    if num == 1:
        return 0
    return f(num.bit_count()) + 1

class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        cnt = Counter()
        n = len(s)
        prefix = 0
        for i in range(n):
            if s[i] == '0':
                continue
            # the rest n - i - 1 digits, how many ones (j)?
            for j in range(n-i):
                cnt[prefix + j] += frac[n-i-1] * inv[j] * inv[n-i-1-j]
                cnt[prefix + j] %= M
            prefix += 1
        if 0 in cnt:
            del cnt[0]
        # cnt[prefix] += 1
        
        res = 0
        # print(cnt)
        for c in cnt:
            if c!=0 and f(c) <= k - 1:
                # print(c, f(c), k, cnt[c])
                res += cnt[c]
                res %= M
        return res
        ",1448268557
xy-li,xy-li,260,3646,python3,"M = 10**9 + 7

from collections import Counter
class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        c = Counter()
        s = Counter()
        res = 0
        for num in nums:
            cur = c[num - 1] + c[num + 1] + 1
            s[num] += (s[num - 1] + s[num + 1] + cur * num) % M
            s[num] %= M
            res += (s[num - 1] + s[num + 1] + cur * num) % M
            res %= M
            c[num] += cur
            c[num] %= M
        
        return res
            ",1448233723
cro_poder,cro_poder,262,3612,cpp," 

class Solution {
public:
    bool hasIncreasingSubarrays(std::vector<int>& nums, int k) {
        int n = nums.size();
 
        for (int i = 0; i <= n - 2 * k; ++i) {
            bool f1 = true;
            bool f2 = true;
 
            for (int j = 0; j < k - 1; ++j) {
                if (nums[i + j] >= nums[i + j + 1]) {
                    f1 = false;
                    break;
                }
            }
 
            if (f1) {
                for (int j = 0; j < k - 1; ++j) {
                    if (nums[i + k + j] >= nums[i + k + j + 1]) {
                        f2 = false;
                        break;
                    }
                }
 
                if (f2) {
                    return true;
                }
            }
        }

        return false;   
    }
};
",1448200016
cro_poder,cro_poder,262,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        vector<int>v;
        for(int i=0;i<nums.size()-1;i++){
            if(nums[i]<nums[i+1])v.push_back(1);
            else v.push_back(-1);
        }
        vector<int>v2;
        for(int i=v.size()-1;i>=0;i--){
            if(v[i]==-1)v2.push_back(0);
            else{
                v2.push_back(1+(v2.size()?v2.back():0));
            }
        }
        reverse(v2.begin(),v2.end());
        v2.push_back(0);
        for(auto&it:v2)it++;
        int ans = 0;
        for(int i=0;i<v2.size();i++){
            int e = v2[i];
            if(e){
                int f = i+e;
                if(f<v2.size()&&v2[f]>=e){
                    ans = max(ans,e);
                }
            }
            if(e){
                int f = i-e;
                if(f>=0&&v2[f]>=2*e){
                    ans = max(ans,e);
                }
            }
        }
        return ans;
    }
};",1448197808
cro_poder,cro_poder,262,3631,cpp,"class Solution {
public:
    const int MOD = 1e9 + 7;
    vector<unsigned long long> factorial;
    vector<unsigned long long> invFactorial;

    Solution() {
        precomputeFactorials(800, MOD);
    }
 
    void precomputeFactorials(int maxN, int mod) {
        factorial.resize(maxN + 1, 1);
        invFactorial.resize(maxN + 1, 1);
        
        for (int i = 2; i <= maxN; i++) {
            factorial[i] = (factorial[i - 1] * i) % mod;
        }
        invFactorial[maxN] = modInverse(factorial[maxN], mod);
        for (int i = maxN - 1; i > 0; i--) {
            invFactorial[i] = (invFactorial[i + 1] * (i + 1)) % mod;
        }
    }

    unsigned long long modInverse(unsigned long long n, int mod) {
        unsigned long long result = 1;
        int exp = mod - 2;
        while (exp > 0) {
            if (exp % 2 == 1) result = (result * n) % mod;
            n = (n * n) % mod;
            exp /= 2;
        }
        return result;
    }
 
    unsigned long long nCrMod(int n, int r, int mod) {
        if (n < r) return 0;
        return ((factorial[n] * invFactorial[r]) % mod * invFactorial[n - r]) % mod;
    }

    int countKReducibleNumbers(string s, int k) {
        vector<int> hash(800, 0);
        hash[0] = 1e9; 
        auto calculateKReducibility = [&](int x) -> int {
            int steps = 0;
            while (x > 1) {
                x = bitset<32>(x).count();
                steps++;
            }
            return steps;
        };

        for (int i = 1; i < 800; i++) {
            hash[i] = calculateKReducibility(i);
        }

        int ta = count(s.begin(), s.end(), '1');
        int back = 0;
        int ans = 0;

        for (int i = s.size() - 1; i >= 0; i--) {
            if (s[i] == '1') {
                ta--;
                int lc = ta;

                for (int j = 0; j <= back; j++) {
                    if (hash[lc + j] < k) {
                        ans = (ans + nCrMod(back, j, MOD)) % MOD;
                    }
                }
            }
            back++;
        }

        return ans;
    }
};
",1448268835
cro_poder,cro_poder,262,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        const int MOD = 1e9 + 7;
        int n = nums.size();
        vector<int> dp(n);
        map<int, int> mp1, mp2;

        dp[n - 1] = nums[n - 1] % MOD;
        mp1[nums[n - 1]] = 1;
        mp2[nums[n - 1]] = nums[n - 1] % MOD;

        for (int i = n - 2; i >= 0; i--) {
            int ue = nums[i] - 1, le = nums[i] + 1;

            int eff = (mp1[ue] + mp1[le] + 1) % MOD;
            int cs = (mp2[ue] + mp2[le]) % MOD;
            cs = (cs + 1LL * eff * nums[i]) % MOD;

            dp[i] = cs;
            mp1[nums[i]] = (mp1[nums[i]] + eff) % MOD;
            mp2[nums[i]] = (mp2[nums[i]] + cs) % MOD;
        }
 
        int result = 0;
        for (int i = 0; i < n; i++) {
            result = (result + dp[i]) % MOD;
        }

        return result;
    }
};
",1448222660
Marmaduke,Marmaduke,264,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n= nums.size();
        vector<int> dp(n);
        int prev = 2e9+7;
        for(int i = 0; i < n; i++)
        {
            int x = nums[i];
            if(x > prev)
            {
                dp[i] = dp[i-1] + 1;
            }
            else
            {
                dp[i] = 1;
            }
            prev = x;
        }
        
        for(int i = k-1; i+k < n; i++)
        {
            int a = dp[i];
            int b = dp[i+k];
            int z = min(a,b);
            if(z >= k)
            {
                return true;
            }
        }
        
        return false;
    }
};",1448183650
Marmaduke,Marmaduke,264,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n= nums.size();
        vector<int> dp(n);
        int prev = 2e9+7;
        for(int i = 0; i < n; i++)
        {
            int x = nums[i];
            if(x > prev)
            {
                dp[i] = dp[i-1] + 1;
            }
            else
            {
                dp[i] = 1;
            }
            prev = x;
        }
        
        int high = n;
        int low = 1;
        while(low < high)
        {
            int mid = (low+high+1)/2;
            bool found = false;
            //cout << ""mid = "" << mid << endl;
            for(int i = mid-1; i+mid < n; i++)
            {
                
                int a = dp[i];
                int b = dp[i+mid];
                //cout << i << "" "" << a << "" "" << b << endl;
                int z = min(a,b);
                if(z >= mid)
                {
                    found = true;
                    break;
                }
            }
            if(found)
            {
                low = mid;
            }
            else
            {
                high = mid-1;
            }
        }
        
        return low;
    }
};",1448190312
Marmaduke,Marmaduke,264,3631,cpp,"const int M = 1000;
vector<long long int> brc;
vector<vector<long long int>> pc;
const int mod = 1e9+7;
class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        if(brc.empty())
        {
            long long int high = 0;
            brc = vector<long long int>(M);
            brc[0] = 0;
            brc[1] = 0;
            for(int i = 2; i < M; i++)
            {
                int p = 0;
                int t = i;
                while(t)
                {
                    if(t&1)
                    {
                        p++;
                    }
                    t /= 2;
                }
                
                brc[i] = 1+brc[p];
                //cout << i << "" "" << p << "" "" << brc[i] << endl;
                high = max(high, brc[i]);
            }
            
            //cout << high << endl;
            
            pc = vector<vector<long long int>>(M, vector<long long int>(M,0));
            pc[0][0] = 1;
            pc[1][0] = 1;
            pc[1][1] = 1;
            for(int L = 2; L < M; L++)
            {
                pc[L][0] = 1;
                for(int i = 1; i <= L; i++)
                {
                    pc[L][i] = (pc[L-1][i] + pc[L-1][i-1]) % mod;
                    //cout << L << "" "" << i << "" "" << pc[L][i] << endl;
                }
            }
        }
        
        int n = s.length();
        long long int ans = 0;
        int bit = 0;
        for(int i = 0; i < n; i++)
        {
            long long int g = n-1-i; // length of string to the immediate right
            if(s[i] == '1')
            {
                //cout << ""i = "" << i << endl;
                long long int sub = 0;
                for(int j = 0; j <= g; j++)
                {
                    if(1 + brc[bit+j] <= k)
                    {
                        //cout << ""j = "" << j << endl;
                        sub += pc[g][j];
                    }
                }
                ans += sub;
                ans %= mod;
                bit++;
                //cout << i << "" "" << sub << endl;
            }
        }
        ans = (ans + mod - 1) % mod; // zero was counted above
        return ans;
    }
};",1448276178
Marmaduke,Marmaduke,264,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        const int mod = 1e9+7;
        int M = 1e5+7;
        vector<long long int> ct(M,0);
        vector<long long int> sum(M,0);
        long long int ans = 0;
        for(int i = 0; i < nums.size(); i++)
        {
            long long int u = nums[i];
            long long int p = u;
            long long int t = 1;
            p += (sum[u+1]) + u*ct[u+1];
            p %= mod;
            t += ct[u+1];
            if(u > 0)
            {
                p += (sum[u-1]) + u*ct[u-1];
                p %= mod;
                t += ct[u-1];
            }
            ans = (ans + p) % mod;
            ct[u] = (ct[u] + t) % mod;
            sum[u] = (sum[u] + p) % mod;
            //cout << i << "" "" << t << "" "" << p << endl;
        }
        
        return ans;
    }
};",1448213560
Sammy Taubman,staubman1,265,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        increasingLengths = [0 for i in range(len(nums))]

        last = -1001
        length = 0
        for i, n in enumerate(nums):
            if n > last:
                length += 1
            else:
                length = 1
            last = n
            increasingLengths[i] = length
     

        for left in range(k - 1, len(nums) - k):
            if increasingLengths[left] >= k and increasingLengths[left + k] >= k:
                return True

        return False",1448184554
Sammy Taubman,staubman1,265,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        increasingLengths = [0 for i in range(len(nums))]
        
        last = -1001
        length = 0
        for i, num in enumerate(nums):
            if num > last:
                length += 1
            else:
                length = 1
            last = num
            increasingLengths[i] = length
        
        k = 0
        
        for i in range(0, len(nums)):
            if i + k + 1>= len(nums):
                return k
            
            potential = k + 1
            while (i + potential < len(nums) and increasingLengths[i] >= potential and increasingLengths[i + potential] >= potential):
                k += 1
                potential += 1
        
        return k",1448192725
Sammy Taubman,staubman1,265,3631,python3,"import math

class Solution:
    def isKReducible(self, n, k):
        if n == 1:
            return True
        for i in range(k):
            n = n.bit_count()
            if n == 1:
                return True
        return False
    
    def waysToPlace(self, s, o):
        MOD = (10 ** 9) + 7
    
        # calculate ways to place o 1s s.t the result is less than s
        # idea is scan and solve how many ways when we place all 1s to the left of index
        rem = o
        total = 0
        for i, c in enumerate(s):
            if c == '1':
                if rem == 0:
                    return total + 1
                # (len(s) - i - 1) spots to place (rem ones)
                # (len(s) - i - 1) choose rem
                total += math.comb(len(s) - i - 1, rem) % MOD
                rem -= 1
        return total
    
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        # after one iteration, we are at max 800 -- so manually solve that
        # then question is, how many numbers less than n with correct number of
        # it's giving stars and bars but < is annoying
        
        MOD = (10 ** 9) + 7
        
        if k == 5:
            # every number between 1 and 800 is 4-reducible, so we could set every bit if we want
            # therefore answer is n - 1
            return (int(s, 2) - 1) % MOD
        
        total = 0
        
        for i in range(1, len(s)):
            if self.isKReducible(i, k - 1):
                total += self.waysToPlace(s, i) % MOD
                total = total % MOD
        
        return total",1448255018
Sammy Taubman,staubman1,265,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        # sum based on starting num
        # go in reverse storing count + sum
        # to be efficient, use dict and check num + 1 and num - 1
        
        MOD = (10 ** 9) + 7
        
        # num: (count, sum)
        dp = {}
        total = 0
        
        for i in range(0, len(nums)):
            idx = len(nums) - i - 1
            
            count = 1
            seqSum = nums[idx]
            
            if nums[idx] + 1 in dp:
                otherCount, otherSum = dp[nums[idx] + 1]
                count += otherCount
                seqSum += (otherCount * nums[idx]) + otherSum
                seqSum %= MOD
            if nums[idx] - 1 in dp:
                otherCount, otherSum = dp[nums[idx] - 1]
                count += otherCount
                seqSum += (otherCount * nums[idx]) + otherSum
                seqSum %= MOD
            
            total += seqSum
            total %= MOD
            oldCount, oldSum = dp.get(nums[idx], (0, 0))
            dp[nums[idx]] = (count + oldCount, (seqSum + oldSum) % MOD)
        
        return total
        ",1448210984
Tushar Agarwal,techtushar2002,268,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k)
    {
        int n = nums.size();
        vector<int> inc(n,0);
        for(int i=1; i<n; i++)
            {
                inc[i] = inc[i-1];
                if(nums[i] > nums[i-1])
                    inc[i]++;
            }
        for(int i=0; i<n; i++)
            {
                if(i+2*k <= n)
                {
                    if(inc[i+k-1]-inc[i] == k-1 && inc[i+2*k-1]-inc[i+k] == k-1)
                        return true;
                }
                else break;
            }
        return false;
    }
};",1448185170
Tushar Agarwal,techtushar2002,268,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size(), ans = 0;
        vector<int> inc(n,1);
        for(int i=n-2; i>=0; i--)
            {
                if(nums[i] < nums[i+1])
                    inc[i] = inc[i+1] + 1;
            }
        for(int i=0; i<n; i++)
            {
                ans = max(ans, inc[i]/2);
                if(i+inc[i] < n)
                    ans = max(ans,min(inc[i],inc[i+inc[i]]));
            }
        return ans;
    }
};",1448200101
Tushar Agarwal,techtushar2002,268,3631,cpp,"long long mod = 1e9+7;
long long power(long long x,long long y)
{
    if(x==0) return 1;
    if(y==0) return 1;
    long long value = 0;
    value = power(x,y/2);
    value = (value*value)%mod;
    if(y&1LL) value *= x;
    return value%mod;
}

int inversemod(long long x) 
{
    return power(x,mod-2)%mod;
}

class Solution {
public:
    int countKReducibleNumbers(string s, int k)
    {
    	vector<long long> fac(801,1), inv(801,1);
    	for(long long i=1; i<=800; i++)
    	{
    	    fac[i] = fac[i-1]*i;
    	    fac[i] %= mod;
    	}
    	inv[800] = inversemod(fac[800]);
        for (long long i = 799; i >= 0; i--)
            inv[i] = inv[i+1] * (i+1) % mod;
        
        vector<long long> f(801,0);
        long long count = 0;
        for(int i=2; i<=800; i++)
            {
                int popc = __builtin_popcount(i);
                f[i] = f[popc]+1;
            }
        int n = s.size(), pre = 0;
        for(int i=0; i<n; i++)
        {
            if(s[i] == '1')
            {
                int x = n-i-1;
                for(int j=0; j<=x; j++)
                    {
                        if(f[pre+j] < k)
                        {
                            count += (fac[x]%mod*inv[j]%mod*inv[x-j]%mod);
                            count %= mod;
                        }
                    }
                pre++;
            }
        }
        return count-1;
    }
};
",1448283272
Tushar Agarwal,techtushar2002,268,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums)
    {
        int n = nums.size();
        long long res = 0, mod = 1e9+7;
        vector<long long> end(1e5+2,0),sum(1e5+2,0); 
        for(int i=0; i<n; i++)
            {
                long long num = nums[i];
                if(num != 0) end[num] += end[num-1];
                end[num] += end[num+1];
                end[num]++;
                end[num] %= mod;
                if(num != 0) sum[num] += sum[num-1] + num*end[num-1];
                sum[num] += sum[num+1] + num*end[num+1];
                sum[num] += num;
                sum[num] %= mod;
            }
        for(int i=0; i<=1e5; i++)
            {
                res += sum[i];
                res %= mod;
            }
        return res;
    }
};",1448233010
Terry,tttyyy49,269,3612,java,"class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        int n = nums.size();
        int[] dp = new int[n];
        Arrays.fill(dp, 1);
        for (int i = 1; i < n; ++i) {
            if (nums.get(i) > nums.get(i - 1)) {
                dp[i] = dp[i - 1] + 1;
            }
        }
        
        for (int j = 0; j + k < n; ++j) {
            if (dp[j] >= k && dp[j + k] >= k) return true;
        }
        return false;
    }
}",1448187263
Terry,tttyyy49,269,3619,java,"class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        int n = nums.size();
        int[] dp = new int[n];
        Arrays.fill(dp, 1);
        for (int i = 1; i < n; ++i) {
            if (nums.get(i) > nums.get(i - 1)) {
                dp[i] = dp[i - 1] + 1;
            }
        }
        
        int start = 1;
        int end = n / 2;
        while (start + 1 < end) {
            int mid = (start + end) / 2;
            if (good(mid, dp)) {
                start = mid;
            } else {
                end = mid;
            }
        }
        if (good(end, dp)) return end;
        return start;
    }
    
    boolean good(int k, int[] dp) {
        for (int j = 0; j + k < dp.length; ++j) {
            if (dp[j] >= k && dp[j + k] >= k) return true;
        }
        return false;
    }
}",1448193233
Terry,tttyyy49,269,3631,java,"class Solution {
    static final long MOD = (long) 1e9 + 7;
    
    public int countKReducibleNumbers(String s, int k) {
        int n = s.length();
        
        // [i][bitCount][tight?1:0]
        long[][][] dp = new long[n + 1][n + 1][2];
        
        dp[0][0][0] = 0;
        dp[0][0][1] = 1;
        
        for (int i = 0; i < n; ++i) {
            int d = s.charAt(i) - '0';
            if (d == 0) {
                for (int j = 0; j <= n; ++j) {
                    dp[i + 1][j][1] += dp[i][j][1];
                    dp[i + 1][j][1] %= MOD;
                    
                    dp[i + 1][j][0] += dp[i][j][0];
                    dp[i + 1][j][0] %= MOD;
                    if (j + 1 <= n) {
                        dp[i + 1][j + 1][0] += dp[i][j][0];
                        dp[i + 1][j + 1][0] %= MOD;
                    }
                }
            } else { // d == 1
                for (int j = 0; j <= n; ++j) {
                    if (j + 1 <= n) {
                        dp[i + 1][j + 1][1] = dp[i][j][1];
                        dp[i + 1][j + 1][1] %= MOD;
                    }
                    
                    dp[i + 1][j][0] += dp[i][j][1];
                    dp[i + 1][j][0] %= MOD;
                    
                    dp[i + 1][j][0] += dp[i][j][0];
                    dp[i + 1][j][0] %= MOD;
                    
                    if (j + 1 <= n) {
                        dp[i + 1][j + 1][0] += dp[i][j][0];
                        dp[i + 1][j + 1][0] %= MOD;
                    }
                }
            }
        }
        
        long res = 0;
        for (int j = 1; j <= n; ++j) {
            if (isKReducible(j, k)) {
                res += dp[n][j][0];
                res %= MOD;
            }
        }
        return (int) res;
    }
    
    boolean isKReducible(int x, int k) {
        for (int i = 1; i < k; ++i) {
            x = Integer.bitCount(x);
        }
        return x == 1;
    }
}",1448283496
Terry,tttyyy49,269,3646,java,"class Solution {
    final static long MOD = (long) 1e9 + 7;
    
    public int sumOfGoodSubsequences(int[] nums) {
        // endingNum -> count of subsequence ending with endingNum
        Map<Integer, Long> dp = new HashMap<>();
        // endingNum -> sum of subsequence ending with endingNum
        Map<Integer, Long> sum = new HashMap<>();
        
        long res = 0;
        for (int x : nums) {
            long cnt = 1; // self
            cnt += dp.getOrDefault(x - 1, 0L);
            cnt += dp.getOrDefault(x + 1, 0L);
            cnt %= MOD;
            
            long s = (cnt * x) % MOD;
            s += sum.getOrDefault(x - 1, 0L);
            s %= MOD;
            s += sum.getOrDefault(x + 1, 0L);
            s %= MOD;
            
            dp.put(x, (dp.getOrDefault(x, 0L) + cnt) % MOD);
            sum.put(x, (sum.getOrDefault(x, 0L) + s) % MOD);
        }
        
        for (int x : sum.keySet()) {
            res += sum.get(x);
            res %= MOD;
        }
        
        return (int) res;
    }
}",1448221026
All Shahoriar Tonmoy,astthecoder,270,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        vector<int> x;
        int c=1;
        for(int i=1;i<nums.size();i++){
            if(nums[i]<=nums[i-1]){
                x.push_back(c);
                c=0;
            }
            c++;
        }
        x.push_back(c);
        for(int i=0;i<x.size();i++){
            if(x[i]>=2*k) return true;
            if(i && x[i]>=k && x[i-1]>=k) return true;
        }
        return false;
    }
};",1448192609
All Shahoriar Tonmoy,astthecoder,270,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        vector<int> x;
        int c=1;
        for(int i=1;i<nums.size();i++){
            if(nums[i]<=nums[i-1]){
                x.push_back(c);
                c=0;
            }
            c++;
        }
        x.push_back(c);
        int ans=0;
        for(int i=0;i<x.size();i++){
            ans=max(ans, x[i]/2);
            if(i) ans=max(ans,min(x[i],x[i-1]));
        }
        return ans;
    }
};",1448197205
All Shahoriar Tonmoy,astthecoder,270,3631,cpp,"#define ll long long int
class Solution {
public:
    string t;
    ll dp[801][801][2], mod=1000000007, cnt[801];

    ll solve(ll i, ll c, ll f){
        if(i==t.size()){
            if(!c && f) return 1;
            else return 0;
        }
        if(dp[i][c][f]!=-1) return dp[i][c][f];
        dp[i][c][f]=0;
        if(t[i]=='0'){
            dp[i][c][f] = (dp[i][c][f] + solve(i+1, c, f)) % mod;
            if(f && c) dp[i][c][f] = (dp[i][c][f] + solve(i+1, c-1, f)) % mod;
        }
        else{
            dp[i][c][f] = (dp[i][c][f] + solve(i+1, c, 1)) % mod;
            if(c) dp[i][c][f] = (dp[i][c][f] + solve(i+1, c-1, f)) % mod;
        }
        return dp[i][c][f];
    }

    int countKReducibleNumbers(string s, int k) {
        memset(dp, -1, sizeof(dp));
        memset(cnt, 0, sizeof(cnt));
        t=s;
        ll ans=0;
        for(ll i=1;i<=800;i++){
            ll x=0, temp=i;
            while(temp){
                x+=(temp%2);
                temp/=2;
            }
            cnt[i]=cnt[x]+1;
            if(cnt[i] <= k)
                ans = (ans + solve(0, i, 0)) %mod;
        }
        return ans;
    }
};",1448269926
All Shahoriar Tonmoy,astthecoder,270,3646,cpp,"#define ll long long int
class Solution {
public:
    ll mod = 1000000007;
    ll cnt[100005], p[100005];

    int sumOfGoodSubsequences(vector<int>& nums) {
        memset(cnt, 0, sizeof(cnt));
        for(ll i=0;i<nums.size();i++){
            nums[i]++;
            ll c=cnt[nums[i]-1]+cnt[nums[i]+1];
            p[i] = c+1;
            cnt[nums[i]]+=p[i];
            cnt[nums[i]] %=mod;
        }
        ll ans=0;
        memset(cnt, 0, sizeof(cnt));
        for(ll i=nums.size()-1;i>=0;i--){
            ll c=cnt[nums[i]-1]+cnt[nums[i]+1];
            p[i] = (p[i] * (c + 1)) % mod;
            cnt[nums[i]]+=(c+1);
            cnt[nums[i]] %=mod;
            ll x=((nums[i] - 1)*p[i])%mod;
            ans=(ans+x)%mod;
        }        

        return ans;
    }
};",1448236642
ocavue,ocavue,271,3612,python3,"from typing import List


def is_strictly_increasing(nums: List[int]) -> bool:
    for i in range(1, len(nums)):
        if nums[i] <= nums[i - 1]:
            return False
    return True


class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)

        for a in range(n):
            b = a + k
            c = b + k

            if c > n:
                break

            nums1 = nums[a:b]
            nums2 = nums[b:c]

            if is_strictly_increasing(nums1) and is_strictly_increasing(nums2):
                return True
        return False

 ",1448182701
ocavue,ocavue,271,3619,python3,"from typing import List


def check(nums: List[int]) -> bool:
    n = len(nums)

    dp = [1] * n

    for i in range(n - 2, -1, -1):
        j = i + 1
        if nums[i] < nums[j]:
            dp[i] = dp[j] + 1

    best = 1

    for j in range(1, n):
        k = dp[j]
        i = j - k
        if i < 0:
            continue

        if dp[i] >= k:
            best = max(best, k)

    return best


class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        case1 = check(nums)
        case2 = check([-num for num in nums[::-1]])
        return max(case1, case2)

 ",1448198968
ocavue,ocavue,271,3631,python3,"from functools import cache

inf = float(""inf"")
MOD = 10**9 + 7


# def logger(func):
#     def new_func(*args, **kwargs):
#         result = func(*args, **kwargs)

#         print_args = "", "".join([repr(a) for a in args])
#         print_kwargs = "", "".join([f""{k}={repr(v)}"" for k, v in kwargs.items()])
#         print_all = "", "".join([p for p in [print_args, print_kwargs] if p])
#         print(f""{func.__name__}({print_all}) == {result}"")
#         return result

#     return new_func


@cache
# @logger
def get_k(num: int) -> int:
    if num == 1:
        return 0
    bit_count = num.bit_count()
    if num == bit_count:
        return inf
    # assert bit_count < num
    return get_k(bit_count) + 1


for i in range(1, 10):
    get_k(i)


class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        n = len(s)

        @cache
        # @logger
        def dfs(i: int, equal: bool, ones_before: int) -> int:
            # assert ones_before <= 800
            # assert 0 <= i < n

            if i == n - 1:
                if equal:
                    if s[i] == ""0"":
                        return 0
                    else:
                        case0 = 1 if get_k(ones_before) < k else 0
                        return case0
                else:
                    case1 = 1 if get_k(ones_before + 1) < k else 0
                    case0 = 1 if get_k(ones_before) < k else 0
                    return case1 + case0

            # assert i < n - 1
            if equal:
                if s[i] == ""0"":
                    case0 = dfs(i + 1, True, ones_before)
                    return case0
                else:
                    case1 = dfs(i + 1, True, ones_before + 1)
                    case0 = dfs(i + 1, False, ones_before)
                    return (case1 + case0) % MOD
            else:
                # print(""case1"", i + 1, False, ones_before + 1)
                case1 = dfs(i + 1, False, ones_before + 1)
                case2 = dfs(i + 1, False, ones_before)
                return (case1 + case2) % MOD

        return dfs(0, True, 0)
 ",1448276767
ocavue,ocavue,271,3646,python3,"from collections import Counter
from typing import List

MOD = 10**9 + 7


class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        n = len(nums)
        result = 0

        num_to_sum = Counter()
        num_to_count = Counter()

        for i in range(n - 1, -1, -1):
            num = nums[i]

            c = num_to_count[num + 1] + num_to_count[num - 1] + 1
            s = num_to_sum[num + 1] + num_to_sum[num - 1] + c * num

            num_to_sum[num] += s
            num_to_sum[num] %= MOD

            num_to_count[num] += c
            num_to_count[num] %= MOD

            result += s
            result %= MOD

        return result % MOD

 ",1448222958
svxvdp,svxvdp,272,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        N = len(nums)

        def ok(lo):
            for i in range(lo, lo + k - 1):
                if nums[i + 1] <= nums[i]:
                    return False
            return True
                
        for lo in range(N - 2 * k + 1):
            if ok(lo) and ok(lo + k):
                return True
        return False
                
            
        ",1448184902
svxvdp,svxvdp,272,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        N = len(nums)
        l = []

        cnt = 1
        i = 1
        for i in range(1, N):
            if nums[i] > nums[i - 1]:
                cnt += 1
            else:
                l.append(cnt)
                cnt = 1
        l.append(cnt)

        ans = max(l) // 2

        for i in range(len(l) - 1):
            ans = max(ans, min(l[i], l[i + 1]))
        return ans

        ",1448196745
svxvdp,svxvdp,272,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        import math

        def main(count):
            s_count1 = s.count('1')
            ans = 0
            for i in range(N):
                if s[i] == '0':
                    continue

                # choice 1. use 0.
                ans += math.comb(N - i - 1, count)

                s_count1 -= 1
                if s_count1 == 0:
                    return ans

                # choice 2. use 1.
                count -= 1

                if count == 0:
                    return ans + 1

            return ans
            


        MOD = 10 ** 9 + 7
        N = len(s)


        lk = [0 for _ in range(N + 5)]
        lk[1] = 0
        for i in range(2, N):
            lk[i] = lk[i.bit_count()] + 1
        
        
        L = []
        for i in range(1, N):
            if lk[i] <= k - 1:
                L.append(i)
        # print(L)
        

        ans = 0
        for count in L:
            # print(count, main(count))
            ans = (ans + main(count)) % MOD
        return ans

        ",1448283778
svxvdp,svxvdp,272,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        MOD = 10 ** 9 + 7

        D = {}
        for e in nums:
            A, B = D.get(e, (0, 0))
            A += 1
            B += e

            for t in [e + 1, e - 1]:
                X, Y = D.get(t, (0, 0))

                A += X
                B += Y + e * X
            
            D[e] = (A % MOD, B % MOD)
        
        ans = 0
        for _, B in D.values():
            ans = (ans + B) % MOD
        return ans

        ",1448213658
a7174812,a7174812,274,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        vector<int> v(nums.size()+1);
        v[1] = 1;
        for(int i = 1; i < nums.size(); ++i){
            if(nums[i] > nums[i-1])
                v[i+1] = v[i] + 1;
            else
                v[i+1] = 1;
        }
        // for(auto i : v)
        //     cout<<i<<"" "";
        for(int i = k*2-1; i < nums.size(); ++i){
            if(v[i+1] >= k && v[i+1-k] >= k)
                return true;
        }

        return false;
    }
};",1448191481
a7174812,a7174812,274,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        vector<int> v(nums.size()+1);
        v[1] = 1;
        for(int i = 1; i < nums.size(); ++i){
            if(nums[i] > nums[i-1])
                v[i+1] = v[i] + 1;
            else
                v[i+1] = 1;
        }
        int lo = 0;
        int hi = nums.size() / 2 + 1;
        while(lo < hi){
            int mid = lo + (hi - lo) / 2;
            if(check(v, mid))
                lo = mid + 1;
            else
                hi = mid;
        }
        return lo - 1;
    }
    bool check(vector<int>& v, int k){
        for(int i = k*2; i < v.size(); ++i){
            if(v[i] >= k && v[i-k] >= k)
                return true;
        }

        return false;
    }
};",1448197742
a7174812,a7174812,274,3631,cpp,"class Solution {
public:
    vector<vector<int>> C;
    int ans = 0;
    const int mod = 1e9 + 7;
    vector<int> times;
    int k;
    int countKReducibleNumbers(string s, int _k) {
        k = _k;
        times.resize(801);
        times[1] = 1;
        for(int i = 2; i <= 800; ++i){
            int x = __builtin_popcount(i);
            // cout<<x<<endl;
            times[i] = times[x] + 1;
        }
        C = getCombArray(s.size());
        perm(s,0,0);
        return ((ans - 1) + mod) % mod;
    }

    void perm(string& s, int idx, int cnt){
        if(idx == s.size())
            return;
        if(s[idx] == '1'){
            int m = s.size() - idx - 1;
            for(int n = 0; n <= m; ++n){
                if(times[n+cnt] <= k)
                    ans = (ans + C[m][n]) % mod;
            }
                
            perm(s, idx+1, cnt+1);    
        }else{
            perm(s, idx+1, cnt);    
        }
        
    }

    vector<vector<int>> getCombArray(int n){
        const int mod = 1e9 + 7;
        vector<vector<int>> C(n+1, vector<int>(n+1));
        C[0][0] = 1;
        for(int i = 1; i <= n; ++i){
            C[i][0] = 1;
            for(int j = 1; j <= i; ++j){
                C[i][j] = (C[i-1][j] + C[i-1][j-1]) % mod;
            }
        }
        
        return C;
    }
};",1448263644
a7174812,a7174812,274,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        const int mod = 1e9 + 7;
        unordered_map<int, long long> cnt, sum;
        long long ans = 0;
        for(auto i : nums){
            long long t = 1;
            if(cnt.count(i+1)){
                t = (cnt[i+1] + t) % mod;
                sum[i] = (sum[i] + cnt[i+1] * i + sum[i+1]) % mod;
                ans = (ans + sum[i+1] + cnt[i+1] * i) % mod;
            }
            if(cnt.count(i-1)){
                t = (cnt[i-1] + t) % mod;
                sum[i] = (sum[i] + cnt[i-1] * i + sum[i-1]) % mod;
                ans = (ans + sum[i-1] + cnt[i-1] * i) % mod;
            }
            cnt[i] = (cnt[i] + t) % mod;
            sum[i] = (sum[i] + i) % mod;
            ans = (ans + i) % mod;
        }
        

        return ans;
    }
};",1448225844
czjnbb,czjnbb,275,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        
        leng = len(nums)
        
        for i in range(k-1, leng - k):
            f = True
            for j in range(i-k+2, i+1):
                if nums[j] <= nums[j-1]:
                    f = False
                    break
                    
            f2 = True
            for j in range(i+2, i+k+1):
                if nums[j] <= nums[j-1]:
                    f2 = False
                    break
                    
            if f and f2:
                return True
            
        return False
            ",1448185828
czjnbb,czjnbb,275,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        
        leng = len(nums)
        res = 1
        
        dp = [1]
        
        for i in range(1, leng):
            cur = nums[i]
            if cur > nums[i-1]:
                dp.append(dp[-1] + 1)
            else:
                dp.append(1)
        
        for i,d in enumerate(dp):
            res = max(res, d // 2)
            if (i - d) >= 0 and dp[i-d] >= d:
                res = max(res, d)
                
        return res
        
            ",1448194242
czjnbb,czjnbb,275,3631,python3,"mem = {}
mem[1] = 0
        
for i in range(2, 801):
    step = 1
    cur = bin(i).count('1')
    while cur > 1:
        step += 1
        cur = bin(cur).count('1')
    mem[i] = step
    
    
### pre-calc combination number
### comb2[i][j] is eq to comb(i, j)

comb2 = [[1]]
mod = 10**9 + 7

for i in range(1, 800 + 1):
    comb2.append([1])
    for j in range(i - 1):
        comb2[-1].append((comb2[-2][j] + comb2[-2][j+1]) % mod)
    comb2[-1].append(1)



class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        
        lens = len(s)
        tot1 = 1
        cl = lens - 1
        res = 0
        
        
        for i in range(1, lens):
            cnt = comb2[cl][i]
            step = mem[i] + 1
            if step <= k:
                res = (res + cnt) % mod
                
                
        for i in range(1, lens):
            if s[i] == '0':
                continue
            
            
            cl = lens - i - 1
            for j in range(cl + 1):
                cnt = comb2[cl][j]
                step = mem[j + tot1] + 1
                if step <= k:
                    res = (res + cnt) % mod
            tot1 += 1
            
        return res
            
            
        
        
        
        
        
        
            
        ",1448270862
czjnbb,czjnbb,275,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        
        mod = 10**9 + 7
        run = 1
        accu = nums[0]
        leng = len(nums)
        
        dp = defaultdict(int)
        cnt = defaultdict(int)
        
        dp[nums[0]] = nums[0]
        cnt[nums[0]] = 1
                
        for i in range(1, leng):
            cur = nums[i]
            tot = 1
            sums = 0
            if cur - 1 in cnt:
                tot += cnt[cur - 1]
                sums += dp[cur - 1]
            if cur + 1 in cnt:
                tot += cnt[cur + 1]
                sums += dp[cur + 1]
            
            ans = (sums + tot * cur) % mod
            dp[cur] += ans
            dp[cur] %= mod
            
            cnt[cur] += tot
            cnt[cur] %= mod
            

                
        return sum(dp.values()) % mod
            
            ",1448235016
kzyKT,kzyKT,277,3612,cpp,"#define F first
#define S second
#define R cin>>
#define ll long long
#define ln cout<<'\n'
#define in(a) insert(a)
#define pb(a) push_back(a)
#define pd(a) printf(""%.10f\n"",a)
#define mem(a) memset(a,0,sizeof(a))
#define all(c) (c).begin(),(c).end()
#define iter(c) __typeof((c).begin())
#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)
#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)
#define rep(i,n) REP(i,0,n)
#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)
ll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}
template<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?"" "":"""");pr(b...);}
template<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}
const ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={0,-1,0,1,-1,-1,1,1},dy[8]={-1,0,1,0,-1,1,1,-1};
typedef pair<ll,ll> P;

class Solution {
public:
  bool hasIncreasingSubarrays(vector<int>& a, int k) {
    REP(j,k,a.size()-k+1) {
      ll f=1;
      REP(i,1,k) {
        if(a[j+i-1]>=a[j+i]) f=0;
        if(a[j+i-k-1]>=a[j+i-k]) f=0;
      }
      if(f) return 1;
    }
    return 0;
  }
};",1448186199
kzyKT,kzyKT,277,3619,cpp,"#define F first
#define S second
#define R cin>>
#define ll long long
#define ln cout<<'\n'
#define in(a) insert(a)
#define pb(a) push_back(a)
#define pd(a) printf(""%.10f\n"",a)
#define mem(a) memset(a,0,sizeof(a))
#define all(c) (c).begin(),(c).end()
#define iter(c) __typeof((c).begin())
#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)
#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)
#define rep(i,n) REP(i,0,n)
#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)
ll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}
template<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?"" "":"""");pr(b...);}
template<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}
const ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={0,-1,0,1,-1,-1,1,1},dy[8]={-1,0,1,0,-1,1,1,-1};
typedef pair<ll,ll> P;

class Solution {
public:
  int maxIncreasingSubarrays(vector<int>& a) {
    ll n=a.size();
    ll d[n];
    mem(d);
    rep(i,n-1) d[i+1]=d[i]+(a[i]<a[i+1]);
    ll ans=0;
    REP(j,1,n) {
      ll l=0,r=n;
      while(l+1<r) {
        ll m=(l+r)/2;
        ll x1=j-m,y1=j-1;
        ll x2=j,y2=j+m-1;
        if(x1<0||y2>=n) {
          r=m;
          continue;
        }
        ll d1=d[y1]-d[x1],d2=d[y2]-d[x2];
        if(d1==m-1&&d2==m-1) l=m;
        else r=m;
      }
      ans=max(ans,l);
    }
    return ans;
  }
};",1448201883
kzyKT,kzyKT,277,3631,cpp,"#define F first
#define S second
#define R cin>>
#define ll long long
#define ln cout<<'\n'
#define in(a) insert(a)
#define pb(a) push_back(a)
#define pd(a) printf(""%.10f\n"",a)
#define mem(a) memset(a,0,sizeof(a))
#define all(c) (c).begin(),(c).end()
#define iter(c) __typeof((c).begin())
#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)
#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)
#define rep(i,n) REP(i,0,n)
#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)
ll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}
template<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?"" "":"""");pr(b...);}
template<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}
const ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={0,-1,0,1,-1,-1,1,1},dy[8]={-1,0,1,0,-1,1,1,-1};
typedef pair<ll,ll> P;

void extended_euclid(ll x,ll y,ll *c,ll *a,ll *b){
  ll a0,a1,a2,b0,b1,b2,r0,r1,r2,q;r0=x;r1=y;a0=1;a1=0;b0=0;b1=1;
  while(r1>0){q=r0/r1;r2=r0%r1;a2=a0-q*a1;b2=b0-q*b1;r0=r1;r1=r2;a0=a1;a1=a2;b0=b1;b1=b2;}
  *c=r0;*a=a0;*b=b0;
}

ll get_inv(ll n, ll p){
  ll a,b,c;
  extended_euclid(n,p,&c,&a,&b);
  if(a<p) a+=p;
  return a%p;
}

ll fact[2100],fact_inv[2100];

void init() {
  fact[0]=1;
  REP(i,1,2100) fact[i]=fact[i-1]*i%MAX;
  fact_inv[2050]=get_inv(fact[2050],MAX);
  rrep(i,2050)fact_inv[i]=fact_inv[i+1]*(i+1)%MAX;
}

ll nCr(ll N,ll K){
  if(K<0||K>N)return 0;
  return fact[N]*fact_inv[K]%MAX*fact_inv[N-K]%MAX;
}

class Solution {
public:
  int countKReducibleNumbers(string s, int k) {
    init();
    ll n=s.size();
    ll d[888];mem(d);
    d[0]=MAX;
    REP(i,1,888) {
      ll x=i;
      if(x>1) d[i]++;
      while(x>1) {
        x=__builtin_popcount(x);
        d[i]++;
        if(d[i]>k) break;
      }
    }
    ll ans=0,c=0;
    rep(i,n) {
      if(s[i]=='1') {
        ll m=n-i-1;
        rep(j,m+1) {
          if(d[j+c]<=k) {
            ans+=nCr(m,j);
            ans%=MAX;
          }
        }
        c++;
      }
    }
    return ans;
  }
};",1448256889
kzyKT,kzyKT,277,3646,cpp,"#define F first
#define S second
#define R cin>>
#define ll long long
#define ln cout<<'\n'
#define in(a) insert(a)
#define pb(a) push_back(a)
#define pd(a) printf(""%.10f\n"",a)
#define mem(a) memset(a,0,sizeof(a))
#define all(c) (c).begin(),(c).end()
#define iter(c) __typeof((c).begin())
#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)
#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)
#define rep(i,n) REP(i,0,n)
#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)
ll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}
template<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?"" "":"""");pr(b...);}
template<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}
const ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={0,-1,0,1,-1,-1,1,1},dy[8]={-1,0,1,0,-1,1,1,-1};
typedef pair<ll,ll> P;

class Solution {
public:
  int sumOfGoodSubsequences(vector<int>& a) {
    ll n=a.size();
    map<ll,ll> dp[2];
    ll d1[n],d2[n];
    mem(d1),mem(d2);
    rep(i,n) {
      dp[1][a[i]]++;
      d1[i]++;
      if(dp[0].count(a[i]-1)) {
        dp[1][a[i]]+=dp[0][a[i]-1];
        d1[i]+=dp[0][a[i]-1];
      }
      if(dp[0].count(a[i]+1)) {
        dp[1][a[i]]+=dp[0][a[i]+1];
        d1[i]+=dp[0][a[i]+1];
      }
      dp[1][a[i]]%=MAX;
      d1[i]%=MAX;
      tr(it,dp[1]) dp[0][it->F]+=it->S;
      dp[1].clear();
    }
    dp[0].clear();
    rrep(i,n) {
      dp[1][a[i]]++;
      d2[i]++;
      if(dp[0].count(a[i]-1)) {
        dp[1][a[i]]+=dp[0][a[i]-1];
        d2[i]+=dp[0][a[i]-1];
      }
      if(dp[0].count(a[i]+1)) {
        dp[1][a[i]]+=dp[0][a[i]+1];
        d2[i]+=dp[0][a[i]+1];
      }
      dp[1][a[i]]%=MAX;
      d2[i]%=MAX;
      tr(it,dp[1]) dp[0][it->F]+=it->S;
      dp[1].clear();
    }
    ll ans=0;
    rep(i,n) {
      ans+=a[i]*d1[i]%MAX*d2[i];
      ans%=MAX;
    }
    return ans;
  }
};
",1448221346
LGM70,LGM70,278,3612,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        max_inc_len = [0] * len(nums)
        l = 1
        for i, num in enumerate(nums[1:]):
            if num > nums[i]:
                l += 1
            else:
                max_inc_len[i] = l
                l = 1
        max_inc_len[-1] = l
        rslt = 0
        i = len(nums) - 1
        while i >= 0:
            rslt = max(rslt, max_inc_len[i] // 2)
            pre_i = i - max_inc_len[i]
            if pre_i >= 0:
                rslt = max(rslt, min(max_inc_len[i], max_inc_len[pre_i]))
            i = pre_i
        return rslt

    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        return self.maxIncreasingSubarrays(nums) >= k",1448193928
LGM70,LGM70,278,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        max_inc_len = [0] * len(nums)
        l = 1
        for i, num in enumerate(nums[1:]):
            if num > nums[i]:
                l += 1
            else:
                max_inc_len[i] = l
                l = 1
        max_inc_len[-1] = l
        rslt = 0
        i = len(nums) - 1
        while i >= 0:
            rslt = max(rslt, max_inc_len[i] // 2)
            pre_i = i - max_inc_len[i]
            if pre_i >= 0:
                rslt = max(rslt, min(max_inc_len[i], max_inc_len[pre_i]))
            i = pre_i
        return rslt",1448191473
LGM70,LGM70,278,3631,python3,"class Solution:
    def __init__(self):
        self.M = int(1e9) + 7
        self.N = 800
        self.fac = [1] * (self.N + 1)
        self.inv_fac = [1] * (self.N + 1)
        for i in range(1, len(self.fac)):
            self.fac[i] = (self.fac[i - 1] * i) % self.M
        self.inv_fac[-1] = pow(self.fac[-1], -1, self.M)
        for i in range(len(self.inv_fac) - 2, -1, -1):
            self.inv_fac[i] = (self.inv_fac[i + 1] * (i + 1)) % self.M

    def countKReducibleNumbers(self, s: str, k: int) -> int:
        def is_k_reducible(x: int, k: int) -> bool:
            if x == 1:
                return True
            for _ in range(k):
                x = x.bit_count()
                if x == 1:
                    return True
            return False

        def comb(n: int, k: int) -> int:
            return (self.fac[n] * self.inv_fac[k] % self.M) * self.inv_fac[n - k] % self.M

        def calc(l: int, cnt: int, k: int) -> int:
            rslt = 0
            for ones in range(0, l + 1):
                if is_k_reducible(ones + cnt, k - 1):
                    rslt = (rslt + comb(l, ones)) % self.M
            return rslt

        rslt = 0
        cnt = 0
        for i, c in enumerate(s):
            if c == '1':
                rslt = (rslt + calc(len(s) - i - 1, cnt, k)) % self.M
                cnt += 1
        return rslt
",1448278361
LGM70,LGM70,278,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        M = int(1e9) + 7
        dp = {}
        for num in nums:
            if num in dp:
                dp[num][0] = (dp[num][0] + 1) % M
                dp[num][1] = (dp[num][1] + num) % M
            else:
                dp[num] = [1, num]
            if num - 1 in dp:
                dp[num][0] = (dp[num][0] + dp[num - 1][0]) % M
                dp[num][1] = (dp[num][1] + dp[num - 1][1] + num * dp[num - 1][0]) % M
            if num + 1 in dp:
                dp[num][0] = (dp[num][0] + dp[num + 1][0]) % M
                dp[num][1] = (dp[num][1] + dp[num + 1][1] + num * dp[num + 1][0]) % M
        rslt = 0
        for _, v in dp.items():
            rslt = (rslt + v[1]) % M
        return rslt",1448206916
canisolve4,canisolve4,279,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        a = 0
        b = 0
        p = -inf
        for n in nums:
            if n > p:
                b += 1
            else:
                a = b
                b = 1
            p = n
            if a >= k and b >= k or b >= 2 * k:
                return True
        return False",1448183497
canisolve4,canisolve4,279,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        m = 0
        a = 0
        b = 0
        p = -inf
        for n in nums:
            if n > p:
                b += 1
            else:
                a = b
                b = 1
            p = n
            m = max(m, min(a, b), b // 2)
        return m",1448185572
canisolve4,canisolve4,279,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        m = 10**9 + 7
        n = len(s)
        l = []
        for i in range(n + 1):
            a = i
            for _ in range(k - 1):
                a = a.bit_count()
            if a == 1:
                l.append(i)

        f = [1]
        for i in range(1, n + 1):
            f.append(f[-1] * i % m)

        r = 0
        c = 0
        for i, d in enumerate(s):
            d = int(d)
            if d == 1:
                for j in l:
                    x = j - c
                    y = n - 1 - i
                    if 0 <= x <= y:
                        r = (r + f[y] * pow(f[x], -1, m) * pow(f[y-x], -1, m)) % m
            c += d

        return r",1448285352
canisolve4,canisolve4,279,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        c = [0] * (10**5+2)
        s = [0] * (10**5+2)
        m = 10**9+7
        for n in nums:
            d = (1 + c[n-1] + c[n+1]) % m
            c[n] = (c[n] + d) % m
            s[n] = (s[n] + n * d + s[n-1] + s[n+1]) % m
        return sum(s) % m",1448222721
Varun Deep Saini,sojabhai,280,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        
        for(int i = 0; i <= n - 2 * k; i++) {
            bool one = 1;
            for(int j = i; j < i + k - 1; j++) {
                if(nums[j] >= nums[j + 1]) {
                    one = 0;
                    break;
                }
            }

            if(one) {
                int b = i + k; 
                bool two = 1;
                for(int j = b; j < b + k - 1; j++) {
                    if(nums[j] >= nums[j + 1]) {
                        two = 0;
                        break;
                    }
                }

                if(two) {
                    return 1;
                }
            }
        }

        return 0;
    }
};",1448239468
Varun Deep Saini,sojabhai,280,3619,cpp,"class Solution {
public:


    bool ok(int k, vector<int>& a, int n){
        for(int i = 0; i <= n - 2*k; i++){
            if(a[i] >= k && a[i +k] >= k){
                return 1;
            }
        }
        return 0;
    }

    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        if (n < 2) return 0; 
        vector<int> prefixSum(n, 1);
        for(int i = n - 2; i >=0; --i){
            if(nums[i] < nums[i+1]){
                prefixSum[i] = prefixSum[i+1] + 1;
            }else{
                prefixSum[i] = 1;
            }
        }

        int l = 1;
        int r = n / 2;
        int ans = 0;

        while(l <= r){
            int mid = l + (r - l) / 2;
            if(ok(mid, prefixSum, n)){
                ans = mid; 
                l = mid +1; 
            }
            else{
                r = mid -1;
            }
        }

        return ans;
    }

};",1448244555
Varun Deep Saini,sojabhai,280,3631,cpp,"class Solution {
public:
    const int MOD = 1e9 + 7;
    string s;
    int k;
    int dp[801][2][801][2]; 

    int f(int ones_count) {
        if (ones_count == 0) return 1000;
        if (ones_count == 1) return 0;
        int cnt = 1 + f(__builtin_popcountl(ones_count));
        return cnt;
    }
    string ss;

    int rec(int pos, int tight, int ones_count, int started) {
        if (pos == s.size()) {
            if (!started) return 0;
            if (tight == 1) return 0;
            int steps = f(ones_count);
            if (steps >= k) return 0;
            // cout << ss << endl;
            return 1;
        }
        if (dp[pos][tight][ones_count][started] != -1)
            return dp[pos][tight][ones_count][started];
        int res = 0;

        int limit = tight ? s[pos] - '0' : 1;

        if(0 <= limit)res = (res + rec(pos + 1, tight && (0 == limit), ones_count, started)) % MOD;
        if(1 <= limit)res = (res + rec(pos + 1, tight && (1 == limit), ones_count + 1, 1)) % MOD;
        
        return dp[pos][tight][ones_count][started] = res;
    }

    int countKReducibleNumbers(string s, int k) {
        this->s = s;
        this->k = k;
        memset(dp, -1, sizeof(dp));
        int ans = rec(0, 1, 0, 0);
        return ans;
    }
};
",1448285590
Varun Deep Saini,sojabhai,280,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        #define int long long
        const int mod = 1e9 + 7;
        map<int, int> dp; 
        map<int, int> sum;   

        for (auto &i : nums) {
            int cnt = 1; 
            int s = i; 
            for (int dx = -1; dx <= 1; dx += 2) {
                int neighbor = i + dx;
                if (dp.count(neighbor)) {
                    cnt = (cnt + dp[neighbor]) % mod;
                    s = (s + sum[neighbor] + dp[neighbor] * i % mod) % mod;
                }
            }

            dp[i] = (dp[i] + cnt) % mod;
            sum[i] = (sum[i] + s) % mod;
        }

        int ans = 0;
        for (auto& i : sum) {
            ans += i.second;
            ans %= mod;
        }
        #undef int 
        return (int)ans;
    }
};
",1448257745
naresh50,naresh50,281,3612,java,"class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        int n = nums.size();
        int[] arrStart = new int[n];
        int[] arrEnd = new int[n];

        for (int i = 0; i < n; i++) {
            if (arrStart[i] == 0) helper(arrStart, nums, i);
        }
        for (int i = n - 1; i >= 0; i--) {
            if (arrEnd[i] == 0) helper2(arrEnd, nums, i);
        }

        int ans = 0;
        for (int i = 0; i < n - 1; i++) {
            int tempAns = Math.min(arrEnd[i], arrStart[i + 1]);
            ans = Math.max(ans, tempAns);
        }

        if(ans>=k) return true;
        else return false;
    }
    public int helper(int[] arr, List<Integer> nums, int index) {
        if (index == nums.size() - 1 || nums.get(index) >= nums.get(index + 1)) {
            return arr[index] = 1;
        }
        return arr[index] = helper(arr, nums, index + 1) + 1;
    }

    public int helper2(int[] arr, List<Integer> nums, int index) {
        if (index == 0 || nums.get(index) <= nums.get(index - 1)) {
            return arr[index] = 1;
        }
        return arr[index] = helper2(arr, nums, index - 1) + 1;
    }
}",1448202340
naresh50,naresh50,281,3619,java,"import java.util.List;

class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        int n = nums.size();
        int[] arrStart = new int[n];
        int[] arrEnd = new int[n];

        for (int i = 0; i < n; i++) {
            if (arrStart[i] == 0) helper(arrStart, nums, i);
        }
        for (int i = n - 1; i >= 0; i--) {
            if (arrEnd[i] == 0) helper2(arrEnd, nums, i);
        }

        int ans = 0;
        for (int i = 0; i < n - 1; i++) {
            int tempAns = Math.min(arrEnd[i], arrStart[i + 1]);
            ans = Math.max(ans, tempAns);
        }
        return ans;
    }

    public int helper(int[] arr, List<Integer> nums, int index) {
        if (index == nums.size() - 1 || nums.get(index) >= nums.get(index + 1)) {
            return arr[index] = 1;
        }
        return arr[index] = helper(arr, nums, index + 1) + 1;
    }

    public int helper2(int[] arr, List<Integer> nums, int index) {
        if (index == 0 || nums.get(index) <= nums.get(index - 1)) {
            return arr[index] = 1;
        }
        return arr[index] = helper2(arr, nums, index - 1) + 1;
    }
}
",1448199668
naresh50,naresh50,281,3631,java,"class Solution {
    int MOD = (int)1e9+7;
    int k;
    String binaryString;
    int[] reductionSteps; 
    Integer[][][][] dp;

    public int countKReducibleNumbers(String s, int k) {
        binaryString = s;
        this.k = k;
        compute();
        int length = s.length();
        dp = new Integer[length + 1][length + 1][2][2];
        
        return findCount(0, 0, 1, 0);
    }

    void compute() {
        reductionSteps = new int[801]; 
        Arrays.fill(reductionSteps, -1);
        reductionSteps[1] = 0;
        for (int count = 2; count <= 800; count++) {
            int steps = 0;
            int temp = count;
            while (temp != 1) {
                temp = Integer.bitCount(temp);
                steps++;
            }
            reductionSteps[count] = steps;
        }
    }

   
    int findCount(int index, int onesCount, int tight, int hasStarted) {
        if (index == binaryString.length()) {
            if (hasStarted == 1) {
                if (tight == 1) {
                    return 0; 
                }
                int totalSteps = onesCount == 1 ? 0 : reductionSteps[onesCount] + 1;
                return totalSteps <= k ? 1 : 0;
            }
            return 0;
        }
        if (dp[index][onesCount][tight][hasStarted] != null) {
            return dp[index][onesCount][tight][hasStarted];
        }
        int maxDigit = tight == 1 ? binaryString.charAt(index) - '0' : 1;
        int count = 0;
        for (int digit = 0; digit <= maxDigit; digit++) {
            int newHasStarted = hasStarted;
            if (hasStarted == 0 && digit != 0) {
                newHasStarted = 1;
            }
            int newOnesCount = onesCount;
            if (newHasStarted == 1 && digit == 1) {
                newOnesCount += 1;
            }
            int newtight = tight;
            if (tight == 1 && digit < maxDigit) {
                newtight = 0;
            }
            count = (count + findCount(index + 1, newOnesCount, newtight, newHasStarted)) % MOD;
        }
        dp[index][onesCount][tight][hasStarted] = count;
        return count;
    }
}
",1448285659
naresh50,naresh50,281,3646,java,"class Solution {
    public int sumOfGoodSubsequences(int[] nums) { 
        int MOD = 1000000007;
        HashMap<Integer, Integer> cntMap = new HashMap<>();
        HashMap<Integer, Integer> smMap = new HashMap<>();
        
        for (int num : nums) {
            int cnt = 1; 
            int sm = num;
            
            for (int x = num - 1; x <= num + 1; x += 2) {
                if (cntMap.containsKey(x)) {
                    int prevCnt = cntMap.get(x);
                    int prevSm = smMap.get(x);
                    cnt = (cnt + prevCnt) % MOD;
                    sm = (int)(((long)sm + prevSm + (long)num * prevCnt) % MOD);
                }
            }
            cntMap.put(num, (cntMap.getOrDefault(num, 0) + cnt) % MOD);
            smMap.put(num, (smMap.getOrDefault(num, 0) + sm) % MOD);
        }
        
        int result = 0;
        for (int val : smMap.values()) {
            result = (result + val) % MOD;
        }
        return result;
    }
}",1448241217
Andrew H. Pometta,apometta,282,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        for i in range(n):
            if i + 2 * k > n: break

            success = True
            for j in range(i + 1, i + k):
                if nums[j] <= nums[j - 1]:
                    success = False
                    break
            if not success: continue

            for j in range(i + k + 1, i + (k * 2)):
                if nums[j] <= nums[j - 1]:
                    success = False
                    break

            if success: return True

        return False",1448184100
Andrew H. Pometta,apometta,282,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        streaks = []
        n = len(nums)

        curr = 1
        for i in range(1, n):
            if nums[i] > nums[i - 1]:
                curr += 1
            else:
                streaks.append(curr)
                curr = 1
        streaks.append(curr)

        best = streaks[0] // 2
        for i in range(1, len(streaks)):
            best = max(best, max(streaks[i] // 2, min(streaks[i - 1], streaks[i])))
        return best",1448193722
Andrew H. Pometta,apometta,282,3631,python3,"set_reductions = [-1] * 801
set_reductions[1] = 0
for i in range(2, len(set_reductions)):
    n = i
    bits = 0
    while n > 0:
        bits += (n & 1)
        n >>= 1
    set_reductions[i] = set_reductions[bits] + 1

class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        #constraints show that s[0] MUST be 1
        #otherwise we would prune until it is
        while len(s) > 0 and s[0] == '0':
            s = s[1:]
        if len(s) <= 1: return 0
        zeros, ones = s.count('0'), s.count('1')
            
        global set_reductions
        answer = 0
        LEN = len(s)
        BASE = 1_000_000_007

        for set_bits in range(1, LEN):
            if set_reductions[set_bits] + 1 > k: continue #irrelevant
            
            remaining = set_bits
            i = 0

            while i < LEN:
                if s[i] == '0':
                    i += 1
                    continue

                if remaining == 0:
                    answer += 1
                    answer %= BASE
                    break
                
                answer += comb(LEN - (i + 1), remaining)
                answer %= BASE
                remaining -= 1
                i += 1
        return answer",1448285662
Andrew H. Pometta,apometta,282,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        BASE = 1_000_000_007
        goods = 0
        cache = {}

        for i in range(len(nums) - 1, -1, -1):
            n = nums[i]
            if n not in cache:
                cache[n] = [0, 0]

            for j in (n + 1, n - 1):
                if j not in cache: continue
                
                count, total = cache[j]
                inc = count * n
                goods += total + inc
                cache[n][0] += count
                cache[n][1] += total + inc

                cache[n][0] %= BASE
                cache[n][1] %= BASE
                goods %= BASE

            cache[n][0] += 1
            cache[n][1] += n
            goods += n
            cache[n][0] %= BASE
            cache[n][1] %= BASE
            goods %= BASE

        return goods",1448210529
Sahil Kumar,user2672IT,285,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n=nums.size();
        vector<int> pref(n),suff(n);
        pref[0]=1;
        for(int i=1;i<n;i++){
            if(nums[i]>nums[i-1]){
                pref[i]=pref[i-1]+1;
            }else{
                pref[i]=1;
            }
            // cout<<pref[i]<<"" "";
        }
        
        
        suff[n-1]=1;
        for(int i=n-2;i>=0;i--){
            if(nums[i]<nums[i+1]){
                suff[i]=suff[i+1]+1;
            } else{
                suff[i]=1;
            }
            // cout<<suff[i]<<"" "";
        }
        int ans=1;
        for(int i=0;i<n-1;i++){
            ans=max(ans,min(pref[i],suff[i+1]));
        }
        return ans>=k;
    }
};",1448192686
Sahil Kumar,user2672IT,285,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n=nums.size();
        vector<int> pref(n),suff(n);
        pref[0]=1;
        for(int i=1;i<n;i++){
            if(nums[i]>nums[i-1]){
                pref[i]=pref[i-1]+1;
            }else{
                pref[i]=1;
            }
            // cout<<pref[i]<<"" "";
        }
        
        
        suff[n-1]=1;
        for(int i=n-2;i>=0;i--){
            if(nums[i]<nums[i+1]){
                suff[i]=suff[i+1]+1;
            } else{
                suff[i]=1;
            }
            // cout<<suff[i]<<"" "";
        }
        int ans=1;
        for(int i=0;i<n-1;i++){
            ans=max(ans,min(pref[i],suff[i+1]));
        }
        return ans;
    }
};",1448190347
Sahil Kumar,user2672IT,285,3631,cpp,"long long mod=1e9+7;

class Solution {
public:
    int oper;
    vector<int> res;
    vector<vector<vector<int>>> dp;
    int rec(int idx,string &s,int state,int sum){
        
        if(idx==s.size()){
            return res[sum]<=oper-1;
        }
        if(dp[state][idx][sum]!=-1)return dp[state][idx][sum];
        long long ans=0;
         if(state){
             if(s[idx]=='0'){
                 ans+=rec(idx+1,s,state,sum);
                 
             }else{
                 ans+=rec(idx+1,s,state,sum+1);
                 ans+=rec(idx+1,s,0,sum);
             }
         } else{
             
             ans+=rec(idx+1,s,0,sum);
             ans+=rec(idx+1,s,0,sum+1);
         }
        
        ans%=mod;
        return dp[state][idx][sum]=ans;
    }
    int countKReducibleNumbers(string s, int k) {
        
         int n=s.size();
         res=vector<int>(n+1);
         res[0]=k+1;
         int sum=0;
         for(int i=0;i<n;i++){
             sum+=(s[i]-'0');
         }
         for(int i=n;i>=1;i--){
             
             int temp=i;
             int cur=0;
             while(temp>1){
                 temp=__builtin_popcount(temp);
                 cur+=1;
             }
             res[i]=cur;
         }
        
        oper=k;
        dp=vector<vector<vector<int>>> (2,vector<vector<int>>(n,vector<int>(n+1,-1)));
        
        int ans=rec(0,s,1,0);
        if(res[sum]<=oper-1)
          ans-=1;
        ans+=mod;
        ans%=mod;
        
        return ans;
    }
};",1448286206
Sahil Kumar,user2672IT,285,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        long long mod=1e9+7;
        
        map<int,long long> dpnumber;
        map<int,long long> dpsum;
        int n=nums.size();
        int ans=0;
        for(int i=0;i<n;i++){
            dpnumber[nums[i]]+=dpnumber[nums[i]-1]+dpnumber[nums[i]+1]+1;
            dpnumber[nums[i]]%=mod;
            long long curr_sum=(dpnumber[nums[i]-1]+dpnumber[nums[i]+1]+1)*nums[i]+dpsum[nums[i]-1]+dpsum[nums[i]+1];
            curr_sum%=mod;
            dpsum[nums[i]]+=curr_sum;
            dpsum[nums[i]]%=mod;
            // cout<<dpsum[nums[i]]<<"" "";
            ans+=curr_sum;
            
            ans%=mod;
        }
        
        return ans;
    }
};",1448240819
zokumyoin,zokumyoin,286,3612,java,"class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        return maxIncreasingSubarrays(nums) >= k;
    }
    
    private int maxIncreasingSubarrays(List<Integer> nums) {

        int[] max = new int[nums.size()];
        for (int i = 0; i < nums.size(); i++) {
            if (i == 0) {
                max[i] = 1;
            } else if (nums.get(i) > nums.get(i - 1)) {
                max[i] = max[i - 1] + 1;
            } else {
                max[i] = 1;
            }
        }
        int lo = 1, hi = nums.size();
        while (lo < hi) {
            int mid = lo + (hi - lo + 1) / 2;
            boolean exists = false;
            for (int i = 0; i + mid < nums.size(); i++) {
                if (max[i] >= mid && max[i + mid] >= mid) {
                    exists = true;
                    break;
                }
            }
            if (exists) {
                lo = mid;
            } else {
                hi = mid - 1;
            }
        }
        return hi;

    }
}",1448190339
zokumyoin,zokumyoin,286,3619,java,"import java.util.Arrays;
import java.util.List;

class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {

        int[] max = new int[nums.size()];
        for (int i = 0; i < nums.size(); i++) {
            if (i == 0) {
                max[i] = 1;
            } else if (nums.get(i) > nums.get(i - 1)) {
                max[i] = max[i - 1] + 1;
            } else {
                max[i] = 1;
            }
        }
        int lo = 1, hi = nums.size();
        while (lo < hi) {
            int mid = lo + (hi - lo + 1) / 2;
            boolean exists = false;
            for (int i = 0; i + mid < nums.size(); i++) {
                if (max[i] >= mid && max[i + mid] >= mid) {
                    exists = true;
                    break;
                }
            }
            if (exists) {
                lo = mid;
            } else {
                hi = mid - 1;
            }
        }
        return hi;

    }
}",1448189450
zokumyoin,zokumyoin,286,3631,java,"import java.util.HashSet;

class Solution {
    public int countKReducibleNumbers(String s, int k) {

        // 1-reducible: has 1 one (1, 2, 4, 8 ..)
        // 2-reducible: has 1, 2, 4, 8 .. bits set

        // reduce s once -> a value <= 800

        int MOD = 1_000_000_007;

        int len = s.length();
        boolean[] canUseAsBitCount = new boolean[len + 1];

        for (int i = 1; i <= len; i++) {
            int times = 0;
            int v = i;
            while (v > 1) {
                times++;
                v = Integer.bitCount(v);
            }
            if (times <= k - 1) {
                canUseAsBitCount[i] = true;
            }
        }
        int[] prefOnes = new int[s.length()];
        for (int i = 0; i < s.length(); i++) {
            prefOnes[i] = s.charAt(i) - '0' + (i == 0 ? 0 : prefOnes[i - 1]);
        }

        int[][] dp = new int[s.length()][s.length()];

        dp[0][0] = 1;


        if (s.length() > 1) {
            dp[0][1] = 1;
        }

        for (int i = 1; i < s.length(); i++) {
            int bit = s.charAt(i) - '0';

            for (int j = 0; j < s.length(); j++) {
                int cnt = 0;

                // append 0
                cnt += dp[i - 1][j];

                // append 1
                if (j - 1 >= 0) {
                    cnt += dp[i - 1][j - 1];
                    cnt %= MOD;

                    // e.g.
                    // s =    101110...
                    // we get 101111
                    if (bit == 0 && prefOnes[i] == j - 1 && dp[i - 1][j - 1] > 0) {
                        cnt--;
                        cnt += MOD;
                        cnt %= MOD;
                    }
                }
                dp[i][j] = cnt;
//                System.out.printf(""dp[%d][%d]=%d\n"", i, j, cnt);
            }
        }

        int bitCount = 0;
        for (char c : s.toCharArray()) {
            if (c == '1') {
                bitCount++;
            }
        }
        if (bitCount < dp[0].length) {

            dp[s.length() - 1][bitCount]--;
            dp[s.length() - 1][bitCount] += MOD;
            dp[s.length() - 1][bitCount] %= MOD;
        }


        int ans = 0;
        for (int i = 1; i < s.length(); i++) {
            if (canUseAsBitCount[i]) {
//                System.out.printf(""dp[%d][%d]=%d\n"", s.length() - 1, i, dp[s.length() - 1][i]);
                ans += dp[s.length() - 1][i];
                ans %= MOD;
            }
        }
        return ans;


    }
}",1448279490
zokumyoin,zokumyoin,286,3646,java,"import java.util.Arrays;

class Solution {
    public int sumOfGoodSubsequences(int[] arr) {

        int MOD = 1_000_000_007;

        long ans = 0;

        int[] cntAtTail = new int[arr.length];
        int[] combined = new int[100001];


        for (int i = 0; i < arr.length; i++) {
            int v = arr[i];
            int cnt = 1;
            if (v - 1 >= 0) {
                cnt += combined[v - 1];
                cnt %= MOD;
            }
            if (v + 1 < combined.length) {
                cnt += combined[v + 1];
                cnt %= MOD;
            }
            cntAtTail[i] = cnt;

            combined[v] += cntAtTail[i];
            combined[v] %= MOD;
        }

        Arrays.fill(combined, 0);
        int[] cntAtHead = new int[arr.length];
        for (int i = arr.length - 1; i >= 0; i--) {
            int v = arr[i];
            int cnt = 1;
            if (v - 1 >= 0) {
                cnt += combined[v - 1];
                cnt %= MOD;
            }
            if (v + 1 < combined.length) {
                cnt += combined[v + 1];
                cnt %= MOD;
            }
            cntAtHead[i] = cnt;

            combined[v] += cntAtHead[i];
            combined[v] %= MOD;
        }

        for (int i = 0; i < arr.length; i++) {
            long totalCnt = (long) cntAtTail[i] * cntAtHead[i] % MOD;
            ans += totalCnt * arr[i] % MOD;
            ans %= MOD;
        }

        return (int) ans;


    }
}",1448223024
abhishek vaish,abhishekvaish,290,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        inc = [1] * n
        for i in range(1,n):
            if nums[i] > nums[i-1]:
                inc[i] = inc[i-1] + 1
        pre = [0] * (n+1)
        for i in range(n):
            pre[i+1] = inc[i] + pre[i]
        
        # print(""---""*n)
        # print(inc)
        req = (k * (k+1)) // 2
        for i in range(n-(2*k)+1):
            left = pre[i+k]-pre[i] - ((inc[i]-1)*k)
            right = pre[i+2*k] - pre[i+k] - ((inc[i+k]-1)*k)
            # print(i,left, right)
            if left == req and right == req:
                return True
        return False
            ",1448194070
abhishek vaish,abhishekvaish,290,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        inc = [1] * n
        for i in range(1,n):
            if nums[i] > nums[i-1]:
                inc[i] = inc[i-1] + 1
        pre = [0] * (n+1)
        for i in range(n):
            pre[i+1] = inc[i] + pre[i]
        
        # print(""---""*n)
        # print(inc)
        def possible(k):
            req = (k * (k+1)) // 2
            for i in range(n-(2*k)+1):
                left = pre[i+k]-pre[i] - ((inc[i]-1)*k)
                right = pre[i+2*k] - pre[i+k] - ((inc[i+k]-1)*k)
                # print(i,left, right)
                if left == req and right == req:
                    return True
            return False
        
        b,e = 1,(n//2) + 1
        while b < e:
            m = (b+e)//2
            if not possible(m):
                e = m
            else:
                b = m + 1
        return b-1
                
        
        ",1448198307
abhishek vaish,abhishekvaish,290,3631,python3,"from functools import cache
m = 801
inf = float('inf')
count = [inf] * m
count[1] = 0
for i in range(2,m):
    count[i] = 1 + count[i.bit_count()]

# fact = [1]*m
# ifact = [1]*m
MOD =10**9+7
# for i in range(2,m):
#     fact[i] = (i * fact[i-1]) % MOD
    
# ifact[m-1] = pow(fact[m-1],-1,MOD)
# for i in reversed(range(m-1)):
#     ifact[i] = ((i+1) * ifact[i+1] ) % MOD


class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        n = len(s)
        if n == 1: return 0
        @cache
        def DP(i,cnt,upper):
            if i == n:
                if upper: return 0
                return 0 if  count[cnt] + 1 > k else 1
            
            res = 0
            if upper:
                if s[i] == '0':
                    res = DP(i+1,cnt,True)
                else:
                    res = DP(i+1,cnt,False) + DP(i+1,cnt+1,True)
            else:
                res = DP(i+1,cnt+1,False) + DP(i+1,cnt,False)
            
            return res % MOD
        
        return DP(0,0,True)
                
        
        
        # m = 0
        # for x in s: 
        #     if x == '1':
        #         m += 1
        # print((fact[3]*ifact[1]*ifact[2])%MOD)
#         print(""---""*n)
        
#         res = 0
#         for i in range(1,m+1):
#             if count[i]+1 > k: continue
#             # nCi
#             print(i,(fact[n] * ifact[i] * ifact[n-i])%MOD)
#             res += (fact[n] * ifact[i] * ifact[n-i])%MOD
#             res %= MOD
        # return res
            
        
        
        ",1448280143
abhishek vaish,abhishekvaish,290,3646,python3,"MOD = 10**9+7
class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        # [3,4,5]
        # [19,13,5]
        n = len(nums)
        m = max(nums) + 3
        DP = [0]*m
        count = [0] * m
        # idx = [m-1] * m
        for i in reversed(range(n)):
            x = nums[i]
            
            # DP[x] = x 
            count[x] += (1 + count[x+1] + count[x-1])
            DP[x] += (x + x*count[x+1] + DP[x+1] + DP[x-1] + x*count[x-1]) % MOD
            
            DP[x] %= MOD
            count[x] %= MOD
            
#             if DP[x+1] > 0:
#                 DP[x] += x + DP[x+1]
#             if DP[x-1] > 0:
#                 DP[x] += x + DP[x-1]
                
#             DP[x] %= MOD
        
        s = 0 
        for x in DP:
            s = (s+x)%MOD
        return s",1448232992
Chou,a0920732333,292,3612,cpp,"class Solution 
{
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) 
    {
        int n = nums.size(), l = 0;
        vector<int> left(n);
        for(int r = 1; r < n; r++)
        {
            if(nums[r] > nums[r - 1])
            {
                left[r] = l;
            }
            else
            {
                left[r] = r;
                l = r;
            }
        }
        for(int i = k * 2 - 1; i < n; i++)
        {
            if(i - left[i] + 1 >= k && i - k - left[i - k] + 1 >= k)
            {
                return true;
            }
        }
        return false;
    }
};",1448185780
Chou,a0920732333,292,3619,cpp,"class Solution 
{
public:
    int maxIncreasingSubarrays(vector<int>& nums) 
    {
        int n = nums.size(), l = 0, r = 1;
        vector<int> left(n);
        for(; r < n; r++)
        {
            if(nums[r] > nums[r - 1])
            {
                left[r] = l;
            }
            else
            {
                left[r] = r;
                l = r;
            }
        }
        vector<int> right(n);
        r = n - 1;
        l = n - 2;
        right[r] = r;
        for(; l >= 0; l--)
        {
            if(nums[l] < nums[l + 1])
            {
                right[l] = r;
            }
            else
            {
                right[l] = l;
                r = l;
            }
        }
        int k = 1;
        for(int i = 0; i + 1 < n; i++)
        {
            k = max(k, min(i - left[i] + 1, right[i + 1] - (i + 1) + 1));
        }
        return k;
    }
};",1448194259
Chou,a0920732333,292,3631,cpp,"class Solution 
{
public:
    const int mod = 1e9 + 7;
    vector<long long> factorial, moduleInverse_factorial;
    long long fastPower(long long a, long long b)//a ^ b
    {
        long long ans = 1;
        while(b)
        {
            if(b & 1)
            {
                ans = (ans * a) % mod;
            }
            a = (a * a) % mod;
            b >>= 1;
        }
        return ans;
    }
    long long C(int a, int b)//a!/b!/(a-b)!, a <= 40, b <= 40
    {
        return ((factorial[a] * moduleInverse_factorial[b]) % mod * moduleInverse_factorial[a - b]) % mod;
    }
    long long moduleInverse(long long a, long long p)//a^(p - 2)
    {
        return fastPower(a, p - 2);
    }
    int reduce(int n)
    {
        int t = 1;
        while(n != 1)
        {
            n = __builtin_popcount(n);
            t++;
        }
        return t;
    }
    int countKReducibleNumbers(string s, int k) 
    {
        long long ans = 0;
        int n = s.length();
        factorial.resize(n + 1);
        moduleInverse_factorial.resize(n + 1);
        factorial[0] = factorial[1] = 1;
        moduleInverse_factorial[0] = moduleInverse_factorial[1] = 1;
        for(int i = 2; i < n + 1; i++)
        {
            factorial[i] = (factorial[i - 1] * i) % mod;
            moduleInverse_factorial[i] = moduleInverse(factorial[i], mod);
        }
        int pre = 0;
        for(int i = 0; i < n; i++)
        {
            if(s[i] == '1')
            {
                int digit = n - i - 1;
                //0 1
                if(i != 0)
                {
                    ans = (ans + (reduce(pre) <= k)) % mod;
                }
                for(int j = 1; j <= digit; j++)
                {
                    if(reduce(j + pre) <= k)
                    {
                        ans = (ans + C(digit, j)) % mod;
                        // cout << i << ' ' << j << ' ' << digit << ' ' << C(digit, j) << '\n';
                    }
                }
                pre++;
            }
        }
        return ans;
    }
};
//1111...800
//800
//3
//2
//1
//1 2 4 8

//2
//3 5 9 

//3
//7 14

//111
//0 + 00 01 10 11
//1 + 0 + 0 1
//1 + 1 + 0
//000 001 010 011
//100 101
//110",1448280239
Chou,a0920732333,292,3646,cpp,"class Solution 
{
public:
    int sumOfGoodSubsequences(vector<int>& nums) 
    {
        int mod = 1e9 + 7;
        long long ans = 0;
        unordered_map<long long, pair<long long, long long>> um;
        for(int& it : nums)
        {
            long long buf = (um[it - 1].first * it + um[it - 1].second + um[it + 1].first * it + um[it + 1].second) % mod;
            um[it].first = (1 + um[it].first + um[it - 1].first + um[it + 1].first) % mod;
            um[it].second = (um[it].second + buf + it) % mod;
            ans = (ans + buf + it) % mod;
            // cout << um[it].first << ' ' << um[it].second << '\n';
        }
        return (int)ans;
    }
};",1448219267
Sam Huang,CelonyMire,295,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& a, int k) {
        int n = a.size();
        for (int i = 0; i + k <= n; i++) {
            for (int j = 0; j + k <= n; j++) {
                bool ok = j == i + k;
                for (int k2 = 1; k2 < k; k2++) {
                    ok &= a[i + k2] > a[i + k2 - 1] && a[j + k2] > a[j + k2 - 1];
                }
                if (ok) {
                    return true;
                }
            }
        }
        return false;
    }
};",1448185217
Sam Huang,CelonyMire,295,3619,cpp,"#include <bits/stdc++.h>
using namespace std;

#ifdef LC_LOCAL
#include ""parser.hpp""
#else
#define dbg(...)
#endif

// ----- CHANGE FOR PROBLEM -----
class Solution {
public:
  int maxIncreasingSubarrays(vector<int> &a) {
    int n = a.size();
    vector<int> inc(n + 1);
    for (int i = 0, j = 1; i < n; i++) {
      for (j = max(j, i + 1); j < n && a[j] > a[j - 1]; j++) {
      }
      inc[i] = j - i;
    }
    int ans = 0;
    for (int i = 0; i < n; i++) {
      ans = max(ans, inc[i] / 2);
      ans = max(ans, min(inc[i], inc[i + inc[i]]));
    }
    return ans;
  }
};
// ----- CHANGE FOR PROBLEM -----

#ifdef LC_LOCAL
int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  exec(&Solution::maxIncreasingSubarrays); // CHANGE FOR PROBLEM
}
#endif",1448199746
Sam Huang,CelonyMire,295,3631,cpp,"#include <bits/stdc++.h>
using namespace std;

#ifdef LC_LOCAL
#include ""parser.hpp""
#else
#define dbg(...)
#endif

// ----- CHANGE FOR PROBLEM -----
class Solution {
public:
  int countKReducibleNumbers(string s, int k) {
    const int M = 1e9 + 7;
    int n = s.size();
    vector dp(n + 1, vector(n + 1, vector(2, -1)));
    auto dfs = [&](auto &self, int i, int c, int f) -> int {
      if (i == n) {
        return c == 0;
      }
      if (c == -1) {
        return 0;
      }
      if (dp[i][c][f] != -1) {
        return dp[i][c][f];
      }
      int ans = 0;
      if (f) {
        if (s[i] == '0') {
          ans += self(self, i + 1, c, f);
          ans %= M;
        } else {
          ans += self(self, i + 1, c - 1, f);
          ans %= M;
          ans += self(self, i + 1, c, false);
          ans %= M;
        }
      } else {
        ans += self(self, i + 1, c, false);
        ans %= M;
        ans += self(self, i + 1, c - 1, false);
        ans %= M;
      }
      return dp[i][c][f] = ans;
    };
    vector<int> cnt(n);
    for (int i = 1; i < n; i++) {
      cnt[i] = dfs(dfs, 0, i, 1);
    }
    int c = ranges::count(s, '1');
    int ans = 0;
    for (int i = 1; i < n; i++) {
      int x = i;
      for (int k2 = 0; k2 < k - 1; k2++) {
        x = popcount(1U * x);
      }
      dbg(i, x, cnt[i]);
      if (x == 1) {
        ans += cnt[i] - int(i == c);
        ans %= M;
      }
    }
    dbg(cnt);
    return ans;
  }
};
// ----- CHANGE FOR PROBLEM -----

#ifdef LC_LOCAL
int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  exec(&Solution::countKReducibleNumbers); // CHANGE FOR PROBLEM
}
#endif",1448280854
Sam Huang,CelonyMire,295,3646,cpp,"#include <bits/stdc++.h>
using namespace std;

#ifdef LC_LOCAL
#include ""parser.hpp""
#else
#define dbg(...)
#endif

// ----- CHANGE FOR PROBLEM -----
template <int M>
struct int_mod {
  int v{};
  constexpr int_mod() = default;
  constexpr int_mod(long long vx) : v((vx % M + M) % M) {}
  constexpr int_mod &operator=(long long vx) {
    v = (vx % M + M) % M;
    return *this;
  }
#define OP(op)                                                                                                                                                                                                                                                                                                                                                                                                 \
  constexpr friend int_mod operator op(const int_mod &a, const int_mod &b) {                                                                                                                                                                                                                                                                                                                                   \
    return ((1LL * a.v op b.v) % M + M) % M;                                                                                                                                                                                                                                                                                                                                                                   \
  }                                                                                                                                                                                                                                                                                                                                                                                                            \
  constexpr friend int_mod operator op(long long a, const int_mod &b) {                                                                                                                                                                                                                                                                                                                                        \
    return (((a % M + M) % M op b.v) % M + M) % M;                                                                                                                                                                                                                                                                                                                                                             \
  }                                                                                                                                                                                                                                                                                                                                                                                                            \
  constexpr int_mod &operator op##=(const int_mod & other) {                                                                                                                                                                                                                                                                                                                                                   \
    v = ((1LL * v op other.v) % M + M) % M;                                                                                                                                                                                                                                                                                                                                                                    \
    return *this;                                                                                                                                                                                                                                                                                                                                                                                              \
  }
  OP(+)
  OP(-)
  OP(*)
#undef OP
};

const int M = 1e9 + 7;

class Solution {
public:
  int sumOfGoodSubsequences(vector<int> &a) {
    int n = a.size();
    int mx = ranges::max(a);
    vector l(n, int_mod<M>());
    vector r(n, int_mod<M>());
    int_mod<M> ans = 0;
    {
      vector dp(mx + 2, int_mod<M>(0));
      for (int i = 0; i < n; i++) {
        auto cur = dp[a[i] + 1];
        if (a[i] > 0) {
          cur += dp[a[i] - 1];
        }
        l[i] = cur + 1;
        dp[a[i]] += cur + 1;
      }
    }
    {
      vector dp(mx + 2, int_mod<M>(0));
      for (int i = n - 1; i >= 0; i--) {
        auto cur = dp[a[i] + 1];
        if (a[i] > 0) {
          cur += dp[a[i] - 1];
        }
        r[i] = cur + 1;
        dp[a[i]] += cur + 1;
      }
    }
    for (int i = 0; i < n; i++) {
      ans += l[i] * r[i] * a[i];
    }
    return ans.v;
  }
};
// ----- CHANGE FOR PROBLEM -----

#ifdef LC_LOCAL
int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  exec(&Solution::sumOfGoodSubsequences); // CHANGE FOR PROBLEM
}
#endif",1448222907
Zamfirescu George-Iulian,SkinnySnakeLimb,297,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        for a in range(n - 2 * k + 1):
            ar1 = nums[a:a + k]
            ar2 = nums[a + k:a + 2 * k]

            ok = True
            for i in range(1, k):
                if ar1[i] <= ar1[i - 1]:
                    ok = False
                    break
                if ar2[i] <= ar2[i - 1]:
                    ok = False
                    break
            if ok:
                return ok

        return False",1448185614
Zamfirescu George-Iulian,SkinnySnakeLimb,297,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        bigs = [0] * n
        r = 0
        for l in range(n):
            if l > r:
                r = l
            while r + 1 < n and nums[r + 1] > nums[r]:
                r += 1

            bigs[l] = r - l + 1
        print(bigs)
        lo = 0
        up = n // 2
        ret = 0
        while lo <= up:
            mid = (lo + up) // 2
            ok = False
            for i in range(n - 2 * mid + 1):
                if bigs[i] >= mid and bigs[i + mid] >= mid:
                    ok = True
                    break

            if ok:
                ret = mid
                lo = mid + 1
            else:
                up = mid - 1

        return ret
                    ",1448192337
Zamfirescu George-Iulian,SkinnySnakeLimb,297,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        MOD = 10 ** 9 + 7
        n = len(s)

        @cache
        def factMod(n):
            if n <= 1:
                return 1

            ret = 1
            for i in range(2, n + 1):
                ret *= i
                ret %= MOD

            return ret

        def nck(n, k):
            ret = factMod(n)
            ret *= pow(factMod(k), -1, MOD)
            ret *= pow(factMod(n - k), -1, MOD)

            return ret % MOD

        @cache
        def get_freqs(pos):
            rem = n - pos
            ret = {}
            if pos == n - 1:
                if s[-1] == '1':
                    return {0: 1, 1: 1}
                else:
                    return {0: 1}
            
            if s[pos] == '1':
                for k in range(0, rem - 1 + 1):
                    ret[k] = ret.get(k, 0) + nck(rem - 1, k)
                    ret[k] %= MOD
                    
            temp = get_freqs(pos + 1)
            off = 1 if s[pos] == '1' else 0
            for k in temp:
                ret[k + off] = ret.get(k + off, 0) + temp[k]
                ret[k + off] %= MOD

            return ret

        counts = get_freqs(0)
        c = Counter(s)
        counts[c['1']] -= 1

        dists = [1_000] * (n + 1)
        dists[1] = 0

        for i in range(2, n + 1):
            o = i.bit_count()
            dists[i] = min(dists[i], dists[o] + 1)

        ret = 0
        for am, cnt in counts.items():
            if dists[am] <= k - 1:
                ret += cnt
                ret %= MOD

        return ret",1448274529
Zamfirescu George-Iulian,SkinnySnakeLimb,297,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        MOD = 10 ** 9 + 7

        ret = 0
        have = {}

        for num in nums:
            val = 1
            sums = num
            if num - 1 in have:
                val += have[num - 1][0]
                sums += have[num - 1][1] + have[num - 1][0] * num
                sums %= MOD
            if num + 1 in have:
                val += have[num + 1][0]
                sums += have[num + 1][1] + have[num + 1][0] * num
                sums %= MOD
            if num in have:
                val += have[num][0]
                sums += have[num][1]
                sums %= MOD
                
            have[num] = (val, sums)

        return sum([v[1] for v in have.values()]) % MOD",1448214880
xymabinogi,xymabinogi,298,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> dp(n, 0);
        dp[0] = 1;
        
        for (int i = 1; i < n; i++){
            if (nums[i] > nums[i - 1]) dp[i] = dp[i - 1] + 1;
            else dp[i] = 1;
        }
        
        for (int i = 0; i < n; i++){
            int b = i + k;
            int br = b + k - 1;
            if (br >= n) break;
            
            if (dp[br] >= k and dp[b - 1] >= k) return true;
            
        }
        return false;
    }
};",1448182129
xymabinogi,xymabinogi,298,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp(n, 0);
        dp[0] = 1;
        
        for (int i = 1; i < n; i++){
            if (nums[i] > nums[i - 1]) dp[i] = dp[i - 1] + 1;
            else dp[i] = 1;
        }
        
        auto check = [&](int k) -> bool {
            for (int i = 0; i < n; i++){
                int b = i + k;
                int br = b + k - 1;
                if (br >= n) break;

                if (dp[br] >= k and dp[b - 1] >= k) return true;
            
            }
            return false;
        };
        
        
        int l = 0, r = n;
        while(l < r){
            int mid = (l + r + 1) / 2;
            if (check(mid)) l = mid;
            else r = mid - 1;
        }
        return l;
        
    }
};",1448183648
xymabinogi,xymabinogi,298,3631,cpp,"constexpr int P = 1000000007;
using i64 = long long;
// assume -P <= x < 2P
int modNorm(int x) {
    if (x < 0) {
        x += P;
    }
    if (x >= P) {
        x -= P;
    }
    return x;
}
template<class T>
T power(T a, i64 b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}
struct Z {
    int x;
    Z(int x = 0) : x(modNorm(x)) {}
    Z(i64 x) : x(modNorm(x % P)) {}
    int val() const {
        return x;
    }
    Z operator-() const {
        return Z(modNorm(P - x));
    }
    Z inv() const {
        assert(x != 0);
        return power(*this, P - 2);
    }
    Z &operator*=(const Z &rhs) {
        x = i64(x) * rhs.x % P;
        return *this;
    }
    Z &operator+=(const Z &rhs) {
        x = modNorm(x + rhs.x);
        return *this;
    }
    Z &operator-=(const Z &rhs) {
        x = modNorm(x - rhs.x);
        return *this;
    }
    Z &operator/=(const Z &rhs) {
        return *this *= rhs.inv();
    }
    friend Z operator*(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res *= rhs;
        return res;
    }
    friend Z operator+(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res += rhs;
        return res;
    }
    friend Z operator-(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res -= rhs;
        return res;
    }
    friend Z operator/(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res /= rhs;
        return res;
    }
    friend std::istream &operator>>(std::istream &is, Z &a) {
        i64 v;
        is >> v;
        a = Z(v);
        return is;
    }
    friend std::ostream &operator<<(std::ostream &os, const Z &a) {
        return os << a.val();
    }
};
const int M = 850;
class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        
        int n = s.length();
        vector<int> steps(n + 1, 0);
        steps[1] = 1;
        for (int i = 2; i <= n; i++){
            bitset<M> x(i);
            steps[i] = steps[x.count()] + 1;
        }   
        Z res = 0;
        
        vector<vector<vector<Z>>> dp(n + 1, vector<vector<Z>>(n + 1, vector<Z>(2, 0)));
        dp[0][0][1] = 1;
        
        vector<int> vec(n);
        for (int i = 0; i < n; i++){
            if (s[i] == '1') vec[i] = 1;
            else vec[i] = 0;
        }
        
        
        for (int i = 0; i < n; i++){
            for (int j = 0; j < n; j++){
                for (int w = 0; w < 2; w++){
                    for (int p = 0; p < 2; p++){
                        bool valid = !w or (w == 1 and p <= vec[i]);
                        bool bounded = (w == 1 and p == vec[i]);
                        
                        if (valid) dp[i + 1][j + (p == 1)][bounded] += dp[i][j][w];
                        
                    }
                }
            }
        }
        
        for (int j = 1; j <= n; j++) if (steps[j] <= k){
            res += dp[n][j][0];
            res += dp[n][j][1];
        }
        
    
        bitset<M> x(s);
        if (steps[x.count()] <= k) res -= 1;
        return res.val();
        
    }
    
    
    
    
    
};",1448274841
xymabinogi,xymabinogi,298,3646,cpp,"constexpr int P = 1000000007;
using i64 = long long;
// assume -P <= x < 2P
int modNorm(int x) {
    if (x < 0) {
        x += P;
    }
    if (x >= P) {
        x -= P;
    }
    return x;
}
template<class T>
T power(T a, i64 b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}
struct Z {
    int x;
    Z(int x = 0) : x(modNorm(x)) {}
    Z(i64 x) : x(modNorm(x % P)) {}
    int val() const {
        return x;
    }
    Z operator-() const {
        return Z(modNorm(P - x));
    }
    Z inv() const {
        assert(x != 0);
        return power(*this, P - 2);
    }
    Z &operator*=(const Z &rhs) {
        x = i64(x) * rhs.x % P;
        return *this;
    }
    Z &operator+=(const Z &rhs) {
        x = modNorm(x + rhs.x);
        return *this;
    }
    Z &operator-=(const Z &rhs) {
        x = modNorm(x - rhs.x);
        return *this;
    }
    Z &operator/=(const Z &rhs) {
        return *this *= rhs.inv();
    }
    friend Z operator*(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res *= rhs;
        return res;
    }
    friend Z operator+(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res += rhs;
        return res;
    }
    friend Z operator-(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res -= rhs;
        return res;
    }
    friend Z operator/(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res /= rhs;
        return res;
    }
    friend std::istream &operator>>(std::istream &is, Z &a) {
        i64 v;
        is >> v;
        a = Z(v);
        return is;
    }
    friend std::ostream &operator<<(std::ostream &os, const Z &a) {
        return os << a.val();
    }
};
const int M = 1E5 + 5;
Z dp[M];
Z val[M];

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int n = nums.size();
        memset(dp, 0, sizeof(dp));
        memset(val, 0, sizeof(val));
        Z res = 0;
        for (auto v : nums){
            if (v) {
                res += (val[v - 1] + dp[v - 1] * v);
                val[v] += val[v - 1] + dp[v - 1] * v;
                dp[v] += dp[v - 1];
            }
            res += (val[v + 1] + dp[v + 1] * v);
            val[v] += val[v + 1] + dp[v + 1] * v;
            dp[v] += dp[v + 1];
            
            dp[v] += 1;
            val[v] += v;
            res += v;
            
        }
        return res.val();
    }
};",1448195178
Pankaj Ananda Bhosale,pankaj_777,300,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        auto check = [&] (vector<int> x) -> bool {
            for (int i = 1; i < k; i++) {
                if (x[i - 1] >= x[i]) 
                    return false;
            }
            return true;
        };
        
        for (int i = 0; i <= n - 2 * k; i++) {
            vector<int> a, b;
            for (int j = i; j < i + k; j++) {
                a.push_back(nums[j]);
            }
            for (int j = i + k; j < i + 2 * k; j++) {
                b.push_back(nums[j]);
            }
            if (check(a) and check(b)) return true;
        }
        return false;
    }
};",1448186023
Pankaj Ananda Bhosale,pankaj_777,300,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp(n + 1);
        for (int i = 0, j = 0; j < n; i = j) {
            int prev = INT_MIN;
            while (j < n and nums[j] > prev) {
                prev = nums[j];
                j++;
            }
            for (int k = i; k < j; k++) {
                dp[k] = j - k; 
            }
        }
        
        auto possible = [&] (int mid) -> bool {
            for (int i = 0; i <= n - 2 * mid; i++) {
                if (dp[i] >= 2 * mid) return true;
                if (dp[i] >= mid and dp[i + mid] >= mid) 
                    return true;
            }
            return false;
        };
        
        int low = 1, high = n / 2;
        while (low <= high) {
            int mid = low + (high - low) / 2;
            if (possible(mid)) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        
        return low - 1;
    }
};",1448207769
Pankaj Ananda Bhosale,pankaj_777,300,3631,cpp,"#define ll long long int
const int mod = 1e9 + 7;

class Solution {
public:
    int addm(ll a, ll b) {
        return (a + b) % mod;
    } 
    
    bool is_K_Reducible(int x, int k) {
        while (k--) {
            x = __builtin_popcount(x);
        }
        return x == 1;
    }
    
    int countKReducibleNumbers(string s, int k) {
        int n = s.size();
        
        vector<vector<vector<int>>> dp(n + 1, vector<vector<int>> (n + 2, vector<int> (2, -1)));
        auto fun = [&] (int idx, int cnt, int isEqual, auto&& fun) -> int {
            if (idx == n) {
                return !isEqual and is_K_Reducible(cnt, k - 1);
            }
            
            if (dp[idx][cnt][isEqual] != -1) return dp[idx][cnt][isEqual];
            int res = 0;
            
            char lmt = (isEqual ? s[idx] : '1');
            for (char ch = '0'; ch <= lmt; ch++) {
                res = addm(res, fun(idx + 1, cnt + (ch - '0'), isEqual and ch == lmt, fun));
            }
            
            return dp[idx][cnt][isEqual] = res;
        };
        
        return fun(0, 0, 1, fun);
    }
};",1448268696
Pankaj Ananda Bhosale,pankaj_777,300,3646,cpp,"#define ll long long int
const int N = 1e5 + 10;
const int mod = 1e9 + 7;

int addm(ll a, ll b) {
    return (a + b) % mod;
}

int mulm(ll a, ll b) {
    return (a * b) % mod;
}

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int n = nums.size();
        vector<pair<int, int>> dp(N); // cnt, sum
        vector<int> res(n); // sum of all subsequences starting from i
        int ans = 0;
        for (int i = n - 1; i >= 0; i--) {
            int x = nums[i];
            int cnt = dp[x + 1].first, sum = dp[x + 1].second;
            if (x) {
                cnt = addm(cnt, dp[x - 1].first);
                sum = addm(sum, dp[x - 1].second);
            }
            res[i] = addm(sum, mulm(x, cnt + 1));
            dp[x].first = addm(cnt + 1, dp[x].first);
            dp[x].second = addm(dp[x].second, res[i]);
            ans = addm(ans, res[i]);
        }
        return ans;
    }
};",1448243659
kdplus,Mikaalm,301,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        set<int> s;
        for (int i = 0; i + k - 1 < nums.size(); ++i) {
            int flag = true;
            for (int j = i + 1; j <= i + k - 1; ++j) {
                if (nums[j] <= nums[j - 1]) {
                    flag = false;
                    break;
                }
            }
            if (flag) s.insert(i);
            // if (flag)cout << i << endl;
            if (flag && s.count(i - k)) return true;
        }
        return false;
    }
};",1448185993
kdplus,Mikaalm,301,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        int cnt = 1;
        vector<int> len(n, 1);
        for (int i = 0; i < nums.size(); ++i) {
            if (i && nums[i] > nums[i - 1]) {
                ++cnt;
            } else {
                cnt = 1;
            }
            len[i] = cnt; 
        }

        auto check = [&] (int k) {
            for (int i = 0; i < n; ++i) {
                if (len[i] >= k && i - k >= 0 && len[i - k] >= k) return true;
            }
            return false;
        };
        int l = 1, r = n + 1, mid;
        while (l < r) {
            mid = l + (r - l) / 2;
            if (!check(mid)) r = mid;
            else l = mid + 1;
        }
        
        return l - 1;
    }
};",1448204022
kdplus,Mikaalm,301,3631,cpp,"class Solution {
public:
    using ll = long long;
    int countKReducibleNumbers(string s, int k) {
        const ll MOD = 1e9 + 7;
        const ll p = MOD;
        vector<ll> inv(800 + 1), fact(800 + 1), fact_inv(800 + 1);
        inv[1] = 1;
        for (ll i = 2; i < inv.size(); ++i) inv[i] = (p - p / i) * inv[p % i] % p;
    
        // 预处理线性求阶乘的逆元 为组合数做铺垫
        fact[0] = 1;
        fact_inv[0] = 1;
        for (ll i = 1; i < fact.size(); ++i) {
            fact[i] = fact[i - 1] * i % p;
            fact_inv[i] = fact_inv[i - 1] * inv[i] % p;
        }
    
        // 基于阶乘逆元求组合数取模
        auto Comb = [&](const auto n, const auto m) -> ll {
            if (n < m) return 0;
            return fact[n] * fact_inv[n - m] % p * fact_inv[m] % p;
        }; 
        
        vector<ll> dp(801, 0);
        dp[1] = 1;
        int n = s.length();
        for (int i = 2; i <= 800; ++i) {
            int bc = __builtin_popcount(i);
            assert(dp[bc] != 0);
            dp[i] = dp[bc] + 1;   
            // cout << i << ' ' << dp[i] << endl;
        }
        ll ans = 0;
        ll have = 0;
        for (int i = 0; i < n; ++i) {
            if (s[i] == '1') {
                int len = n - i - 1;
                for (int j = 0; j <= len; ++j) {
                    if (dp[have + j] > k or have + j == 0) continue;
                    ans = (ans + Comb(len, j)) % MOD;
                    // cout << len << ""_"" << j <<  ""_"" << ans << endl;
                }
                // cout << ans << endl;
                ++have;
            }
        }
        return ans; 
    }
};",1448282779
kdplus,Mikaalm,301,3646,cpp,"class Solution {
public:
    using ll = long long;
    int sumOfGoodSubsequences(vector<int>& nums) {
        int n = nums.size();
        ll const MOD = 1e9 + 7;
        unordered_map<ll, ll> dp, sum;
        for (int i = 0; i < nums.size(); ++i) {
            int num = nums[i];
            dp[num] += dp[num - 1];
            dp[num] %= MOD;
            dp[num] += dp[num + 1];
            dp[num] %= MOD;
            dp[num] += 1;
            dp[num] %= MOD;
            
            sum[num] += sum[num - 1] + num * dp[num - 1] % MOD;
            sum[num] %= MOD;
            sum[num] += sum[num + 1] + num * dp[num + 1] % MOD;
            sum[num] %= MOD;
            sum[num] += num;
            sum[num] %= MOD;
            // cout << num << ' ' << dp[num] << endl;
        }
        ll ans = 0;
        for (auto [k, v] : sum) ans = (ans + v) % MOD;
        return ans;
    }
};",1448221800
Guddu Singh,guddusingh123,302,3612,cpp,"// DEBUGGING TEMPLATE
#define sim template < class c
#define ris return * this
#define dor > debug & operator <<
#define eni(x) sim > typename \
enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {
sim > struct rge { c b, e; };
sim > rge<c> range(c i, c j) { return rge<c>{i, j}; }
sim > auto dud(c* x) -> decltype(cout << *x, 0);
sim > char dud(...);
struct debug {
#ifndef ONLINE_JUDGE
~debug() { cout << endl; }
eni(!=) cout << boolalpha << i; ris; }
eni(==) ris << range(begin(i), end(i)); }
sim, class b dor(pair < b, c > d) {
ris << ""("" << d.first << "", "" << d.second << "")"";
}
sim dor(rge<c> d) {
*this << ""["";
for (auto it = d.b; it != d.e; ++it)
*this << "", "" + 2 * (it == d.b) << *it;
ris << ""]"";
}
#else
sim dor(const c&) { ris; }
#endif
};
#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""

class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& a, int k) {
        int n = a.size();
        vector<int> suf(n, 1);
        for (int i = n - 2; i >= 0; i--) {
            if (a[i] < a[i + 1]) {
                suf[i] = suf[i + 1] + 1;                
            }
        }
        
        for (int i = 0; i + k < n; i++) {
            
            if (suf[i] >= k && suf[i + k] >= k) {
                return true;
            }
        }
        return false;
    }
};",1448187103
Guddu Singh,guddusingh123,302,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& a) {
        int n = a.size();
        vector<int> suf(n, 1), pre(n, 1);
        for (int i = n - 2; i >= 0; i--) {
            if (a[i] < a[i + 1]) {
                suf[i] = suf[i + 1] + 1;                
            }
        }
        for (int i = 1; i < n; i++) {
            if (a[i] > a[i - 1]) {
                pre[i] = pre[i - 1] + 1;
            }
        }
        
        int res = 0;
        for (int i = 1; i < n; i++) {
            res = max(res, min(pre[i - 1], suf[i]));
        }
        return res;
    }
};",1448195127
Guddu Singh,guddusingh123,302,3631,cpp,"#define ll long long

const int mod = 1e9 + 7;

ll add(ll &x, ll y) {
    x = (x + y) % mod;
    return x;
}

class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        int n = s.size();
        
        vector<ll> pre(n + 1);
        pre[1] = 0;
        for (int i = 2; i <= n; i++) {
            int c = 0;
            for (int j = 0; j < 10; j++) {
                if (i >> j & 1) {
                    c++;
                }
            }
            pre[i] = pre[c] + 1;
        }
        
        vector<vector<vector<ll>>> dp(n + 1, vector<vector<ll>>(n + 1, vector<ll>(2, -1)));
        auto fun = [&](auto self, int i, int c, int f) {
            if (i >= n){ 
                if (f) return 0LL;
                return (ll)(pre[c] < k);
            }
            if (dp[i][c][f] != -1) return dp[i][c][f];  
            dp[i][c][f] = 0;
            if (f) {
                if (s[i] == '1'){ 
                    add(dp[i][c][f], self(self, i + 1, c + 1, f));
                    add(dp[i][c][f], self(self, i + 1, c, 0));
                }
                else add(dp[i][c][f], self(self, i + 1, c, f));
            } 
            else {
                add(dp[i][c][f], self(self, i + 1, c + 1, 0));
                add(dp[i][c][f], self(self, i + 1, c, 0));
            }
            return dp[i][c][f];
        };
        ll x = (fun(fun, 1, 1, 1) + fun(fun, 1, 0, 0)) % mod;
        x = (x - 1 + mod) % mod;
        return x;
    }
};",1448276038
Guddu Singh,guddusingh123,302,3646,cpp,"#define ll long long

// DEBUGGING TEMPLATE
#define sim template < class c
#define ris return * this
#define dor > debug & operator <<
#define eni(x) sim > typename \
enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {
sim > struct rge { c b, e; };
sim > rge<c> range(c i, c j) { return rge<c>{i, j}; }
sim > auto dud(c* x) -> decltype(cout << *x, 0);
sim > char dud(...);
struct debug {
#ifndef ONLINE_JUDGE
~debug() { cout << endl; }
eni(!=) cout << boolalpha << i; ris; }
eni(==) ris << range(begin(i), end(i)); }
sim, class b dor(pair < b, c > d) {
ris << ""("" << d.first << "", "" << d.second << "")"";
}
sim dor(rge<c> d) {
*this << ""["";
for (auto it = d.b; it != d.e; ++it)
*this << "", "" + 2 * (it == d.b) << *it;
ris << ""]"";
}
#else
sim dor(const c&) { ris; }
#endif
};
#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""


const int mod = 1e9 + 7;

ll add(ll &x, ll y) {
    x = (x + y) % mod;
    return x;
}

ll sub(ll &x, ll y) {
    x = (x - y + mod) % mod;
    return x;
}

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& a) {
        int n = a.size();
        map<ll, ll> pre, suf;
        vector<ll> p(n);
        for (int i = 0; i < n; i++) {
            int x = a[i];
            if (pre.count(x - 1)) {
                add(pre[x], pre[x - 1]);
                add(p[i], pre[x - 1]);
            }
            if (pre.count(x + 1)) {
                add(pre[x], pre[x + 1]);
                add(p[i], pre[x + 1]);
            }
            add(pre[x], 1);
            add(p[i], 1);
        }
        ll res = 0;
        
        for (int i = n - 1; i >= 0; i--) {
            int x = a[i];
            ll q = 0;
            if (suf.count(x - 1)) {
                add(suf[x], suf[x - 1]);
                add(q, suf[x - 1]);
            }
            if (suf.count(x + 1)) {
                add(suf[x], suf[x + 1]);
                add(q, suf[x + 1]);
            }
            add(suf[x], 1);
            add(q, 1);
            ll cur = p[i] * q % mod;
            cur = cur * x % mod;
            add(res, cur);
        }
        debug();
        return res;
    }
};",1448246830
Utkarsh Jain,U7KARSH,303,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        vector<int> a;
    int x{1};
    for (int i = 1; i < nums.size(); i++)
    {
        if (nums[i]>nums[i-1])
        {
            x++;
        }
        else
        {
            a.push_back(x);
            x = 1;
        }
        
    }
    a.push_back(x);
    int ans{0};
    for (int i = 0; i < a.size(); i++)
    {
        ans = max(ans, a[i]/2);
        if (i>0)
        {
            ans = max(ans, min(a[i],a[i-1]));
        }
        
    }
    return ans>=k;
    }
};",1448184880
Utkarsh Jain,U7KARSH,303,3619,cpp,"class Solution {
public:
int maxIncreasingSubarrays(vector<int>& nums) 
{
    vector<int> a;
    int x{1};
    for (int i = 1; i < nums.size(); i++)
    {
        if (nums[i]>nums[i-1])
        {
            x++;
        }
        else
        {
            a.push_back(x);
            x = 1;
        }
        
    }
    a.push_back(x);
    int ans{0};
    for (int i = 0; i < a.size(); i++)
    {
        ans = max(ans, a[i]/2);
        if (i>0)
        {
            ans = max(ans, min(a[i],a[i-1]));
        }
        
    }
    return ans;
}
};",1448184265
Utkarsh Jain,U7KARSH,303,3631,cpp,"class Solution {
public:
const int mod = 1e9+7;
long long f(int i, int x, int y, string &s, map<int,int> &m, vector<vector<vector<long long>>> &dp)
{
    if (i==s.length())
    {
        if (m[y] && x==0)
        {
            return 1;
        }
        return 0;
    }
    if (dp[i][x][y]!=-1)
    {
        return dp[i][x][y];
    }
    long long ans{0};
    if (x==1)
    {
        if (s[i]=='0')
        {
            ans += f(i+1, x, y, s, m, dp);
            ans %= mod;
        }
        else
        {
            ans += f(i+1, 0, y, s, m, dp);
            ans %= mod;
            ans += f(i+1, 1, y+1, s, m, dp);
            ans %= mod;
        }
        
    }
    else
    {
        ans += f(i+1, 0, y, s, m, dp);
        ans %= mod;
        ans += f(i+1, 0, y+1, s, m, dp);
        ans %= mod;
    }
    return dp[i][x][y] = ans%mod;
}

int countKReducibleNumbers(string s, int k) 
{
    int n = s.length(),x;
    map<int,int> m;
    for (int i = 1; i <= n; i++)
    {
        x = i;
        for (int j = 0; j < k-1; j++)
        {
            x = __builtin_popcount(x);
        }
        if (x==1)
        {
            m[i]++;
        }
        
    }
    vector<vector<vector<long long>>> dp(800, vector<vector<long long>>(2, vector<long long>(801, -1)));
    long long ans = f(0, 1, 0, s, m, dp);
    ans %= mod;
    return ans;
}
};",1448276148
Utkarsh Jain,U7KARSH,303,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int n = nums.size();
        map<long long, long long> m1, m2;
        vector<long long> dp(n, 0);
        const long long mod = 1e9+7;
        long long ans{0};
        for(int i = 0; i < n; i++)
        {
            dp[i] = nums[i];
            if(m1.find(nums[i]-1)!=m1.end())
            {
                dp[i] += m1[nums[i]-1]%mod + nums[i]*m2[nums[i]-1]%mod;
                dp[i] %= mod;
                m2[nums[i]] += m2[nums[i]-1];
                m2[nums[i]]%=mod;
            }
            if(m1.find(nums[i]+1)!=m1.end())
            {
                dp[i] += m1[nums[i]+1]%mod + nums[i]*m2[nums[i]+1]%mod;
                dp[i] %= mod;
                m2[nums[i]] += m2[nums[i]+1];
                m2[nums[i]]%=mod;
            }
            m2[nums[i]]++;
            m2[nums[i]]%=mod;
            m1[nums[i]] += dp[i];
            m1[nums[i]] %= mod;
            ans += dp[i];
            ans %= mod;
        }
        return ans;
    }
};",1448266949
rohinth076,rohinth076,304,3612,java,"class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        int n = nums.size();
        int count = 0;
        boolean flag = false;
        int prev = -1001;
        outer:for(int i=0;i<n;i++){
            if(nums.get(i) > prev){
               count++;
                if(count >= k){
                    int prev1 = -1001;
                    int count1 = 0;
                    for(int j=i+1;j<n;j++){
                        if(prev1 < nums.get(j)){
                            count1++;
                            prev1 = nums.get(j);
                            if(count1 == k){
                                flag = true;
                                break outer;
                            }
                        }else{
                            break;
                        }
                    }
                }
            }else{
                count = 1;
            }
            prev = nums.get(i);
        }
        return flag;
    }
}",1448188268
rohinth076,rohinth076,304,3619,java,"class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        List<int[]> arr = new ArrayList<>();
        int n = nums.size();
        int count = 1;
        for(int i=1;i<n;i++){
            if(nums.get(i) > nums.get(i-1)){
                count++;
            }else{
                arr.add(new int[]{i-count,i-1,count});
                count = 1;
            }
        }
        arr.add(new int[]{n-count,n-1,count});
        int m = arr.size();
        int ans = 0;
        int[] prev = new int[3];
        for(int i=0;i<m;i++){
            int[] x = arr.get(i);
            ans = Math.max(ans,x[2]/2);
            ans = Math.max(ans,Math.min(x[2],prev[2]));
            prev = x;
        }
        return ans;
    }
}",1448196637
rohinth076,rohinth076,304,3631,java,"class Solution {
    int mod = 1_000_000_000+7;
    int[][][] dp;
    int n;
    int k;
    char[] arr;
    Map<Integer,Boolean> isValid;
    boolean valid(int m){
        if(isValid.containsKey(m)){
            return isValid.get(m);
        }
        int temp = m;
        //System.out.println(m+"" ""+k);
        for(int i=1;i<=k;i++){
            temp = Integer.bitCount(temp);
        }
        isValid.put(m,temp == 1);
        return isValid.get(m);
    }
    int rec(int level,int count,int f){
        if(level == n){
            if(count == 0 || f == 1)return 0;
            int val = 0;
            if(valid(count)){
                //System.out.println(count);
                val = 1;
            }
            return val;
        }
        if(dp[level][count][f] != -1)return dp[level][count][f];
        long ans = 0;
        if(f == 1){
            ans += rec(level+1,count,(arr[level]=='0')?1:0);
            if(arr[level] == '1'){
                ans += rec(level+1,count+1,1);
            }
        }else{
            ans += rec(level+1,count+1,0);
            ans += rec(level+1,count,0);
        }
        ans %= mod;
        dp[level][count][f] = (int)ans;
        return dp[level][count][f];
    }
    public int countKReducibleNumbers(String s, int kk) {
        isValid = new HashMap<>();
        arr = s.toCharArray();
        n = arr.length;
        k = kk-1;
        dp = new int[n][n][2];
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                Arrays.fill(dp[i][j],-1);
            }
        }
        //System.out.println(""---"");
        return rec(0,0,1);
    }
}",1448269665
rohinth076,rohinth076,304,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        map = defaultdict(int)
        count = defaultdict(int)
        ans = 0
        mod = 1_000_000_000 + 7

        for i in nums:
            sum = i
            c = 1

            if (i + 1) in map:
                sum += map[i + 1]
                sum += i * count[i + 1]
                c += count[i + 1]
                sum %= mod

            if (i - 1) in map:
                sum += map[i - 1]
                sum += i * count[i - 1]
                c += count[i - 1]
                sum %= mod

            sum %= mod
            ans += sum
            ans %= mod

            map[i] += sum
            count[i] += c

        return ans",1448224056
Ying Liu,pein531,307,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> dp(n, 1);
        for(int i = 1; i < n; i++) {
            if(nums[i] > nums[i - 1]) {
                dp[i] = dp[i - 1] + 1;
            }
        }
        set<int> pos;
        for(int i = 0; i < n; i++) {
            if(dp[i] >= k) pos.insert(i);
        }
        for(int i: pos) {
            if(pos.count(i + k)) return true;
        }
        return false;
    }
};",1448188817
Ying Liu,pein531,307,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp(n, 1);
        for(int i = 1; i < n; i++) {
            if(nums[i] > nums[i - 1]) {
                dp[i] = dp[i - 1] + 1;
            }
        }
        function<bool(int)> check = [&](int len) {
            for(int i = len - 1; i + len < n; i++) {
                if(dp[i] >= len && dp[i + len] >= len) {
                    return true;
                }
            }
            return false;
        };
        int l = 1, r = n/2;
        while(l < r) {
            int mid = l + r + 1 >> 1;
            cout << mid << endl;
            if(check(mid)) {
                l = mid;
            }else {
                r = mid - 1;
            }
        }
        return r;
    }
};",1448195475
Ying Liu,pein531,307,3631,cpp,"const int mod = 1e9 + 7, N = 1010;
typedef long long LL;
LL C[N][N];
LL a[N];

class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        for(int i = 0; i <= 1000; i++) {
            C[i][0] = 1;
            for(int j = 1; j <= i; j++) {
                (C[i][j] = C[i - 1][j] + C[i - 1][j - 1]) %= mod;
            }
        }
        int ccnt = 0;
        for(int i = 0; i < s.size(); i++) {
            a[i] = 0;
        }
        for(int i = 0; i < s.size(); i++) {
            if(s[i] == '1') {
                for(int j = 0; j <= s.size() - 1 - i; j++) {
                    (a[j + ccnt] += C[s.size() - 1 - i][j]) %= mod;
                }
                ccnt++;
            }
        }
        LL ans = 0;
        auto count = [&](int x) {
            if(x == 1) return 1;
            int ans = 2;
            while(__builtin_popcount(x) - 1) {
                x = __builtin_popcount(x);
                ans++;
            }
            return ans;
        };
        for(int i = 1; i < s.size(); i++) {
            if(count(i) <= k) {
                (ans += a[i]) %= mod;
            }
        }
        return ans;
    }
};",1448248364
Ying Liu,pein531,307,3646,cpp,"typedef long long LL;
const int N = 100010, MOD = 1e9 + 7;

class Solution {
public:
    int sumOfGoodSubsequences(vector<int> &nums) {
        vector<LL> ans(N, 0), cnt(N, 0);
        LL res = 0;
        for(int num : nums) {
            LL pcnt = ((num == 0 ? 0 : cnt[num - 1]) + cnt[num + 1] + 1) % MOD;
            LL pans = ((num == 0 ? 0 : ans[num - 1]) + ans[num + 1] + pcnt * num) % MOD;
            cnt[num] = (cnt[num] + pcnt) % MOD;
            ans[num] = (ans[num] + pans) % MOD;
            res = (res + pans) % MOD;
        }
        return res;
    }
};",1448283991
cm_fast,cm_fast,308,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& a, int k) {
        int n = a.size();
        vector<int> suff(n, 1);
        for (int i = n-2; i >=0; i--)
        {
            if (a[i] < a[i + 1])
            {
                suff[i] = suff[i + 1] + 1;
            }
            
        }
        
        int low = 1, high = n / 2, ans = 0;
        while (low <= high)
        {
            int mid = low + (high - low) / 2;
            bool found = false;
            for (int i = 0; i + 2 * mid <= n; ++i)
            {
                if (suff[i] >= mid && suff[i + mid] >= mid)
                {
                    found = true;
                    break;
                }
            }
            if (found)
            {
                ans = mid;
                low = mid + 1;
            }
            else
            {
                high = mid - 1;
            }
        }
        return (ans>=k);
    }
};",1448202045
cm_fast,cm_fast,308,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& a) {
         int n = a.size();
        vector<int> suff(n, 1);
        for (int i = n-2; i >=0; i--)
        {
            if (a[i] < a[i + 1])
            {
                suff[i] = suff[i + 1] + 1;
            }
            
        }
        
        int low = 1, high = n / 2, ans = 0;
        while (low <= high)
        {
            int mid = low + (high - low) / 2;
            bool found = false;
            for (int i = 0; i + 2 * mid <= n; ++i)
            {
                if (suff[i] >= mid && suff[i + mid] >= mid)
                {
                    found = true;
                    break;
                }
            }
            if (found)
            {
                ans = mid;
                low = mid + 1;
            }
            else
            {
                high = mid - 1;
            }
        }
        return ans;
    }
};",1448201025
cm_fast,cm_fast,308,3631,cpp,"string addBinaryStrings(string num1, string num2)
{
    string result = """";
    int carry = 0, i = num1.size() - 1, j = num2.size() - 1;
    while (i >= 0 || j >= 0 || carry)
    {
        int sum = carry;
        if (i >= 0)
            sum += num1[i--] - '0';
        if (j >= 0)
            sum += num2[j--] - '0';
        result = char((sum % 2) + '0') + result;
        carry = sum / 2;
    }
    return result;
}
string subtractBinaryStrings(string num1, string num2)
{
    bool negative = false;
    if (num1.length() < num2.length() || (num1.length() == num2.length() && num1 < num2))
    {
        swap(num1, num2);
        negative = true;
    }
    int n1 = num1.length(), n2 = num2.length();
    string result = """";
    int borrow = 0;
    for (int i = 0; i < n1; ++i)
    {
        int bit1 = num1[n1 - 1 - i] - '0';
        int bit2 = (i < n2) ? num2[n2 - 1 - i] - '0' : 0;
        int sub = bit1 - bit2 - borrow;
        if (sub < 0)
        {
            sub += 2;
            borrow = 1;
        }
        else
        {
            borrow = 0;
        }
        result.push_back(sub + '0');
    }
    while (result.length() > 1 && result.back() == '0')
        result.pop_back();
    if (negative)
        result.push_back('-');
    reverse(result.begin(), result.end());
    return result;
}
const int mod = 1e9 + 7;
int gcd(int a, int b)
{
    if (b == 0)
        return a;
    return gcd(b, a % b);
}
int add(int x, int y)
{
    x += y;
    while (x >= mod)
        x -= mod;
    while (x < 0)
        x += mod;
    return x;
}

int mul(int x, int y)
{
    return (x * 1LL * y) % mod;
}

int binpow(int x, int y)
{
    int z = 1;
    while (y)
    {
        if (y & 1)
        {
            z = mul(z, x);
        }
        x = mul(x, x);
        y >>= 1;
    }
    return z;
}

int inv(int x)
{
    return binpow(x, mod - 2);
}

int divide(int x, int y)
{
    return mul(x, inv(y));
}
class Solution
{
public:
    int cal[801];
    long long dp[801][801][2][2];
    long long helper(int pos, int cnt, int tight, int flag, string &s, int k)
    {
        if (pos == s.size())
        {
            if (flag && cal[cnt] != -1 && cal[cnt] <= k - 1)
            {
                return 1;
            }
            return 0;
        }
        if (dp[pos][cnt][tight][flag] != -1)
        {
            return dp[pos][cnt][tight][flag];
        }
        int limit = tight ? (s[pos] - '0') : 1;
        long long res = 0;
        for (int digit = 0; digit <= limit; ++digit)
        {
            int new_tight = tight && (digit == limit) ? 1 : 0;
            int flag2 = flag;
            int new_cnt = cnt;
            if (flag || digit != 0)
            {
                flag2 = 1;
                new_cnt += digit;
            }
            res = add(res, helper(pos + 1, new_cnt, new_tight, flag2, s, k));
        }
        return dp[pos][cnt][tight][flag] = res;
    }
    int countKReducibleNumbers(string s, int k)
    {
        memset(cal, -1, sizeof(cal));
        cal[0] = 0;
        for (int c = 1; c <= 800; ++c)
        {
            int temp_c = c;
            int step = 0;
            while (temp_c != 1 && step <= k)
            {
                temp_c = __builtin_popcount(temp_c);
                step++;
            }
            if (temp_c == 1 && step <= k)
            {
                cal[c] = step;
            }
            else
            {
                cal[c] = -1;
            }
        }
        int n = s.size();
        s = subtractBinaryStrings(s, ""1"");
        for (int i = 0; i < 801; i++)
        {
            for (int j = 0; j < 801; j++)
            {
                for (int k = 0; k < 2; k++)
                {
                    for (int l = 0; l < 2; l++)
                    {
                        dp[i][j][k][l] = -1;
                    }
                }
            }
        }
        memset(dp, -1, sizeof(dp));
        long long total = helper(0, 0, 1, 0, s, k);
        return (int)(total % mod);
    }
};
",1448263196
cm_fast,cm_fast,308,3646,cpp,"const int mod = 1e9 + 7;
int gcd(int a, int b)
{
    if (b == 0)
        return a;
    return gcd(b, a % b);
}
int add(int x, int y)
{
    x += y;
    while (x >= mod)
        x -= mod;
    while (x < 0)
        x += mod;
    return x;
}

int mul(int x, int y)
{
    return (x *1LL* y) % mod;
}

int binpow(int x, int y)
{
    int z = 1;
    while (y)
    {
        if (y & 1)
        {
            z = mul(z, x);
        }
        x = mul(x, x);
        y >>= 1;
    }
    return z;
}

int inv(int x)
{
    return binpow(x, mod - 2);
}

int divide(int x, int y)
{
    return mul(x, inv(y));
}

class Solution
{
public:
    int sumOfGoodSubsequences(vector<int> &a)
    {

        int mx = 0;
        int n = a.size();

        for (int i = 0; i < n; i++)
        {
            mx = max(mx, a[i]);
        }
        vector<long long> dp1(mx + 2, 0);
        vector<long long> dp2(mx + 2, 0);
        for (int i = 0; i < n; i++)
        {
            long long cnt = 0;
            long long curr = 0;
            if (a[i] > 0)
            {
                cnt += dp1[a[i] - 1];
                curr += dp2[a[i] - 1];
            }
            if (a[i] < mx + 1)
            {
                cnt += dp1[a[i] + 1];
                curr += dp2[a[i] + 1];
            }
            long long cnt2 = add(1, cnt);
            long long sum2 = add(add(a[i], curr), mul(a[i], cnt));
            dp1[a[i]] = add(dp1[a[i]], cnt2);
            dp2[a[i]] = add(dp2[a[i]], sum2);
        }
        long long ans = 0;
        for (int i = 0; i < mx + 2; i++)
        {
            ans = add(ans, dp2[i]);
        }
        return (int)ans;
    }
};
",1448218881
2499370956,2499370956,309,3612,java,"class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        return maxIncreasingSubarrays(nums) >= k;
    }

    public int maxIncreasingSubarrays(List<Integer> nums) {
        int n = nums.size();
        int[] inc = new int[n];
        inc[0] = 1;
        for (int i = 1; i < n; i++) {
            if (nums.get(i) > nums.get(i - 1)) {
                inc[i] = inc[i - 1] + 1;
            } else {
                inc[i] = 1;
            }
        }
        int low = 1;
        int high = n / 2;
        while (low < high) {
            int mid = (low + high + 1) / 2;
            boolean valid = false;
            for (int i = mid; i < n; i++) {
                if (inc[i] >= mid && inc[i - mid] >= mid) {
                    valid = true;
                    break;
                }
            }
            if (valid) {
                low = mid;
            } else {
                high = mid - 1;
            }
        }
        return low;
    }
}",1448192563
2499370956,2499370956,309,3619,java,"class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        int n = nums.size();
        int[] inc = new int[n];
        inc[0] = 1;
        for (int i = 1; i < n; i++) {
            if (nums.get(i) > nums.get(i - 1)) {
                inc[i] = inc[i - 1] + 1;
            } else {
                inc[i] = 1;
            }
        }
        int low = 1;
        int high = n / 2;
        while (low < high) {
            int mid = (low + high + 1) / 2;
            boolean valid = false;
            for (int i = mid; i < n; i++) {
                if (inc[i] >= mid && inc[i - mid] >= mid) {
                    valid = true;
                    break;
                }
            }
            if (valid) {
                low = mid;
            } else {
                high = mid - 1;
            }
        }
        return low;
    }
}",1448191207
2499370956,2499370956,309,3631,java,"import java.math.BigInteger;

class Solution {
    private final static int MOD = 1000000007;
    private final static BigInteger BiMOD = BigInteger.valueOf(1000000007);
    private final static int[] reducible;

    static {
        reducible = new int[801];
        for (int i = 2; i <= 800; i++) {
            int j = Integer.bitCount(i);
            reducible[i] = reducible[j] + 1;
        }
    }

    public int countKReducibleNumbers(String s, int k) {
        if (k == 5) {
            return new BigInteger(s, 2).subtract(BigInteger.ONE).mod(BiMOD).intValue();
        }

        int n = s.length();
        int[] prefixBits = new int[n];
        prefixBits[0] = 1;
        for (int i = 1; i < n; i++) {
            prefixBits[i] = prefixBits[i - 1] + (s.charAt(i) == '1' ? 1 : 0);
        }

//        System.out.println(Arrays.toString(prefixBits));

        long[][] dp = new long[n][n];
        Arrays.fill(dp[0], 1);
        for (int i = 1; i < n; i++) {
            for (int b = 1; b < n; b++) {
                dp[b][i] = (dp[b][i - 1] + dp[b - 1][i - 1]) % MOD;
            }
            if (s.charAt(i) == '1') {
                int b = prefixBits[i] - 1;
                dp[b][i] += 1;
                dp[b][i] %= MOD;
            }
        }

//        System.out.println(Arrays.deepToString(dp));

        long sum = 0;
        for (int b = 1; b < n; b++) {
            if (reducible[b] < k) {
                sum += dp[b][n - 1];
            }
        }
        return (int) (sum % MOD);
    }
}",1448284099
2499370956,2499370956,309,3646,java,"class Solution {
    private final static int MOD = 1000000007;

    public int sumOfGoodSubsequences(int[] nums) {
        int max = Arrays.stream(nums).max().getAsInt();
        long[] dpSum = new long[max + 1];
        long[] dpCount = new long[max + 1];
        for (int i = 0; i < nums.length; i++) {
            int value = nums[i];

            dpSum[value] += value;
            dpSum[value] += (value - 1 >= 0) ? dpSum[value - 1] + dpCount[value - 1] * value : 0;
            dpSum[value] += (value + 1 <= max) ? dpSum[value + 1] + dpCount[value + 1] * value : 0;
            dpSum[value] %= MOD;

            dpCount[value] += 1;
            dpCount[value] += (value - 1 >= 0) ? dpCount[value - 1] : 0;
            dpCount[value] += (value + 1 <= max) ? dpCount[value + 1] : 0;
            dpCount[value] %= MOD;
        }
        long sum = Arrays.stream(dpSum).sum();
        return (int) (sum % MOD);
    }
}",1448209572
Oone,Oone,310,3612,java,"import java.lang.reflect.InvocationHandler;
import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;

public class Main {
    public static void main(String[] args) {
        int[] nums1 = {1,2,1};
        long[] nums2 = {0, 2, 2};
        int[][] edges = {{0,1},{0,2}};
        String[] grid = {""acca"",""bbbb"",""caca""};
        Solution solution = new Solution();
    }
}

class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        boolean flag = false;
        for (int i = 0; i <= nums.size() - 2 * k; i++) {
            boolean ok = true;
            for (int j = 0; j < k - 1; j++)
                if (nums.get(i + j) >= nums.get(i + j + 1)) {
                    ok = false;
                    break;
                }
            for (int j = 0; j < k - 1; j++)
                if (nums.get(i + k + j) >= nums.get(i + k + j + 1)) {
                    ok = false;
                    break;
                }
            flag |= ok;
        }
        return flag;
    }
}",1448277233
Oone,Oone,310,3619,java,"import java.lang.reflect.InvocationHandler;
import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;

public class Main {
    public static void main(String[] args) {
        int[] nums1 = {1,2,1};
        long[] nums2 = {0, 2, 2};
        int[][] edges = {{0,1},{0,2}};
        String[] grid = {""acca"",""bbbb"",""caca""};
        Solution solution = new Solution();
    }
}

class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        int n=nums.size();
        int[] l=new int[n+10];
        int[] r=new int[n+10];
        for(int i=0;i<n;++i){
            l[i]=1;
            if(i>0&&nums.get(i-1)<nums.get(i))
                l[i]=l[i-1]+1;
        }
        int ans=0;
        r[n]=0;
        for(int i=n-1;i>=0;--i) {
            r[i] = 1;
            if (i < n - 1 && nums.get(i + 1) > nums.get(i))
                r[i] = r[i + 1] + 1;
            ans = Math.max(ans, Math.min(l[i], r[i + 1]));
        }
        return ans;
    }
}",1448272998
Oone,Oone,310,3631,java,"import java.lang.reflect.InvocationHandler;
import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;

public class Main {
    public static void main(String[] args) {
        int[] nums1 = {3,4,5,1,6,7};
        long[] nums2 = {0, 2, 2};
        int[][] edges = {{0,1},{0,2}};
        String[] grid = {""acca"",""bbbb"",""caca""};
        Solution solution = new Solution();
        solution.countKReducibleNumbers(""1000"",2);
    }
}

class Solution {
    int mod = 1000000007, k, n;
    int[] num, cnt;
    long[][] dp;

    long DFS(int pos, int st, int op) {
        if (pos == -1) {
            if (cnt[st] < k)
                return 1;
            else return 0;
        }
        if (op == 0 && dp[pos][st] != -1) return dp[pos][st];
        int up = (op != 0 ? num[n - pos - 1] : 1);
        long ret = 0;
        for (int i = 0; i <= up; ++i)
            ret = (ret + DFS(pos - 1, st + (i == 1 ? 1 : 0), op & (i == up ? 1 : 0))) % mod;
        if (op == 0) dp[pos][st] = ret;
        return ret;
    }

    public int countKReducibleNumbers(String s, int k) {
        if(s.length()==1)return 0;
        n = s.length();
        this.k = k;
        cnt = new int[n + 10];
        num = new int[n + 10];
        dp = new long[n + 10][n + 10];
        cnt[0] = k + 1;
        for (int i = 0; i <= n; ++i)
            for (int j = 0; j <= n; ++j)
                dp[i][j] = -1;
        for (int i = 1; i <= n; ++i) {
            int tmp = i;
            int sum = 0;
            while (tmp != 1 && sum < k) {
                int tmp_ = tmp;
                tmp = 0;
                while (tmp_ != 0) {
                    tmp += tmp_ & 1;
                    tmp_ >>= 1;
                }
                sum++;
            }
            cnt[i] = sum;
        }
        int flag = 0;
        for (int i = 0; i < n; ++i)
            if (s.charAt(i) == '1') {
                num[i] = 1;
                flag++;
            } else num[i] = 0;
        return (int)(DFS(n - 1, 0, 1) - (cnt[flag] < k ? 1 : 0) + mod) % mod;
    }
}",1448242865
Oone,Oone,310,3646,java,"import java.lang.reflect.InvocationHandler;
import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;

public class Main {
    public static void main(String[] args) {
        int[] nums1 = {1,2,1};
        long[] nums2 = {0, 2, 2};
        int[][] edges = {{0,1},{0,2}};
        String[] grid = {""acca"",""bbbb"",""caca""};
        Solution solution = new Solution();
        solution.sumOfGoodSubsequences(nums1);
    }
}

class Solution {
    public int sumOfGoodSubsequences(int[] nums) {
        int mod = 1000000007;
        HashMap<Integer, Long> map = new HashMap<>();
        int n = nums.length;
        long[] l = new long[n + 10];
        for (int i = 0; i < n; ++i) {
            l[i] = ((map.getOrDefault(nums[i] - 1, 0L) + map.getOrDefault(nums[i] + 1, 0L)) % mod + 1) % mod;
            map.put(nums[i], (map.getOrDefault(nums[i], 0L) + l[i]) % mod);
        }
        long ans = 0;
        map.clear();
        for (int i = n - 1; i >= 0; --i) {
            long tmp = ((map.getOrDefault(nums[i] - 1, 0L) + map.getOrDefault(nums[i] + 1, 0L)) % mod + 1) % mod;
            ans = (ans + nums[i] * l[i] % mod * tmp % mod) % mod;
            map.put(nums[i], (map.getOrDefault(nums[i], 0L) + tmp) % mod);
        }
        return (int) ans;
    }
}",1448263876
JOZLEETCODE,JLZ998112,311,3612,java,"class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> a, int len) {
        int n = a.size();
        int i = 0;
        while(i<n){
            int j = i+1;
            while(j<n && a.get(j)>a.get(j-1) && j-i<len){
                ++j;
            }
          //  System.out.println(i+""...""+j);
            int len1 = j-i;
            if(len1==len){
                int k = j+1;
                while(k<n && a.get(k)>a.get(k-1) && k-j<len){
                    ++k;
                }
            //    System.out.println(j+""...""+k);
                int len2 = k-j;
                if(len2==len){
                    return true;
                }
            }
            ++i;
        }
        return false;
    }
}",1448184359
JOZLEETCODE,JLZ998112,311,3619,java,"class Solution {
    public int maxIncreasingSubarrays(List<Integer> a) {
        int n = a.size();
        int[] end = new int[n];
        int[] start = new int[n];
        int i = 0;
        while(i<n){
            int j = i+1;
            while(j<n && a.get(j)>a.get(j-1)){
                ++j;
            }
            int len = j-i;
            for(int p = i; p<j; ++p){
                start[p] = len - (p-i);
                end[p] = (p-i)+1;
            }
            i = j;
        }
        int res = 0;
        for(i=0; i+1<n; ++i){
            int l1 = end[i];
            int l2 = start[i+1];
            int cur = Math.min(l1, l2);
            res = Math.max(res, cur);
        }
        return res;
    }
}",1448197698
JOZLEETCODE,JLZ998112,311,3631,java,"class Solution {
   private int[] reducible;
    private int limit = 900;
    private long Mod = (long) (1e9 + 7);
    private long[][][] dp;

    public int countKReducibleNumbers(String s, int k) {
        char[] c = s.toCharArray();
        int n = c.length;
        dp = new long[n][2][n + 1];
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < 2; ++j) {
                Arrays.fill(dp[i][j], -1);
            }
        }

        reducible = new int[limit + 10];
        reducible[1] = 1;
        for (int i = 2; i <= limit; ++i) {
            int cur = i;
            int ck = k - 1;
            while (cur > 1 && ck > 0) {
                int count = Integer.bitCount(cur);
                cur = count;
                --ck;
            }
            if (cur == 1) {
                reducible[i] = 1;
            }
        }

        long rt = solve(c, 0, 0, 0);
        return (int) rt;
    }

    private long solve(char[] c, int i, int sm, int bits) {
        int n = c.length;
        if (i == n) {
            return sm == 0 ? 0 : reducible[bits];
        }
        if (dp[i][sm][bits] != -1) {
            return dp[i][sm][bits];
        }
        int nsm = sm;
        if (sm == 0 && c[i] == '1') {
            nsm = 1;
        }
        long way1 = solve(c, i + 1, nsm, bits);
        long way2 = 0;
        if (sm == 0 && c[i] == '1') {
            way2 = solve(c, i + 1, sm, bits + 1);
        } else if (sm == 1) {
            way2 = solve(c, i + 1, sm, bits + 1);
        }
        long res = way1 + way2;
        res %= Mod;
        dp[i][sm][bits] = res;
        return res;
    }
}",1448270549
JOZLEETCODE,JLZ998112,311,3646,java,"class Solution {
    private long Mod = (long) (1e9 + 7);

    public int sumOfGoodSubsequences(int[] a) {
        int n = a.length;
        int maxv = 0;
        for (int ai : a) {
            maxv = Math.max(maxv, ai);
        }
        long[] dp = new long[maxv + 5];
        long[] count = new long[maxv + 5];
        for (int i = 0; i < n; ++i) {
            int v = a[i];
            if (v - 1 >= 0) {
                long cvm1 = count[v - 1];
                dp[v] += dp[v - 1] + cvm1 * v;
                dp[v] %= Mod;
                count[v] += cvm1;
                count[v] %= Mod;
            }
            long cvp1 = count[v + 1];
            dp[v] += dp[v + 1] + cvp1 * v;
            dp[v] %= Mod;
            count[v] += cvp1;
            count[v] %= Mod;
            dp[v] += v;
            dp[v] %= Mod;
            count[v] += 1;
            count[v] %= Mod;
        }
        long sum = 0;
        for (int i = 0; i < dp.length; ++i) {
            sum += dp[i];
            sum %= Mod;
        }
        return (int) sum;
    }
}",1448225601
sveng101,sveng101,314,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        incr_lens = []
        prev = float(""inf"")
        for i, num in enumerate(nums):
            incr_lens.append((incr_lens[-1] if num > prev else 0) + 1)
            if i >= k and incr_lens[i] >= k and incr_lens[i - k] >= k:
                return True
            #print(incr_lens)
            prev = num
        
        return False
                ",1448185003
sveng101,sveng101,314,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        incr_lens = []
        prev = float(""inf"")
        res = 0
        for i, num in enumerate(nums):
            incr_lens.append((incr_lens[-1] if num > prev else 0) + 1)
            prev = num
            res = max(res, incr_lens[-1] >> 1)
            if incr_lens[-1] <= i and incr_lens[i - incr_lens[-1]] >= incr_lens[-1]:
                res = max(res, incr_lens[-1])
        #print(incr_lens)
        return res",1448195004
sveng101,sveng101,314,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        md = 10 ** 9 + 7
        res = 0
        if not k: return 0 if s == ""1"" else 1
        
        n = len(s)

        op_cnt = [float(""inf""), 0]
        for num in range(2, n + 1):
            op_cnt.append(op_cnt[num.bit_count()] + 1)
        #print(op_cnt)

        seen_ones_cnt = 0
        res = 0
        for i, l in enumerate(s):
            if l == ""0"": continue
            n_bits = n - i - 1
            for n_ones in range(n_bits + 1):
                if op_cnt[n_ones + seen_ones_cnt] < k:
                    res = (res + math.comb(n_bits, n_ones)) % md
            #print(i, res)
            seen_ones_cnt += 1
        return res
        """"""
        bitcount_ops_cnts_cumu = [[0]]
        for n_bit in range(1, n):
            ops_cnt_cumu = []
            for n_ones in range(n_bit + 1):
                cnt = math.comb(n_bit, n_ones)
                while len(ops_cnt_cumu) <= op_cnt[n_ones] + 1:
                    ops_cnt_cumu.append(0)
                ops_cnt_cumu[op_cnt[n_ones] + 1] = (ops_cnt_cumu[op_cnt[n_ones] + 1] + cnt) % md
            #if len(ops_cnt_cumu) > 1:
            #    ops_cnt_cumu[1] -= 2
            #    ops_cnt_cumu[0] += 2
            while not ops_cnt_cumu[-1]:
                ops_cnt_cumu.pop()
            for i in range(1, len(ops_cnt_cumu)):
                ops_cnt_cumu[i] = (ops_cnt_cumu[i] + ops_cnt_cumu[i - 1]) % md
            bitcount_ops_cnts_cumu.append(ops_cnt_cumu)
        print(n, len(bitcount_ops_cnts_cumu))
        print(bitcount_ops_cnts_cumu[n - 1])
        res = 0 #bitcount_ops_cnts_cumu[n - 1][min(k, len(bitcount_ops_cnts_cumu[n - 1]) - 1)] - 1
        print(bitcount_ops_cnts_cumu)
        #print(res)
        cnt = 0
        for i, l in enumerate(s):
            if l == ""0"": continue
            res = (res + bitcount_ops_cnts_cumu[n - i - 1][min(k - cnt, len(bitcount_ops_cnts_cumu[n - i - 1]) - 1)]) % md
            print(i, res)
            cnt += 1
        
        return (res - 1) % md
        """"""",1448291593
sveng101,sveng101,314,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        md = 10 ** 9 + 7
        res = 0
        seen_cnts = {}
        seen_sms = {}
        for num in nums:
            cnt = (1 + seen_cnts.get(num - 1, 0) + seen_cnts.get(num + 1, 0)) % md
            sm = (seen_sms.get(num - 1, 0) + seen_sms.get(num + 1, 0) + cnt * num) % md
            seen_cnts[num] = (seen_cnts.get(num, 0) + cnt) % md
            seen_sms[num] = (seen_sms.get(num, 0) + sm) % md
            
        return sum(seen_sms.values()) % md",1448208639
VIV,VIkkY53,315,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        vector<int> v;
        int n = nums.size();
        for (int i = 0; i < n;) {
            int end = i + 1;
            while (end < n && nums[end - 1] < nums[end]) {
                end++;
            }
            v.push_back(end - i);
            i = end;
        }
        int ans = v[0] / 2;
        for (int i = 0; i < v.size() - 1; i++) {
            ans = max(ans, v[i + 1] / 2);
            ans = max(ans, min(v[i], v[i + 1]));
        }
        return ans >= k;
    }
};",1448188447
VIV,VIkkY53,315,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        vector<int> v;
        int n = nums.size();
        for (int i = 0; i < n;) {
            int end = i + 1;
            while (end < n && nums[end - 1] < nums[end]) {
                end++;
            }
            v.push_back(end - i);
            i = end;
        }
        int ans = v[0] / 2;
        for (int i = 0; i < v.size() - 1; i++) {
            ans = max(ans, v[i + 1] / 2);
            ans = max(ans, min(v[i], v[i + 1]));
        }
        return ans;
    }
};",1448187283
VIV,VIkkY53,315,3631,cpp,"class Solution {
public:
    typedef long long ll;
    int countKReducibleNumbers(string s, int k) {
       vector<vector<ll>> ncr(1001, vector<ll>(1001, 0));
        ll mod = 1e9 + 7;
        ncr[1][0] = 1;
        ncr[1][1] = 1;
        for (int i = 2; i <= 1000; i++) {
            ncr[i][0] = ncr[i][i] = 1;
            for (int j = 1; j < i; j++) {
                ncr[i][j] = ncr[i - 1][j] + ncr[i - 1][j - 1];
                ncr[i][j] %= mod;
            }
        }
        vector<ll> kred(800, 0);
        kred[0] = k + 1;
        kred[1] = 0;
        for (ll i = 2; i < 800; i++) {
            kred[i] = 1 + kred[__builtin_popcount(i)];
        }
        ll ans = 0;
        int n = s.size();
        ll alreadySB = 0;
        for (int i = 0; i < n - 1; i++) {
            if (s[i] == '1') {
                ll l = (n - i) - 1;
                for (ll j = 0; j <= l; j++) {
                    ll currSB = alreadySB + j;
                    ll cnt = ncr[l][j];
                    ans += (1 + kred[currSB] <= k ? cnt : 0);
                    ans %= mod;
                    // cout << i << "" "" << j << "" "" << cnt << "" "" << kred[currSB] << endl;
                }
                alreadySB++;
            } 
        }
        if (s[n - 1] == '1') {
            ans += (1 + kred[alreadySB] <= k ? 1 : 0);
            ans %= mod;
        }
        return ans;
    }
};",1448278245
VIV,VIkkY53,315,3646,cpp,"class Solution {
public:
    typedef long long ll;
    int sumOfGoodSubsequences(vector<int>& nums) {
        vector<ll> dp(1e5 + 1, 0);
        vector<ll> dpf(1e5 + 1, 0);
        ll mod = 1e9 + 7;
        dp[nums[0]] = nums[0];
        dpf[nums[0]] = 1;
        int n = nums.size();
        for (ll i = 1; i < n; i++) {
            ll a = nums[i];
            dp[a] += a + (a - 1 >= 0 ? (dp[a - 1] + (a * dpf[a - 1])) % mod : 0) + (a + 1 <= 1e5 ? (dp[a + 1] + (a * dpf[a + 1])) % mod : 0);
            dp[a] %= mod;
            dpf[a] += 1 + (a - 1 >= 0 ? dpf[a - 1] : 0) + (a + 1 <= 1e5 ? dpf[a + 1] : 0);
            dpf[a] %= mod;
        }
        ll ans = 0;
        for (int i = 0; i <= 1e5; i++) {
            if (dp[i]) {
                // cout << i << "" "" << dp[i] << "" "" << dpf[i] << endl;
            }
            ans += dp[i] % mod;
            ans %= mod;
        }
        return (int)ans;
    }
};",1448219456
Umesh Kumar,icosa,317,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        if(k == 1) return true;
        for(int i=0; i<nums.size()-2*k+1; i++){
            bool ok = true;
            for(int j=1; j<k; j++) if(nums[j+i] <= nums[j+i-1]) ok = false;
            for(int j=1; j<k; j++) if(nums[j+i+k] <= nums[j+i+k-1]) ok = false;
            if(ok) return true;
        }
        return false;
    }
};",1448186136
Umesh Kumar,icosa,317,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        nums.push_back(-1e9-7);
        int prev = 0, cur = 1, ans = 1;
        int n = nums.size();
        for(int i=1; i<n; i++){
            if(nums[i] > nums[i-1]){
                cur++;
            }
            else{
                ans = max(ans, min(prev, cur));
                ans = max(ans, cur/2);
                prev = cur;
                cur = 1;
            }
        }
        return ans;
    }
};",1448199686
Umesh Kumar,icosa,317,3631,cpp,"#define ll long long
#define FOR(i,l,r) for(int i=l; i<r; i++)
const ll mod = 1e9+7;
const int MAX = 807;
int red[MAX];

template <int MOD, int RT>
struct mint {
  static const int mod = MOD;
  static constexpr mint rt() { return RT; }  // primitive root for FFT
  int v;
  explicit operator int() const {
    return v;
  }  // explicit -> don't silently convert to int
  mint() : v(0) {}
  mint(ll _v) {
    v = int((-MOD < _v && _v < MOD) ? _v : _v % MOD);
    if (v < 0) v += MOD;
  }
  bool operator==(const mint &o) const { return v == o.v; }
  friend bool operator!=(const mint &a, const mint &b) { return !(a == b); }
  friend bool operator<(const mint &a, const mint &b) { return a.v < b.v; }
  friend void re(mint &a) {
    ll x;
    cin >> x;
    a = mint(x);
  }
  // friend str ts(mint a) { return ts(a.v); }

  mint &operator+=(const mint &o) {
    if ((v += o.v) >= MOD) v -= MOD;
    return *this;
  }
  mint &operator-=(const mint &o) {
    if ((v -= o.v) < 0) v += MOD;
    return *this;
  }
  mint &operator*=(const mint &o) {
    v = int((ll)v * o.v % MOD);
    return *this;
  }
  mint &operator/=(const mint &o) { return (*this) *= inv(o); }
  friend mint pow(mint a, ll p) {
    mint ans = 1;
    assert(p >= 0);
    for (; p; p /= 2, a *= a)
      if (p & 1) ans *= a;
    return ans;
  }
  friend mint inv(const mint &a) {
    assert(a.v != 0);
    return pow(a, MOD - 2);
  }

  mint operator-() const { return mint(-v); }
  mint &operator++() { return *this += 1; }
  mint &operator--() { return *this -= 1; }
  friend mint operator+(mint a, const mint &b) { return a += b; }
  friend mint operator-(mint a, const mint &b) { return a -= b; }
  friend mint operator*(mint a, const mint &b) { return a *= b; }
  friend mint operator/(mint a, const mint &b) { return a /= b; }
};

const ll MOD = 1e9 + 7;
using mi = mint<MOD, 5>;  // 5 is primitive root for both common mods
using vmi = vector<mi>;
using pmi = pair<mi, mi>;
using vpmi = vector<pmi>;

/**
 * Description: pre-compute factorial mod inverses,
 * assumes $MOD$ is prime and $SZ < MOD$.
 * Time: O(SZ)
 * Source: KACTL
 * Verification: https://dmoj.ca/problem/tle17c4p5
 */

vmi invs, fac, ifac;
void genFac(int SZ) {
  invs.resize(SZ), fac.resize(SZ), ifac.resize(SZ);
  invs[1] = fac[0] = ifac[0] = 1;
  FOR(i, 2, SZ) invs[i] = mi(-(ll)MOD / i * (int)invs[MOD % i]);
  FOR(i, 1, SZ) fac[i] = fac[i - 1] * i, ifac[i] = ifac[i - 1] * invs[i];
}
mi comb(int a, int b) {
  if (a < b || b < 0) return 0;
  return fac[a] * ifac[b] * ifac[a - b];
}

class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        genFac(MAX);
        red[1] = 0;
        for(int i=2; i<MAX; i++){
            red[i] = 1 + red[__builtin_popcount(i)];
        }

        ll ans = 0, n1 = 0;
        for(int i=0; i<s.size(); i++){
            char c = s[i];
            if(c == '1'){
                int m = s.size() - i - 1;
                for(int ones=(n1 > 0 ? 0 : 1); ones <= m; ones++){
                    if(red[n1 + ones] < k){
                        ans = (ans + (int)comb(m, ones)) % mod;
                    }
                }
                n1++;
            }
        }

        return ans;
    }
};",1448257772
Umesh Kumar,icosa,317,3646,cpp,"#define ll long long
const ll mod = 1e9+7;
const int MAX = 1e5+7;
ll dp[MAX], sdp[MAX];

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int n = nums.size();
        memset(dp, 0, sizeof(dp));
        memset(sdp, 0, sizeof(sdp));
        ll sum = 0;
        for(auto x: nums){
            ll cur = dp[x+1], scur = (dp[x+1] * x + sdp[x+1])%mod;
            if(x > 0) {
                cur += dp[x-1];
                scur = (scur + dp[x-1] * x + sdp[x-1]) % mod;
            }
            cur++;
            scur += x;
            sum = (sum + scur) % mod;
            dp[x] = (dp[x] + cur) % mod;
            sdp[x] = (sdp[x] + scur) % mod;
        }
        return sum;
    }
};",1448222393
Satj,Satj,318,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& a, int k) {
        int n = a.size();
        int prev = 0, cur = 0;
        int ret = 0;
        for (int i = 0; i < n; i++) {
            if (i == 0 || a[i - 1] >= a[i]) {
                ret = max({ret, min(prev, cur), prev / 2, cur / 2});
                prev = cur; cur = 1;
                continue ;
            }
            cur++;
        }
        ret = max({ret, min(prev, cur), prev / 2, cur / 2});
        return ret >= k;
    }
};",1448251322
Satj,Satj,318,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& a) {
        int n = a.size();
        int prev = 0, cur = 0;
        int ret = 0;
        for (int i = 0; i < n; i++) {
            if (i == 0 || a[i - 1] >= a[i]) {
                ret = max({ret, min(prev, cur), prev / 2, cur / 2});
                prev = cur; cur = 1;
                continue ;
            }
            cur++;
        }
        ret = max({ret, min(prev, cur), prev / 2, cur / 2});
        return ret;
    }
};",1448249013
Satj,Satj,318,3631,cpp,"
class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        init(s);
        long ret = 0;
        int shift = 0;
        vector <long> cnt(n + 1, 0);
        for (int i = 0; i < n; i++) {
            if (s[i] == '0') continue ;
            int p = n - i - 1;
            for (int j = 0; j <= p; j++)
                cnt[j + shift] = (cnt[j + shift] + comb[p][j]) % mod;
            shift++;
        }
        // for (int i = 0; i <= n; i++) cout << cnt[i] << "" ""; cout << endl;
        // for (int i = 0; i <= n; i++) cout << res[i] << "" ""; cout << endl;
        for (int i = 1; i <= n; i++) {
            if (res[i] + 1 <= k)
                ret = (ret + cnt[i]) % mod;
        }
        return ret;
    }
private:
    long comb[801][801] = {};
    long res[801] = {};
    int n;
    int mod = 1e9 + 7;
    int reduce(int x) {
        int ret = 0;
        while (x > 1) {
            x = __builtin_popcount(x);
            ret++;
        }
        return ret;
    }
    void init(string &s) {
        n = s.size();
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i; j++)
                comb[i][j] = (j == 0 || j == i) ? 1 : (comb[i - 1][j] + comb[i - 1][j - 1]) % mod;
        }
        for (int i = 0; i <= n; i++) {
            res[i] = reduce(i);
        }
    }
};",1448233021
Satj,Satj,318,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& a) {
        int mod = 1e9 + 7;
        int n = a.size();
        int m = *max_element(a.begin(), a.end());
        vector <long> tot(m + 1, 0);
        vector <long> cnt(m + 1, 0);
        long ret = 0;
        for (auto x : a) {
            // options 2 ? 
            int cur_cnt = 0;
            long cur_tot = 0;
            if (x - 1 >= 0) {
                cur_cnt = (cur_cnt + cnt[x - 1]) % mod;
                cur_tot = (cur_tot + cnt[x - 1] * x + tot[x - 1]) % mod;
            }
            if (x + 1 <= m) {
                cur_cnt = (cur_cnt + cnt[x + 1]) % mod;
                cur_tot = (cur_tot + cnt[x + 1] * x + tot[x + 1]) % mod;
            }
            cur_cnt += 1;
            cur_tot += x;
            ret = (ret + cur_tot) % mod;
            cnt[x] = (cur_cnt + cnt[x]) % mod;
            tot[x] = (cur_tot + tot[x]) % mod;
        }
        return ret;
    }
};",1448292234
Edeeva,KYR4,319,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& a, int k) {
        int n = a.size();
        for (int i = 0; i + 2 * k <= n; i++)
        {
            bool bad = false;
            int j = i + k;
            for (int x = i + 1; x < i + k; x++)
            {
                if (a[x] <= a[x - 1])
                {
                    bad = true;
                    break;
                }
            }
            for (int x = j + 1; x < j + k; x++)
            {
                if (a[x] <= a[x - 1])
                {   
                    bad = true;
                    break;
                }
            }
            if (!bad) return true;
        }
        return false;
    }
};",1448185628
Edeeva,KYR4,319,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& a) {
        int n = a.size();
        vector<int> bad; 
        bad.push_back(0);
        for (int i = 0; i + 1 < n; i++)
        {
            if (a[i] >= a[i + 1])
            {
                bad.push_back(i + 1);
            }
        }
        bad.push_back(n);
        int m = bad.size();
        int ans = 1;
        for (int i = 0; i + 2 < m; i++)
        {
            int x = bad[i + 1] - bad[i];
            int y = bad[i + 2] - bad[i + 1];
            ans = max(ans, min(x, y));
        }
        for (int i = 0; i + 1 < m; i++)
        {
            int x = bad[i + 1] - bad[i];
            ans = max(ans, x / 2);
        }
        return ans;
        
    }
};",1448195862
Edeeva,KYR4,319,3631,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp> 
#include <ext/pb_ds/tree_policy.hpp>
#define rep(i,a,b) for (int i = a; i < b; i++)
#define mp make_pair
#define pii pair<int,int> 
#define pb push_back
#define pll pair<long long, long long>
#define fi first
#define se second
#define speedboost ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0)
using namespace std;
using namespace __gnu_pbds;
typedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;
typedef tree<pair<int,int>, null_type,  less<pair<int,int>>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;
typedef vector<int> vi;
typedef vector<string> vs;
typedef vector<long long> vll;
typedef long long ll;
typedef long double ld;
ll mod = 1000000007;
const int N = 800;
const int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1};
const char dir[4]{'D','R','U','L'};
#define all(x) begin(x), end(x)
string yes = ""YES\n"";
string no = ""NO\n"";
int inf = 1e9;

vll fac(N + 1, 1);

ll power(ll base, ll ex)
{
    ll res = 1;
    ll x = base;
    ll y = ex;
    while (y > 0)
    {
        if (y & 1)
        {
            y--;
            res *= x;
            res %= mod;
        }
        else
        {
            y >>= 1;
            x = x* x;
            x %= mod;
        }
    }
    return res;
}

ll inverse(ll x)
{
    return power(x, mod - 2);
}
 
ll binomial(int n, int k) {
    return fac[n] * inverse(fac[k] * fac[n - k] % mod) % mod;
}

void cntfac()
{
    for (int i = 2; i <= N; i++)
    {
        fac[i] = fac[i - 1] * i;
        fac[i] %= mod;
    }
}

int n, m;
vector<int> pos;

ll cntans(int idx, int p)
{
   // cout << ""CNT "" << idx << ' ' << p << ""\n"";
    if (p == 0) return 1;
    int curpos = pos[idx];
    ll add = 0;
    if (curpos >= p)
    {
        add += binomial(curpos, p);
       // cout << ""ADD BINOM "" << add << ""\n"";
    }
    if (idx != m - 1)
    {
        ll rec = cntans(idx + 1, p - 1);
        add += rec;
        add %= mod;
        cout << ""ADD P-1 "" << rec << ""\n""; 
    }
    return add;
}

class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        cntfac(); pos.clear();
        ll ans = 0;
        int n = s.size();
        vector<int> need(n + 1);
        need[1] = 1;
        for (int i = 2; i <= n; i++)
        {
            need[i] = need[__builtin_popcount(i)] + 1;
            //cout << i << "" NEED "" << need[i] << ""\n"";
        }
        int curbit = 0;
        for (int i = n - 1; i >= 0; i--)
        {
            if (s[i] == '1')
            {
                pos.pb(curbit);
            }
            curbit++;
        }
        m = pos.size();
        reverse(all(pos));
        for (int p = 1; p <= n; p++)
        {
            if (need[p] <= k)
            {
                ans += cntans(0, p);
                ans %= mod;
            }
        }
        int ret = ans;
        return ret;
    }
};",1448272618
Edeeva,KYR4,319,3646,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp> 
#include <ext/pb_ds/tree_policy.hpp>
#define rep(i,a,b) for (int i = a; i < b; i++)
#define mp make_pair
#define pii pair<int,int> 
#define pb push_back
#define pll pair<long long, long long>
#define fi first
#define se second
#define speedboost ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0)
using namespace std;
using namespace __gnu_pbds;
typedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;
typedef tree<pair<int,int>, null_type,  less<pair<int,int>>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;
typedef vector<int> vi;
typedef vector<string> vs;
typedef vector<long long> vll;
typedef long long ll;
typedef long double ld;
ll mod = 1000000007;
const int N = 200000;
const int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1};
const char dir[4]{'D','R','U','L'};
#define all(x) begin(x), end(x)
string yes = ""YES\n"";
string no = ""NO\n"";
int inf = 1e9;
ll V = 100050;

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        vector<ll> ways(V + 1, 0);
        vector<ll> sum(V + 1, 0);
        for (ll x : nums)
        {
            ll curway = 1;
            ll cursum = x;
            curway += ways[x];
            cursum += sum[x];
            curway %= mod; cursum %= mod;
            if (x > 0)
            {
                curway += ways[x - 1];
                cursum += (sum[x - 1] + (ways[x - 1] * x));
                curway %= mod; cursum %= mod;
            }
            curway += ways[x + 1];
            cursum += (sum[x + 1] + (ways[x + 1] * x));
            curway %= mod; cursum %= mod;
            ways[x] = curway;
            sum[x] = cursum;
        }
        ll ans = 0;
        for (int v = 0; v <= V; v++) {
            ans = (ans + sum[v]) % mod;
        }
        return ans;
    }
};",1448225369
phongtran82148,phongtran82148,320,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        vector<int> arr;
        int cur = 1;
        for (int i = 1; i < nums.size(); i++) {
            if (nums[i] > nums[i - 1]) {
                cur++;
            } else {
                arr.push_back(cur);
                cur = 1;
            }
        }
        arr.push_back(cur);
        int output = 0;
        for (int i = 0; i < arr.size(); i++) {
            output = max(output, arr[i]);
        }
        output /= 2;
        for (int i = 1; i < arr.size(); i++) {
            output = max(output, min(arr[i], arr[i - 1]));
        }
        return (k <= output);
    }
};",1448185403
phongtran82148,phongtran82148,320,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        vector<int> arr;
        int cur = 1;
        for (int i = 1; i < nums.size(); i++) {
            if (nums[i] > nums[i - 1]) {
                cur++;
            } else {
                arr.push_back(cur);
                cur = 1;
            }
        }
        arr.push_back(cur);
        int output = 0;
        for (int i = 0; i < arr.size(); i++) {
            output = max(output, arr[i]);
        }
        output /= 2;
        for (int i = 1; i < arr.size(); i++) {
            output = max(output, min(arr[i], arr[i - 1]));
        }
        return output;
    }
};",1448184155
phongtran82148,phongtran82148,320,3631,cpp,"class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        int N = 1000000007;
        vector<long long> cmb(1, 1);
        vector<long long> cnt(801, 0);
        int bts = 0;
        long long output = 0;
        for (int i = 0; i < s.size(); i++) bts += (s[i] - '0');
        for (int i = s.size() - 1; i >= 0; i--) {
            if (s[i] == '1') {
                bts--;
                for (int j = 0; j < cmb.size(); j++) {
                    cnt[bts + j] = (cnt[bts + j] + cmb[j]) % N;
                }
            }
            cmb.push_back(0);
            for (int j = cmb.size() - 1; j >= 1; j--) {
                cmb[j] = (cmb[j] + cmb[j - 1]) % N;
            }
        }
        for (int i = 1; i < cnt.size(); i++) {
            int kk = 0;
            int t = i;
            while (t > 1) {
                int tt = t;
                int ss = 0;
                while (tt > 0) {
                    ss += (tt % 2 != 0) ? 1 : 0;
                    tt /= 2;
                }
                t = ss;
                kk++;
            }
            if (kk <= k - 1) output = (output + cnt[i]) % N;
        }
        // for (int i = 0; i < 30; i++) cout << cnt[i] << "" "";
        // cout << endl;
        return output;
    }
};

",1448292796
phongtran82148,phongtran82148,320,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int N = 1000000007;
        vector<long long> cnt(100004, 0);
        vector<long long> sm(100004, 0);
        long long output = 0;
        for (int i = nums.size() - 1; i >= 0; i--) {
            long long tmp = (cnt[nums[i] + 1] + (nums[i] > 0 ? cnt[nums[i] - 1] : 0) + 1) % N;
            cnt[nums[i]] = (cnt[nums[i]] + tmp) % N;
            long long tmp2 = (sm[nums[i] + 1] + (nums[i] > 0 ? sm[nums[i] - 1] : 0) + tmp * nums[i]) % N;
            sm[nums[i]] = (sm[nums[i]] + tmp2) % N;
            output = (output + tmp2) % N;
        }
        return output;
    }
};\",1448244862
Kalix1110,Kalix1110,321,3612,cpp,"
/*
	Name :- Tafheem Ahemad
	its always me vs me
*/
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
template <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

template<typename A,typename B>istream&operator>>(istream&is,pair<A,B>&p){is>>p.first>>p.second;return is;}
template<typename A,typename B>ostream&operator<<(ostream&os,pair<A,B>p){os<<p.first<<' '<<p.second<<endl;return os;}
template<typename T>istream&operator>>(istream&is,vector<T>&vc){for(T&x:vc)is>>x;return is;}
template<typename T>ostream&operator<<(ostream&os,vector<T>vc){for(int i=0;i<(int)vc.size();i++)os<<vc[i]<<"" "";return os;}

#define ll long long int
#define ld long double
#define F first
#define S second
#define vl vector<ll>
#define vi vector<int>
#define vb vector<bool>
#define vs vector<string>
#define vll vector<vl>
#define vii vector<vi>
#define pii pair<int,int>
#define pll pair<ll,ll>
#define ump unordered_map
#define all(v) v.begin(),v.end()
#define take_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cin>>a[i][j];}}
#define print_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cout<<a[i][j]<<' ';}cout<<endl;}
#define yes(x) if(x) cout<<""YES""<<endl; else cout<<""NO""<<endl;
#define cl(n) for(int i=0;i<=n+5;i++) g[i].clear()
#define memset(arr,val) memset(arr,val,sizeof(arr))
#define bpc(x) __builtin_popcountll(x)
#define __lcm(a,b) (a/__gcd(a, b)*b)
#define pq_max priority_queue<ll>
#define pq_min priority_queue<ll,vl,greater<ll>>
#define in insert
#define pb push_back
#define fast() ios::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);cout.precision(numeric_limits<double>::max_digits10);
mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
const int MOD=1e9+7;
vector<vector<ll>>delta1={{1,0},{-1,0},{0,-1},{0,1}};
vector<vector<ll>>delta2={{1,0},{-1,0},{0,-1},{0,1},{1,1},{-1,1},{1,-1},{-1,-1}};


class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        ll n=nums.size();
        vl dp1(n,0);
        vl dp2(n,0);
        
        dp1[0]=1;
        for(int i=1;i<n;i++){
            if(nums[i]>nums[i-1]){
                dp1[i]=dp1[i-1]+1;
            }else{
                dp1[i]=1;
            }
        }
        
        dp2[n-1]=1;
        for(int i=n-2;i>=0;i--){
            if(nums[i]<nums[i+1]){
                dp2[i]=dp2[i+1]+1;
            }else{
                dp2[i]=1;
            }
        }
        
        ll mx=0;
        for(int i=0;i<n-1;i++){
            if(min(dp1[i],dp2[i+1]) >= k) return 1;
        }
        
        return 0;
    }
};",1448189378
Kalix1110,Kalix1110,321,3619,cpp,"/*
	Name :- Tafheem Ahemad
	its always me vs me
*/
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
template <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

template<typename A,typename B>istream&operator>>(istream&is,pair<A,B>&p){is>>p.first>>p.second;return is;}
template<typename A,typename B>ostream&operator<<(ostream&os,pair<A,B>p){os<<p.first<<' '<<p.second<<endl;return os;}
template<typename T>istream&operator>>(istream&is,vector<T>&vc){for(T&x:vc)is>>x;return is;}
template<typename T>ostream&operator<<(ostream&os,vector<T>vc){for(int i=0;i<(int)vc.size();i++)os<<vc[i]<<"" "";return os;}

#define ll long long int
#define ld long double
#define F first
#define S second
#define vl vector<ll>
#define vi vector<int>
#define vb vector<bool>
#define vs vector<string>
#define vll vector<vl>
#define vii vector<vi>
#define pii pair<int,int>
#define pll pair<ll,ll>
#define ump unordered_map
#define all(v) v.begin(),v.end()
#define take_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cin>>a[i][j];}}
#define print_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cout<<a[i][j]<<' ';}cout<<endl;}
#define yes(x) if(x) cout<<""YES""<<endl; else cout<<""NO""<<endl;
#define cl(n) for(int i=0;i<=n+5;i++) g[i].clear()
#define memset(arr,val) memset(arr,val,sizeof(arr))
#define bpc(x) __builtin_popcountll(x)
#define __lcm(a,b) (a/__gcd(a, b)*b)
#define pq_max priority_queue<ll>
#define pq_min priority_queue<ll,vl,greater<ll>>
#define in insert
#define pb push_back
#define fast() ios::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);cout.precision(numeric_limits<double>::max_digits10);
mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
const int MOD=1e9+7;
vector<vector<ll>>delta1={{1,0},{-1,0},{0,-1},{0,1}};
vector<vector<ll>>delta2={{1,0},{-1,0},{0,-1},{0,1},{1,1},{-1,1},{1,-1},{-1,-1}};


class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        ll n=nums.size();
        vl dp1(n,0);
        vl dp2(n,0);
        
        dp1[0]=1;
        for(int i=1;i<n;i++){
            if(nums[i]>nums[i-1]){
                dp1[i]=dp1[i-1]+1;
            }else{
                dp1[i]=1;
            }
        }
        
        dp2[n-1]=1;
        for(int i=n-2;i>=0;i--){
            if(nums[i]<nums[i+1]){
                dp2[i]=dp2[i+1]+1;
            }else{
                dp2[i]=1;
            }
        }
        
        ll mx=0;
        for(int i=0;i<n-1;i++){
            mx=max(mx,min(dp1[i],dp2[i+1]));
        }
        
        return mx;
    }
};",1448185931
Kalix1110,Kalix1110,321,3631,cpp,"/*
	Name :- Tafheem Ahemad
	its always me vs me
*/
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
template <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

template<typename A,typename B>istream&operator>>(istream&is,pair<A,B>&p){is>>p.first>>p.second;return is;}
template<typename A,typename B>ostream&operator<<(ostream&os,pair<A,B>p){os<<p.first<<' '<<p.second<<endl;return os;}
template<typename T>istream&operator>>(istream&is,vector<T>&vc){for(T&x:vc)is>>x;return is;}
template<typename T>ostream&operator<<(ostream&os,vector<T>vc){for(int i=0;i<(int)vc.size();i++)os<<vc[i]<<"" "";return os;}

#define ll long long int
#define ld long double
#define F first
#define S second
#define vl vector<ll>
#define vi vector<int>
#define vb vector<bool>
#define vs vector<string>
#define vll vector<vl>
#define vii vector<vi>
#define pii pair<int,int>
#define pll pair<ll,ll>
#define ump unordered_map
#define all(v) v.begin(),v.end()
#define take_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cin>>a[i][j];}}
#define print_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cout<<a[i][j]<<' ';}cout<<endl;}
#define yes(x) if(x) cout<<""YES""<<endl; else cout<<""NO""<<endl;
#define cl(n) for(int i=0;i<=n+5;i++) g[i].clear()
#define memset(arr,val) memset(arr,val,sizeof(arr))
#define bpc(x) __builtin_popcountll(x)
#define __lcm(a,b) (a/__gcd(a, b)*b)
#define pq_max priority_queue<ll>
#define pq_min priority_queue<ll,vl,greater<ll>>
#define in insert
#define pb push_back
#define fast() ios::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);cout.precision(numeric_limits<double>::max_digits10);
mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
const int MOD=1e9+7;
vector<vector<ll>>delta1={{1,0},{-1,0},{0,-1},{0,1}};
vector<vector<ll>>delta2={{1,0},{-1,0},{0,-1},{0,1},{1,1},{-1,1},{1,-1},{-1,-1}};

class Solution {
public:
    ll n;
    string s;
    ll dp[800+5][900+2][2];
    ll countLexicographicallySmallest(int pos, int count, bool tight) {
        if(count<0) return 0;
    if (pos == n) {

        return count == 0 ? 1 : 0;
    }
    
    if (dp[pos][count][tight] != -1) {
        return dp[pos][count][tight];
    }

    ll limit = tight ? (s[pos] - '0') : 1;
    ll totalWays = 0;

    for (int digit = 0; digit <= limit; digit++) {
        int newCount = count - digit;
        
            totalWays += countLexicographicallySmallest(pos + 1, newCount, tight && (digit == limit));
            totalWays%=MOD;

    }

    return dp[pos][count][tight] = totalWays%MOD;
}
    
    ll step(ll x){
        ll c=0;
        while(x>1){
            x=bpc(x);
            c++;
        }
        
        return c;
    }
    int countKReducibleNumbers(string _s, int k) {
        s=_s;
        n=s.size();
        ll ans=0;
        memset(dp,-1);
        ll c=0;
        for(auto &it:s){
            if(it=='1') c++;
        }
        
        // ll x=0;
        for(int i=1;i<=900;i++){
            int st=step(i);
            if(st<k){
                
                ans+=countLexicographicallySmallest(0,i,1);
                if(c==i) ans--;
                ans=(ans+MOD)%MOD;
                
                // x++;
            }
        }
        
        // cout<<x<<endl;
        return ans;
    }
};",1448279411
Kalix1110,Kalix1110,321,3646,cpp,"/*
	Name :- Tafheem Ahemad
	its always me vs me
*/
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
template <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

template<typename A,typename B>istream&operator>>(istream&is,pair<A,B>&p){is>>p.first>>p.second;return is;}
template<typename A,typename B>ostream&operator<<(ostream&os,pair<A,B>p){os<<p.first<<' '<<p.second<<endl;return os;}
template<typename T>istream&operator>>(istream&is,vector<T>&vc){for(T&x:vc)is>>x;return is;}
template<typename T>ostream&operator<<(ostream&os,vector<T>vc){for(int i=0;i<(int)vc.size();i++)os<<vc[i]<<"" "";return os;}

#define ll long long int
#define ld long double
#define F first
#define S second
#define vl vector<ll>
#define vi vector<int>
#define vb vector<bool>
#define vs vector<string>
#define vll vector<vl>
#define vii vector<vi>
#define pii pair<int,int>
#define pll pair<ll,ll>
#define ump unordered_map
#define all(v) v.begin(),v.end()
#define take_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cin>>a[i][j];}}
#define print_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cout<<a[i][j]<<' ';}cout<<endl;}
#define yes(x) if(x) cout<<""YES""<<endl; else cout<<""NO""<<endl;
#define cl(n) for(int i=0;i<=n+5;i++) g[i].clear()
#define memset(arr,val) memset(arr,val,sizeof(arr))
#define bpc(x) __builtin_popcountll(x)
#define __lcm(a,b) (a/__gcd(a, b)*b)
#define pq_max priority_queue<ll>
#define pq_min priority_queue<ll,vl,greater<ll>>
#define in insert
#define pb push_back
#define fast() ios::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);cout.precision(numeric_limits<double>::max_digits10);
mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
const int MOD=1e9+7;
vector<vector<ll>>delta1={{1,0},{-1,0},{0,-1},{0,1}};
vector<vector<ll>>delta2={{1,0},{-1,0},{0,-1},{0,1},{1,1},{-1,1},{1,-1},{-1,-1}};

   
class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        ll n = nums.size();
        ll sum=0;
        
        map<ll,ll>mp;
        map<ll,ll>mp2;
        for(int i=0;i<n;i++){
            ll a=mp[nums[i]-1];
            a+=mp[nums[i]+1];
            a++;
            a%=MOD;
            
            ll s1=mp2[nums[i]-1];
            s1+=mp2[nums[i]+1];
            s1%=MOD;
            
            
            ll p=((a*nums[i])%MOD + s1%MOD)%MOD;
            sum+=p;
            sum%=MOD;
            // cout<<p<<endl;
            
            mp[nums[i]]+=a;
            mp2[nums[i]]+=p;
        }
        
        
        // cout<<""*****""<<endl;
        return sum;
    }
};",1448244413
Aniket Saini,Ani_S,323,3612,java,"class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        for(int i = 0; i < nums.size() - (2 * k) + 1; i++) {
            int j = i + k;
            boolean possible = true;
            
            for(int z = 1; z < k; z++) {
                if(nums.get(i + z) <= nums.get(i + z - 1) || nums.get(j + z) <= nums.get(j + z - 1)) {
                    possible = false;
                    break;
                }
            }
            
            if(possible)
                return true;
        }
        
        return false;
    }
}",1448186091
Aniket Saini,Ani_S,323,3619,java,"class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        Stack<Integer> stack = new Stack<>();
        int lastPossible = 0;
        int ans = 0;
        
        for(int i = 0; i < nums.size(); i++) {
            if(stack.isEmpty() || stack.peek() < nums.get(i)) {
                stack.push(nums.get(i));
            } else {
                int size = stack.size();
                
                ans = Math.max(ans, size / 2);
                ans = Math.max(ans, Math.min(size, lastPossible));
                lastPossible = size;
                
                stack.clear();
                
                stack.push(nums.get(i));
            }
        }
        
        if(!stack.isEmpty()) {
            int size = stack.size();
                
            ans = Math.max(ans, size / 2);
            ans = Math.max(ans, Math.min(size, lastPossible));
            lastPossible = size;

            stack.clear();
        }
        
        return ans;
    }
}",1448200475
Aniket Saini,Ani_S,323,3631,java,"class Solution {
    static int mod = 1000000007;
    
    Boolean dp[][];
    Long memo[][][];
    
    public int countKReducibleNumbers(String s, int k) {
        
        dp = new Boolean[s.length() + 1][k + 1];
        memo = new Long[s.length()][s.length() + 1][2];
        
        for(int i = 1; i <= s.length(); i++) {
            isKReducible(i, k);
        }
        
        return (int)countPossible(s.toCharArray(), 0, 0, 0, k);
    }
    
    private long countPossible(char arr[], int i, int count, int smaller, int k) {
        if(i == arr.length)
        {
            if(smaller > 0 && isKReducible(count, k)) {
                // System.out.println(count);
                return 1l;
            } else {
                return 0l;
            }
        }
        
        if(memo[i][count][smaller] != null)
            return memo[i][count][smaller];
        
        long ans = 0;
        ans = (ans + countPossible(arr, i + 1, count + (arr[i] == '1' ? 1 : 0), smaller, k)) % mod;
        
        if(arr[i] == '0') {
            if(smaller > 0) {
                ans = (ans + countPossible(arr, i + 1, count + 1, smaller, k)) % mod;
            }
        } else {
            ans = (ans + countPossible(arr, i + 1, count, 1, k)) % mod;
        }
        
        return memo[i][count][smaller] = ans;
    } 
    
    private boolean isKReducible(int num, int k) {
        if(k == 0)
            return false;
        
        if(dp[num][k] != null)
            return dp[num][k];
        
        if(num == 1)
            return dp[num][k] = true;
        
        return dp[num][k] = isKReducible(Integer.bitCount(num), k - 1);
    }
}",1448279600
Aniket Saini,Ani_S,323,3646,java,"class Solution {
    static int mod = 1000000007;
    public int sumOfGoodSubsequences(int[] nums) {
        Map<Integer, Long> map = new HashMap<>();
        long left[] = new long[nums.length];
        
        long sum = 0;
        
        for(int i = 0; i < nums.length; i++) {
            int num = nums[i];
            
            // Case of num - 1
            long cntMinus1 = map.getOrDefault(num - 1, 0l);
            
            // Case of num + 1
            long cntPlus1 = map.getOrDefault(num + 1, 0l);
            
            left[i] = (cntPlus1 + cntMinus1 + 1) % mod;
            
            map.put(num, (map.getOrDefault(num, 0l) + left[i]) % mod);
            
            // System.out.print(left[i] + "" "");
        }
        
        // System.out.println();
        
        map = new HashMap<>();
        long right[] = new long[nums.length];
        
        for(int i = nums.length - 1; i >= 0; i--) {
            int num = nums[i];
            
            // Case of num - 1
            long cntMinus1 = map.getOrDefault(num - 1, 0l);
            
            // Case of num + 1
            long cntPlus1 = map.getOrDefault(num + 1, 0l);
            
            right[i] = (cntPlus1 + cntMinus1 + 1) % mod;
            
            map.put(num, (map.getOrDefault(num, 0l) + right[i]) % mod);
        }
        
//         for(int i = 0; i < nums.length; i++)
//             System.out.print(right[i] + "" "");
        
//         System.out.println();
        
        for(int i = 0; i < nums.length; i++) {
            long freq = (left[i] * right[i]) % mod;
            sum = (sum + (freq * nums[i]) % mod) % mod;
        }
        
        
        return (int)sum;
    }
}",1448250150
lihaicoder,lihaicoder,325,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        prevlen = 0
        prevnum = nums[0] + 1
        thislen = 0
        ans = 0
        maxlen = 0
        for i, num in enumerate(nums):
            if num > prevnum:
                thislen += 1
            else:
                prevlen = thislen
                thislen = 1
            ans = max(ans, min(prevlen, thislen))
            maxlen = max(maxlen, thislen)
            # print(i, num, prevnum, thislen, prevlen)
            prevnum = num
        ans = max(ans, maxlen // 2)
        return ans >= k
                ",1448190136
lihaicoder,lihaicoder,325,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        prevlen = 0
        prevnum = nums[0] + 1
        thislen = 0
        ans = 0
        maxlen = 0
        for i, num in enumerate(nums):
            if num > prevnum:
                thislen += 1
            else:
                prevlen = thislen
                thislen = 1
            ans = max(ans, min(prevlen, thislen))
            maxlen = max(maxlen, thislen)
            # print(i, num, prevnum, thislen, prevlen)
            prevnum = num
        return max(ans, maxlen // 2)
                ",1448189533
lihaicoder,lihaicoder,325,3631,python3,"from functools import cache

class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        mod = 1_000_000_007
        
        @cache
        def red(num):
            if num == 1:
                return 0
            return red(num.bit_count()) + 1
        n = len(s)
        f = [[0]*2 for _ in range(n+1)]
        f[1][0] = 1
        f[0][1] = 1
        for i in range(1, n):
            # print(f)
            newf = [[0]*2 for _ in range(n+1)]
            for used in range(n):
                for skipped in [0, 1]:
                    f[used][skipped] %= mod
                    if f[used][skipped] == 0:
                        continue
                    this = f[used][skipped]
                    if skipped:
                        newf[used+1][1] += this
                        newf[used][1] += this
                    else:
                        if s[i] == ""1"":
                            newf[used][1] += this
                            newf[used + 1][0] += this
                        else:
                            newf[used][0] += this
            f = newf
        # print(f)
        ans = 0
        for used in range(1, n + 1):
            if red(used) + 1 <= k:
                # print(""used"", used, red(used))
                for skipped in [0, 1]:
                    this = f[used][skipped] % mod
                    ans = (ans + this) % mod
        # print(""-""*10)
        # if ans == 0:
            # return 0
        if red(s.count(""1"")) + 1 <= k:
            ans -= 1
        return ans

        
#         @cache
#         def f(idx, used, skipped):
#             if idx == 0:
#                 if used == 1 and not skipped:
#                     return 1
#                 if used == 0 and skipped:
#                     return 1
#                 return 0
#             ans = 0
#             if s[idx] == ""0"":
                
                
#             ans %= mod
#             return ans


        
                
            
",1448280793
lihaicoder,lihaicoder,325,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        mod = 1_000_000_007
        f = defaultdict(int)
        s = defaultdict(int)
        # f[0] = 1
        for num in nums:
            adds = num + s[num-1] + num * f[num-1] + s[num + 1] + num * f[num + 1]
            adds %= mod
            s[num] = (s[num] + adds) % mod
            f[num] += (1 + f[num-1] + f[num+1])
            # print(num, dict(s), dict(f))
        return sum(s.values()) % mod",1448213129
Palash Agrawal,Golu-bhai,326,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        int dp[n];
        dp[0]=1;
        int ans =1;
        for(int i=1;i<n;i++){
            if(nums[i-1]<nums[i]) dp[i]=1+dp[i-1];
            else dp[i]=1;
            ans = max(ans, dp[i]/2);
            int p = i-dp[i];
            if(p>=0 and dp[p]>=dp[i])ans =max(ans, dp[i]);
        }
        return ans>=k;
    }
};",1448189901
Palash Agrawal,Golu-bhai,326,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        int dp[n];
        dp[0]=1;
        int ans =1;
        for(int i=1;i<n;i++){
            if(nums[i-1]<nums[i]) dp[i]=1+dp[i-1];
            else dp[i]=1;
            ans = max(ans, dp[i]/2);
            int p = i-dp[i];
            if(p>=0 and dp[p]>=dp[i])ans =max(ans, dp[i]);
        }
        return ans;
    }
};",1448188201
Palash Agrawal,Golu-bhai,326,3631,cpp,"#define ll long long
const int mx = 1000;
class Solution {
    
    const ll M = 1e9+7;
    
    ll facInv[mx + 1], natInv[mx + 1], fact[mx + 1];

    void invNum(ll p) {
        natInv[0] = natInv[1] = 1;
        for (int i = 2; i <= mx; i++)
            natInv[i] = natInv[p % i] * (p - p / i) % p;
    }

    void invFac(ll p) {
        facInv[0] = facInv[1] = 1;
        for (int i = 2; i <= mx; i++)
            facInv[i] = (natInv[i] * facInv[i - 1]) % p;
    }

    void factorial(ll p) {
        fact[0] = 1;
        for (int i = 1; i <= mx; i++) 
            fact[i] = (fact[i - 1] * i) % p;
    }

    ll comb(ll n, ll r, ll p) {
        return ((fact[n] * facInv[r]) % p * facInv[n - r]) % p;
    }
    
    int calc(int num){
        int k =0;
        while(num>1){
            int cnt =0;
            int temp = num;
            while(temp){
                if(temp%2) cnt++;
                temp/=2;
            }
            k++;
            num = cnt;
        }
        return k;
    }
    ll help(vector<int>&freq, int rem, int pr, int k){
        ll ans =0;
        ll p = 1000000007;
        for(int i=0;i<=rem;i++){
            if(pr ==0 and i==0) continue;
            if((freq[pr+i]+1)>k) continue;
            if(i==0) {ans++;continue;}
            (ans+=comb(rem, i, p))%=M;
        }
        return ans;
    }

public:
    int countKReducibleNumbers(string s, int k) {
        ll p = 1000000007;
        invNum(p);
        invFac(p);
        factorial(p);
        vector<int>freq(801);
        
        for(int i =1;i<=800;i++){
            freq[i]=calc(i);
        }
        int pr =0, n = s.size();
        ll ans =0;
        int i =0;
        while(i<n){
            while(i<n and s[i]=='0'){
                i++;
            }
            if(i==n) break;
            (ans+=help(freq, (n-i-1), pr, k))%=M;
            pr++;
            i++;
        }
        return ans;
    }
};",1448287724
Palash Agrawal,Golu-bhai,326,3646,cpp,"typedef long long ll;
class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int n = nums.size();
        const int M = 1e9+7;
        int mx = 1e5+3;
        vector<ll>dp(mx, 0), dpi(n, 0);
        ll ans =0;
        for(int i=0;i<n;i++){
            ll x = dp[nums[i]+1] + 1;
            if(nums[i]) x+=dp[nums[i]-1];
            dpi[i]=(x)%M;
            //cout<<i<<endl;
            dp[nums[i]]+=dpi[i];
            //cout<<nums[i]<<"" ""<<dp[nums[i]]<<endl;
            
        }
        dp.assign(dp.size(), 0);
        for(int i = n-1;i>=0;i--){
            ll x = dp[nums[i]+1] + 1;
            if(nums[i]) x+=dp[nums[i]-1];
            ll rt = (x)%M;
            //cout<<dpi[i]<<"" ""<<rt<<"" ""<<nums[i]<<endl;
            ll cadd=(dpi[i]*rt)%M;
            (cadd*=nums[i])%=M;
            (ans+=cadd)%=M;
            (dp[nums[i]]+=rt)%=M;
        }
        return ans;
    }
};",1448236497
Tim Lu,Casterkiller,328,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        N = len(nums)
        for i in range(N):
            if i + 2 * k <= N:
                start = nums[i]
                fail = False
                for j in range(1, k):
                    ni = i + j
                    if nums[ni] <= nums[ni - 1]:
                        fail = True
                        break
                if fail:
                    continue
                start = nums[i + k]
                for j in range(1, k):
                    ni = i + k + j
                    if nums[ni] <= nums[ni - 1]:
                        fail = True
                        break
                if not fail:
                    return True

        return False
                    ",1448184545
Tim Lu,Casterkiller,328,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        N = len(nums)
        ps = [1] * N

        for i in range(1, N):
            ps[i] = ps[i - 1] + 1 if nums[i] > nums[i - 1] else 1

        # print(ps)

        best = 0
        for i in range(1, N):
            r = ps[i]
            if i - r >= 0:
                best = max(best, min(ps[i - r], r))
            best = max(best, r // 2)

        return best",1448194321
Tim Lu,Casterkiller,328,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        M = 10 ** 9 + 7
        k -= 1

        count = sum(1 if c == '1' else 0 for c in s)

        @cache
        def go(cnt, step):
            if cnt == 1:
                return 1
            if step == 0 or cnt == 0:
                return 0

            return go(cnt.bit_count(), step - 1)
            
        # print('count', count)
        rs = list(reversed(s))
        total = 0
        # print('init total', total)
        ones = 0
        for i in range(len(rs)):
            if rs[i] == '1':
                ones += 1

                total += 1 if go(count - ones, k) else 0
                for j in range(1, i + 1):
                    total += comb(i, j) if go(count - ones + j, k) else 0
                    total %= M
                total %= M
                # print(i, total)

        # 1010100010100
        # 111
        
        return total",1448294549
Tim Lu,Casterkiller,328,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        M = 10 ** 9 + 7
        lookup = defaultdict(int)
        count = Counter()

        total = 0
        for n in nums:
            s = lookup[n - 1] + lookup[n + 1] + (1 + count[n - 1] + count[n + 1]) * n
            lookup[n] += s
            lookup[n] %= M
            total += s
            total %= M
            count[n] += count[n - 1] + count[n + 1] + 1
            # print(n, lookup, count)
            # print(total)

        # print(lookup)
        return total",1448238535
Saikat Ghosh,saikat93ify,330,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>&A, int k) {
    
        vector <int> increasing_subarray_from(A.size(), 1); 
        for(int i = A.size() - 2; i >= 0; i--)
        {
            increasing_subarray_from[i] = 1 + (A[i] < A[i + 1] ? increasing_subarray_from[i + 1] : 0);
        }
        
        for(int i = 0; i <= A.size() - 1 - k; i++)
        {
            int j = i + k; 
            //cout << ""i = "" << i << "" INcreasing = "" << increasing_subarray_from[i] <<"" j = "" << increasing_subarray_from[j] << ""\n"";//
            if(increasing_subarray_from[i] >= k && increasing_subarray_from[j] >= k)
            {
                return true;
            }
        }
        
        return false;
    }
};",1448274732
Saikat Ghosh,saikat93ify,330,3619,cpp,"class Solution {
public:
    int increasing_subarrays_exist(vector <int> &A, int k)
    {
        vector <int> increasing_subarray_from(A.size(), 1); 
        for(int i = A.size() - 2; i >= 0; i--)
        {
            increasing_subarray_from[i] = 1 + (A[i] < A[i + 1] ? increasing_subarray_from[i + 1] : 0);
        }
        
        for(int i = 0; i < A.size() - 1 - k; i++)
        {
            int j = i + k; 
            
            
            
            if(increasing_subarray_from[i] >= k && increasing_subarray_from[j] >= k)
            {
                //cout << ""Increasing from "" << i << "" = "" << increasing_subarray_from[i] << "" j = "" << j << "" = "" << increasing_subarray_from[j] << ""\n"";
                return true;
            }
        }
        
        return false;
    }
    
    int maxIncreasingSubarrays(vector<int>& nums) 
    {
        //Left <= answer < right
        int left = 1, right = nums.size(); 
        while(right - left > 1)
        {
            int mid = (left + right)/2; 
            
            if(increasing_subarrays_exist(nums, mid))
            {
                left = mid; 
            }
            else 
            {
                right = mid;
            }
        }
        
        return left; 
    }
};",1448269499
Saikat Ghosh,saikat93ify,330,3631,cpp,"class Solution 
{
    public:
    long long power_mod(long long x, long long power, int mod)
    {
        long long answer = 1; 
        while(power > 0)
        {
            if(power%2 == 1)
            {
                answer = (answer*x)%mod;
            }

            x = (x*x)%mod; 
            power = power/2;
        }

        return answer;
    }

    int bit_count(int n)
    {
        int bits = 0; 
        while(n > 0)
        {
            bits += (n%2 == 1);
            n /= 2;
        }

        return bits;
    }

    int reductions(int n)
    {
        if(n == 1)
        {
            return 0;
        }

        return 1 + reductions(bit_count(n));
    }

    int choose(int n, int r, vector <int> &factorial, vector <int> &inv_factorial, int mod)
    {
        int numerator = factorial[n]; 
        int inv_denominator = (inv_factorial[r]*1LL*inv_factorial[n - r])%mod;
        return (numerator*1LL*inv_denominator)%mod;
    }

    int countKReducibleNumbers(string S, int k) 
    {
        const int MAX_N = 1000, MOD = 1e9 + 7;
        vector <int> factorial(MAX_N, 1), inverse_factorial(MAX_N); 
        for(int i = 1; i < MAX_N; i++)
        {
            factorial[i] = (factorial[i - 1]*1LL*i)%MOD;
        }

        //i*(i - 1)! = i!
        inverse_factorial[MAX_N - 1] = power_mod(factorial[MAX_N - 1], MOD - 2, MOD);
        for(int i = MAX_N - 2; i >= 0; i--)
        {
            inverse_factorial[i] = ((i + 1)*1LL*inverse_factorial[i + 1])%MOD;
        }

        vector <int> is_good(MAX_N);
        vector <int> good_numbers_till(MAX_N);
        for(int i = 1; i < MAX_N; i++)
        {
            is_good[i] = (reductions(i) <= k - 1);
            good_numbers_till[i] = good_numbers_till[i - 1] + is_good[i];
        }
        
        int answer = 0; 
        int prefix_sum = 0; 
        for(int i = 0; i < S.size(); i++)
        {
            if(S[i] == '1')
            {
                int suffix = S.size() - i - 1; 
                int min_sum = prefix_sum, max_sum = prefix_sum + suffix; 

                for(int target_sum = prefix_sum; target_sum <= max_sum; target_sum++)
                {
                    if(!is_good[target_sum])
                    {
                        continue;
                    }
                    
                    int suffix_1s = target_sum - prefix_sum;
                    int no_of_ways = choose(suffix, suffix_1s, factorial, inverse_factorial, MOD); 
                    //cout << ""C("" << suffix << "","" << suffix_1s << "") = "" << no_of_ways << ""\n"";
                    answer += no_of_ways; 
                    answer %= MOD;

                    //cout << ""Prefix = "" << prefix_sum << "" T = "" << target_sum << "" Add "" << no_of_ways << ""\n"";
                }
            }
            
            prefix_sum += (S[i] - '0');
        }

        return answer; 
    }
};",1448238128
Saikat Ghosh,saikat93ify,330,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) 
    {
        const int MOD = 1e9 + 7;
        map <int, long long> sequences_with_last; 
        vector <long long> prefix_ending(nums.size()); 
        for(int i = 0; i < nums.size(); i++)
        {
            prefix_ending[i] += sequences_with_last[nums[i] - 1] + sequences_with_last[nums[i] + 1];
            prefix_ending[i] %= MOD;
            
            sequences_with_last[nums[i]] += 1 + prefix_ending[i];
            sequences_with_last[nums[i]] %= MOD;
        }
        
        map <int, long long> sequences_with_first; 
        vector <long long> suffix_ending(nums.size()); 
        for(int i = nums.size() - 1; i >= 0; i--)
        {
            suffix_ending[i] += sequences_with_first[nums[i] + 1] + sequences_with_first[nums[i] - 1];
            suffix_ending[i] %= MOD; 
            
            sequences_with_first[nums[i]] += 1 + suffix_ending[i];
            sequences_with_first[nums[i]] %= MOD;
        }
       
        long long sum = 0; 
        for(int i = 0; i < nums.size(); i++)
        {
            //cout << ""i = "" << i << "" Prefix Ending = "" << prefix_ending[i] <<""  Suffix ending = "" << suffix_ending[i] << ""\n"";
            long long contribution = prefix_ending[i] + suffix_ending[i] + prefix_ending[i]*1LL*suffix_ending[i] + 1;
            contribution %= MOD; 
            
            sum += contribution*nums[i]; 
            sum %= MOD;
        }
        
        return sum; 
    }
};",1448255231
EthanZyh,EthanZyh,331,3612,python,"class Solution(object):
    def hasIncreasingSubarrays(self, nums, k):
        """"""
        :type nums: List[int]
        :type k: int
        :rtype: bool
        """"""
        def is_inc(a):
            for i in range(1, len(a)):
                if a[i]<=a[i-1]:
                    return False
            return True

        n = len(nums)
        for i in range(n):
            if i>=k-1 and i+k<=n-1:
                if is_inc(nums[i-k+1:i+1]) and is_inc(nums[i+1:i+k+1]):
                    return True
        return False",1448183147
EthanZyh,EthanZyh,331,3619,python,"class Solution(object):
    def maxIncreasingSubarrays(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        n=len(nums)
        a = nums
        r = [0 for i in range(n)]
        l = [0 for i in range(n)]
        last = -1e18
        now = 0
        for i in range(n):
            if a[i]>last:
                now+=1
                l[i]=now
                last=a[i]
            else:
                now=1
                l[i]=1
                last=a[i]
        last = 1e18
        now = 0
        for i in range(n-1, -1, -1):
            if a[i]<last:
                now+=1
                r[i]=now
                last=a[i]
            else:
                now=1
                r[i]=1
                last=a[i]
        ans = 1
        for i in range(n-1):
            ans = max(ans, min(l[i],r[i+1]))
        # print(l)
        # print(r)
        return ans",1448191497
EthanZyh,EthanZyh,331,3631,python,"class Solution(object):
    def countKReducibleNumbers(self, s, k):
        """"""
        :type s: str
        :type k: int
        :rtype: int
        """"""
        K=k
        s = list(s)
        P = int(1e9+7)
        L = len(s)
        f = [[[0 for j in range(L+1)] for i in range(L+1)] for _ in range(2)]
        f[0][0][0] = 1
        for i in range(0,L):
            bit = int(s[i])
            for j in range(i+1):
                small = f[1][i][j]
                equal = f[0][i][j]
                for k in range(2):
                    newj = j + int(k==1)
                    f[1][i+1][newj] = (f[1][i+1][newj] + small) %P
                    if k<=bit:
                        newSE = int(k<bit)
                        f[newSE][i+1][newj] = (f[newSE][i+1][newj] + equal) %P
        bitc = [0 for i in range(900)]
        for i in range(1, 850):
            bitc[i] = bitc[i//2] + (i%2) 
        
        def valid(m,K):
            for i in range(K-1):
                m = bitc[m]
            return m==1
        
        ans = 0
        for j in range(1, L+1):
            # print(j,valid(j,K),f[1][L][j])
            ans = (ans + valid(j,K)*f[1][L][j]) %P
        return ans


                        ",1448260997
EthanZyh,EthanZyh,331,3646,python,"class Solution(object):
    def sumOfGoodSubsequences(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        M = 100000
        f = [0 for i in range(M+1)]
        g = [0 for i in range(M+1)]
        a = nums
        n = len(a)
        P = int(1e9+7)
        for i in range(n):
            g[a[i]] = (g[a[i]] + a[i]) %P
            if a[i]>=1:
                g[a[i]] = (g[a[i]] + g[a[i]-1] + a[i]*f[a[i]-1])%P
            if a[i]<M:
                g[a[i]] = (g[a[i]] + g[a[i]+1] + a[i]*f[a[i]+1])%P
            f[a[i]] = (f[a[i]] + 1) %P
            if a[i]>=1:
                f[a[i]] = (f[a[i]] + f[a[i]-1]) %P
            if a[i]<M:
                f[a[i]] = (f[a[i]] + f[a[i]+1]) %P
        ans = 0
        for i in range(M+1):
            ans = (ans + g[i])%P
        return ans",1448208424
Shuqi Shang,sshang,332,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        
        n = len(nums)
        
        dp = []
        for i, num in enumerate(nums):
            if i > 0 and nums[i] > nums[i-1]:
                dp.append(dp[-1] + 1)
            else:
                dp.append(1)
                
        rev = []
        for i in range(n-1, -1, -1):
            if i < n - 1 and nums[i+1] > nums[i]:
                rev.append(rev[-1] + 1)
            else:
                rev.append(1)
                
        rev.reverse()
        
        # print(dp)
        # print(rev)
        
        res = 1
        for i in range(n-1):
            res = max(res, min(dp[i], rev[i+1]))
        return res >= k",1448193786
Shuqi Shang,sshang,332,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        
        n = len(nums)
        
        dp = []
        for i, num in enumerate(nums):
            if i > 0 and nums[i] > nums[i-1]:
                dp.append(dp[-1] + 1)
            else:
                dp.append(1)
                
        rev = []
        for i in range(n-1, -1, -1):
            if i < n - 1 and nums[i+1] > nums[i]:
                rev.append(rev[-1] + 1)
            else:
                rev.append(1)
                
        rev.reverse()
        
        # print(dp)
        # print(rev)
        
        res = 1
        for i in range(n-1):
            res = max(res, min(dp[i], rev[i+1]))
        return res",1448192749
Shuqi Shang,sshang,332,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        
        mod = 10 ** 9 + 7
        
        if s == '0' or s == '1':
            return 0
        
        n = len(s)
        cnts = [float('inf')] * (n + 1)
        cnts[1] = 0
        
        for num in range(2, n + 1):
            cur, cnt = num, 1
            while cur != 1 and cnt < k:
                cur = bin(cur).count('1')
                cnt += 1
                
            if cur == 1:
                cnts[num] = cnt - 1
                
        @lru_cache(None)
        def count(i, need, equal):
            if need == 0:
                return 1
            if n - i < need:
                return 0
            
            if equal:
                if s[i] == '0':
                    return count(i + 1, need, True)
                else:
                    return (count(i + 1, need - 1, True) + count(i + 1, need, False)) % mod
            else:
                return (count(i + 1, need - 1, False) + count(i + 1, need, False)) % mod
                    
        res = 0
        for num, cnt in enumerate(cnts):
            if cnt != float('inf'):
                res = (res + count(0, num, True)) % mod
                
        ori = s.count('1')
        if cnts[ori] != float('inf'):
            res -= 1
        
        return res",1448275059
Shuqi Shang,sshang,332,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        
        mod = 10 ** 9 + 7
        
        d = defaultdict(int)
        d_cnt = defaultdict(int)
        for i, num in enumerate(nums):
            d[num] = d[num] + num + (d[num - 1] + num * d_cnt[num - 1]) + (d[num + 1] + num * d_cnt[num + 1])
            d[num] = d[num] % mod
            d_cnt[num] = d_cnt[num] + 1 + d_cnt[num - 1] + d_cnt[num + 1]
            
        return sum(d.values()) % mod ",1448204839
Ajay Maheshwari,unknown_ajay,333,3612,cpp,"/*
 
 File   : Leetcode.cpp
 -------------------
 |   Hello         |
 |   DSA !         |
 -------------------
 
 */

#define mii map<int,int>
#define vi vector<int>
#define vs vector<string>
#define vb vector<bool>
#define pii pair<int,int>
#define endl ""\n""
#define intmax INT_MAX
#define intmin INT_MIN
#define need_for_speed ios_base::sync_with_stdio(false); cin.tie(NULL);
#define ff(i,a,b) for(int i=a;i<b;i++)
#define rfor(i,a,b) for(int i=a;i>=b;i--)
#define all(x) x.begin(),x.end()
#define pt(x) { cout<<x<<""\n""; }
#define fs first.second
#define ss second.second
#define countofSet(x) __builtin_popcount(x)
#define pb push_back
#define fir first
#define sec second
#define sqrt(x) sqrtl(x)


class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& v, int k) {
        
        
        int n = (int)v.size();
        vi I;
        int i = 0;
        while(i<n)
        {
            int j = i;
            while(j+1<n && v[j+1] > v[j]) j++;
            I.pb(j-i+1);
            i = j+1;
        }
        
        auto poss = [&](int k) -> bool {
          
            bool ok = false;
            int m = (int)I.size();
            for(int i=0;i<m;i++)
            {
                ok |= ( I[i] >= 2 * k );
                ok|= ( i+1<m && I[i] >= k && I[i+1] >= k );
            }
            return ok;
        };
        
        return poss(k);
    }
};",1448199736
Ajay Maheshwari,unknown_ajay,333,3619,cpp,"
/*
 
 File   : Leetcode.cpp
 -------------------
 |   Hello         |
 |   DSA !         |
 -------------------
 
 */

#define mii map<int,int>
#define vi vector<int>
#define vs vector<string>
#define vb vector<bool>
#define pii pair<int,int>
#define endl ""\n""
#define intmax INT_MAX
#define intmin INT_MIN
#define need_for_speed ios_base::sync_with_stdio(false); cin.tie(NULL);
#define ff(i,a,b) for(int i=a;i<b;i++)
#define rfor(i,a,b) for(int i=a;i>=b;i--)
#define all(x) x.begin(),x.end()
#define pt(x) { cout<<x<<""\n""; }
#define fs first.second
#define ss second.second
#define countofSet(x) __builtin_popcount(x)
#define pb push_back
#define fir first
#define sec second
#define sqrt(x) sqrtl(x)

class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& v)
    {
        int n = (int)v.size();
        vi I;
        int i = 0;
        while(i<n)
        {
            int j = i;
            while(j+1<n && v[j+1] > v[j]) j++;
            I.pb(j-i+1);
            i = j+1;
        }
        
        auto poss = [&](int k) -> bool {
          
            bool ok = false;
            int m = (int)I.size();
            for(int i=0;i<m;i++)
            {
                ok |= ( I[i] >= 2 * k );
                ok|= ( i+1<m && I[i] >= k && I[i+1] >= k );
            }
            return ok;
        };
               
        int l = 1;
        int r = n/2;
        while(l+1<r)
        {
            int md = (l+r)/2;
            if( poss(md) ) l = md;
            else r = md;
        }
        
        int ans = l;
        if( poss(r) ) ans = r;
        return ans;
    }
};",1448198353
Ajay Maheshwari,unknown_ajay,333,3631,cpp,"using namespace std;

/*
 
 File   : Leetcode.cpp
 -------------------
 |   Hello         |
 |   DSA !         |
 -------------------
 
 */

#define mii map<int,int>
#define vi vector<int>
#define vs vector<string>
#define vb vector<bool>
#define pii pair<int,int>
#define endl ""\n""
#define intmax INT_MAX
#define intmin INT_MIN
#define need_for_speed ios_base::sync_with_stdio(false); cin.tie(NULL);
#define ff(i,a,b) for(int i=a;i<b;i++)
#define rfor(i,a,b) for(int i=a;i>=b;i--)
#define all(x) x.begin(),x.end()
#define pt(x) { cout<<x<<""\n""; }
#define fs first.second
#define ss second.second
#define countofSet(x) __builtin_popcount(x)
#define pb push_back
#define fir first
#define sec second
#define sqrt(x) sqrtl(x)
#define ll long long

const int M = 1e9+7;
const int N = 1000;
vector<int> red(N);
bool done = false;

void pre()
{
    if(done) return;
    for(int i=1;i<=800;i++)
    {
        int j = i;
        int op = 0;
        while(j!=1) {
            j = __builtin_popcount(j);
            op++;
        }
        red[i] = op;
    }
    done = 1;
}

class Solution {
public:
    int countKReducibleNumbers(string s, int k)
    {
        pre();
        int n = s.length();
        ll ans = 0;
        int st = 0;
        for(auto &x:s) st += (x == '1');
        
        vector< vector< vector<ll> > > dp(n+1, vector< vector<ll> > (n+1, vector<ll> (2,-1LL)));
        
        for(int i = 1 ; i <= n ;i++)
        {
            if( red[i] + 1 > k ) continue;
            
            // if og string has b bits set we can reduce it in red[i] + 1 steps
            // cout << ""Keeping "" << i << "" bits in og string ways = "" << ways(ways,0,b,true) << ""\n"";
            
            auto ways = [&](const auto &ways,int idx,int rem,bool cap) -> ll {
                
                if(rem == 0) return 1;
                if(idx == n) return (rem == 0);
                
                if( dp[idx][rem][cap] != -1 ) return dp[idx][rem][cap];
                
                ll cnt = 0;
                // place
                if( s[idx] == '0' && cap ) {}
                else cnt += ways(ways,idx+1,rem-1, cap && ( s[idx] == '1' ) );
                
                cnt %= M;
                    
                // not place
                cnt += ways(ways,idx+1,rem, cap && ( s[idx] == '0' ) );
                cnt %= M;
                
                return dp[idx][rem][cap] = cnt;
            };
            
            ans += ways(ways,0,i,true);
            ans %= M;

            if( i == st )
            {
                ans = (ans%M - 1) %M;
                ans += M;
                ans %= M;
            }
        }
        
        return (int)(ans %M);
    }
};",1448295408
Ajay Maheshwari,unknown_ajay,333,3646,cpp,"#include ""bits/stdc++.h""
using namespace std;

/*
 
 File   : Leetcode.cpp
 -------------------
 |   Hello         |
 |   DSA !         |
 -------------------
 
 */

#define mii map<int,int>
#define vi vector<int>
#define vs vector<string>
#define vb vector<bool>
#define pii pair<int,int>
#define endl ""\n""
#define intmax INT_MAX
#define intmin INT_MIN
#define need_for_speed ios_base::sync_with_stdio(false); cin.tie(NULL);
#define ff(i,a,b) for(int i=a;i<b;i++)
#define rfor(i,a,b) for(int i=a;i>=b;i--)
#define all(x) x.begin(),x.end()
#define pt(x) { cout<<x<<""\n""; }
#define fs first.second
#define ss second.second
#define countofSet(x) __builtin_popcount(x)
#define pb push_back
#define fir first
#define sec second
#define sqrt(x) sqrtl(x)
#define ll long long
const int M = 1e9 + 7;

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums)
    {
        int n = (int)nums.size();
        vector<ll> dpCnt(n,0);
        vector<ll> dpSum(n,0);
        map<int,ll> mpSum;
        map<int,ll> mpCnt;
        
        int ans = 0;
        dpCnt[0] = mpCnt[ nums[0] ] = 1;
        dpSum[0] = mpSum[ nums[0] ] = nums[0];
        
        ff(i,1,n)
        {
            ll cnt = 0;
            ll sm = 0;
            
            int prev = nums[i] - 1;
            if( mpCnt.find(prev) != mpCnt.end() )
            {
                cnt += mpCnt[ prev ];
                cnt %= M;
                
                sm += mpSum[ prev ];
                sm %= M;
            }
            
            prev = nums[i] + 1;
            if( mpCnt.find(prev) != mpCnt.end() )
            {
                cnt += mpCnt[ prev ];
                cnt %= M;
                
                sm += mpSum[ prev ];
                sm %= M;
            }
            
            dpCnt[i] = cnt + 1;
            dpSum[i] = ( (nums[i] %M * dpCnt[i] %M ) %M + sm %M ) %M;
            
            mpCnt[ nums[i] ] += dpCnt[i];
            mpCnt[ nums[i] ] %= M;
            
            mpSum[ nums[i] ] += dpSum[i];
            mpSum[ nums[i] ] %= M;
        }
        
        for(auto &x:dpSum)
        {
            ans += x;
            ans %= M;
        }
        return ans;
    }
};",1448242411
Priyabrata Das,Thunder_strom007,334,3612,cpp,"class Solution {
public:
    bool check(vector<int>&arr,int i,int j){
        for(int l=i+1;l<=j;l++){
            if(arr[l]<=arr[l-1]) return false;
        }
        return true;
    }
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        for(int a=0;a<n;a++){
            int idx1 = a;
            int idx2 = a + k - 1;
            int idx3 = a + k;
            int idx4 = idx3 + k - 1;
            if(idx2 < n && idx4 < n){
                if(check(nums,idx1,idx2) && check(nums,idx3,idx4)) return true;
            }
        }
        return false;
    }
};",1448183624
Priyabrata Das,Thunder_strom007,334,3619,cpp,"class Solution {
public:
    vector<int> pref;
    void f(vector<int>& arr){
        int n = arr.size();
        pref.assign(n-1,0);
        for(int i=1;i<n;i++){
            if(arr[i]>arr[i-1]){
                pref[i-1] = 1;
            }
            else{
                pref[i-1] = 0;
            }
            if(i-2>=0) pref[i-1] += pref[i-2];
        }
    }
    bool check(int i,int j){
        int len = j-i+1;
        int sum = pref[j];
        sum -= pref[i];
        return sum == len - 1;
    }
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        for(int a=0;a<n;a++){
            int idx1 = a;
            int idx2 = a + k - 1;
            int idx3 = a + k;
            int idx4 = idx3 + k - 1;
            if(idx2 < n && idx4 < n){
                if(check(idx1,idx2) && check(idx3,idx4)) return true;
            }
        }
        return false;
    }
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        
        vector<int> arr = {INT_MIN};
        for(auto &x : nums){
            arr.push_back(x);
        }

        f(arr);
        
        int ans = 1;
        int lo = 2, hi = n;
        while(lo<=hi){
            int mid = lo + (hi-lo)/2;
            if(hasIncreasingSubarrays(nums,mid)){
                ans = mid;
                lo = mid + 1;
            }
            else{
                hi = mid - 1;
            }
        }
        return ans;
    }
};",1448232277
Priyabrata Das,Thunder_strom007,334,3631,cpp,"class Solution {
public:
    int n;
    string str;
    int K;
    int mod = 1e9+7;
    
    long long dp[801][801][2];
   
    long long f(int i,int ones,bool flag){
        if(i==n){
            if(!flag) return 0;
            int op = 1;
            int val = ones;
            while(val!=1){
                op++;
                if(op>K) return 0;
                val = __builtin_popcount(val);
            }
            return op<=K;
        }
        if(dp[i][ones][flag]!=-1) return dp[i][ones][flag];
        long long ans = 0;
        if(flag){
            ans += f(i+1,ones,true);
            ans %= mod;
            ans += f(i+1,ones+1,true);
            ans %= mod;
        }
        else{
            if(str[i] == '1'){
                ans += f(i+1,ones+1,false);
                ans %= mod;
                ans += f(i+1,ones,true);
                ans %= mod;
            }
            else{
                ans += f(i+1,ones,false);
                ans %= mod;
            }
        }
        return dp[i][ones][flag] = ans;
    }
    int countKReducibleNumbers(string s, int k) {
        str = s;
        n = s.size();
        K = k;
        
        memset(dp,-1,sizeof(dp));
        
        return (int)f(0,0,false);
    }
};",1448288894
Priyabrata Das,Thunder_strom007,334,3646,cpp,"class Solution {
public:
    
    int sumOfGoodSubsequences(vector<int>& nums) {
        map<long long,long long> freq,sum;
        int n = nums.size();
        long long ans = 0;
        int mod = 1e9+7;
        
        for(int i=0;i<n;i++){
            long long val = nums[i];
            
            if(freq.count(val-1)){
                freq[val] += freq[val-1];
                freq[val] %= mod;
                sum[val] += ((sum[val-1] + (freq[val-1]*val)%mod)%mod);
                sum[val] %= mod;
            }
            if(freq.count(val+1)){
                freq[val] += freq[val+1];
                freq[val] %= mod;
                sum[val] += ((sum[val+1] + (freq[val+1]*val)%mod)%mod);
                sum[val] %= mod;
            }
            sum[val] += val;
            sum[val] %= mod;
            freq[val]++;
            freq[val] %= mod;
        }
        
        for(auto &x : sum){
            ans += x.second;
            ans %= mod;
        }
        
        return (int)ans;
    }
};",1448265592
BrutalKiller,BrutalKiller,335,3612,cpp,"#include ""bits/stdc++.h""
#define all(a) a.begin(), a.end()
#define pb push_back
#define vi vector <ll>
#define vvi vector <vector <ll>>
#define pll pair<ll, ll>

using namespace std;

typedef int ll;

class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& v, int k) {

        for(int i = 0; i + (2 * k) - 1 < v.size(); i++){
            int last = v[i];
            ll x = i + 1;
            bool flag = true;
            
            for(ll j = 1; j < k; j++){
                if(v[x] <= last){
                    flag = false;
                    break;
                }

                last = v[x];
                x++;
            }

            x = i + k;
            last = v[x];
            x++;
            for(ll j = 1; j < k; j++){
                if(v[x] <= last){
                    flag = false;
                    break;
                }

                last = v[x];
                x++;
            }

            if(flag)
                return true;
        }
        return false;
    }
};",1448188841
BrutalKiller,BrutalKiller,335,3619,cpp,"#include ""bits/stdc++.h""
#define all(a) a.begin(), a.end()
#define pb push_back
#define vi vector <ll>
#define vvi vector <vector <ll>>
#define pll pair<ll, ll>

using namespace std;

typedef int ll;

class Solution {

    vi help;
public:
    int maxIncreasingSubarrays(vector<int>& v) {

        ll n = v.size();
        ll l = 0, r = 0;
        ll ans = 0;
        ll cnt = 1;
        help = vi(n);
        
        while(l < n){
            r = max(l + 1, r);
            cnt = max(1, cnt);

            while(r < n && v[r] > v[r - 1]){
                r++;
                cnt++;
            }

            help[l] = cnt;
            l++;
            cnt--;
        }
        help.pb(1);
        
        for(ll i = 0; i < n; i++){
            ans = max(ans, help[i] / 2);

            ll x = min(help[i], help[i + help[i]]);
            ans = max(ans, x);
        }
        return ans;
    }
};",1448216578
BrutalKiller,BrutalKiller,335,3631,cpp,"#include ""bits/stdc++.h""
#define all(a) a.begin(), a.end()
#define pb push_back
#define vi vector <ll>
#define vvi vector <vector <ll>>
#define pll pair<ll, ll>

using namespace std;

typedef long long ll;

class Solution {

    vector <vvi> dp;
    string s;
    vi help;
    ll M = 1e9 + 7;
    ll n, k;

    ll cnt(ll x){
        for(int i = 1; i <= 7; i++){
            x = __builtin_popcount(x);

            if(x == 1)
                return i;
        }
        return 7;
    }

    ll dfs(ll x, ll y, ll z){
        if(x == n){
            if(z == 0 or (help[y] >= k and y != 1))
                return 0;
            return 1;
        }

        if(dp[x][y][z] != -1)
            return dp[x][y][z];

        ll ans = 0;
        if(z == 0){
            if(s[x] == '0')
                ans = (ans + dfs(x + 1, y, 0)) % M;
            else{
                ans = (ans + dfs(x + 1, y + 1, 0)) % M;
                ans = (ans + dfs(x + 1, y, 1)) % M;
            }
        }
        else{
            ans = (ans + dfs(x + 1, y + 1, 1)) % M;
            ans = (ans + dfs(x + 1, y, 1)) % M;
        }

        return dp[x][y][z] = ans;
    }
public:
    int countKReducibleNumbers(string ss, int kk) {
        ll ans = 0;
        s = ss;
        n = s.size();
        k = kk;
        help = vi(n + 1, -1);
        help[0] = 7;
        
        for(ll i = 1; i <= n; i++){
            help[i] = cnt(i);
        }

        dp = vector <vvi> (n, vvi(n + 1, vi(2, -1)));
        ans = dfs(0, 0, 0);
        return ans;
    }
};",1448282312
BrutalKiller,BrutalKiller,335,3646,cpp,"#include ""bits/stdc++.h""
#define all(a) a.begin(), a.end()
#define pb push_back
#define vi vector <ll>
#define vvi vector <vector <ll>>
#define pll pair<ll, ll>

using namespace std;

typedef long long ll;

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& v) {
        vi dp(1e5 + 5, 0);
        vi help(1e5 + 5, 0);
        ll M = 1e9 + 7;
        
        for(auto & e : v){
            
            help[e] = (help[e] + e) % M;
            
            ll x = 0;

            if(e != 0){
                x = dp[e - 1] * e % M;
                x = (x + help[e - 1]) % M;
                help[e] = (help[e] + x) % M;
            }
            
            x = dp[e + 1] * e % M;
            x = (x + help[e + 1]) % M;
            help[e] = (help[e] + x) % M;

            dp[e] = (dp[e] + 1) % M;
            dp[e] = (dp[e + 1] + dp[e]) % M;

            if(e != 0)
                dp[e] = (dp[e - 1] + dp[e]) % M;

        }
        
        ll ans = 0;
        for(auto & e : help){
            ans = (ans + e) % M;
        }

        return ans;
    }
};",1448240199
Mark33,mark233,338,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        if k == 1:
            return True
        lo, fa = 0, k
        count = 0
        while fa + 1 < len(nums):
            if nums[lo+1] > nums[lo] and nums[fa+1] > nums[fa]:
                count += 1
            else:
                count = 0
            if count == k - 1:
                return True
            lo += 1
            fa += 1
        return False",1448183960
Mark33,mark233,338,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        def if_k_valid(k):
            if k == 1:
                return True
            lo, fa = 0, k
            count = 0
            while fa + 1 < len(nums):
                if nums[lo+1] > nums[lo] and nums[fa+1] > nums[fa]:
                    count += 1
                else:
                    count = 0
                if count == k - 1:
                    return True
                lo += 1
                fa += 1
            return False
        res = 1
        l, r = 1, len(nums) // 2
        while l < r:
            mid = (l + r) // 2
            if if_k_valid(mid):
                res = mid
                l = mid + 1
            else:
                r = mid
        if if_k_valid(l):
            res = l
        return res",1448199282
Mark33,mark233,338,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        count_1 = s.count(""1"")
        @cache
        def is_count_1_valid(num, limit):
            if num == 1:
                return True
            if limit == 0:
                return False
            return is_count_1_valid(bin(num).count(""1""), limit - 1)
        res = 0 
        MOD = 10 ** 9 + 7
        count = count_1
        for i in range(len(s) - 1, -1, -1):
            if s[i] == '1':
                count -= 1
                length = len(s) - i - 1
                for j in range(length + 1):
                    if is_count_1_valid(count + j, k - 1):
                        res += math.comb(length, j)
                        # print(res, j, length, count)
                        res = res % MOD
        return res",1448282563
Mark33,mark233,338,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        dp = collections.defaultdict(lambda : [0, 0])
        res = 0
        MOD = 10 ** 9 + 7
        for num in nums:
            count1, all_sum1 = dp[num - 1]
            count2, all_sum2 = dp[num + 1]
            count = count1 + count2 + 1
            all_sum = all_sum1 + all_sum2 + count * num
            dp[num][0] += count
            dp[num][1] += all_sum
            res += all_sum
            res = res % MOD
        return res
    
    ## [10,10,1,9] 68",1448216048
Anupam Shah,user9218i,339,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        if(k == 1)  return 1;
        for(int i = 0; i <= nums.size() - k - k; i ++) {
            bool no = 0;
            //cout 
            for(int j = i+1; j < i + k; j ++) {
                if(nums[j] <= nums[j-1])    no = 1;
            }
            for(int j = i+k+1; j < i + k+k; j ++) {
                if(nums[j] <= nums[j-1])    no = 1;
            }
            if(!no)     return 1;
        }
        return 0;
    }
};",1448184654
Anupam Shah,user9218i,339,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> l(n);   vector<int> r(n);
        for(int i = 0; i < nums.size(); i ++) {
            if(!i)  l[i] = 1;
            else    l[i] = (nums[i] > nums[i-1] ? l[i-1] + 1 : 1);
        }
        for(int i = nums.size() - 1; i >= 0; i --) {
            if(i == nums.size() - 1)  r[i] = 1;
            else    r[i] = (nums[i] < nums[i+1] ? r[i+1] + 1 : 1);
        }
        int ans = 0;
        for(int i = 0; i < nums.size() - 1; i ++)
            ans = max(ans, min(l[i], r[i+1]));
        return ans;
    }
};",1448191251
Anupam Shah,user9218i,339,3631,cpp,"class Solution {
public:
    typedef long long int ll;
    ll MOD = 1000000007;
    
    ll digitDP(const string &n, int pos, int count, bool tight, int l, vector<vector<vector<ll>>>& dp) {
        if(count < 0)   return 0;
        
        if (pos == n.size()) {
            return count == 0 ? 1 : 0;
        }
        if (dp[pos][count][tight] != -1) {
            return dp[pos][count][tight];
        }
        int limit = tight ? n[pos] - '0' : 1;
        ll res = 0;
        res += digitDP(n, pos + 1, count, tight && (limit == 0), l, dp);
        if (limit == 1) {
            res += digitDP(n, pos + 1, count - 1, tight, l, dp);
        }
        res %= MOD;
        return dp[pos][count][tight] = res;
    }
    ll countNumbersWithLSetBits(string n, int l, vector<vector<vector<ll>>>& dp) {
        if(l == 0)  return 0;
        return digitDP(n, 0, l, true, l, dp);
    }
    
    int go(int n, int k, vector<vector<int>>& dp) {
        if(k < 0)   return 0;
        if(k == 0)  return n == 1;
        if(dp[n][k] != -1)  return dp[n][k];
        
        return dp[n][k] = go(__builtin_popcount(n), k-1, dp);
    }
    int countKReducibleNumbers(string s, int k) {
        int n = s.length();
        ll ans = 0;
        
        vector<vector<int>> dp(n+1, vector<int> (k+1, -1));
        vector<vector<vector<ll>>> dp2(n+1, vector<vector<ll>> (n+1, vector<ll> (2, -1)));
        
        for(int i = 1; i <= s.length(); i++) {
            if(go(i, k-1, dp)) {
                //cout << i << endl;
                ans += countNumbersWithLSetBits(s, i, dp2);
                ans %= MOD;
            }
        }
        
        int b = 0;
        for(int i = 0; i < s.length(); i ++)    b += (s[i] - '0');
        k --;
        while(k --) {
            b = __builtin_popcount(b);
        }
        if(b == 1)      ans = (ans - 1 + MOD)%MOD;
        
        return ans;
    }
};

/*
""10""
2

*/
    ",1448269070
Anupam Shah,user9218i,339,3646,cpp,"class Solution {
public:
    typedef long long ll;
    ll MOD = 1000000007;
    int sumOfGoodSubsequences(vector<int>& nums) {
        vector<pair<ll,ll>> dp;
        for(int i = 0; i <= 1e5 + 2; i ++)  dp.push_back({0, 0});
        
        ll ans = 0;
        for(int i = nums.size() - 1; i >= 0; i --) {
            
            ll l = nums[i] - 1, r = nums[i] + 1;
            ll s = 0, f = 0;
            
            s += (ll)dp[r].second + (ll)((ll)nums[i] * (ll)dp[r].first);
            f += (ll)dp[r].first;
            
            s %= MOD, f %= MOD;
            
            if(l >= 0) {
                s += (ll)dp[l].second + (ll)((ll)nums[i] * (ll)dp[l].first);
                f += (ll)dp[l].first;
            }
            s %= MOD, f %= MOD;
            s += (ll)nums[i];   f ++;
            s %= MOD, f %= MOD;
            
            dp[nums[i]].first +=  f, dp[nums[i]].second +=  s, 
            dp[nums[i]].first %= MOD, dp[nums[i]].second %= MOD;
            ans += s;
            ans %= MOD;
        }
        return (int)ans;
    }
};",1448237719
Kartik Garg,Kartik_garg163,340,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> idx(n,1);
        idx[n-1] = 1;
        for(int i=n-2; i>=0; i--){
            // int cnt = 1;
            // while(i >= 0 && nums[i] < nums[i+1]){
            //     cnt++;
            //     idx[i] = cnt;
            //     i--;
            // }
            // idx[i] = cnt;
            if(nums[i+1] > nums[i]){
                idx[i] += idx[i+1];
            }
        }
        int ans = 0;
        for(int i=0; i<n; i++){
            int val = idx[i]/2;
            if(val == k){
                return true;
            }
            if(i+idx[i] < n){
                if(idx[i+idx[i]] >= idx[i]){
                    if(idx[i] == k){
                        return true;
                    }
                }
            }
        }
        return false;
        
    }
};",1448202501
Kartik Garg,Kartik_garg163,340,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> idx(n,1);
        idx[n-1] = 1;
        for(int i=n-2; i>=0; i--){
            // int cnt = 1;
            // while(i >= 0 && nums[i] < nums[i+1]){
            //     cnt++;
            //     idx[i] = cnt;
            //     i--;
            // }
            // idx[i] = cnt;
            if(nums[i+1] > nums[i]){
                idx[i] += idx[i+1];
            }
        }
        int ans = 0;
        for(int i=0; i<n; i++){
            ans = max(ans,idx[i]/2);
            if(i+idx[i] < n){
                if(idx[i+idx[i]] >= idx[i]){
                    ans = max(ans, idx[i]);
                }
            }
        }
        return ans;
    }
};",1448198984
Kartik Garg,Kartik_garg163,340,3631,cpp,"class Solution {
public:
    const long long N = 802;
    long long mod_power(long long a, long long b, long long mod){
        if(b == 0){
            return 1;
        }
        long long x = mod_power(a, b/2, mod);
        if(b % 2 == 0){
            return (x * x) % mod;
        }
        else{
            long long y = (x * x) % mod;
            y = (y * a) % mod;
            return y;
        }
    }

    long long inverse(long long a, long long mod){
        return mod_power(a, mod - 2, mod);
    }
    vector<long long> factorial;
    void fac(long long mod){
        factorial.resize(N);
    	factorial[0] = 1;
    	for(long long i=1; i<N; i++){
    		factorial[i] = factorial[i-1] * i % mod;
    	}
    }
    long long combination(long long n, long long r, long long mod){
    	long long num1 = factorial[n];
    	long long num2 = factorial[r];
    	long long num3 = factorial[n-r];
    	long long num4 = num2 * num3 % mod;
    	long long ans = num1 * inverse(num4,mod) % mod;
    	return ans;
    }
    int countKReducibleNumbers(string s, int k) {
        int n = s.length();
        map<int,long long> cnt;
        for(int i=1; i<=n; i++){
            int num = i;
            long long count = 1;
            bool ok = true;
            while(num != 1){
                num = __builtin_popcount(num);
                count++;
                if(count > k){
                    ok = false;
                    break;
                }
            }
            if(ok){
                cnt[i] = count;
            }
            // cout<<cnt[i]<<endl;
        }
        long long mod = 1e9 + 7;
        fac(mod);
        long long ans = 0;
        for(int i=1; i<n; i++){
            for(int j=i-1; j>=0; j--){
                if(cnt[j+1] > 0){
                    long long val = combination(i-1,j,mod);
                    ans = (ans + val) % mod;
                    // cout<<i<<"" ""<<j<<"" ""<<ans<<endl;
                }
            }
        }
        long long h = 1;
        for(int f=1; f<n; f++){
            if(s[f] == '1'){
                int d = n - f - 1;
                // for(int i=1; i<n; i++){
                    for(int j=d; j>=0; j--){
                        if(cnt[j+h] > 0){
                            long long val = combination(d,j,mod);
                            ans = (ans + val) % mod;
                            // cout<<i<<"" ""<<j<<"" ""<<ans<<endl;
                        }
                    }
                // }
                h++;
            }
        }
        return ans;
    }
};",1448296043
Kartik Garg,Kartik_garg163,340,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        map<int,long long> mp;
        map<int,long long> sum;
        long long ans = 0;
        long long mod = 1e9 + 7;
        for(int i=0; i<nums.size(); i++){
            mp[nums[i]] += 1;
            sum[nums[i]] = (sum[nums[i]] + nums[i]) % mod;
            ans = (ans + nums[i]) % mod;
            int num1 = nums[i]-1;
            int num2 = nums[i] + 1;
            long long val1 = (sum[num1]+(mp[num1]*nums[i]%mod)%mod);
            long long val2 = (sum[num2]+(mp[num2]*nums[i]%mod)%mod);
            mp[nums[i]] = (mp[nums[i]] + mp[num1]) % mod;
            mp[nums[i]] = (mp[nums[i]] + mp[num2]) % mod;
            sum[nums[i]] = ((sum[nums[i]] + val1) % mod + val2) % mod;
            ans = ((ans + val1) % mod + val2) % mod;
        }
        return ans;
    }
};",1448232910
Chuan-Chih Chou,chuan-chih,344,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        def inc(i):
            return all(b > a for a, b in pairwise(nums[i:i+k]))
        n = len(nums)
        for i in range(n):
            if i + 2 * k <= n and inc(i) and inc(i + k):
                return True
        return False",1448183200
Chuan-Chih Chou,chuan-chih,344,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        longest = [1] * n
        l = 0
        prev = -inf
        for r, curr in enumerate(nums):
            if curr <= prev:
                longest[l:r] = reversed(range(1, 1 + r - l))
                l = r
            prev = curr
        r = n
        longest[l:r] = reversed(range(1, 1 + r - l))
        # print(longest)
        def check(k):
            for i in range(n - 2 * k + 1):
                if longest[i] >= k and longest[i + k] >= k:
                    return True
            return False
        low = 1
        high = n // 2
        while low < high:
            mid = (low + high + 1) // 2
            if check(mid):
                low = mid
            else:
                high = mid - 1
        return low
",1448210963
Chuan-Chih Chou,chuan-chih,344,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        mod = 10 ** 9 + 7
        @cache
        def dp(x):
            if not x:
                return math.inf
            if x == 1:
                return 0
            return 1 + dp(x.bit_count())
        l = [int(d) for d in s]
        n = len(l)
        fac = [1]
        for i in range(1, n + 1):
            fac.append(fac[-1] * i)
            fac[-1] %= mod
        # Count lower bit_length() numbers
        ans = 0
        for length in range(1, n):
            space = length - 1
            for x in range(space + 1):
                if 1 + dp(1 + x) <= k:
                    ans += fac[space] * pow(fac[x], -1, mod) * pow(fac[space - x], -1, mod)
                    ans %= mod
        # Scan left-right, count numbers with prefix
        acc = 1
        for i in range(1, n):
            bit = l[i]
            if bit:
                space = n - i - 1
                for x in range(space + 1):
                    if 1 + dp(acc + x) <= k:
                        ans += fac[space] * pow(fac[x], -1, mod) * pow(fac[space - x], -1, mod)
                        ans %= mod
                acc += 1
        return ans
            
        
            ",1448284083
Chuan-Chih Chou,chuan-chih,344,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        mod = 10 ** 9 + 7
        max_v = max(nums)
        count = [0] * (max_v + 1)
        total = [0] * (max_v + 1)
        for x in nums:
            new = x
            c = 1
            if x - 1 >= 0:
                new += total[x - 1] + x * count[x - 1]
                c += count[x - 1]
            if x + 1 < len(count):
                new += total[x + 1] + x * count[x + 1]
                c += count[x + 1]
            total[x] += new
            total[x] %= mod
            count[x] += c
            count[x] %= mod
        return sum(total) % mod",1448233384
Maruzensky,Maruzensky,346,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        
        for i in range(n - 2 * k + 1):
            left, right = nums[i: i + k], nums[i + k: i + 2 * k]
            if all(x < y for x, y in zip(left, left[1:])) and all(x < y for x, y in zip(right, right[1:])):
                return True
            
        return False",1448182090
Maruzensky,Maruzensky,346,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        
        is_increasing = [(x < y) for x, y in zip(nums, nums[1:])]
        is_false = [i for i in range(n - 1) if is_increasing[i] is False]
        
        gaps = [y - x for x, y in zip([-1] + is_false, is_false + [n - 1])]
        
        if len(gaps) == 1:
            return gaps[0] // 2
        
        return max(max(gaps) // 2, max(min(x, y) for x, y in zip(gaps, gaps[1:])))",1448190305
Maruzensky,Maruzensky,346,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        def power(p, x, e):
            base = x
            answer = 1
            while e:
                if e & 1:
                    answer = (answer * base) % p

                base = (base * base) % p
                e >>= 1

            return answer


        def inv(p, x):
            return power(p, x, p - 2)
        
        
        def hamming(x):
            answer = 0
            while x:
                b = x & (-x)
                x -= b
                answer += 1

            return answer
        

        times = [[] for _ in range(15)]

        for v in range(1, 901):
            temp = v
            i = 0
            while temp > 1:
                i += 1
                temp = hamming(temp)

            times[i].append(v)
            
        n = len(s)
        mod = 10**9 + 7
        want = []
        for t in times[:k]:
            want.extend(t)

        fact = [1]
        inv_fact = [1]
        for x in range(1, 1000):
            inv_x = inv(mod, x)
            fact.append((fact[-1] * x) % mod)
            inv_fact.append((inv_fact[-1] * inv_x) % mod)
            
            
        def choose(x, y):
            if y > x or y < 0:
                return 0
            return (fact[x] * inv_fact[y] * inv_fact[x - y]) % mod
        
        
        def count(b):
            answer = 0
            for i, c in enumerate(s):
                if c == '1':
                    answer += choose(n - 1 - i, b)
                    b -= 1
                    
            return answer % mod
        
        return sum(count(b) for b in want) % mod

",1448263425
Maruzensky,Maruzensky,346,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        # nums = [x + 2 for x in nums]
        mod = 10**9 + 7
        m = max(nums)
        
        assert m < 10**6
        
        left = [0]
        seen = [0] * (m + 3)
        seen[nums[0]] = 1
        
        for x in nums[1:]:
            how = seen[x - 1] + seen[x + 1]
            left.append(how)
            seen[x] += how + 1
            seen[x] %= mod
            
        right = [0]
        seen = [0] * (m + 3)
        seen[nums[-1]] = 1
        
        for x in nums[:-1][::-1]:
            how = seen[x - 1] + seen[x + 1]
            right.append(how)
            seen[x] += how + 1
            seen[x] %= mod
            
        right = right[::-1]
        
        answer = 0
        for l, r, x in zip(left, right, nums):
            answer += (l + 1) * (r + 1) * x
            answer %= mod
            
        return answer
",1448226707
Rishabh Tiwari,rishabhtwr07,347,3612,java,"class Solution {
    int n;
    
    int dp[];
    private boolean fnc(int x) {
        for(int i = 0; i < n; ++i) {
            if(i + x >= n)
                break;
            if(dp[i] >= x && dp[i + x] >= x)
                return true;
        }
        return false;
    }
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        n = nums.size();
        dp = new int[n];
        Arrays.fill(dp, 1);
        for(int i = n - 2; i >= 0; --i) {
            if(nums.get(i) < nums.get(i + 1)) 
                dp[i] = 1 + dp[i + 1];
        }
        return fnc(k);
    }
}

",1448191640
Rishabh Tiwari,rishabhtwr07,347,3619,java,"class Solution {
    int n;
    
    int dp[];

    private boolean fnc(int x) {
        for(int i = 0; i < n; ++i) {
            if(i + x >= n)
                break;
            if(dp[i] >= x && dp[i + x] >= x)
                return true;
        }
        return false;
    }
    public int maxIncreasingSubarrays(List<Integer> nums) {
        n = nums.size();
        
        int l = 1;
        int r = n / 2, mid;
        dp = new int[n];
        Arrays.fill(dp, 1);

        for(int i = n - 2; i >= 0; --i) {
            if(nums.get(i) < nums.get(i + 1)) 
                dp[i] = 1 + dp[i + 1];
        }

        while(r - l > 1) {
            mid = (l + r) / 2;
            //System.out.println(l + "" "" + r + "" "" + mid);
            if(fnc(mid)) {
                l = mid;
            } else {
                r = mid - 1;
            }
        }
        if(fnc(r)) {
            return r;
        }
        return l;
    }
}",1448188869
Rishabh Tiwari,rishabhtwr07,347,3631,java,"class Solution {
    boolean precom[][];
    int n;
    String str;
    int k;
    static final int MOD = 1000000007;
    private int bits(int x) {
        int ret = 0;
        while(x > 0) {
            if((x % 2) == 1)
                ret++;
            x /= 2;
        }
        return ret;
    }
    
    private void precompute(int x) {
        for(int i = 1; i <= x; ++i) {
            precom[0][i] = true;
            precom[1][i] = true;
        }

        precom[0][0] = true;
        precom[1][0] = false;
        for(int i = 2; i <= n; ++i) {
            for(int j = 0; j <= x; ++j) {
                if(j == 0)
                    precom[i][0] = false;
                else {
                    precom[i][j] = precom[bits(i)][j - 1];
                }
            }         
        }
        // for(int i = 0; i <= n; ++i) {
        //     System.out.println(i + "" "" + precom[i][k]);
        // }
    }

    long dp[][][];

    private long fnc(int x, int y, int z) {
        if(x == n) {
            if(z == 0)
                return 0L;
            return precom[y][k] ? 1L: 0L;
        }
        if(dp[x][y][z] != -1)
            return dp[x][y][z];
        dp[x][y][z] = 0L;
        int bitVal = (str.charAt(x) == '1' ? 1: 0);
       
        // Same bit
        dp[x][y][z] = fnc(x + 1, y + bitVal, z);
        dp[x][y][z] %= MOD;
        
        //flip
        if(bitVal == 1)
            dp[x][y][z] += fnc(x + 1, y, 1);
        else if(z == 1) {
            dp[x][y][z] += fnc(x + 1, y + 1, 1);
        }

        dp[x][y][z] %= MOD;
       // System.out.println(x + "" "" + y + "" "" + z + "" "" + dp[x][y][z]);
        return dp[x][y][z];
    }
    
    public int countKReducibleNumbers(String s, int k) {
        this.k = k;
        n = s.length();
        precom = new boolean[n + 1][k + 1];
        str = s;
        precompute(k);
        dp = new long[n + 1][n + 1][2];
        for(int i = 0; i < n; ++i) {
            for(int j = 0; j < n; ++j) {
                Arrays.fill(dp[i][j], -1);
            }
        }
        long ans = fnc(0, 0, 0) - 1 + MOD;
        ans %= MOD;
        return (int)ans;
    }
}",1448277391
Rishabh Tiwari,rishabhtwr07,347,3646,java,"class Solution {
    static final int MOD = 1000000007;
    public int sumOfGoodSubsequences(int[] nums) {
        int n = nums.length, x;

        long dp[] = new long[100005];
        Arrays.fill(dp, 0L);
        long subs[] = new long [100005];
        Arrays.fill(subs, 0L);

        long ret = 0L;
        long val, tmp;
        for(int i = n - 1; i >= 0; --i) {
            x = nums[i];
            tmp = 1L + subs[x + 1];
            tmp %= MOD;
            if(x != 0)
                tmp += subs[x - 1];
            tmp %= MOD;
            val = tmp * (long)x;
            val %= MOD;
            val += dp[x + 1];
            val %= MOD;
            if(x != 0)
                val += dp[x - 1];
            val %= MOD;
            
            //System.out.println(i + "" "" + x + "" "" + val);
            ret += val;
            ret %= MOD;
            dp[x] += val;
            dp[x] %= MOD;
            subs[x] += 1L;
            subs[x] %= MOD;
            subs[x] += subs[x + 1];
            subs[x] %= MOD;
            if(x != 0)
                subs[x] += subs[x - 1];
            subs[x] %= MOD;
        }

        return (int)ret;
    }
}",1448238980
Armaan,Armaan48,349,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        for (int i=0;i + 2*k<=n;i++){
            int tans = true;
            for (int j=i+1;j<i+k;j++){
                if (nums[j] <= nums[j - 1])
                    tans = false;
            }
            for (int j=i+k+1;j<i+2*k;j++){
                if (nums[j] <= nums[j-1])
                        tans = false;
            }
            if (tans)
                    return true;
        }
        return false;
    }
}; ",1448185125
Armaan,Armaan48,349,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        int i = 0;
        vector<int> ans;
        int val = 0;

        while (i<n){
            int j = i + 1;
            while(j<n and nums[j] > nums[j-1])
                j++;
            val = max(val , (j - i)/2);
            ans.push_back((j-i));
            i= j ;
        }
        for (int i=1;i<ans.size();i++)
            val = max(val ,min(ans[i],ans[i-1]));
        return val;
    }
};",1448198435
Armaan,Armaan48,349,3631,cpp,"class Solution {
public:
    vector<vector<vector<long long>>> dp;
    string s;
    int n,k;
    vector<long long> help;

    long long mod;
    Solution(){
        mod = 1000000007;
    }
    long long reduce(int a){
        if (help[a]!=-1)
                return help[a];
        if (a <= 1)
                return help[a] = 0;
        int cnt =0 ;
        for (int bit=30;bit>=0;bit--){
            cnt += ((a&(1ll<<bit))!=0);
        }
        return help[a] =  1+ reduce(cnt);
    }
    string path;
    long long solve(int i,int j,int f){
        if (i == n){
            return (j and   1+reduce(j)<=k and f);
        }
    long long  &ans = dp[i][j][f];
        if (ans!=-1)
                return ans;
        ans = 0;
        ans = solve(i + 1, j + (s[i] == '1') , f);
        if (s[i]=='1' or f == 1){
            ans = (ans + solve(i + 1 ,  j + (s[i] == '0') , f || (s[i] == '1')))%mod;
        }
        return ans;
    }
    int countKReducibleNumbers(string S, int K) {
        s = S;
        n = s.size();
        k = K;
        help = vector<long long> (801, -1);
        dp = vector<vector<vector<long long>>> ( n , vector<vector<long long>>( n  + 1,vector<long long> (2, -1)));
        return solve( 0 ,0 , 0);
    }
};",1448277503
Armaan,Armaan48,349,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int n = nums.size();
        map<int,pair<long long,long long>> dp;
        long long mod = 1000000007;
        for (int i=n-1;i>=0;i--){
            long long prv = dp[nums[i]].first;
            dp[nums[i]].first++;
            if (dp.count(nums[i] + 1)){
                dp[nums[i]].second = (dp[nums[i]].second +  dp[nums[i] + 1].second)%mod ; 
                dp[nums[i]].first = (dp[nums[i]].first  + dp[nums[i]+1].first)%mod;
            }
            if (dp.count(nums[i] - 1)){
                dp[nums[i]].second = (dp[nums[i]].second + dp[nums[i] - 1].second)%mod ;
                dp[nums[i]].first = (dp[nums[i]].first + dp[nums[i]-1].first)%mod;
                
            }
            dp[nums[i]].second = (dp[nums[i]].second + (dp[nums[i]].first - prv + mod) * nums[i]%mod)%mod;
        }
long long sum = 0;
        for (auto v: dp){
                sum = (sum + v.second.second)%mod;
        }
        return sum;
        
    }
};",1448230403
Peter Lin,inversionpeter,351,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        if (k == 1) {
            return true;
        }
        bool increasing;
        for (int i = 0; i <= nums.size() - (k << 1); ++i) {
            increasing = true;
            for (int j = i + 1; j < i + k; ++j) {
                if (nums[j - 1] >= nums[j]) {
                    increasing = false;
                    break;
                }
            }
            if (increasing) {
                for (int j = i + k + 1; j < i + (k << 1); ++j) {
                    if (nums[j - 1] >= nums[j]) {
                        increasing = false;
                        break;
                    }
                }
                if (increasing) {
                    return true;
                }
            }
        }
        return false;
    }
};",1448183887
Peter Lin,inversionpeter,351,3619,cpp,"int longests[200000];

class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int length = nums.size(), maximum = 0;
        longests[length - 1] = 1;
        for (int i = length - 2; i >= 0; --i) {
            if (nums[i] < nums[i + 1]) {
                longests[i] = longests[i + 1] + 1;
            }
            else {
                longests[i] = 1;
            }
        }
        for (int i = 0; i < length; ++i) {
            maximum = max(maximum, longests[i] >> 1);
            if (i + longests[i] < length) {
                maximum = max(maximum, min(longests[i], longests[i + longests[i]]));
            }
        }
        return maximum;
    }
};",1448192898
Peter Lin,inversionpeter,351,3631,cpp,"#define MOD 1000000007

int lookup[801], DP[801][801][2];

const static auto Initialize = []{
    ios::sync_with_stdio(false); cin.tie(nullptr);
    lookup[1] = 0;
    for (int i = 2, c; i <= 800; ++i) {
        c = 0;
        for (int j = 0; j < 10; ++j) {
            if (i & (1 << j)) {
                ++c;
            }
        }
        lookup[i] = lookup[c] + 1;
    }
    DP[1][0][0] = 1;
    DP[1][1][1] = 1;
    for (int i = 2; i <= 800; ++i) {
        DP[i][0][0] = 1;
        for (int j = 1; j <= i; ++j) {
            DP[i][j][0] = (DP[i - 1][j][0] + DP[i - 1][j][1]) % MOD;
            DP[i][j][1] = (DP[i - 1][j - 1][0] + DP[i - 1][j - 1][1]) % MOD;
        }
    }
    return nullptr;
}();

class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        int length = s.size(), counts = 0, ones = 1;
        for (int i = 1; i < length; ++i) {
            for (int j = 1; j <= i; ++j) {
                if (lookup[j] + (i > 1) <= k) {
                    counts += DP[i][j][1];
                    //cout << i << ' ' << j << ' ' << DP[i][j][1] << '\n';
                    if (counts >= MOD) {
                        counts -= MOD;
                    }
                }
            }
        }
        for (int i = 1; i < length; ++i) {
            if (s[i] == '1') {
                for (int j = 0; j <= length - i; ++j) {
                    if (lookup[j + ones] + 1 <= k) {
                        counts += DP[length - i][j][0];
                        if (counts >= MOD) {
                            counts -= MOD;
                        }
                    }
                }
                ++ones;
            }
        }
        return counts;
    }
};

// ""101011"" 3 -> 42?",1448285087
Peter Lin,inversionpeter,351,3646,cpp,"#define MOD 1000000007
int DP1[100005], DP2[100005];

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int total = 0, bound = 0;
        memset(DP1, 0, sizeof(DP1));
        memset(DP2, 0, sizeof(DP2));
        for (int i : nums) {
            if (!i) {
                DP1[0] = (DP1[0] + DP1[1] + 1) % MOD;
                DP2[0] = (DP2[0] + DP2[1]) % MOD;
            }
            else {
                DP1[i] = ((long long)DP1[i] + DP1[i + 1] + DP1[i - 1] + 1) % MOD;
                DP2[i] = ((long long)DP2[i] + (DP2[i + 1] + (long long)DP1[i + 1] * i) + (DP2[i - 1] + (long long)DP1[i - 1] * i) + i) % MOD;
            }
            bound = max(bound, i);
        }
        for (int i = 0; i <= bound; ++i) {
            total += DP2[i];
            if (total >= MOD) {
                total -= MOD;
            }
        }
        return total;
    }
};",1448216165
tranphuc8a,tranphuc8a,352,3612,cpp,"

class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> dp(n + 1, -1);
        for (int i = n - 1; i >= 0; i--){
            dp[i] = i;
            if (i + 1 < n && nums[i] < nums[i + 1]){
                dp[i] = dp[i + 1];
            } 
            if (dp[i] - i + 1 >= k){
                int next = i + k;
                if (dp[next] - next + 1 >= k) return 1;
            }
        }
        return 0;
    }
};",1448185756
tranphuc8a,tranphuc8a,352,3619,cpp,"

class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp(n + 1, -1);
        int res = 0;
        for (int i = n - 1; i >= 0; i--){
            dp[i] = i;
            if (i + 1 < n && nums[i] < nums[i + 1]){
                dp[i] = dp[i + 1];
            } 
            int next = dp[i] + 1;
            res = max(res, (dp[i] - i + 1)/2);
            if (next < n){
                res = max(res, min(dp[i] - i + 1, dp[next] - next + 1));
            }
        }
        // for (int i = 0; i < n; i++){
        //     cout << dp[i] << "" "";
        // }
        // cout << endl;
        return res;
    }
};
",1448216666
tranphuc8a,tranphuc8a,352,3631,cpp,"
const int mod = 1e9 + 7;
const int MAX = 800;

class Solution {
public:

	int cntBitOne(int n){
		int res = 0;
		while (n) {
			res += (n & 1);
			n >>= 1;
		}
		return res;
	}

    int countKReducibleNumbers(string s, int k) {
        int n = s.size();
        vector<int> red(n + 1, 1);
        for (int i = 2; i <= n; i++){
        	red[i] = 1 + red[cntBitOne(i)];
        }
        // for (int i = 0; i <= n; i++){
        // 	cout << red[i] << "" "";
        // }
        // cout << endl;
        if (s == ""1"") return 0;


        vector<int> acceptCntSetBit(n + 1, 0);
        for (int i = 1; i <= n; i++) {
        	if (red[i] <= k){
        		acceptCntSetBit[i] = 1;
        	}
        }


        vector<vector<vector<int>>> dp(n + 2, vector<vector<int>>(2, vector<int>(n + 1, 0)));
        dp[n][0][0] = 1;

        for (int i = n - 1; i >= 0; i--){
        	for (int tight = 0; tight < 2; tight++){
        		for (int cntBit = 0; cntBit <= n; cntBit++){
        			if (tight){
        				if (s[i] == '0'){
        					dp[i][tight][cntBit] = dp[i + 1][tight][cntBit];
        				} else {
        					dp[i][tight][cntBit] = dp[i + 1][0][cntBit];
        					if (cntBit > 0){
        						dp[i][tight][cntBit] = (dp[i][tight][cntBit] + 0ll + dp[i + 1][tight][cntBit - 1]) % mod;
        					}
        				}
        			} else {
        				dp[i][tight][cntBit] = dp[i + 1][tight][cntBit];
        				if (cntBit > 0){
        					dp[i][tight][cntBit] = (dp[i][tight][cntBit] + dp[i + 1][tight][cntBit - 1]) % mod;
        				}
        			}
        		}
        	}
        }

        int res = 0;
        for (int cntBit = 0; cntBit <= n; cntBit++){
        	if (acceptCntSetBit[cntBit]){
        		res = (res + 0ll + dp[0][1][cntBit]) % mod;
        	}
        }

        return res;
    }
};

",1448291938
tranphuc8a,tranphuc8a,352,3646,cpp,"
const int mod = 1e9 + 7;
const int MAX = 1e5;

int lft[MAX + 1] = {}, rgt[MAX + 1] = {};

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int n = nums.size();
        map<int, int> cntLeft, cntRight;
        fill(lft, lft + n, 0);
        fill(rgt, rgt + n, 0);
        for (int i = 0; i < n; i++){
            int add = (1ll + cntLeft[nums[i] - 1] + cntLeft[nums[i] + 1]) % mod;
            lft[i] = add;
            cntLeft[nums[i]] = (cntLeft[nums[i]] + add) % mod;
        }
        for (int i = n - 1; i >= 0; i--){
            int add = (1ll + cntRight[nums[i] - 1] + cntRight[nums[i] + 1]) % mod;
            rgt[i] = add;
            cntRight[nums[i]] = (cntRight[nums[i]] + add) % mod;
        }

        int res = 0;
        for (int i = 0; i < n; i++){
            int mult = lft[i] * 1ll * rgt[i] % mod;
            res = (res + nums[i] * 1ll * mult) % mod;
        }
        return res;
    }
};",1448246296
Akshayan M,AKXYN,353,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n=len(nums)
        for i in range(n-2*k+1):
            flag=False
            for j in range(i+1,i+k):
                if nums[j]<=nums[j-1]: 
                    flag=True
                    break
            for j in range(i+k+1,i+2*k):
                if nums[j]<=nums[j-1]: 
                    flag=True
                    break
            if not flag: return True
        return False",1448229193
Akshayan M,AKXYN,353,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        left=[]
        right=[]
        prev=-1
        streak=0
        for e in nums:
            if e>prev: streak+=1
            else: streak=1
            left.append(streak)
            prev=e
        prev=float('inf')
        streak=0
        for e in nums[::-1]:
            if e<prev: streak+=1
            else: streak=1
            right.append(streak)
            prev=e
        right.reverse()
        res=0
        n=len(nums)
        # print(left)
        # print(right)
        for i in range(n-1):
            res=max(res,min(left[i],right[i+1]))
        return res
                ",1448239999
Akshayan M,AKXYN,353,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        dp=[0]
        for i in range(1,801):
            j=i
            for _ in range(k-1):
                j=bin(j).count('1')
            dp.append(int(j==1))
        # print(dp[:10])
        n=len(s)
        mod=10**9+7
        @cache
        def solve(i,equal,tot):
            if i==n: return dp[tot] if not equal else 0
            res=solve(i+1,equal and s[i]=='0',tot)
            if not equal or s[i]=='1': res+=solve(i+1,equal and s[i]=='1',tot+1)
            return res%mod
        return solve(0,1,0)
            ",1448292592
Akshayan M,AKXYN,353,3646,python3,"from bisect import bisect_right
class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        data=defaultdict(list)
        for i,e in enumerate(nums):
            data[e].append(i)
        
        mod=10**9+7
        
        @cache
        def count(i):
            res=1
            ref=data[nums[i]]
            j=bisect_right(ref,i)
            if j<len(ref): res+=count(ref[j])
                
            ref=data[nums[i]+1]
            j=bisect_right(ref,i)
            if j<len(ref): res+=count(ref[j])
            
            ref=data[nums[i]-1]
            j=bisect_right(ref,i)
            if j<len(ref): res+=count(ref[j])
            
            return res
        
        @cache
        def solve(i):
            res=nums[i]
            ref=data[nums[i]]
            j=bisect_right(ref,i)
            if j<len(ref): res+=solve(ref[j])
                
            ref=data[nums[i]+1]
            j=bisect_right(ref,i)
            if j<len(ref): res+=count(ref[j])*nums[i]+solve(ref[j])
            
            ref=data[nums[i]-1]
            j=bisect_right(ref,i)
            if j<len(ref): res+=count(ref[j])*nums[i]+solve(ref[j])
            
            return res%mod
        
        s=set()
        res=0
        for i,e in enumerate(nums):
            if e not in s:
                res+=solve(i)
                s.add(e)
                res%=mod
        return res
            ",1448273615
Vladislav,timetoai,355,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        inc = [1] * len(nums)
        acc = 1
        for i in range(1, len(nums)):
            if nums[i] > nums[i - 1]:
                acc += 1
            else:
                acc = 1
            inc[i] = acc
        for i in range(k - 1, len(nums) - k):
            if inc[i] >= k and inc[i + k] >= k:
                return True
        return False
        ",1448183568
Vladislav,timetoai,355,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        inc = []
        acc = 1
        for i in range(1, len(nums)):
            if nums[i] > nums[i - 1]:
                acc += 1
            else:
                inc.append(acc)
                acc = 1
        inc.append(acc)
        ret = max(1, inc[0] // 2)
        for i in range(1, len(inc)):
            ret = max(ret, min(inc[i], inc[i - 1]), inc[i] // 2)
        return ret
        ",1448192356
Vladislav,timetoai,355,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        mod = 10 ** 9 + 7
        n = len(s)
        # 0op: 1
        # 1op: any 1-bit (excluding 1) [2, 4, 8, 16 ...]
        # 2op: any i-bit (excluding i = 1), where i in 1op res [3, 5, 6 ...]
        # 3op: any i1-bit (excluding i1 э i), where i1 in 2op res
        left_ones = [""1"" == s[i] for i in range(n)]
        for i in range(n - 2, - 1, - 1):
            left_ones[i] += left_ones[i + 1]

        def combn(bits):
            opts = {bits - 1: 1}  # left: cnt
            tot = 0
            for i in range(1, n):
                nxt = defaultdict(int)
                for left, cnt in opts.items():
                    if left == 0:
                        if left_ones[i] > 0:
                            tot = (tot + cnt) % mod
                        continue
                    if s[i] == ""0"":
                        nxt[left] += cnt
                    else:
                        nxt[left - 1] += cnt
                        tot = (tot + math.comb(n - i - 1, left)) % mod
                opts = nxt
            return tot

        # def combinationsn(bits):
        #     cur = {(n, bits - 1)}
        #     for i in range(1, n):
        #         nxt = set()
        #         for ss, left in cur:
        #             if left == 0:
        #                 yield ss + (n - i) * ""0""
        #                 continue
        #             if s[i] == ""0"":
        #                 nxt.add((ss + ""0"", left))
        #             else:
        #                 nxt.add((ss + ""1"", left - 1))
                        
        #         cur = nxt
        #     for ss, left in cur:
        #         if left == 0:
        #             yield ss
        
        used = {1}
        cur = [1]
        ret = 0
        for ki in range(k):
            nxt = []
            for i in cur:
                # print(i, comb(n - 1, i), combn(i))
                ret = (ret + math.comb(n - 1, i) % mod + combn(i) % mod) % mod
                for bit_poses in combinations(range(min(10, n - 1)), i):
                    ni = sum(1 << b for b in bit_poses)
                    if ni not in used:
                        nxt.append(ni)
                        used.add(ni)
                # for bit_poses in combinationsn(i):
                #     ni = sum(1 << b for b in bit_poses)
                #     if ni not in used:
                #         nxt.append(ni)
                #         used.add(ni)
            cur = nxt
        return ret
        ",1448286757
Vladislav,timetoai,355,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        mod = 10 ** 9 + 7
        end = defaultdict(int)
        cnt = defaultdict(int)
        ret = 0
        for num in nums:
            cur_cnt = cnt[num - 1] + cnt[num + 1] + 1
            cur = (end[num - 1] + num * cur_cnt + end[num + 1]) % mod
            ret = (ret + cur) % mod
            end[num] = (end[num] + cur) % mod
            cnt[num] += cur_cnt
        return ret
        ",1448200864
Rad0miR,Rad0miR,357,3612,csharp,"public class Solution {
    public bool HasIncreasingSubarrays(IList<int> nums, int k) {
        List<int> temp = new();
        int prev = Int32.MinValue, cnt = 0;
        foreach (int x in nums) 
        {
            if (x <= prev) 
            {
                temp.Add(cnt);
                prev = x;
                cnt = 1;
                continue;
            }

            prev = x;
            cnt++;
        }
        temp.Add(cnt);

        int ans = temp.Max() / 2;

        if (temp.Count > 1) 
            ans = Math.Max(ans, temp.Zip(temp.Skip(1), (f, s) => Math.Min(f, s)).Max());

        return ans >= k;
    }
}",1448190848
Rad0miR,Rad0miR,357,3619,csharp,"public class Solution {
    public int MaxIncreasingSubarrays(IList<int> nums) 
    {
        List<int> temp = new();
        int prev = Int32.MinValue, cnt = 0;
        foreach (int x in nums) 
        {
            if (x <= prev) 
            {
                temp.Add(cnt);
                prev = x;
                cnt = 1;
                continue;
            }

            prev = x;
            cnt++;
        }
        temp.Add(cnt);

        int ans = temp.Max() / 2;

        if (temp.Count > 1) 
            ans = Math.Max(ans, temp.Zip(temp.Skip(1), (f, s) => Math.Min(f, s)).Max());
        
        return ans;
    }
}",1448189493
Rad0miR,Rad0miR,357,3631,csharp,"public class Solution {
    public int CountKReducibleNumbers(string s, int k) 
    {
        int[] ops = new int[801];
        for (int i = 1; i <= 800; ++i) 
        {
            int x = i;
            while (x > 1) 
            {
                ops[i]++;
                x = BitOperations.PopCount((uint)x);
            }
        }

        //Console.WriteLine(String.Join(' ', ops));

        List<int> good = Enumerable.Range(1, 800).Where(i => ops[i] + 1 <= k).ToList();

        //Console.WriteLine(String.Join(' ', good));
        
        Dictionary<(int, int), long> dp = new();

        const int mod = 1_000_000_007;
        long ans = 0;

        int bits = 0;
        for(int i = 0; i < s.Length; ++i) 
        {
            if (s[i] == '0') continue;

            ++bits;
            foreach (int val in good) 
            {
                //Console.WriteLine($""{i} {val} {s.Length - i - 1} {val - bits + 1} {C(s.Length - i - 1, val - bits + 1)}"");
                ans += C(s.Length - i - 1, val - bits + 1);
                ans %= mod;
            }
        }
        
        return (int) ans;

        long C(int n, int k) 
        {
            if (k > n || k < 0) return 0;
            if (n == 0) return k == 0 ? 1 : 0;
            if (k == 0) return 1;
            var key = (n, k);
            if (!dp.ContainsKey(key)) 
            {
                dp[key] = (C(n - 1, k - 1) + C(n - 1, k)) % mod;
            }
            return dp[key];
        }
    }
}
/*
10
01
*/",1448276047
Rad0miR,Rad0miR,357,3646,csharp,"public class Solution 
{
    public int SumOfGoodSubsequences(int[] nums) 
    {
        const int mod = 1_000_000_007;
        long[] sums = new long[100_002];
        long[] cnts = new long[100_002];
        cnts[0] = 0;

        foreach (int x in nums) 
        {
            //if (x == 0) continue;

            sums[x] = Sum3(
                sums[x], 
                Sum(Mult((x == 0 ? 0 :cnts[x - 1]) + 1, x), x == 0 ? 0 :sums[x - 1]),
                Sum(Mult(cnts[x + 1], x), sums[x + 1])
                );
            
            cnts[x] = Sum3(
                cnts[x], 
                (x == 0 ? 0 :cnts[x - 1]) + 1, cnts[x + 1]
                );

            //Console.WriteLine(String.Join(' ', sums.Take(3)));
            //Console.WriteLine(String.Join(' ', cnts.Take(3)));
        }
        
        return (int) (sums.Sum() % mod);

        long Mult(long a, long b) => (a * b) % mod;
        long Sum(long a, long b) => (a + b) % mod;
        long Sum3(long a, long b, long c) => (a + b + c) % mod;
    }
}",1448287032
Skhirtladze,jskhirtladze,359,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int ans=0;
        int cnt=0;
        vector <int> a;
        for (int i=0;i<nums.size();i++)
            if (i==0 || nums[i]<=nums[i-1]) a.push_back(1);
                                       else a[a.size()-1]++;

        for (int i=0;i<a.size();i++) {
            ans=max(ans, a[i]/2);
            if (i) ans=max(ans, min(a[i],a[i-1]));
        }

        return (ans>=k);
    }
};",1448189711
Skhirtladze,jskhirtladze,359,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int ans=0;
        int cnt=0;
        vector <int> a;
        for (int i=0;i<nums.size();i++)
            if (i==0 || nums[i]<=nums[i-1]) a.push_back(1);
                                       else a[a.size()-1]++;

        for (int i=0;i<a.size();i++) {
            ans=max(ans, a[i]/2);
            if (i) ans=max(ans, min(a[i],a[i-1]));
        }
        return ans;
    }
};",1448187426
Skhirtladze,jskhirtladze,359,3631,cpp,"class Solution {
public:

    const static long long M = 1000*1000*1000+7;
    long long C[1000][1000];
    long long occ[1000];

    int bcnt(int x) {
        int cnt=0;
        while (x) {
            cnt+=(x%2);
            x/=2;
        }
        return cnt;
    }

    long long upd(int placed, int need, int space) {
        int ones=need-placed;
        if (ones<0) return 0;
        if (ones>space ) return 0;

        occ[need]+=C[space][ones];
        occ[need]%=M;
        return C[space][ones];
    }

    int countKReducibleNumbers(string s, int k) {

        vector <long long> need(801,0);
        for (int i=2;i<=800;i++)
            need[i]=1+need[bcnt(i)];

        for (int i=0;i<1000;i++)
            for (int j=0;j<=i;j++)
                if (j==0 || j==i)
                    C[i][j]=1;
                else C[i][j]=(C[i-1][j]+C[i-1][j-1])%M;

        int n=s.size();
        int original_cnt=0;
        for (int i=0;i<n;i++)
            if (s[i]=='1') {
                for (int j=1;j<=n;j++)
                    upd(original_cnt, j, n - i - 1);
                original_cnt++;
        }

        long long ans=0;
        for (int j=1;j<=n;j++) {
            if (need[j]+1LL > k) continue;
            ans=(ans+occ[j])%M;
        }
        return ans;
    }
};",1448293952
Skhirtladze,jskhirtladze,359,3646,cpp,"class Solution {
public:

    static const int N=100000+10;
    int sum[N],cnt[N];
    static const long long M=1000*1000*1000+7;
    
    int sumOfGoodSubsequences(vector<int>& nums) {
        long long ans=0;
        for (int i=0;i<nums.size();i++) {
            long long x = nums[i];
            long long a = x > 0 ? sum[x-1] : 0;
            long long acnt = x > 0 ? cnt[x-1] : 0;
            long long b = sum[x+1];
            long long bcnt = cnt[x+1];

            long long allcnt = (acnt+bcnt)%M;
            long long allsum = (a+b)%M;

            long long currcnt=(allcnt+1LL)%M;
            long long currsum=((x*currcnt)%M+allsum)%M;
            
            ans=(ans+currsum)%M;
            cnt[x]+=currcnt; cnt[x]%=M;
            sum[x]+=currsum; sum[x]%=M;
        }
        return ans;
    }
};",1448217853
varous,sourav_suku,360,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n=nums.size();
        for(int i=0;i+k*2<=n;++i){
            int flag=1;
            for(int j=i+1;j<i+k;++j){
                if(nums[j]<=nums[j-1])flag=0;
            }
            for(int j=i+k+1;j<i+k*2;++j){
                if(nums[j]<=nums[j-1])flag=0;
            }
            if(flag)return true;
        }
        return false;
    }
};",1448199996
varous,sourav_suku,360,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n=nums.size();
        vector<int> dp(n);
        int res=1;
        for(int i=n-1;i>=0;--i){
            dp[i]=1;
            if(i+1<n&&nums[i+1]>nums[i])dp[i]+=dp[i+1];
            int ind=i+dp[i];
            int cur=dp[i]/2;
            if(ind<n){
                int val=min(dp[i],dp[ind]);
                cur=max(cur,val);
            }
            res=max(res,cur);
            // cout<<i<<"" ""<<dp[i]<<endl;
        }
        return res;
    }
};",1448245033
varous,sourav_suku,360,3631,cpp,"const long long int M=(int)1e9+7;
#define popcount(x)     __builtin_popcount(x)
#define ll long long
ll dp[805][805][2];
ll dp2[805];
class Solution {
public:
    ll cal(string& s,int ind,int sum,int strict,int k){
        if(ind==s.size()){
            // cout<<sum<<"" ""<<dp2[sum]<<endl;
            if(1+dp2[sum]<=k){
                return dp[ind][sum][strict]=1;
            }else{
                return dp[ind][sum][strict]=0;
            }
        }else if(dp[ind][sum][strict]!=-1)return dp[ind][sum][strict];
        else{
            int st=0,end=(strict?s[ind]-'0':1);
            ll val=0;
            for(int i=st;i<=end;++i){
                val+=cal(s,ind+1,sum+i,strict&&(i==s[ind]-'0'),k);
                val%=M;
            }
            return dp[ind][sum][strict]=val;
        }
    }
    int countKReducibleNumbers(string s, int k) {
        int n=s.size();
        for(int i=0;i<=n;++i)for(int j=0;j<=n;++j){dp[i][j][0]=-1;   dp[i][j][1]=-1;}
        dp2[1]=0;       dp2[0]=k+1;
        int sum=0;
        for(int i=0;i<n;++i)sum+=s[i]-'0';
        for(int i=2;i<=n;++i){
            int val=popcount(i);
            dp2[i]=dp2[val]+1;
            // cout<<i<<"" ""<<dp2[i]<<endl;
        }
        ll val=cal(s,0,0,1,k);
        if(1+dp2[sum]<=k)--val;
        val+=M;     val%=M;
        return val;
    }
};",1448287535
varous,sourav_suku,360,3646,cpp,"const long long int M=(int)1e9+7;
#define ll long long
class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int n=nums.size();
        map<int,ll> dp1,dp2;
        ll res=0;
        for(int i=n-1;i>=0;--i){
            ll cnt=dp1[nums[i]+1];
            cnt+=dp1[nums[i]-1];
            cnt++;      cnt%=M;
            ll cur=(cnt)*nums[i]; 
            cur%=M;
            cur+=dp2[nums[i]+1];
            cur%=M;
            cur+=dp2[nums[i]-1];
            cur%=M;
            res+=cur;       res%=M;
            dp2[nums[i]]+=cur;      dp2[nums[i]]%=M;
            dp1[nums[i]]+=cnt;      dp1[nums[i]]%=M;
        }
        return res;
    }
};",1448228110
ez95088,ez95088,362,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        if (k == 1) {
            return true;
        }
        for (int s1 = 0, s2 = k; s2 + k - 1 < nums.size(); s1++, s2++) {
            bool first = true;
            bool second = true;
            for (int i = s1 + 1; i < s1 + k; i++) {
                if (nums[i] <= nums[i - 1]) {
                    first = false;
                    break;
                }
            }
            for (int i = s2 + 1; i < s2 + k; i++) {
                if (nums[i] <= nums[i - 1]) {
                    second = false;
                    break;
                }
            }
            if (first && second) {
                return true;
            }
        }
        return false;
    }
};",1448185921
ez95088,ez95088,362,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> res(n, 0);
        int increasing = 0;
        int prev = INT_MIN;
        for (int end = 0; end < n; end++) {
            if (nums[end] > prev) {
                increasing++;
            } else {
                increasing = 1;
            }
            res[end] = increasing;
            prev = nums[end];
        }
        int result = 1;
        for (int i = 0; i < n; i++) {
            result = max(result, res[i] / 2);
            if (i - res[i] >= 0 && res[i - res[i]] >= res[i]) {
                result = max(result, res[i]);
            }
        }
        return result;
    }
};",1448202049
ez95088,ez95088,362,3631,cpp,"class Solution {
private:
    int power2[801];
    int mod = 1e9 + 7;
    int memo[801][801][2];
public:
    int countKReducibleNumbers(string s, int k) {
        int n = s.size();
        int steps[801];
        steps[0] = 0;
        int rr = 0;
        for (int i = 1; i <= 800; i++) {
            steps[i] = __builtin_popcount(i);
            rr = max(rr, steps[i]);
        }
        int p2 = 1;
        power2[0] = 1;
        for (int i = 1; i <= 800; i++) {
            p2 = (p2 * 2) % mod;
            power2[i] = p2;
        }
        steps[1] = 0;
        for (int i = 2; i <= 800; i++) {
            steps[i] = steps[steps[i]] + 1;
        }
        memset(memo, -1, sizeof(memo));
        for (int i = 1; i <= n; i++) {
            dp(0, i, s, true);
        }
        int res = 0;
        for (int i = 1; i <= n; i++) {
            if (steps[i] + 1 <= k) {
                res = (res + dp(0, i, s, true)) % mod;
            }
        }
        int s_bits = 0;
        for (int i = 0; i < n; i++) {
            s_bits += s[i] == '1';
        }
        if (steps[s_bits] + 1 <= k) {
            res--;
        }
        return res;
    }
    // need to fill k bits from s[i] to s[-1]
    int dp(int i, int k, string &s, bool constrained) {
        int n = s.size();
        int bit_left = n - i;
        if (bit_left < k) {
            return 0;
        }
        if (k == 0) {
            return 1;
        }
        if (i == n) {
            return k == 0? 1: 0;
        }
        if (memo[i][k][constrained? 1: 0] != -1) {
            return memo[i][k][constrained? 1: 0];
        }
        long long res = 0;
        if (not constrained) {
            res = dp(i + 1, k, s, constrained);
            res = (res + dp(i + 1, k - 1, s, constrained)) % mod;
        } else {
            int bit = s[i] - '0';
            if (bit == 1) {
                res = dp(i + 1, k, s, not constrained);
                res = (res + dp(i + 1, k - 1, s, constrained)) % mod;
            } else {
                res = dp(i + 1, k, s, constrained);
            }
        }
        memo[i][k][constrained? 1: 0] = res;
        return res;
    }
};",1448300991
ez95088,ez95088,362,3646,cpp,"class Solution {
private:
    int mod = 1e9 + 7;
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        map<int, pair<long long, long long>> mp; // num -> sum, ways
        for (int num: nums) {
            pair<long long, long long> cur = mp[num];
            cur.first = (cur.first + num) % mod;
            cur.second = (cur.second + 1) % mod;
            auto next = mp[num + 1];
            long long nn = (next.first + next.second * num % mod) % mod;
            cur.first = (cur.first + nn) % mod;
            cur.second = cur.second + next.second % mod;
            auto prev = mp[num - 1];
            long long pp = (prev.first + prev.second * num % mod) % mod;
            cur.first = (cur.first + pp) % mod;
            cur.second = cur.second + prev.second % mod;
            mp[num] = cur;
        }
        long long res = 0;
        for (auto it = mp.begin(); it != mp.end(); it++) {
            res = (res + it->second.first) % mod;
        }
        return res;
    }
};",1448232721
Atul,coderchamp07,363,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();

        vector<int> incLen(n, 1);
        for(int r = 1; r < n; r++) {
            if(nums[r - 1] < nums[r])
                incLen[r] += incLen[r - 1];
        }

        for(int i = 0; i + k < n; i++) {
            if(incLen[i] >= k && incLen[i + k] >= k)
                return true;
        }
        return false;
    }
};",1448183244
Atul,coderchamp07,363,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();

        vector<int> incLen(n, 1);
        for(int r = 1; r < n; r++) {
            if(nums[r - 1] < nums[r])
                incLen[r] += incLen[r - 1];
        }

        auto poss = [&](int k) -> bool {
            for(int i = 0; i + k < n; i++) {
                if(incLen[i] >= k && incLen[i + k] >= k)
                    return true;
            }
            return false;
        };

        int l = 0, r = n - 1;
        while(l <= r) {
            int m = (l + r) / 2;
            if(poss(m))
                l = m + 1;
            else
                r = m - 1;
        }
        return r;
    }
};",1448186110
Atul,coderchamp07,363,3631,cpp,"class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        const int mod = 1e9 + 7;
        int n = s.size();

        auto setBitsIn = [&](int v) -> int {
            int ans = 0;
            for(int bit = 0; bit < 32; bit++) {
                if((v >> bit) & 1)
                    ans++;
            }
            return ans;
        };
        
        set<int> canHaveSetBits;

        map<int, int> t;
        for(int i = 1; i <= n; i++) {
            t[i] = 1 + t[setBitsIn(i)];
            if(t[i] <= k)
                canHaveSetBits.insert(i);
        }

        map<int, int> dp[n][2];

        auto recur = [&](auto&& recur, int pos, bool tight, int setBits) -> int {
            if(pos == n)
                return !tight && canHaveSetBits.count(setBits);
            if(setBits > *canHaveSetBits.rbegin())
                return 0;

            if(dp[pos][tight].count(setBits))
                return dp[pos][tight][setBits];

            // add 0 here
            int ans = recur(recur, pos + 1, tight && (s[pos] == '0'), setBits);

            // add 1 here
            if(!tight || s[pos] == '1')
                ans = (1ll * ans + recur(recur, pos + 1, tight && (s[pos] == '1'), setBits + 1)) % mod;
            return dp[pos][tight][setBits] = ans;
        };

        
        return recur(recur, 0, true, 0);
    }
};",1448274192
Atul,coderchamp07,363,3646,python3,"class Solution:
    MOD = int(1e9 + 7)

    def modMul(self, a, b):
        result = 0
        a %= self.MOD
        
        while b > 0:
            if b % 2 == 1:
                result = (result + a) % self.MOD
            a = (a * 2) % self.MOD
            b //= 2
        
        return result % self.MOD

    def sumOfGoodSubsequences(self, nums):
        n = len(nums)
        sumEnding = {}
        cntEnding = {}

        for cur in nums:
            sumEnding[cur] = (sumEnding.get(cur, 0) + cur) % self.MOD
            cntEnding[cur] = cntEnding.get(cur, 0) + 1

            if (cur - 1) in sumEnding:
                cntEnding[cur] += cntEnding[cur - 1]
                sumEnding[cur] = (
                    (sumEnding[cur] + sumEnding[cur - 1]) % self.MOD +
                    self.modMul(cntEnding[cur - 1], cur)
                ) % self.MOD

            if (cur + 1) in sumEnding:
                cntEnding[cur] += cntEnding[cur + 1]
                sumEnding[cur] = (
                    (sumEnding[cur] + sumEnding[cur + 1]) % self.MOD +
                    self.modMul(cntEnding[cur + 1], cur)
                ) % self.MOD

        ans = sum(sumEnding.values()) % self.MOD
        return ans
",1448223679
Halsey Walker,HalseyWalker,364,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int N = nums.size();
        vector<int> startList(N,0);
        int prev = nums[0];
        int left = 0;
        for(int i = 1;i < N;++i){
            int cur = nums[i];
            if(cur > prev){
                startList[i] = left;
            }
            else{
                startList[i] = i;
                left = i;
            }

            prev = cur;
        }
        for(int i = 0;i < N; ++i){
            if(i+1-startList[i] >= k){
                if(i + 1 - startList[i] >= k*2) return true;
                int prevEnd = startList[i] - 1;
                if(prevEnd >= 0){
                    int prevStart = startList[prevEnd];
                    if(prevEnd + 1 - prevStart >= k) return true;
                }

            }
        }
        return false;
    }
};",1448191414
Halsey Walker,HalseyWalker,364,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int N = nums.size();
        vector<int> startList(N,0);
        int prev = nums[0];
        int left = 0;
        for(int i = 1;i < N;++i){
            int cur = nums[i];
            if(cur > prev){
                startList[i] = left;
            }
            else{
                startList[i] = i;
                left = i;
            }

            prev = cur;
        }
        int ans = 1;
        for(int i = 0;i < N; ++i){
            if(i > startList[i]  ){
                int len = i + 1 - startList[i];
                ans = max(ans , len/2);
                int prevEnd = startList[i] - 1;
                if(prevEnd >= 0){
                    int prevStart = startList[prevEnd];
                    int minLen = min(prevEnd + 1 - prevStart, len);
                    ans = max(ans,minLen);
                }

            }
        }
        return ans;
    }
};",1448198799
Halsey Walker,HalseyWalker,364,3631,cpp,"const int mod = 1e9+7;
class Solution {
public:
    int ok(int n,int step){
        if(n <= 1) return 1;
        while(step--){
            if(n == 1) return 1;
            n = __builtin_popcount(n);
        }
        return 0;
    }
    long long jx(int x){
        static bool init = false;
        static vector<long long> list;
        if(!init){
            init = 1;
            list.resize(801,1);
            for(int i = 1;i <= 800;++i){
                list[i] = i * list[i-1];
                list[i] %= mod;
            }
        }
        return list[x];
    }
    long long exp(long long x,int e){
        long long ans = 1;
        long long base = x;
        while(e){
            if(e % 2){
                ans *= base;
                ans %= mod;
            }
            base *= base;
            base %= mod;
            e >>= 1;
        }
        return ans;
    }
    int C(int tot,int take){
        long long res = jx(tot);
        long long a = jx(take);
        long long b = jx(tot - take);
        res *= exp(a,mod-2);
        res %= mod;
        res *= exp(b,mod-2);
        res %= mod;
        return res;
    }
    vector<char> has1List;
    int f(string& s,int one){
        int N = s.length();
        int prev = 0;
        long long ret = 0;
        for(int i = 0;i < N;++i){
            if(s[i] == '1'){
                int back = one - prev;
                prev++;
                if(N-1-i < back){
                    break;
                }
                if(back == 1){
                    if(has1List[i]){
                        ret++;
                    }
                }
                if(back == 0){
                    break;
                }
                else{
                    ret += C(N-1-i , back);
                    ret %= mod;
                }
            }
        }
        return ret%mod;
    }
    int countKReducibleNumbers(string s, int k) {
        int N = s.length();
        has1List.resize(N,0);
        int has = 0;
        for(int i = N-1;i >=0;i--){
            has1List[i] = has;
            if(s[i] == '1'){
                has = 1;
            }
        }
        vector<int> okList(N+1,1);
        for(int i = 1;i <=N;++i){
            okList[i] = ok(i,k);
        }
        long long ans = 0;
        for(int one = 1;one <= N;++one){
            if(okList[one] == 0) continue;
            ans += f(s,one);
            ans %= mod;
        }

        return ans;
    }
};",1448294429
Halsey Walker,HalseyWalker,364,3646,cpp,"const int mod = 1e9+7;
class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int N = nums.size();
        vector<long long> sumList(N,0);
        map<int,long long> cntMap;
        map<int,long long> m;
        for(int i = 0;i < N;++i){
            long long cur = nums[i];
            int a = cur-1;
            int b = cur+1;
            long long sum = cur;
            long long meCnt = 1;
            if(m.find(a) != m.end()){
                long long suma = m[a];
                long long cnt = cntMap[a];
                meCnt += cnt;
                sum += suma + cnt*cur;
                sum %= mod;
            }
            if(m.find(b) != m.end()){
                long long sumb = m[b];
                long long cnt = cntMap[b];
                meCnt += cnt;
                sum += sumb + cnt* cur;
                sum %= mod;
            }
            meCnt%=mod;
            cntMap[cur] += meCnt;
            m[cur] += sum;
            sumList[i] = sum;
        }
        long long ans = 0;
        for(auto sum:sumList) ans += sum;
        return ans % mod;
    }
};",1448226239
Conrad_123,Conrad_123,368,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(std::vector<int>& nums, int k) {

        std::vector<int> counts(nums.size(), 1);

        for(int i = 1; i < nums.size(); i++){
            if(nums[i-1] < nums[i]){
                counts[i] = counts[i-1]+1;
            }
        }

        for(int i = k; i < counts.size(); i++){
            std::cout<<counts[i]<<"" "";
            if(counts[i] < k) continue;

            if(counts[i-k] >= k) return true;
        }

        return false;
    }
};",1448185566
Conrad_123,Conrad_123,368,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(std::vector<int>& nums) {

        std::vector<int> counts(nums.size(), 1);
        int k = 1;
        
        for(int i = 1; i < nums.size(); i++){
            if(nums[i-1] < nums[i]){
                counts[i] = counts[i-1]+1;
            }
            
            while(i - k >= 0 && counts[i] >= k && counts[i-k] >= k){
                k++;
            }        
        }


        return k - 1;
    }
};",1448192380
Conrad_123,Conrad_123,368,3631,cpp,"class Solution {
public:

    int Get_Reduction_Count(int num, int k, std::vector<std::vector<int>>& cache){

        if(num == 1){
            return 0;
        }

        if(k == 0) return 1e9;

        if(cache[num][k] != -1){
            return cache[num][k];
        }

        int idx = 0;
        int bit_counts = 0;
        while((1 << idx) <= num){
            if(num & (1 << idx)) bit_counts++;
            idx++;
        }

        return cache[num][k] = 1+Get_Reduction_Count(bit_counts, k-1, cache);
    }

    int Count_Nums(std::string& s, int idx, int bit_counts, bool is_smaller, std::vector<std::vector<int>>& cache, std::vector<bool>& is_valid){

        if(idx >= s.size() && is_valid[bit_counts] && is_smaller){
            return 1;
        }else if(idx >= s.size()){
            return 0;
        }

        if(cache[idx*2 + is_smaller][bit_counts] != -1){
            return cache[idx*2 + is_smaller][bit_counts];
        }

        int mod = 1e9+7;
        int result = 0;
        if(s[idx] == '1'){
            result += Count_Nums(s, idx+1, bit_counts+1, is_smaller, cache, is_valid);
            result %= mod;
            result += Count_Nums(s, idx+1, bit_counts, true, cache, is_valid);
            result %= mod;
        }else{
            if(is_smaller){
                result += Count_Nums(s, idx+1, bit_counts+1, is_smaller, cache, is_valid);
                result %= mod;
            }
            result += Count_Nums(s, idx+1, bit_counts, is_smaller, cache, is_valid);
            result %= mod;
        }

        return cache[idx*2 + is_smaller][bit_counts] = result;
    }

    int countKReducibleNumbers(std::string s, int k) {

        std::vector<std::vector<int>> reduction_cache(s.size()+1, std::vector<int>(k+1, -1));
        std::vector<bool> is_valid(s.size()+1, false);
    
        for(int i = 1; i <= s.size(); i++){
            int count = Get_Reduction_Count(i, k, reduction_cache);
            if(count < k){  
                is_valid[i] = true;  
            } 
            
        }

        std::vector<std::vector<int>> cache(s.size()*2, std::vector<int>(s.size()+1, -1));

        return Count_Nums(s, 0, 0, false, cache, is_valid);
    }
};",1448230995
Conrad_123,Conrad_123,368,3646,cpp,"class Solution {
public:

    int Count_Sum(std::vector<std::vector<int>>& dag, int idx, std::vector<int>& cache, std::vector<int>& counts){

        if(idx >= dag.size()){
            return 0;
        }

        if(cache[idx] != -1){
            return cache[idx];
        }
        
        int mod = 1e9+7;
        counts[idx] = 1;
        counts[idx] += Count_Sum(dag, dag[idx][0], cache, counts);
        counts[idx] %= mod;
        counts[idx] += Count_Sum(dag, dag[idx][1], cache, counts);
        counts[idx] %= mod;
        
        int skip = Count_Sum(dag, dag[idx][2], cache, counts);
            
        return cache[idx] = (skip + counts[idx])%mod;
    }

    void Get_Count(std::vector<int>& nums, std::vector<int>& counts){
        std::unordered_map<int, int> last_seen;
        std::vector<std::vector<int>> dag(nums.size(), std::vector<int>(3, nums.size()));
        
        for(int i = (int)nums.size()-1; i >= 0; i--){

            if(last_seen.find(nums[i] + 1) != last_seen.end()){
                dag[i][0] = last_seen[nums[i]+1];
            }
            if(last_seen.find(nums[i] - 1) != last_seen.end()){
                dag[i][1] = last_seen[nums[i]-1];
            }
            if(last_seen.find(nums[i]) != last_seen.end()){
                dag[i][2] = last_seen[nums[i]];
            }
            last_seen[nums[i]] = i;
        }

        std::vector<int> cache(nums.size(), -1);

        for(int i = 0; i < nums.size(); i++){
            Count_Sum(dag, i, cache, counts);
        }
    }

    int sumOfGoodSubsequences(std::vector<int>& nums) {

        std::vector<int> counts1(nums.size(), 0);

        Get_Count(nums, counts1);
        std::reverse(nums.begin(), nums.end());
        std::vector<int> counts2(nums.size(), 0);

        Get_Count(nums, counts2);
        std::reverse(nums.begin(), nums.end());
        std::reverse(counts2.begin(), counts2.end());

        long long sum = 0;
        int mod = 1e9 + 7;
        for(int i = 0; i < nums.size(); i++){
            //std::cout<<counts1[i]<<"" ""<<counts2[i]<<'\n';
            long long subarrays = (long long)counts1[i] * (long long)(counts2[i]);
            subarrays %= mod;
            //subarrays += counts1[i] + counts2[i];
            subarrays %= mod;

            sum += subarrays * (long long)nums[i];
            sum %= mod;
        }
    
        return sum;
    }
};",1448295464
kailam11223,kailam11223,369,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        vector<int> lens(nums.size(), 0);
        lens[0] = 1;
        for(int i = 1; i < nums.size(); ++i){
            if(nums[i] <= nums[i-1]){
                lens[i] = 1;
            } else {
                lens[i] = lens[i-1]+1;
            }
            if( i>=k && lens[i] >= k && lens[i-k] >= k) return true;
        }
        
        return false;
    }
};",1448194372
kailam11223,kailam11223,369,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        vector<int> lens(nums.size(), 0);
        lens[0] = 1;
        int ret = 1;
        for(int i = 1; i < nums.size(); ++i){
            if(nums[i] <= nums[i-1]){
                lens[i] = 1;
            } else {
                lens[i] = lens[i-1]+1;
            }
            ret = max(ret, (i >= lens[i] && lens[i-lens[i]] >= lens[i]) ? lens[i] : lens[i]/2);
        }
        
        return ret;
    }
};",1448191799
kailam11223,kailam11223,369,3631,cpp,"class Solution {
private:
    int bit_count(int x){
        int c = 0;
        while(x){
            c += (x%2);
            x >>= 1;
        }
        return c;
    }
    long long pow_mod(long long x, int n){
        if(n==0) return 1;
        x%=MOD;
        long long p = pow_mod(x, n/2);
        p = (p*p)%MOD;
        return (p*((n%2)?x:1LL))%MOD;
    }
    long long nCr(long long n, long long r){
        if(r > n) return 0;
        if(r==0) return 1;
        return (((n * invs[r]) % MOD) * nCr(n-1, r-1)) % MOD;
    }
    void construct(){
        invs = vector<long long>(801, 0);
        for(int i = 1; i < invs.size(); ++i) invs[i] = pow_mod(i, MOD-2);
    }
public:
    int countKReducibleNumbers(string s, int k) {
        // s = std::string(800,'1');
        int n = s.length();
        int b = 0;
        construct();
        for(int i = 0; i < n; ++i){
            b+=(s[i]-'0');
        }
        
        vector<int> v(n+1, 0);
        long long ret = 0;
        // cout<<""s=""<<s<<endl;
        for(int x = 1; x <= n; ++x){
            auto bc = bit_count(x);
            v[x] = v[bc]+1;
            // cout<<""x=""<<x<<"", v=""<<v[x]<<"", bc=""<<bc<<endl;
            if(v[x] > k) continue;
            long long off = (x < b)? 1 : 0;
            // cout<<""off=""<<off<<"", b=""<<b<<endl;
            int c = 0;
            for(int i = 0; i < n && x > c; ++i){
                if(s[i]=='0') continue;
                // cout<<""adding ""<<(n-i-1)<<""C""<<(x - c)<<endl;
                off = (off + nCr(n-i-1, x - c)) % MOD;
                c++;
            }
            ret = (ret + off) % MOD;
        }
        return ret;
        
    }
private:
long long MOD = 1e9+7;
vector<long long> invs;
};",1448288941
kailam11223,kailam11223,369,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        map<int, long long> S;
        map<int, long long> C;
        long long ret = 0;
        for(auto x : nums){
            long long c = C[x-1] + C[x+1] + 1;
            long long s = (S[x-1] + S[x+1] + ((c * x) % MOD)) % MOD;
            S[x] = (S[x] + s) % MOD;
            C[x] = (C[x] + c) % MOD;
            ret = (ret + s) % MOD;
        }
        return ret;
    }
private:
    long long MOD = 1e9+7;
};",1448210686
HarshaNP,NastyWaterEspresso,370,3612,cpp,"#include <vector>
using namespace std;

class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        if (n < 2 * k) return false; 
        auto isStrictlyIncreasing = [&](int start) -> bool {
            for (int i = start; i < start + k - 1; i++) {
                if (nums[i] >= nums[i + 1]) {
                    return false;
                }
            }
            return true;
        };

        for (int i = 0; i <= n - 2 * k; i++) {
 
            if (isStrictlyIncreasing(i) && isStrictlyIncreasing(i + k)) {
                return true;
            }
        }

        return false;
    }
};
",1448181561
HarshaNP,NastyWaterEspresso,370,3619,cpp,"#include <vector>
using namespace std;

class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        if (n < 2 * k) return false;

        vector<int> inc(n, 1);
        for(int i = n - 2; i >= 0; --i){
            if(nums[i] < nums[i+1]) inc[i] = inc[i+1] + 1;
            else inc[i] = 1;
        }

        for(int i = 0; i + 2 * k <= n; ++i){
            if(inc[i] >= k && inc[i + k] >= k){
                return true;
            }
        }
        return false;
    }

    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        int left = 1, right = n / 2, result = 0;
        while(left <= right){
            int mid = left + (right - left) / 2;
            if(hasIncreasingSubarrays(nums, mid)){
                result = mid;
                left = mid + 1;
            }
            else{
                right = mid - 1;
            }
        }
        return result;
    }
};
",1448191832
HarshaNP,NastyWaterEspresso,370,3631,python3,"from math import comb

class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        MOD = 10**9 + 7

        def precompute_f(max_l):
            f = [0] * (max_l + 2)
            f[1] = 0
            for l in range(2, max_l + 1):
                pop = bin(l).count('1')
                f[l] = 1 + f[pop]
            return f

        n = int(s, 2)
        max_l = len(s)
        f = precompute_f(max_l)

        def count_less_than(n, m):
            total = 0
            binary_n = bin(n)[2:]
            num_bits = len(binary_n)
            
            for i, bit in enumerate(binary_n):
                if bit == '1':
                    bits_to_right = num_bits - i - 1
                    if m >= 0 and bits_to_right >= m:
                        total += comb(bits_to_right, m)
                    m -= 1
                
                if m < 0:
                    break
        
            return total

        total = 0

        if n > 1 and k >= 0:
            total += 1
            total %= MOD

        if k >= 1:
            count_l1 = count_less_than(n, 1)
            if n > 1:
                count_l1 -= 1
            total += count_l1
            total %= MOD

        for l in range(2, max_l + 1):
            if f[l] <= (k-1):
                count_l = count_less_than(n, l)
                total += count_l
                total %= MOD

        return total
",1448289206
HarshaNP,NastyWaterEspresso,370,3646,cpp,"#include <vector>
#include <unordered_map>
using namespace std;

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        const int MOD = 1'000'000'007;
 
        unordered_map<int, long> dp;  
        unordered_map<int, long> cnt; 
        
        for(auto num : nums){
            long temp_sum = num; 
            long temp_cnt = 1;   
            
    
            if(cnt.find(num-1) != cnt.end()){
                temp_sum = (temp_sum + dp[num-1] + ((long)cnt[num-1] * num)) % MOD;
                temp_cnt = (temp_cnt + cnt[num-1]) % MOD;
            }
 
            if(cnt.find(num+1) != cnt.end()){
                temp_sum = (temp_sum + dp[num+1] + ((long)cnt[num+1] * num)) % MOD;
                temp_cnt = (temp_cnt + cnt[num+1]) % MOD;
            }
    
            dp[num] = (dp[num] + temp_sum) % MOD;
            cnt[num] = (cnt[num] + temp_cnt) % MOD;
        }
        
    
        long total = 0;
        for(auto &[key, val] : dp){
            total = (total + val) % MOD;
        }
        
        return (int)total;
    }
};
",1448202145
virinci,virinci,371,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        dp = [0] * n
        dp[0] = 1
        for i in range(1, n):
            dp[i] = dp[i - 1] + 1 if nums[i] > nums[i - 1] else 1
        # print(dp)
        for i in range(n):
            ik = i + k - 1
            j = i + k
            jk = i + k + k - 1
            if jk >= n:
                break
            if dp[ik] >= k and dp[jk] == k or dp[jk] >= 2 * k:
                return True
        return False",1448188228
virinci,virinci,371,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        p, s = [0] * n, [0] * n
        p[0], s[n - 1] = 1, 1
        for i in range(1, n):
            p[i] = p[i - 1] + 1 if nums[i] > nums[i - 1] else 1
        for i in range(n - 2, -1, -1):
            s[i] = s[i + 1] + 1 if nums[i] < nums[i + 1] else 1
        ans = max(p) // 2
        for i in range(1, n):
            if p[i] != 1:
                continue
            ans = max(ans, min(p[i - 1], s[i]))
        return ans",1448198062
virinci,virinci,371,3631,cpp,"#ifndef dbg
#define dbg(...)
#endif

auto _fastio = [] { return std::cin.tie(nullptr)->sync_with_stdio(false); }();

class Solution {
public:
	int countKReducibleNumbers(string s, int k) {
		constexpr int L = 800;
		vector z(L + 1, 0LL);
		vector d(2, z);
		d[0][0] = 1;
		dbg(d);

		constexpr long long M = 1e9 + 7;

		for (int c : s) {
			c -= '0';
			vector nd(2, z);

			for (int x = 0; x <= 1; ++x) {
				for (int i = x; i <= L; ++i) {
					nd[1][i] = (nd[1][i] + d[1][i - x]) % M;
				}
			}

			for (int x = 0; x < c; ++x) {
				for (int i = x; i <= L; ++i) {
					nd[1][i] = (nd[1][i] + d[0][i - x]) % M;
				}
			}

			for (int i = c; i <= L; ++i) {
				nd[0][i] = (nd[0][i] + d[0][i - c]) % M;
			}

			d = nd;
			dbg(d);
		}

		auto count = d[1];

		vector k_reducible(k + 1, vector(L + 1, false));
		k_reducible[0][1] = true;

		for (int i = 1; i <= k; ++i) {
			for (int j = 1; j <= L; ++j) {
				auto c = __builtin_popcount(j);
				k_reducible[i][j] = k_reducible[i - 1][c];
			}
		}
		auto ans = 0LL;

		dbg(count);
		dbg(k_reducible);

		for (int i = 1; i <= L; ++i) {
			if (!k_reducible[k - 1][i]) continue;
			ans = (ans + count[i]) % M;
		}

		return ans;
	}
};",1448275776
virinci,virinci,371,3646,cpp,"auto _fastio = [] { return std::cin.tie(nullptr)->sync_with_stdio(false); }();

class Solution {
public:
	int sumOfGoodSubsequences(vector<int>& nums) {
		auto m = ranges::max(nums);

		using i64 = long long;
		constexpr i64 M = 1e9 + 7;
		vector<i64> d(m + 3, 0), c(m + 3, 0);

		for (auto x : nums) {
			d[x + 1] = (d[x + 1] + d[x] + c[x] * x) % M;
			d[x + 1] = (d[x + 1] + d[x + 2] + c[x + 2] * x) % M;
			d[x + 1] = (d[x + 1] + x) % M;
			c[x + 1] = (c[x + 1] + c[x]) % M;
			c[x + 1] = (c[x + 1] + c[x + 2]) % M;
			c[x + 1] = (c[x + 1] + 1) % M;
		}

		return accumulate(d.cbegin(), d.cend(), 0LL) % M;
	}
};",1448218886
Manojkumar Sirvi,sirvi_26,372,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        
         int len1 = 1 , len2 = 0 ; 
        int ans = 0 ; 
        for(int i = 1 ; i<nums.size() ; ++i)
        {
            if(nums[i] > nums[i-1])
            {
                if(len2==0)
                    len1++ ; 
                else 
                {
                    len2++ ; 
                     
                }
            }
            else 
            {
                if(len2==0)
                {
                    len2 = 1 ;
                }
                else
                {
                    len1 = len2 , len2 = 1 ; 
                }
                
            }
            
                // cout<<""len1 : ""<<len1<<"" len2 : ""<<len2<<""\n""  ;
            
            ans = max(ans , min(len1,len2)) ;
            ans = max(ans,len1/2) ; 
            ans = max(ans,len2/2) ; 
        }
        
        return k<=ans ; 
        
    }
};",1448203184
Manojkumar Sirvi,sirvi_26,372,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int len1 = 1 , len2 = 0 ; 
        int ans = 0 ; 
        for(int i = 1 ; i<nums.size() ; ++i)
        {
            if(nums[i] > nums[i-1])
            {
                if(len2==0)
                    len1++ ; 
                else 
                {
                    len2++ ; 
                     
                }
            }
            else 
            {
                if(len2==0)
                {
                    len2 = 1 ;
                }
                else
                {
                    len1 = len2 , len2 = 1 ; 
                }
                
            }
            
                // cout<<""len1 : ""<<len1<<"" len2 : ""<<len2<<""\n""  ;
            
            ans = max(ans , min(len1,len2)) ;
            ans = max(ans,len1/2) ; 
            ans = max(ans,len2/2) ; 
        }
        
        return ans ; 
    }
};",1448202395
Manojkumar Sirvi,sirvi_26,372,3631,cpp,"typedef long long ll ; 
ll mod = 1e9 + 7 ; 

class Solution {
public:
    
    ll op[801] ; 
    
    vector<vector<vector<ll>>> dp ; 
    
    ll get(ll ind , string &s , ll one , ll is_small , int &k)
    {
        if(ind == s.size())
        {
           // cout<<""one : ""<<one<<""\n"" ; 
            if(op[one]<=k and is_small)
                return 1 ; 
            else return 0 ; 
            // return op[one] <= k  ; 
        }
        if(dp[is_small][one][ind]!=-1)
            return dp[is_small][one][ind] ; 
        ll ans = 0 ; 
        
        if(is_small)
        {
            ans = get(ind+1,s,one+1,1,k);
            ans = (ans + get(ind+1,s,one,1,k))%mod ; 
        }
        else 
        {
            if(s[ind]=='0')
                ans = get(ind+1,s,one,0,k) ; 
            else 
            {
                ans = get(ind+1,s,one+1,0,k);
                // cout<<""after one : ""<<ans<<""\n""  ;
                // cout<<""one : ""<<one<<""\n"" ; 
                // cout<<""get : ""<<get(ind+1,s,one,1,k)<<""\n"" ;
                ans = (ans + get(ind+1,s,one,1,k))%mod ; 
                // cout<<""after zero : ""<<ans<<""\n"" ; 
            }
        }
        
        
        return dp[is_small][one][ind] = ans ; 
    }
    
    
    
    
    int countKReducibleNumbers(string s, int k) {
        dp.clear();
         dp.resize(2, vector<vector<ll>>(s.size() + 1, vector<ll>(s.size() + 1, -1)));

       for(int i = 1 ; i<=s.size() ; ++i)
       {
           ll n = i ;
           ll ops = 1 ; 
           while(n>1 and ops<k)
           {
               ops++; 
               n = __builtin_popcount(n);
           }
           if(n==1)
               op[i] = ops ; 
           else op[i] = 10 ; 
       }
        op[0] = 10 ; 
        
       
        return get(0,s,0,0,k);
    }
};",1448289913
Manojkumar Sirvi,sirvi_26,372,3646,cpp,"typedef long long ll ; 
ll mod = 1e9+7 ; 
class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        
        ll ans = 0 ; 
        
        
        map<ll,ll> dp2 , cnt2 ; 
        
        for(ll i = 0  ;i<nums.size() ; ++i)
        {
            ll ncnt = (cnt2[nums[i]-1]+cnt2[nums[i]+1])%mod , sum = (dp2[nums[i]-1]+dp2[nums[i]+1])%mod ; 
            ncnt = (ncnt+1)%mod ; 
            
            ll ex = ( ncnt * nums[i] ) %mod ; 
            
            ll anss = (sum + ex) % mod ; 
            
            ans = (ans + anss) % mod ; 
            
            ll currSum = dp2[nums[i]];
            currSum = (currSum + anss) % mod ; 
            
            ll currCnt = cnt2[nums[i]] ; 
            currCnt = (currCnt + ncnt ) % mod ; 
            
            dp2[nums[i]] = currSum ; 
            cnt2[nums[i]] = currCnt ; 
            
        }
        
        return ans ; 
        
    }
};",1448231166
agix,agix,373,3612,cpp,"class Solution {
public:
    bool ok(vector<int>& nums, int l, int k)
    {
        for (int i = l + 1; i < l + k; i++)
        {
            if (nums[i] <= nums[i - 1])
            {
                return false;
            }
        }
        return true;
    }
    
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        
        for (int i = 0; i + 2 * k - 1 < n; i++)
        {
            if (ok(nums, i, k) && ok(nums, i + k, k))
            {
                return true;
            }
        }
        return false;
    }
};",1448182593
agix,agix,373,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        
        vector<int> l(n);
        l[0] = 1;
        
        for (int i = 1; i < n; i++)
        {
            if (nums[i] > nums[i - 1])
            {
                l[i] = l[i - 1] + 1;
            }
            else
            {
                l[i] = 1;
            }
        }
        
        vector<int> r(n);
        r[n - 1] = 1;
        
        for (int i = n - 2; i >= 0; i--)
        {
            if (nums[i] < nums[i + 1])
            {
                r[i] = r[i + 1] + 1;
            }
            else
            {
                r[i] = 1;
            }
        }
        
        int ans = 1;
        for (int i = 0; i < n - 1; i++)
        {
            int a = l[i];
            int b = r[i + 1];
            ans = max(ans, min(a, b));
        }
        
        return ans;
    }
};",1448198563
agix,agix,373,3631,cpp,"#define LL long long

LL comb[1000][1000];

LL mod = 1e9 + 7;

class Solution {
public:
    int reduce(int num)
    {
        int step = 0;
        while (num > 1)
        {
            int cnt = __builtin_popcount(num);
            num = cnt;
            step++;
        }
        return step;
    }
    
    int countKReducibleNumbers(string s, int k) {
        int x = 800;
        
        unordered_map<int, vector<int>> mp;
        
        for (int i = 1; i <= 800; i++)
        {
            int cnt = reduce(i);
            mp[cnt].push_back(i);
        }
        
        memset(comb, 0, sizeof(comb));
        
        comb[0][0] = 1;
        for (int i = 1; i <= 800; i++)
        {
            comb[i][0] = 1;
            
            for (int j = 1; j <= i; j++)
            {
                comb[i][j] = comb[i - 1][j] + comb[i - 1][j - 1];
                comb[i][j] = comb[i][j] % mod;
            }
        }
        
        int n = s.size();
        int used = 0;
        LL ans = 0;
        
        for (int i = 0; i < n; i++)
        {
            if (s[i] == '1')
            {
                int r = n - i - 1;
                
                for (int j = k - 1; j >= 0; j--)
                {
                    for (auto& value : mp[j])
                    {
                        int bits = value - used;

                        if (bits >= 0 && bits <= r)
                        {
                            ans += comb[r][bits];
                            ans = ans % mod;
                        }
                    }
                }
                
                used += 1;
            }
        }
        
        return ans;
    }
};",1448297086
agix,agix,373,3646,cpp,"#define LL long long 

LL mod = 1e9 + 7;

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int n = nums.size();
        
        unordered_map<int, LL> cnt;
        unordered_map<int, LL> sum;
        
        cnt[nums[0]] = 1;
        sum[nums[0]] = nums[0];
        
        for (int i = 1; i < n; i++)
        {
            int val = nums[i];
            
            LL c = 1;
            LL s = val;
            
            c += cnt[val - 1];
            s += sum[val - 1] + cnt[val - 1] * val;
            
            c += cnt[val + 1];
            s += sum[val + 1] + cnt[val + 1] * val;
            
            //cout << i << endl;
            //cout << c << "" "" << s << endl;
            
            c = c % mod;
            s = s % mod;
            
            cnt[val] += c;
            sum[val] += s;
            cnt[val] = cnt[val] % mod;
            sum[val] = sum[val] % mod;
        }
        
        LL ans = 0;
        
        for (auto& [k, v] : sum)
        {
            ans += v;
            ans = ans % mod;
        }
        
        return ans;
    }
};",1448230852
xjc,kaddie,374,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        last = 0
        cur = 0
        for i, x in enumerate(nums):
            if i == 0 or x > nums[i - 1]:
                cur += 1
            else:
                last, cur = cur, 1

            if (last >= k and cur >= k) or (cur >= 2 * k):
                return True

        return False",1448190383
xjc,kaddie,374,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        last = cur = 0
        k = 0
        for i, x in enumerate(nums):
            if i == 0 or x > nums[i - 1]:
                cur += 1
            else:
                last, cur = cur, 1
            k = max(k, min(last, cur), cur // 2)

        return k",1448194095
xjc,kaddie,374,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        MOD = 10**9 + 7
        N = len(s)

        def ones(x):
            res = 0
            while x:
                res += x & 1
                x >>= 1
            return res

        @cache
        def k_reducible(x, k):
            while x != 1 and k > 0:
                x = ones(x)
                k -= 1
            return x == 1

        res = 0
        left_ones = sum(x == '1' for x in s)
        for i in range(N - 1, -1, -1):
            if s[i] == '0':
                continue
            left_ones -= 1
            bits = N - 1 - i
            for right_ones in range(bits + 1):
                x = left_ones + right_ones
                if k_reducible(x, k - 1):
                    res = (res + comb(bits, right_ones)) % MOD

        return res",1448283998
xjc,kaddie,374,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        MOD = 10**9 + 7
        N = len(nums)

        m = {} # begin: (count, sum)
        for x in nums[::-1]:
            count0, sum0 = m.get(x, (0, 0))
            count0 += 1
            sum0 += x
            for y in (x - 1, x + 1):
                if y in m:
                    count1, sum1 = m[y]
                    count0 += count1
                    sum0 = (sum0 + sum1 + x * count1) % MOD
            m[x] = (count0, sum0)

        return sum(sum0 for _, sum0 in m.values()) % MOD

        @cache
        def dp(i, prev):
            if prev is None:
                if i == N:
                    return 0, 0                    
                count1, sum1 = dp(i + 1, None)
                count2, sum2 = dp(i + 1, nums[i])
                return count1 + count2, (sum1 + sum2 + nums[i] * count2) % MOD
            else:
                if i == N:
                    return 1, 0
                count, sum = dp(i + 1, prev)
                if (nums[i] - prev) in (-1, 1):
                    count2, sum2 = dp(i + 1, nums[i])
                    count += count2
                    sum += (sum2 + nums[i] * count2) % MOD
                return count, sum

        return dp(0, None)[1]",1448246293
bramar2,bramar2,377,3612,cpp,"//#pragma GCC optimize(""O3,unroll-loops"")
//#pragma GCC target(""avx2,bmi,bmi2,lzcnt,popcnt"")
#include <bits/stdc++.h>
using namespace std;
// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// using namespace __gnu_pbds;
// template<typename T>
// using ordered_map = tree<T, T, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// template<typename T>
// using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define ll long long
#define ld long double
#define fastio ios::sync_with_stdio(false); cin.tie(nullptr);

#define dbg_stream cout
void __print(int x) {dbg_stream << x;}
void __print(long x) {dbg_stream << x;}
void __print(long long x) {dbg_stream << x;}
void __print(unsigned x) {dbg_stream << x;}
void __print(unsigned long x) {dbg_stream << x;}
void __print(unsigned long long x) {dbg_stream << x;}
void __print(float x) {dbg_stream << x;}
void __print(double x) {dbg_stream << x;}
void __print(long double x) {dbg_stream << x;}
void __print(char x) {dbg_stream << '\'' << x << '\'';}
void __print(const char *x) {dbg_stream << '\""' << x << '\""';}
void __print(const string &x) {dbg_stream << '\""' << x << '\""';}
void __print(bool x) {dbg_stream << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {dbg_stream << '{'; __print(x.first); dbg_stream << ','; __print(x.second); dbg_stream << '}';}
template<typename T>
void __print(const T &x) {int f = 0; dbg_stream << '{'; for (auto &i: x) dbg_stream << (f++ ? "","" : """"), __print(i); dbg_stream << ""}"";}
void _print() {dbg_stream << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) dbg_stream << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define dbg(x...) dbg_stream << ""["" << #x << ""] = [""; _print(x)
#else
#define dbg(x...)
#endif

template <typename T>
void print(T t) { int f = 0; for(const auto& b : t) cout << (f++ ? "" "" : """") << b; cout << '\n'; }
template <typename T>
void print2d(T t) { for(const auto& b : t) { print(b); } }

inline long long mod_exp(long long base, long long exp, long long modd) { unsigned long long ans = 1; base %= modd; while(exp > 0) { if(exp%2==1) ans = (base*ans)%modd; exp /= 2; base = (base*base)%modd; } return ans; }
inline long long factorial(long long n) { long long ans = 1; for(long long i = 2; i <= n; i++) ans *= n; return ans; }
inline long long memo_factorial(long long n) { static vector<int> memo {1,1,2}; if(static_cast<size_t>(n) >= memo.size()) { memo.resize(n+1); for(long long i = memo.size(); i <= n; i++) memo[i] = i*memo[i-1]; } return memo[n]; }
inline long long nCk(int N, int K) { if(K > N) return 0; if(K > N-K) K = N-K; long long ans = 1; for(long long i = 1; i <= K; i++) ans = (ans * (N - (K-i))) / i; return ans; }

const ll MOD = 1e9 + 7;
const ll MOD99 = 998244353;
const ll BIGMOD = pow(2,31)-1;

class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        bool y = false;
        for(int i = 0; i < n; i++) {
            bool yes = true;

            int lastIdx = i + 2*k - 1;
            if(lastIdx >= n) break;


            for(int j = i + 1; j < i + k; j++) {
                if(nums[j] <= nums[j - 1]) {
                    yes = false;
                    break;
                }
            }
            for(int j = i + k + 1; j <= lastIdx; j++) {
                if(nums[j] <= nums[j - 1]) {
                    yes = false;
                    break;
                }
            }

            y |= yes;
        }
        return y;
    }
};

int main1() {
    fastio;
    return 0;
}",1448185122
bramar2,bramar2,377,3619,cpp,"//#pragma GCC optimize(""O3,unroll-loops"")
//#pragma GCC target(""avx2,bmi,bmi2,lzcnt,popcnt"")
#include <bits/stdc++.h>
using namespace std;
// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// using namespace __gnu_pbds;
// template<typename T>
// using ordered_map = tree<T, T, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// template<typename T>
// using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define ll long long
#define ld long double
#define fastio ios::sync_with_stdio(false); cin.tie(nullptr);

#define dbg_stream cout
void __print(int x) {dbg_stream << x;}
void __print(long x) {dbg_stream << x;}
void __print(long long x) {dbg_stream << x;}
void __print(unsigned x) {dbg_stream << x;}
void __print(unsigned long x) {dbg_stream << x;}
void __print(unsigned long long x) {dbg_stream << x;}
void __print(float x) {dbg_stream << x;}
void __print(double x) {dbg_stream << x;}
void __print(long double x) {dbg_stream << x;}
void __print(char x) {dbg_stream << '\'' << x << '\'';}
void __print(const char *x) {dbg_stream << '\""' << x << '\""';}
void __print(const string &x) {dbg_stream << '\""' << x << '\""';}
void __print(bool x) {dbg_stream << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {dbg_stream << '{'; __print(x.first); dbg_stream << ','; __print(x.second); dbg_stream << '}';}
template<typename T>
void __print(const T &x) {int f = 0; dbg_stream << '{'; for (auto &i: x) dbg_stream << (f++ ? "","" : """"), __print(i); dbg_stream << ""}"";}
void _print() {dbg_stream << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) dbg_stream << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define dbg(x...) dbg_stream << ""["" << #x << ""] = [""; _print(x)
#else
#define dbg(x...)
#endif

template <typename T>
void print(T t) { int f = 0; for(const auto& b : t) cout << (f++ ? "" "" : """") << b; cout << '\n'; }
template <typename T>
void print2d(T t) { for(const auto& b : t) { print(b); } }

inline long long mod_exp(long long base, long long exp, long long modd) { unsigned long long ans = 1; base %= modd; while(exp > 0) { if(exp%2==1) ans = (base*ans)%modd; exp /= 2; base = (base*base)%modd; } return ans; }
inline long long factorial(long long n) { long long ans = 1; for(long long i = 2; i <= n; i++) ans *= n; return ans; }
inline long long memo_factorial(long long n) { static vector<int> memo {1,1,2}; if(static_cast<size_t>(n) >= memo.size()) { memo.resize(n+1); for(long long i = memo.size(); i <= n; i++) memo[i] = i*memo[i-1]; } return memo[n]; }
inline long long nCk(int N, int K) { if(K > N) return 0; if(K > N-K) K = N-K; long long ans = 1; for(long long i = 1; i <= K; i++) ans = (ans * (N - (K-i))) / i; return ans; }

const ll MOD = 1e9 + 7;
const ll MOD99 = 998244353;
const ll BIGMOD = pow(2,31)-1;

class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> strict; strict.reserve(nums.size());
        strict.push_back(1);
        for(int i = 1; i < n; i++) {
            if(nums[i] > nums[i - 1]) {
                strict.back()++;
            }else {
                strict.push_back(1);
            }
        }
        ll ans = *max_element(all(strict)) / 2;

        for(ll i = 1; i < strict.size(); i++) {
            ans = max(ans, (ll)min(strict[i - 1], strict[i]));
        }
        return ans;
    }
};

int main1() {
    fastio;
    return 0;
}",1448192185
bramar2,bramar2,377,3631,cpp,"//#pragma GCC optimize(""O3,unroll-loops"")
//#pragma GCC target(""avx2,bmi,bmi2,lzcnt,popcnt"")
#include <bits/stdc++.h>
using namespace std;
// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// using namespace __gnu_pbds;
// template<typename T>
// using ordered_map = tree<T, T, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// template<typename T>
// using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define ll long long
#define ld long double
#define fastio ios::sync_with_stdio(false); cin.tie(nullptr);

#define dbg_stream cout
void __print(int x) {dbg_stream << x;}
void __print(long x) {dbg_stream << x;}
void __print(long long x) {dbg_stream << x;}
void __print(unsigned x) {dbg_stream << x;}
void __print(unsigned long x) {dbg_stream << x;}
void __print(unsigned long long x) {dbg_stream << x;}
void __print(float x) {dbg_stream << x;}
void __print(double x) {dbg_stream << x;}
void __print(long double x) {dbg_stream << x;}
void __print(char x) {dbg_stream << '\'' << x << '\'';}
void __print(const char *x) {dbg_stream << '\""' << x << '\""';}
void __print(const string &x) {dbg_stream << '\""' << x << '\""';}
void __print(bool x) {dbg_stream << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {dbg_stream << '{'; __print(x.first); dbg_stream << ','; __print(x.second); dbg_stream << '}';}
template<typename T>
void __print(const T &x) {int f = 0; dbg_stream << '{'; for (auto &i: x) dbg_stream << (f++ ? "","" : """"), __print(i); dbg_stream << ""}"";}
void _print() {dbg_stream << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) dbg_stream << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define dbg(x...) dbg_stream << ""["" << #x << ""] = [""; _print(x)
#else
#define dbg(x...)
#endif

template <typename T>
void print(T t) { int f = 0; for(const auto& b : t) cout << (f++ ? "" "" : """") << b; cout << '\n'; }
template <typename T>
void print2d(T t) { for(const auto& b : t) { print(b); } }

inline long long mod_exp(long long base, long long exp, long long modd) { unsigned long long ans = 1; base %= modd; while(exp > 0) { if(exp%2==1) ans = (base*ans)%modd; exp /= 2; base = (base*base)%modd; } return ans; }
inline long long factorial(long long n) { long long ans = 1; for(long long i = 2; i <= n; i++) ans *= n; return ans; }
inline long long memo_factorial(long long n) { static vector<int> memo {1,1,2}; if(static_cast<size_t>(n) >= memo.size()) { memo.resize(n+1); for(long long i = memo.size(); i <= n; i++) memo[i] = i*memo[i-1]; } return memo[n]; }
inline long long nCk(int N, int K) { if(K > N) return 0; if(K > N-K) K = N-K; long long ans = 1; for(long long i = 1; i <= K; i++) ans = (ans * (N - (K-i))) / i; return ans; }

const ll MOD = 1e9 + 7;
const ll MOD99 = 998244353;
const ll BIGMOD = pow(2,31)-1;

class Solution {
public:
    int countKReducibleNumbers(const string& s, int k) {
        int n = s.size();
        if(n == 1) return 0;

        vector valid(n+1, vector<int>(2, -1));
        valid[0][0] = valid[0][1] = 0;
        valid[1][0] = valid[1][1] = 1;

        function<int(int,bool)> dfs = [&](int setBits, bool isOne) -> int {
            if(setBits == 1 && isOne) return 0;
            if(valid[setBits][isOne] >= 0) return valid[setBits][isOne];
            // dbg(setBits, isOne, __builtin_popcount(setBits));
            return valid[setBits][isOne] = (1 + dfs(__builtin_popcount(setBits), setBits == 1));
        };

        for(int i = 2; i <= n; ++i) {
            dfs(i, false);
        }

        // dbg(valid);

        for(int i = 1; i <= n; i++) {
            valid[i][0] = (0 <= valid[i][0] && valid[i][0] <= k);
            valid[i][1] = (0 <= valid[i][1] && valid[i][1] <= k);
        }

        // dbg(valid);


        vector memo(n, vector(n, vector<ll>(2, -1)));
        function<ll(int,int,bool)> go = [&](int i, int bitCnt, bool sameS) -> ll {
            if(i >= n) return (!sameS && valid[bitCnt][false] ? 1LL : 0LL);
            if(memo[i][bitCnt][sameS] >= 0) return memo[i][bitCnt][sameS];
            if(!sameS) {
                return memo[i][bitCnt][sameS] = (go(i + 1, bitCnt + 1, false) + go(i + 1, bitCnt, false)) % MOD;
            }else {
                if(s[i] == '0') {
                    return memo[i][bitCnt][sameS] = go(i + 1, bitCnt, true);
                }else {
                    return memo[i][bitCnt][sameS] = (go(i + 1, bitCnt, false) + go(i + 1, bitCnt + 1, true)) % MOD;
                }
            }
        };


        return int(go(0, 0, true) % MOD);
    }
};

int main1() {
    fastio;
    return 0;
}",1448284740
bramar2,bramar2,377,3646,cpp,"//#pragma GCC optimize(""O3,unroll-loops"")
//#pragma GCC target(""avx2,bmi,bmi2,lzcnt,popcnt"")
#include <bits/stdc++.h>
using namespace std;
// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// using namespace __gnu_pbds;
// template<typename T>
// using ordered_map = tree<T, T, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// template<typename T>
// using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define ll long long
#define ld long double
#define fastio ios::sync_with_stdio(false); cin.tie(nullptr);

#define dbg_stream cout
void __print(int x) {dbg_stream << x;}
void __print(long x) {dbg_stream << x;}
void __print(long long x) {dbg_stream << x;}
void __print(unsigned x) {dbg_stream << x;}
void __print(unsigned long x) {dbg_stream << x;}
void __print(unsigned long long x) {dbg_stream << x;}
void __print(float x) {dbg_stream << x;}
void __print(double x) {dbg_stream << x;}
void __print(long double x) {dbg_stream << x;}
void __print(char x) {dbg_stream << '\'' << x << '\'';}
void __print(const char *x) {dbg_stream << '\""' << x << '\""';}
void __print(const string &x) {dbg_stream << '\""' << x << '\""';}
void __print(bool x) {dbg_stream << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {dbg_stream << '{'; __print(x.first); dbg_stream << ','; __print(x.second); dbg_stream << '}';}
template<typename T>
void __print(const T &x) {int f = 0; dbg_stream << '{'; for (auto &i: x) dbg_stream << (f++ ? "","" : """"), __print(i); dbg_stream << ""}"";}
void _print() {dbg_stream << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) dbg_stream << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define dbg(x...) dbg_stream << ""["" << #x << ""] = [""; _print(x)
#else
#define dbg(x...)
#endif

template <typename T>
void print(T t) { int f = 0; for(const auto& b : t) cout << (f++ ? "" "" : """") << b; cout << '\n'; }
template <typename T>
void print2d(T t) { for(const auto& b : t) { print(b); } }

inline long long mod_exp(long long base, long long exp, long long modd) { unsigned long long ans = 1; base %= modd; while(exp > 0) { if(exp%2==1) ans = (base*ans)%modd; exp /= 2; base = (base*base)%modd; } return ans; }
inline long long factorial(long long n) { long long ans = 1; for(long long i = 2; i <= n; i++) ans *= n; return ans; }
inline long long memo_factorial(long long n) { static vector<int> memo {1,1,2}; if(static_cast<size_t>(n) >= memo.size()) { memo.resize(n+1); for(long long i = memo.size(); i <= n; i++) memo[i] = i*memo[i-1]; } return memo[n]; }
inline long long nCk(int N, int K) { if(K > N) return 0; if(K > N-K) K = N-K; long long ans = 1; for(long long i = 1; i <= K; i++) ans = (ans * (N - (K-i))) / i; return ans; }

const ll MOD = 1e9 + 7;
const ll MOD99 = 998244353;
const ll BIGMOD = pow(2,31)-1;

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        const ll NEUTRAL = -1;

        int n = nums.size(); ll ans = 0;
        map<ll, ll> mp, mp2;
        for(ll i = 0; i < n; i++) {
            ll x = nums[i];
            ans = (ans + x) % MOD;
            if(mp.count(x + 1)) ans = (ans + mp[x + 1]*x) % MOD;
            if(mp.count(x - 1)) ans = (ans + mp[x - 1]*x) % MOD;

            mp[x] = (mp[x] + 1) % MOD;
            if(mp.count(x + 1)) mp[x] = (mp[x] + mp[x + 1]) % MOD;
            if(mp.count(x - 1)) mp[x] = (mp[x] + mp[x - 1]) % MOD;
        }

        for(ll i = n; i --> 0;) {
            ll x = nums[i];
            ans = (ans + x) % MOD;
            if(mp2.count(x + 1)) ans = (ans + mp2[x + 1]*x) % MOD;
            if(mp2.count(x - 1)) ans = (ans + mp2[x - 1]*x) % MOD;

            mp2[x] = (mp2[x] + 1) % MOD;
            if(mp2.count(x + 1)) mp2[x] = (mp2[x] + mp2[x + 1]) % MOD;
            if(mp2.count(x - 1)) mp2[x] = (mp2[x] + mp2[x - 1]) % MOD;
        }
        mp.clear();

        auto rev = [&](ll x) {
            if(mp2.count(x + 1)) mp2[x] = (mp2[x] - mp2[x + 1] + MOD) % MOD;
            if(mp2.count(x - 1)) mp2[x] = (mp2[x] - mp2[x - 1] + MOD) % MOD;
            mp2[x] = (mp2[x] - 1 + MOD) % MOD;
        };
        ++mp[nums[0]];
        rev(nums[0]);
        // dbg(ans);

        for(ll i = 1; i < n; i++) {
            ll x = nums[i];
            // act x as the middle element
            // dbg(mp, mp2);
            for(ll a = -1; a <= 1; a += 2) {
                for(ll b = -1; b <= 1; b += 2) {
                    if(mp.count(x + a) && mp2.count(x + b)) {
                        ll tmp = x * mp[x + a];
                        tmp %= MOD;
                        tmp *= mp2[x + b];
                        tmp %= MOD;
                        // ans += x * mp[x + a] * mp2[x + b];
                        ans = (ans + tmp) % MOD;
                    }
                }
            }
            rev(x);

            mp[x] = (mp[x] + 1) % MOD;
            if(mp.count(x + 1)) mp[x] = (mp[x] + mp[x + 1]) % MOD;
            if(mp.count(x - 1)) mp[x] = (mp[x] + mp[x - 1]) % MOD;
        }

        for(ll i = 0; i < n; i++) {
            ans = (ans - nums[i]) % MOD;
        }
        ans %= MOD; ans += MOD; ans %= MOD;

        return ans;
    }
};

int main1() {
    fastio;
    return 0;
}",1448235002
Mridul Pandey,mridul_cr7,380,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n=nums.size();
        vector<int> st(n,1),en(n,1);
        for(int i=n-2;i>=0;i--)
        {
            if(nums[i]<nums[i+1])
                st[i]=st[i+1]+1;
            
        }
        for(int i=1;i<n;i++)
        {
            if(nums[i]>nums[i-1])
                en[i]=en[i-1]+1;
        }
        int ans=0;
       
        for(int i=1;i<n;i++)
        {
            int mn=min(en[i-1],st[i]);
            ans=max(ans,mn);
        }
        
        return (ans>=k);
    }
};",1448188728
Mridul Pandey,mridul_cr7,380,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n=nums.size();
        vector<int> st(n,1),en(n,1);
        for(int i=n-2;i>=0;i--)
        {
            if(nums[i]<nums[i+1])
                st[i]=st[i+1]+1;
            
        }
        for(int i=1;i<n;i++)
        {
            if(nums[i]>nums[i-1])
                en[i]=en[i-1]+1;
        }
        int ans=0;
       
        for(int i=1;i<n;i++)
        {
            int mn=min(en[i-1],st[i]);
            ans=max(ans,mn);
        }
        return ans;
    }
};",1448186967
Mridul Pandey,mridul_cr7,380,3631,cpp,"int count_setbits(int N)
{ 
   int cnt=0;

   while(N>0)
   {
       cnt+=(N&1);
       N=N>>1;
   }

   return cnt;
}

int cc=0;


class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        
    
        int mod=1e9+7;
        int n=s.size();
        string t=s;
        reverse(t.begin(),t.end());
        vector<vector<vector<int>>> dp(n+1,vector<vector<int>>(n+1,vector<int> (2,0)));
        dp[0][0][1]=1;
        int val=1;
        for(int i=1;i<=n;i++)
        {
            if(t[i-1]=='1')
                val=0;
            dp[i][0][val]=1;
            for(int j=1;j<=i;j++)
            {
                if(t[i-1]=='0')
                {
                    dp[i][j][0]=(dp[i][j][0]+dp[i-1][j][0])%mod;
                    dp[i][j][1]=(dp[i][j][1]+dp[i-1][j][1])%mod;
                }
                else
                {
                    dp[i][j][0]=(dp[i][j][0]+dp[i-1][j][0])%mod;
                    dp[i][j][0]=(dp[i][j][0]+dp[i-1][j][1])%mod;
                }
                if(t[i-1]=='1')
                {
                    dp[i][j][0]=(dp[i][j][0]+dp[i-1][j-1][0])%mod;
                    dp[i][j][1]=(dp[i][j][1]+dp[i-1][j-1][1])%mod;
                }
                else
                {
                    dp[i][j][1]=(dp[i][j][1]+dp[i-1][j-1][0])%mod;
                    dp[i][j][1]=(dp[i][j][1]+dp[i-1][j-1][1])%mod;
                }
                // if(i==n && j==1)
                // {
                //     cout<<dp[i-1][j][0]<<"" ""<<dp[i-1][j][1]<<""\n"";
                // }
            }
        }
        vector<int> st(n+1,0);
      
            st[1]=1;
            for(int i=2;i<=n;i++)
            {
                int num=i;
                int c=1;
                while(num!=1)
                {
                    c++;
                    num=count_setbits(num);
                }
                if(c<=k)
                    st[i]=1;
            }
        int ans=0;
        for(int i=1;i<=n;i++)
        {
            int cnt=dp[n][i][0];
            //cout<<i<<"" ""<<cnt<<""\n"";
            if(st[i]==1)
            {
                ans=(ans+cnt)%mod;
            }
            
        }
        return ans;
    }
};",1448299257
Mridul Pandey,mridul_cr7,380,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int mx=0,mod=1e9+7,ans=0;
        for(auto x:nums)
        {
            mx=max(mx,x);
        }
        vector<int> sum(mx+2,0),count(mx+2,0);
        for(auto x:nums)
        {
            int prev=x-1;
            int nxt=x+1;
            int mn=sum[x];
            int val=(1ll*count[nxt]*1ll*x)%mod;
            sum[x]=(sum[x]+(sum[nxt]+val)%mod)%mod;
            count[x]=(count[x]+count[nxt])%mod;
            if(prev>=0)
            {
                int val=(1ll*count[prev]*1ll*x)%mod;
                sum[x]=(sum[x]+(sum[prev]+val)%mod)%mod;
                count[x]=(count[x]+count[prev])%mod;
            }
            sum[x] = (sum[x] + x)%mod;
            count[x] = (count[x] + 1)%mod;
            ans=(ans+sum[x])%mod;
            ans=((ans-mn)+mod)%mod;
        }
        return ans;
    }
};",1448222575
Ashutosh Singh,AshutoshSingh10,382,3612,cpp,"

	#include <bits/stdc++.h>
	using namespace std;
	using std::cout;
	using std::cin;
	#define endl '\n'    
	#define Endl '\n'    
	#define ll long long
	#define loop(i,a,b) for(long long i=a;i<b;i++)
	#define roop(i,a,b) for(long long i=a-1;i>=b;i--)
	#define all(p) p.begin(),p.end()
	#define pb(p) push_back(p);
	long long pop_count(long long a){int res=0;while(a){res+=(a&1),a>>=1;}return res;}
	template<class T> using _pq = priority_queue<T>;
	template<class T> using _pqr = priority_queue<T, vector<T>, greater<T>>;
	template<class T> void So(vector<T> &v) {sort(v.begin(),v.end());}
	template<class T> void Sore(vector<T> &v) {sort(v.begin(),v.end(),[](T x,T y){return x>y;});}
	#include <ext/pb_ds/assoc_container.hpp>
	#include <ext/pb_ds/tree_policy.hpp>
	using namespace __gnu_pbds;
	#include<iostream>
	template <class T> using OrderSet = tree<T, null_type, 
	less<T>, rb_tree_tag,tree_order_statistics_node_update>;
	ll lcm(ll a, ll b){return (a/__gcd(a,b)*b);}
	const ll INF= LONG_LONG_MAX;
	int mod=1e9+7;


	class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
		int cnt=1;;
		int n=nums.size();
		vector<int> vec;
		for(int i=1;i<n;i++)
		{
			if(nums[i]>nums[i-1])
			{
				cnt++;
			}
			else 
			{
				vec.push_back(cnt);
				cnt=1;
			}

		}
        vec.push_back(cnt);
		int ans=vec[0]/2;
		for(int i=1;i<vec.size();i++)
		{
			ans=max(ans,vec[i]/2);
			ans=max(ans,min(vec[i],vec[i-1]));
		}
		return ans>=k;
	
        
    }
};
",1448198789
Ashutosh Singh,AshutoshSingh10,382,3619,cpp,"	#include <bits/stdc++.h>
	using namespace std;
	using std::cout;
	using std::cin;
	#define endl '\n'    
	#define Endl '\n'    
	#define ll long long
	#define loop(i,a,b) for(long long i=a;i<b;i++)
	#define roop(i,a,b) for(long long i=a-1;i>=b;i--)
	#define all(p) p.begin(),p.end()
	#define pb(p) push_back(p);
	long long pop_count(long long a){int res=0;while(a){res+=(a&1),a>>=1;}return res;}
	template<class T> using _pq = priority_queue<T>;
	template<class T> using _pqr = priority_queue<T, vector<T>, greater<T>>;
	template<class T> void So(vector<T> &v) {sort(v.begin(),v.end());}
	template<class T> void Sore(vector<T> &v) {sort(v.begin(),v.end(),[](T x,T y){return x>y;});}
	#include <ext/pb_ds/assoc_container.hpp>
	#include <ext/pb_ds/tree_policy.hpp>
	using namespace __gnu_pbds;
	#include<iostream>
	template <class T> using OrderSet = tree<T, null_type, 
	less<T>, rb_tree_tag,tree_order_statistics_node_update>;
	ll lcm(ll a, ll b){return (a/__gcd(a,b)*b);}
	const ll INF= LONG_LONG_MAX;
	int mod=1e9+7;


	class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
		int cnt=1;;
		int n=nums.size();
		vector<int> vec;
		for(int i=1;i<n;i++)
		{
			if(nums[i]>nums[i-1])
			{
				cnt++;
			}
			else 
			{
				vec.push_back(cnt);
				cnt=1;
			}

		}
        vec.push_back(cnt);
		int ans=vec[0]/2;
		for(int i=1;i<vec.size();i++)
		{
			ans=max(ans,vec[i]/2);
			ans=max(ans,min(vec[i],vec[i-1]));
		}
		return ans;
	
        
    }
};
",1448196965
Ashutosh Singh,AshutoshSingh10,382,3631,cpp,"		#include <bits/stdc++.h>
		using namespace std;
		using std::cout;
		using std::cin;
		#define endl '\n'    
		#define Endl '\n'    
		#define ll long long
		#define loop(i,a,b) for(long long i=a;i<b;i++)
		#define roop(i,a,b) for(long long i=a-1;i>=b;i--)
		#define all(p) p.begin(),p.end()
		#define pb(p) push_back(p);
		long long pop_count(long long a){int res=0;while(a){res+=(a&1),a>>=1;}return res;}
		template<class T> using _pq = priority_queue<T>;
		template<class T> using _pqr = priority_queue<T, vector<T>, greater<T>>;
		template<class T> void So(vector<T> &v) {sort(v.begin(),v.end());}
		template<class T> void Sore(vector<T> &v) {sort(v.begin(),v.end(),[](T x,T y){return x>y;});}
		#include <ext/pb_ds/assoc_container.hpp>
		#include <ext/pb_ds/tree_policy.hpp>
		using namespace __gnu_pbds;
		#include<iostream>
		template <class T> using OrderSet = tree<T, null_type, 
		less<T>, rb_tree_tag,tree_order_statistics_node_update>;
		ll lcm(ll a, ll b){return (a/__gcd(a,b)*b);}
		const ll INF= LONG_LONG_MAX;
		int mod=1e9+7;



int ca(ll x,ll k)
{
    while(k>0 && x>1)
    {
        ll temp=0;
        while(x>0)
        {
            if(x&1) temp++;
            x>>=1;
        }
        x=temp;
        k--;
    }
    return x==1;
}
class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
		ll sz=s.length();
		
		ll bitsfound=0;
		map<ll,ll> mp;
        ll x=sz+10;
    vector<vector<ll>> vec(x+1,vector<ll> (x+1,0));
    vec[0][0]=1;
	for(ll i=1;i<=x;i++)
	{
		for(ll j=0;j<=x;j++)
		{
			vec[i][j]=vec[i-1][j];
		}
		for(ll j=1;j<=x;j++)
		{
			vec[i][j]=(vec[i-1][j-1]+vec[i][j])%mod;
		}
	}

        
		for(int i=0;i<sz;i++)
		{
			if(s[i]=='1')
			{
                for(ll j=0;j<=sz-i-1;j++)
            	{
            		mp[j+bitsfound]=(mp[j+bitsfound]+vec[sz-i-1][j])%mod;
            	}
				bitsfound++;
			}
		}
        ll ans=0;
        for(auto &[a,b]:mp)
            {
                // cout<<a<<"" ""<<b;
                if(ca(a,k-1)) 
                {
                    // cout<<"" YES"";
                    ans=(ans+b)%mod;
                }
                // cout<<endl;
            }
		
		return ans;
        
    }
};",1448279834
Ashutosh Singh,AshutoshSingh10,382,3646,cpp,"		#include <bits/stdc++.h>
		using namespace std;
		using std::cout;
		using std::cin;
		#define endl '\n'    
		#define Endl '\n'    
		#define ll long long
		#define loop(i,a,b) for(long long i=a;i<b;i++)
		#define roop(i,a,b) for(long long i=a-1;i>=b;i--)
		#define all(p) p.begin(),p.end()
		#define pb(p) push_back(p);
		long long pop_count(long long a){int res=0;while(a){res+=(a&1),a>>=1;}return res;}
		template<class T> using _pq = priority_queue<T>;
		template<class T> using _pqr = priority_queue<T, vector<T>, greater<T>>;
		template<class T> void So(vector<T> &v) {sort(v.begin(),v.end());}
		template<class T> void Sore(vector<T> &v) {sort(v.begin(),v.end(),[](T x,T y){return x>y;});}
		#include <ext/pb_ds/assoc_container.hpp>
		#include <ext/pb_ds/tree_policy.hpp>
		using namespace __gnu_pbds;
		#include<iostream>
		template <class T> using OrderSet = tree<T, null_type, 
		less<T>, rb_tree_tag,tree_order_statistics_node_update>;
		ll lcm(ll a, ll b){return (a/__gcd(a,b)*b);}
		const ll INF= LONG_LONG_MAX;
		int mod=1e9+7;
class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
		map<ll,ll> cnt;
		map<ll,ll> sum;
		ll ans=0;
		for(auto &i:nums)
		{
			ll el=i;
			ll cursum=el;
			ll end=1;
			if(cnt.count(el-1))
			{
				cursum=(cursum+sum[el-1])%mod;
                ll temp=(el*cnt[el-1])%mod;
                cursum=(cursum+temp)%mod;
				end=(end+cnt[el-1])%mod;
				
			}
			if(cnt.count(el+1))
			{
				cursum=(cursum+sum[el+1])%mod;
                ll temp=(el*cnt[el+1])%mod;
                cursum=(cursum+temp)%mod;
				end=(end+cnt[el+1])%mod;
				
			}
		
			cnt[el]=(cnt[el]+end)%mod;
			sum[el]=(sum[el]+cursum)%mod;
			ans=(ans+cursum)%mod;
		}
		return ans;
        
    }
};",1448219604
ssk4988,ssk4988,385,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        for i in range(len(nums)):
            if i + k + k > len(nums): break
            a = True
            b = True
            for j in range(k-1):
                if nums[i + j] >= nums[i + j + 1]: a = False
                if nums[i + j + k] >= nums[i + j + k + 1]: b = False
            if a and b: return True
        return False",1448273190
ssk4988,ssk4988,385,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        dp = [0] * len(nums)
        ans = 1
        n = len(nums)
        for i in range(n)[::-1]:
            if i + 1 >= n: continue
            if nums[i] < nums[i+1]: dp[i] = 1 + dp[i+1]
            v = dp[i]
            ans = max(ans, (v+1) // 2)
            if i + v + 1 < n:
                u = dp[i + v + 1]
                ans = max(ans, 1+min(u, v))
        return ans",1448280513
ssk4988,ssk4988,385,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        if len(s) == 1:
            return 0
        s = list(map(int, s))
        n = len(s)
        # print(s)
        @cache
        def conv(v):
            if v <= 1: return 0
            return 1 + conv(Counter(bin(v))[""1""])
        mod = 1000000007
        @cache
        def dp(idx, pref, c1):
            if idx == n:
                if pref: return 0
                req = conv(c1)
                # if c1 > 1: req += 1
                return req < k
            ans = 0
            for i in range(1 + (s[idx] if pref else 1)):
                ans += dp(idx+1, pref and i == s[idx], c1 + i)
            # print(idx, pref, c1, ans % mod)
            return ans % mod
        return (dp(0, True, 0)-1) % mod",1448300296
ssk4988,ssk4988,385,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        N = 100100
        ways = [0] * N
        sm = [0] * N
        mod = 1000000007
        for v in nums:
            ways[v] += 1
            sm[v] += v
            for d in [-1, 1]:
                if v+d<0: continue
                ways[v] += ways[v+d]
                sm[v] += ways[v+d] * v
                sm[v] += sm[v+d]
                ways[v] %= mod
                sm[v] %= mod
        ans = 0
        # print(sm[:5], ways[:5])
        for i in range(len(sm)):
            ans += sm[i]
            ans %= mod
        return ans",1448290227
Haksell,Haksell,390,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        f = lambda a: all(y>x for x,y in zip(a, a[1:]))
        return any(f(nums[i:i+k]) and f(nums[i+k:i+k+k]) for i in range(len(nums) - 2*k + 1))",1448182049
Haksell,Haksell,390,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        last = [0] * len(nums)
        j = 0
        m = -(1<<30)
        for i, n in enumerate(nums):
            if n <= m:
                j=i
            m=n
            last[i] = j
        groups = [sum(1 for _ in v) for _, v in groupby(last)]
        res=[g//2 for g in groups]+[min(g1,g2) for g1,g2 in zip(groups, groups[1:])]
        # print(last, groups, res)
        return max(res)",1448189254
Haksell,Haksell,390,3631,python3,"MOD=1_000_000_007

# def naive(n, k):
#     def valid(n, k):
#         if k==0:
#             return n==1
#         return valid(bin(n).count(""1""), k-1)
        
#     return sum(valid(i, k) for i in range(1, n))

# for n in [1<<1, 1<<2, 1<<4, 1<<8, 1<<16]:
#     print([naive(n, k) for k in range(1, 6)])

""""""
[1, 1, 1, 1, 1]
[2, 3, 3, 3, 3]
[4, 11, 15, 15, 15]
[8, 107, 247, 255, 255]
[16, 14827, 49047, 65535, 65535]
""""""

def f(s, n):
    if n==0: return 1
    if s==""1"": return 0
    res = comb(len(s)-1, n)
    for i in range(1, len(s)):
        if s[i]==""1"":
            res += f(s[i:], n-1)
            break
    return res % MOD

class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        if len(s)==1:
            return 0
        queue={1}
        for _ in range(k-1):
            queue={i for i in range(1, 801) if bin(i).count(""1"") in queue}
        queue=sorted(queue)
        # print([(i, f(s, i)) for i in queue])
        return sum(f(s, i) for i in queue)%MOD

# smod=0
# for c in s:
#     smod*=2
#     smod+=c==""1""
#     smod%=MOD
""""""

1*127
1111111
111
11
10
1
""""""",1448294672
Haksell,Haksell,390,3646,python3,"MOD=1_000_000_007

class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        cnt=defaultdict(int)
        dp=defaultdict(int)
        for i, n in enumerate(nums):
            dp[n]+=n*(1+cnt[n+1]+cnt[n-1])+dp[n+1]+dp[n-1]
            cnt[n]+=1+cnt[n+1]+cnt[n-1]
            dp[n]%=MOD
            cnt[n]%=MOD
        return sum(dp.values())%MOD",1448210455
i_will_beat_my_iq,i_will_beat_my_iq,391,3612,cpp,"class Solution {
public:
 vector<int> f2_precompute_inc(vector<int>& a, int n) {
        vector<int> inc(n, 1);
        for (int i = n - 2; i >= 0; --i) {
            inc[i] = (a[i] < a[i + 1]) ? inc[i + 1] + 1 : 1;
        }
        return inc;
    }

    bool f3_check_adjacent(vector<int>& inc, int b, int n) {
        for (int i = 0; i + 2 * b <= n; ++i) {
            if (inc[i] >= b && inc[i + b] >= b) {
                return true;
            }
        }
        return false;
    }
    bool hasIncreasingSubarrays(vector<int>& a, int b) {
        int n = a.size();
        
        if (2 * b > n) return false;
        
        vector<int> inc = f2_precompute_inc(a, n);
        
        return f3_check_adjacent(inc, b, n);
    }
};",1448287348
i_will_beat_my_iq,i_will_beat_my_iq,391,3619,cpp,"class Solution {
public:
vector<int> f2_inc_lengths(vector<int>& a, int n) {
        vector<int> inc(n, 1);
        for (int i = n - 2; i >= 0; --i) {
            if (a[i] < a[i + 1]) {
                inc[i] = inc[i + 1] + 1;
            } else {
                inc[i] = 1;
            }
        }
        return inc;
    }

    int f3_max_k(vector<int>& inc, int n) {
        int l = 1, r = n / 2, mx_k = 0;

        while (l <= r) {
            int m = l + (r - l) / 2;
            bool found = false;

            for (int i = 0; i + 2 * m <= n; ++i) {
                if (inc[i] >= m && inc[i + m] >= m) {
                    found = true;
                    break;
                }
            }
            
            if (found) {
                mx_k = m;
                l = m + 1;
            } else {
                r = m - 1;
            }
        }

        return mx_k;
    }
    int maxIncreasingSubarrays(vector<int>& a) {
        int n = a.size();
        if (n < 2) return 0;

        vector<int> inc = f2_inc_lengths(a, n);
        
        return f3_max_k(inc, n);
    }
};",1448278203
i_will_beat_my_iq,i_will_beat_my_iq,391,3631,cpp,"class Solution {
public:
vector<int> f2_compute_steps(int MX) {
        vector<int> steps(MX + 1, -1);
        steps[1] = 0;

        for (int x = 1; x <= MX; ++x) {
            if (steps[x] == -1) {
                int cnt = 0, cur = x;
                vector<int> path;

                while (cur != 1 && (cur > MX || steps[cur] == -1)) {
                    path.push_back(cur);
                    cur = __builtin_popcount(cur);
                    cnt++;
                }
                if (cur <= MX) cnt += steps[cur];

                f7_assign_steps(steps, path, cnt);
            }
        }
        return steps;
    }

    vector<vector<vector<long>>> f3_init_memo(int n) {
        return vector<vector<vector<long>>>(n + 1, vector<vector<long>>(n + 1, vector<long>(2, -1)));
    }

    long f4_dp(int p, int sb, int t, int n, const string& a, int b, const vector<int>& steps, vector<vector<vector<long>>>& memo) {
        const int MOD = 1e9 + 7;
        if (p == n) return (sb >= 1 && sb <= 1000 && steps[sb] <= b - 1) ? 1 : 0;

        if (memo[p][sb][t] != -1) return memo[p][sb][t];

        int limit = t ? (a[p] - '0') : 1;
        long res = 0;

        for (int bit = 0; bit <= limit; ++bit) {
            int nt = t && (bit == limit);
            int nsb = sb + bit;
            res = (res + f4_dp(p + 1, nsb, nt, n, a, b, steps, memo)) % MOD;
        }

        return memo[p][sb][t] = res;
    }

    int f5_count_set_bits(const string& a) {
        return count(a.begin(), a.end(), '1');
    }

    bool f6_is_reducible(int sb, int k, const vector<int>& steps, int MX) {
        int steps_n = (sb <= MX) ? 1 + steps[sb] : 2;
        return (sb >= 1 && steps_n <= k);
    }

    void f7_assign_steps(vector<int>& steps, vector<int>& path, int cnt) {
        for (auto it = path.rbegin(); it != path.rend(); ++it) {
            if (*it < steps.size()) steps[*it] = cnt;
            cnt--;
        }
    }
    int countKReducibleNumbers(string a, int b) {
        const int MX = 1000, MOD = 1e9 + 7;

        vector<int> steps = f2_compute_steps(MX);
        int n = a.size();

        vector<vector<vector<long>>> memo = f3_init_memo(n);

        long total = f4_dp(0, 0, 1, n, a, b, steps, memo);

        int sb = f5_count_set_bits(a);
        bool is_reducible = f6_is_reducible(sb, b, steps, MX);

        if (is_reducible) {
            total = (total - 1 + MOD) % MOD;
        }

        return (total % MOD);
    }
};",1448301396
i_will_beat_my_iq,i_will_beat_my_iq,391,3646,cpp,"class Solution {
public:
using ll = long long;
int f2(vector<int>& a) {
        int mx = 0;
        for (auto x : a) {
            if (x > mx) mx = x;
        }
        return mx;
    }
    
    ll f3(vector<ll>& c, int i) {
        return (i >= 0 ? c[i] : 0);
    }

    ll f4(vector<ll>& s, vector<ll>& c, int i, int x) {
        ll ls = (i >= 0 ? s[i] : 0);
        ll lc = (i >= 0 ? c[i] : 0);
        return ls + (lc * (ll)x) % 1000000007;
    }
    
    int f5(vector<ll>& s) {
        const int M = 1000000007;
        ll ans = 0;
        for (auto v : s) {
            ans = (ans + v) % M;
        }
        return ans;
    }
    int sumOfGoodSubsequences(vector<int>& a) {
        const int M = 1000000007;
        int mx = f2(a);
        
        vector<ll> c(mx + 2, 0);
        vector<ll> s(mx + 2, 0);

        for (auto x : a) {
            ll nc = (f3(c, x - 1) + c[x + 1] + 1) % M;
            ll ns = (f4(s, c, x - 1, x) + s[x + 1] + (c[x + 1] * (ll)x) % M + x) % M;

            c[x] = (c[x] + nc) % M;
            s[x] = (s[x] + ns) % M;
        }

        return f5(s);
    }
};",1448275554
amez,amezzz,394,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        valid = True
        for i in range(n - 2 * k + 1):
            valid = True
            for j in range(i, i + k - 1):
                if not nums[j] < nums[j + 1]:
                    valid = False
            for j in range(i + k, i + 2 * k - 1):
                if not nums[j] < nums[j + 1]:
                    valid = False
            if valid:
                return True
        return valid",1448194086
amez,amezzz,394,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        vals = []
        n = len(nums)
        p = 0
        while p < n:
            start = p
            p += 1
            while p < n and nums[p] > nums[p - 1]:
                p += 1
            vals.append(p - start)
        ans = max(a // 2 for a in vals)
        for a, b in pairwise(vals):
            ans = max(ans, min(a, b))
        return ans
            
        ",1448200256
amez,amezzz,394,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:

        def check(num, t):
            while num > 1 and t > 0:
                num = bin(num).count('1')
                t -= 1
            return num <= 1

        @cache
        def dfs(p, cnt, free, start):
            if p == n:
                return 1 if check(cnt, k - 1) and free else 0
            ans = 0
            if not start:
                ans = dfs(p + 1, cnt, True, False)
            if free:
                if start:
                    ans += dfs(p + 1, cnt, True, True)
                    ans %= mod
                ans += dfs(p + 1, cnt + 1, True, True)
            else:
                if start:
                    if int(s[p]) == 1:
                        ans += dfs(p + 1, cnt, True, True)
                        ans %= mod
                    else:
                        ans += dfs(p + 1, cnt, False, True)
                        ans %= mod
                if int(s[p]) == 1:
                    ans += dfs(p + 1, cnt + 1, False, True)
                    ans %= mod
            return ans

        n = len(s)
        mod = 10 ** 9 + 7
        return dfs(0, 0, False, False) - 1

        
        ",1448289322
amez,amezzz,394,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        mod = 10 ** 9 + 7
        count_dp = defaultdict(int)
        sum_dp = defaultdict(int)
        total_sum = 0

        for num in nums:
            count = 1 
            total = num  

            for diff in [-1, 1]:
                prev_num = num - diff
                if prev_num in count_dp:
                    count += count_dp[prev_num]
                    total += sum_dp[prev_num] + count_dp[prev_num] * num
                    total %= mod 

            count_dp[num] = (count_dp[num] + count) % mod
            sum_dp[num] = (sum_dp[num] + total) % mod
            total_sum = (total_sum + total) % mod

        return total_sum
",1448260889
Sarthak Mathur,WORTH_IT,395,3612,java,"// import java.util.*;
// import java.util.function.*;

// public class Main {
//     public static void main(String[] args) throws Exception {
//         System.out.println(new Solution().solve());
//     }
// }

class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        if (k == 1)
            return true;

        int n = nums.size();

        IntPredicate check = new IntPredicate() {
            @Override
            public boolean test(int i) {
                for (int j = 0; j < k - 1; j++) {
                    if (i + j + 1 >= n)
                        return false;

                    if (nums.get(i + j + 1) <= nums.get(i + j))
                        return false;
                }
                return true;
            }
        };

        for (int i = 0; i < n; i++) {
            if (check.test(i) && check.test(i + k))
                return true;
        }
        return false;
    }
}",1448188085
Sarthak Mathur,WORTH_IT,395,3619,java,"// import java.util.*;
// import java.util.function.*;

// public class Main {
//     public static void main(String[] args) throws Exception {
//         System.out.println(new Solution().solve());
//     }
// }

class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        ArrayList<Integer> sizes = new ArrayList<>();
        int n = nums.size(), l = 0, r;
        while (l < n) {
            r = l + 1;
            while (r < n && nums.get(r) > nums.get(r - 1))
                r++;

            sizes.add(r - l);
            l = r;
        }

        int k = Math.max(1, sizes.get(sizes.size() - 1) >> 1);
        for (int i = 0; i < sizes.size() - 1; i++) {
            k = Math.max(k, sizes.get(i) >> 1);
            k = Math.max(k, Math.min(sizes.get(i), sizes.get(i + 1)));
        }

        return k;
    }
}",1448194093
Sarthak Mathur,WORTH_IT,395,3631,java,"// import java.util.*;
// import java.util.function.*;

// public class Main {
//     public static void main(String[] args) throws Exception {
//         System.out.println(new Solution().countKReducibleNumbers(""111"", 1));
//         System.out.println(new Solution().countKReducibleNumbers(""1000"", 2));
//     }
// }

class Solution {
    static int N = 801;
    static int[] ops = new int[N];

    static {
        for (int i = 2; i < N; i++)
            ops[i] = ops[Integer.bitCount(i)] + 1;
    }

    public int countKReducibleNumbers(String s, int k) {
        int n = s.length();

        // dp[i][set][tight] = Number of suffixes of length i
        Mint[][][] dp = new Mint[n + 1][N][2];
        TriFunction<Integer, Integer, Integer, Mint> solve = new TriFunction<Integer, Integer, Integer, Mint>() {
            @Override
            public Mint apply(Integer i, Integer set, Integer tight) {
                if (set < 0)
                    return Mint.ZERO;

                if (dp[i][set][tight] != null)
                    return dp[i][set][tight];

                if (i == 0) {
                    if (set == 0)
                        return dp[i][set][tight] = Mint.ONE;
                    return dp[i][set][tight] = Mint.ZERO;
                }

                Mint ans = Mint.ZERO;
                if (s.charAt(n - i) == '0' && tight == 1) {
                    ans = ans.add(apply(i - 1, set, tight));
                } else {
                    ans = ans.add(apply(i - 1, set - 1, tight));
                    ans = ans.add(apply(i - 1, set, 0));
                }

                return dp[i][set][tight] = ans;
            }
        };

        Mint ans = Mint.ZERO;
        for (int i = 1; i <= n; i++) {
            if (ops[i] + 1 <= k)
                ans = ans.add(solve.apply(n, i, 1));
        }

        int count = 0;
        for (int i = 0; i < n; i++)
            count += s.charAt(i) - '0';
        if (ops[count] + 1 <= k)
            ans = ans.sub(1);
        return (int) ans.get();
    }
}

@FunctionalInterface
interface TriFunction<One, Two, Three, Return> {
    public Return apply(One one, Two two, Three three);
}

@FunctionalInterface
interface TetraFunction<One, Two, Three, Four, Return> {
    public Return apply(One one, Two two, Three three, Four four);
}

@FunctionalInterface
interface PentaFunction<One, Two, Three, Four, Five, Return> {
    public Return apply(One one, Two two, Three three, Four four, Five five);
}

final class Mint { // 1000000007 998244353
    public static long mod = 1000000007;
    public static boolean modIsPrime = true;
    private final long val;

    public static final Mint ZERO = new Mint(0L);
    public static final Mint ONE = new Mint(1L);

    public static long norm(long val) {
        return (val %= mod) < 0 ? val + mod : val;
    }

    public static long norm(Integer val) {
        return norm(val.longValue());
    }

    public Mint(long val) {
        this.val = norm(val);
    }

    public Mint() {
        this(0);
    }

    public Mint(Mint arg) {
        this(arg.val);
    }

    public Mint(Integer arg) {
        this(arg.longValue());
    }

    public long get() {
        return val;
    }

    public Mint add(long arg) {
        return new Mint(this.val + norm(arg));
    }

    public Mint add(Mint arg) {
        return add(arg.val);
    }

    public Mint add(Integer arg) {
        return add(arg.longValue());
    }

    public Mint add(long... args) {
        Mint sum = this;
        for (long a : args)
            sum = sum.add(a);
        return sum;
    }

    public Mint add(Mint... args) {
        Mint sum = this;
        for (Mint a : args)
            sum = sum.add(a);
        return sum;
    }

    public Mint add(Integer... args) {
        Mint sum = this;
        for (Integer a : args)
            sum = sum.add(a);
        return sum;
    }

    public Mint sub(long arg) {
        return new Mint(val - norm(arg));
    }

    public Mint sub(Mint arg) {
        return sub(arg.val);
    }

    public Mint sub(Integer arg) {
        return sub(arg.longValue());
    }

    public Mint mul(long arg) {
        return new Mint(this.val * norm(arg));
    }

    public Mint mul(Mint arg) {
        return mul(arg.val);
    }

    public Mint mul(Integer arg) {
        return mul(arg.longValue());
    }

    public Mint mul(long... args) {
        Mint product = this;
        for (long a : args)
            product = product.mul(norm(a));
        return product;
    }

    public Mint mul(Mint... args) {
        Mint product = this;
        for (Mint a : args)
            product = product.mul(a);
        return product;
    }

    public Mint mul(Integer... args) {
        Mint product = this;
        for (Integer a : args)
            product = product.mul(norm(a));
        return product;
    }

    public Mint div(Mint arg) {
        return mul(arg.inv());
    }

    public Mint div(long arg) {
        return div(new Mint(arg));
    }

    public Mint div(Integer arg) {
        return div(new Mint(arg));
    }

    public Mint inv() {
        if (!modIsPrime)
            throw new ArithmeticException(val + "" cannot have inverse with mod "" + mod + ""!"");
        return pow(mod - 2);
    }

    public Mint pow(long arg) {
        if (arg < 0)
            return pow(-arg).inv();
        Mint pow = Mint.ONE;
        Mint temp = this;
        while (arg > 0) {
            if ((arg & 1) == 1)
                pow = pow.mul(temp);
            temp = temp.mul(temp);
            arg = arg >> 1;
        }
        return pow;
    }

    public Mint pow(Mint arg) {
        return pow(arg.val);
    }

    public Mint pow(Integer arg) {
        return pow(arg.longValue());
    }

    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;
        Mint mint = (Mint) o;
        return val == mint.val;
    }

    @Override
    public String toString() {
        return Long.toString(val);
    }
}",1448302838
Sarthak Mathur,WORTH_IT,395,3646,java,"// import java.util.*;
// import java.util.function.*;

// public class Main {
//     public static void main(String[] args) throws Exception {
//         System.out.println(new Solution().sumOfGoodSubsequences(new int[]{1, 2, 1}));
//         System.out.println(new Solution().sumOfGoodSubsequences(new int[]{3, 4, 5}));
//     }
// }

class Solution {
    public int sumOfGoodSubsequences(int[] nums) {
        int n = nums.length;

        HashMap<Integer, Mint> sum = new HashMap<>();
        HashMap<Integer, Mint> count = new HashMap<>();
        for (int x : nums) {
            Mint s = Mint.ZERO;
            s = s.add(sum.getOrDefault(x - 1, Mint.ZERO));
            s = s.add(sum.getOrDefault(x + 1, Mint.ZERO));

            Mint c = Mint.ONE;
            c = c.add(count.getOrDefault(x - 1, Mint.ZERO));
            c = c.add(count.getOrDefault(x + 1, Mint.ZERO));

            s = s.add(new Mint(x).mul(c));
            sum.put(x, sum.getOrDefault(x, Mint.ZERO).add(s));
            count.put(x, count.getOrDefault(x, Mint.ZERO).add(c));
        }

        Mint ans = Mint.ZERO;
        for (var asd : sum.values())
            ans = ans.add(asd);

        return (int) ans.get();
    }
}

final class Mint { // 1000000007 998244353
    public static long mod = 1000000007;
    public static boolean modIsPrime = true;
    private final long val;

    public static final Mint ZERO = new Mint(0L);
    public static final Mint ONE = new Mint(1L);

    public static long norm(long val) {
        return (val %= mod) < 0 ? val + mod : val;
    }

    public static long norm(Integer val) {
        return norm(val.longValue());
    }

    public Mint(long val) {
        this.val = norm(val);
    }

    public Mint() {
        this(0);
    }

    public Mint(Mint arg) {
        this(arg.val);
    }

    public Mint(Integer arg) {
        this(arg.longValue());
    }

    public long get() {
        return val;
    }

    public Mint add(long arg) {
        return new Mint(this.val + norm(arg));
    }

    public Mint add(Mint arg) {
        return add(arg.val);
    }

    public Mint add(Integer arg) {
        return add(arg.longValue());
    }

    public Mint add(long... args) {
        Mint sum = this;
        for (long a : args)
            sum = sum.add(a);
        return sum;
    }

    public Mint add(Mint... args) {
        Mint sum = this;
        for (Mint a : args)
            sum = sum.add(a);
        return sum;
    }

    public Mint add(Integer... args) {
        Mint sum = this;
        for (Integer a : args)
            sum = sum.add(a);
        return sum;
    }

    public Mint sub(long arg) {
        return new Mint(val - norm(arg));
    }

    public Mint sub(Mint arg) {
        return sub(arg.val);
    }

    public Mint sub(Integer arg) {
        return sub(arg.longValue());
    }

    public Mint mul(long arg) {
        return new Mint(this.val * norm(arg));
    }

    public Mint mul(Mint arg) {
        return mul(arg.val);
    }

    public Mint mul(Integer arg) {
        return mul(arg.longValue());
    }

    public Mint mul(long... args) {
        Mint product = this;
        for (long a : args)
            product = product.mul(norm(a));
        return product;
    }

    public Mint mul(Mint... args) {
        Mint product = this;
        for (Mint a : args)
            product = product.mul(a);
        return product;
    }

    public Mint mul(Integer... args) {
        Mint product = this;
        for (Integer a : args)
            product = product.mul(norm(a));
        return product;
    }

    public Mint div(Mint arg) {
        return mul(arg.inv());
    }

    public Mint div(long arg) {
        return div(new Mint(arg));
    }

    public Mint div(Integer arg) {
        return div(new Mint(arg));
    }

    public Mint inv() {
        if (!modIsPrime)
            throw new ArithmeticException(val + "" cannot have inverse with mod "" + mod + ""!"");
        return pow(mod - 2);
    }

    public Mint pow(long arg) {
        if (arg < 0)
            return pow(-arg).inv();
        Mint pow = Mint.ONE;
        Mint temp = this;
        while (arg > 0) {
            if ((arg & 1) == 1)
                pow = pow.mul(temp);
            temp = temp.mul(temp);
            arg = arg >> 1;
        }
        return pow;
    }

    public Mint pow(Mint arg) {
        return pow(arg.val);
    }

    public Mint pow(Integer arg) {
        return pow(arg.longValue());
    }

    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;
        Mint mint = (Mint) o;
        return val == mint.val;
    }

    @Override
    public String toString() {
        return Long.toString(val);
    }
}",1448243383
DestinyGod,DestinyGod,397,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        d=[0]*len(nums)
        for i in range(len(nums)-1):
            if nums[i+1]>nums[i]:
                d[i]=1
        c=0
        for i in range(len(nums)-1,-1,-1):
            if d[i]:
                c+=1
                d[i]=c
            else:
                c=0
        for i in range(0,len(nums)-k):
            if d[i]>=k-1 and d[i+k]>=k-1:
                return True
        return False",1448194440
DestinyGod,DestinyGod,397,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        l=0
        r=10**6
        def check(k:int):
            d=[0]*len(nums)
            for i in range(len(nums)-1):
                if nums[i+1]>nums[i]:
                    d[i]=1
            c=0
            for i in range(len(nums)-1,-1,-1):
                if d[i]:
                    c+=1
                    d[i]=c
                else:
                    c=0
            for i in range(0,len(nums)-k):
                if d[i]>=k-1 and d[i+k]>=k-1:
                    return True
            return False
        while l<r:
            mid=(l+r+1)//2
            if check(mid):
                l=mid
            else:
                r=mid-1
        return l",1448197829
DestinyGod,DestinyGod,397,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        mod=10**9+7
        dp=[0]*801
        for i in range(1,801):
            c=0
            x=i
            while i>0:
                c+=(i&1)
                i>>=1
            dp[x]=dp[c]+1
        @cache
        def dfs(cnt:int,limit:int,i:int):
            if i==len(s):
                return (dp[cnt]<=k)&(cnt!=0)&(limit==0)
            if limit:
                if s[i]=='0':
                    return dfs(cnt,1,i+1)
                else:
                    return (dfs(cnt,0,i+1)+dfs(cnt+1,1,i+1))%mod
            else:
                return (dfs(cnt,0,i+1)+dfs(cnt+1,0,i+1))%mod
        return dfs(0,1,0)",1448290110
DestinyGod,DestinyGod,397,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        dp={}
        cnt={}
        res=0
        mod=10**9+7
        for i in nums:
            if i not in dp:
                dp[i]=0
                cnt[i]=0
            c=1
            sum=0
            if i-1 in dp:
                sum+=dp[i-1]
                c+=cnt[i-1]
            if i+1 in dp:
                sum+=dp[i+1]
                c+=cnt[i+1]
            sum=(sum+(c*i)%mod)%mod
            cnt[i]+=c
            cnt[i]%=mod
            res+=sum
            res%=mod
            dp[i]+=sum
            dp[i]%=mod
        return res",1448227609
lovesbumblebees,lovesbumblebees,398,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        if(k == 1) {
            return true;
        }
        // search forward
        vector<bool> forward(nums.size(), false);
        int count = 1;
        for(int i = 1; i < nums.size(); i++) {
            if(nums[i] > nums[i - 1]) {
                count++;
                if(count >= k) {
                    forward[i] = true;
                }
            } else {
                // reset the count
                count = 1;
            }
        }
        // search backward
        // vector<bool> backward(nums.size(), false);
        count = 1;
        for(int i = nums.size() - 2; i >= 0; i--) {
            if(nums[i] < nums[i + 1]) {
                count++;
                if(count >= k) {
                    //backward[i] = true;
                    if(i > 0 && forward[i - 1]) {
                        return true;
                    }
                }
            } else {
                // reset the count
                count = 1;
            }
        }
        return false;
        
    }
};",1448195169
lovesbumblebees,lovesbumblebees,398,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        // search forward
        vector<int> forward(nums.size(), 1);
        int count = 1;
        for(int i = 1; i < nums.size(); i++) {
            if(nums[i] > nums[i - 1]) {
                count++;
            } else {
                // reset the count
                count = 1;
            }
            forward[i] = count;
        }
        // search backward
        count = 1;
        int max_k = 1;
        for(int i = nums.size() - 2; i >= 0; i--) {
            if(nums[i] < nums[i + 1]) {
                count++;
                if(i > 0) {
                    max_k = max(max_k, min(count, forward[i - 1])); 
                }
            } else {
                // reset the count
                count = 1;
            }
        }
        return max_k;
    }
};

",1448201849
lovesbumblebees,lovesbumblebees,398,3631,cpp,"const int MOD = 1000000007;
class Solution {
public:
    int combination[801][801]= {};
    int k_score[801] = {};

    Solution() {
        memset(k_score,  -1, sizeof(k_score)); 
    }

    int kScore(int n) {
        if(k_score[n] >= 0) {
            return k_score[n];
        }
        if(n == 0) {
            return 1000;
        }
        // no operations are necessary
        if(n == 1) {
            return 0;
        }
        // count bits,
        int current = n;
        int bits = 0;
        for(int i = 0; i < 10; i++) {
            if(current & 1) {
                bits++;
            }
            current >>= 1;
        }
        k_score[n] = 1 + kScore(bits); 
        return k_score[n]; 
    }
    // we have SET bits determined
    // we have FREE bits available to be either 0 or 1
    int countLessThan(int free, int set, int k) {
        int count = 0;
        for(int i = 0; i <= free; i++) {
            if(kScore(i + set) < k) {
                count = (count + comb(free, i)) % MOD; 
            }
        }
        return count;
    }

    int comb(int n, int k) {
        if(combination[n + 1][k + 1] >0) {
            return combination[n + 1][k + 1];
        }
        if(k ==0 || k == n) {
            return 1;
        }
        combination[n + 1][k + 1] = (comb(n-1, k) + comb(n-1, k-1)) % MOD;
        return combination[n + 1][k + 1];
    }

    int countKReducibleNumbers(string s, int k) {
        int set = 0;
        int count = 0;
        for(int i = 0; i < s.size(); i++) {
            if(s[i] == '1') {
                count = (count + countLessThan(s.size() - i - 1, set, k)) % MOD;
                set++;
            }
        }
        return count;
    }
};",1448290779
lovesbumblebees,lovesbumblebees,398,3646,cpp,"constexpr int MOD = 1000000007;
class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        vector<long long> dp_count(100003, 0ll); 
        vector<long long> dp_sum(100003, 0ll); 
        dp_count[nums[0] + 1] = 1; 
        dp_sum[nums[0] + 1] = nums[0];
        for(int i = 1; i < nums.size(); i++) {
            dp_count[nums[i] + 1] = (dp_count[nums[i] + 1] + dp_count[nums[i]] + dp_count[nums[i] + 2] + 1) % MOD;
            dp_sum[nums[i] + 1] = (dp_sum[nums[i] + 1] + dp_sum[nums[i]] + dp_sum[nums[i] + 2] + (dp_count[nums[i]] + dp_count[nums[i] + 2] + 1) * nums[i]) % MOD; 
        }
        long long total = 0;
        for(const int num: dp_sum) {
            total = (total + num) % MOD;
        }
        return total;
    }
};",1448238173
Ivan Li,liivan256,400,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n=len(nums)
        for i in range(n - k + 1):
            j = i + k
            if j + k <= n:
                s1 = nums[i:i+k]
                s2 = nums[j:j+k]
                if all(s1[k-1] < s1[k] for k in range(1, len(s1))) and all(s2[k-1] < s2[k] for k in range(1, len(s2))):
                    return True
        return False",1448187343
Ivan Li,liivan256,400,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        def works(m):
            for i in range(n - 2 * m + 1):
                l = i
                r = i + m - 1
                l2 = r + 1
                r2 = l2 + m - 1
                if 0 == query(l,r) == query(l2, r2):
                    return True
            return False
    
        inf = 1 << 30
        n = len(nums)
        dec = [nums[i] >= nums[i + 1] for i in range(n - 1)] + [0]
        psa = [0] + list(accumulate(dec))
        query = lambda l,r: psa[r]-psa[l]
    
        low = 0
        high = n // 2
        while low <= high:
            mid = (low + high) // 2
            if works(mid):
                low = mid + 1
            else:
                high = mid - 1
        return low - 1
",1448217566
Ivan Li,liivan256,400,3631,python3,"from functools import cache

@cache
def get_min_reduction(cur):
    if cur == 1:
        return 0
    return 1 + get_min_reduction(cur.bit_count())


MN = 1000
reductions = [-1] * MN
for i in range(1, MN):
    reductions[i] = get_min_reduction(i)
# print(reductions)

class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        le = len(s)
        MOD = 10 ** 9 + 7
        s = list(map(int, s))
    
        cache = [[[-1] * (le + 1) for _ in range(le)] for _ in range(2)]
        def solve(touch_r, idx, bits):
            nonlocal cache
            if idx == le:
                return bits in fine and not touch_r
            if cache[touch_r][idx][bits] != -1:
                return cache[touch_r][idx][bits]
    
            t = 0
            upper = s[idx] if touch_r else 1
            for dig in range(upper + 1):
                t += solve(touch_r and s[idx] == dig, idx + 1, bits + dig)
            cache[touch_r][idx][bits] = t % MOD
            return cache[touch_r][idx][bits]
    
        fine = set()
        for i in range(1, MN):
            if reductions[i] + 1 <= k:
                fine.add(i)
        return solve(True, 0, 0) % MOD",1448291537
Ivan Li,liivan256,400,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        MOD = 10 ** 9 + 7
        cnt = defaultdict(int)
        total = defaultdict(int)
        n = len(nums)
    
        cnt[nums[0]] = 1  # base case
        total[nums[0]] = nums[0]
    
        for num in nums[1:]:
            # consider subsequence building on top of previous ones
            cnt[num] += cnt[num - 1]
            total[num] += total[num - 1] + num * (cnt[num - 1])
    
            cnt[num] += cnt[num + 1]
            total[num] += total[num + 1] + num * cnt[num + 1]
    
            # consider subsequence start here
            total[num] += num
            cnt[num] += 1
            
            total[num] %= MOD
            cnt[num] %= MOD
    
        return sum(total.values()) % MOD
",1448237527
parth162,parth162,402,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        dp = [1 for i in range(len(nums))]
        dp2 = [1 for i in range(len(nums))]
        
        for i in range(1, len(nums)):
            if nums[i]>nums[i-1]:
                dp[i] = dp[i-1]+1
                
        for i in range(len(nums)-2, -1, -1):
            if nums[i]<nums[i+1]:
                dp2[i]= dp2[i+1]+1
                
        for i in range(1, len(nums)):
            if dp[i-1]>=k and dp2[i]>=k:
                return True
            
        # print(dp, dp2)
                
        return False",1448185054
parth162,parth162,402,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        dp = [1 for i in range(len(nums))]
        dp2 = [1 for i in range(len(nums))]
        
        for i in range(1, len(nums)):
            if nums[i]>nums[i-1]:
                dp[i] = dp[i-1]+1
                
        for i in range(len(nums)-2, -1, -1):
            if nums[i]<nums[i+1]:
                dp2[i]= dp2[i+1]+1
        res = 0
        for i in range(1, len(nums)):
            res = max(res, min(dp[i-1], dp2[i]))
            
        # print(dp, dp2)
                
        return res",1448187015
parth162,parth162,402,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        mx = len(s)
        if mx <= 1:
            return 0
        
        nt = {}
        
        @cache
        def opt2(i):
            if bin(i).count(""1"") == 1:
                return 1
            return opt2(bin(i).count(""1""))+1
        
        want = set([1])
        
        for j in range(2, mx+1):
            nt[j] = opt2(j)
            if nt[j]<=k-1:
                want.add(j)
                
        # print(want)
        
        @cache
        def opt(n, l):
            if n<0:
                return 0
            if n == 0:
                return 1
            if n > l:
                return 0
            if n == l:
                return 1
            return (opt(n,l-1) + opt(n-1,l-1))%(10**9+7)
        
        res = 0
        for n in want: 
            f = 0
            for i,x in enumerate(s):
                if x == ""0"":
                    continue
                l = len(s)-i-1
                res += opt(n-f, l)
                res %= (10**9+7)
                f+=1
        
        return res",1448278416
parth162,parth162,402,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        mp = defaultdict(list)
            
        till_now = {}
        
        for i,x in enumerate(nums):
            mp[x].append(i)
            till_now[nums[i]] = (0,0)
        
        @cache
        def opt(i):
            ele = nums[i]
            need = nums[i]-1
            need2 = nums[i]+1
            
            res = ele
            l = 1
            # print(mp[need], need)
            # for j in mp[need]:
            #     if j>i:
            #         break
            #     s,n = opt(j)
            #     # print(s,n,j)
            #     res += n*nums[i] + s
            #     res%= (10**9+7)
            #     l+=n
            # # print(mp[need2], need2)
            # for j in mp[need2]:
            #     if j>i:
            #         break
            #     s,n = opt(j)
            #     res += n*nums[i] + s
            #     res%= (10**9+7)
            #     l+=n
            if need in till_now:
                s,n = till_now[need]
                res += n*nums[i] + s
                res%= (10**9+7)
                l+=n
            if need2 in till_now:
                s,n = till_now[need2]
                res += n*nums[i] + s
                res%= (10**9+7)
                l+=n
            x,y = till_now[ele]
            till_now[ele] = (res+x, l+y)
                
            return res,l
        ans = 0
        for i in range(len(nums)):
            ans += (opt(i)[0])
            # print(opt(i))
            ans%= (10**9+7)
            
        return ans",1448232609
jianstanleya,jianstanleya,405,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int i = 0;
        vector<int> segs;
        while(i < nums.size()) {
            int j = i + 1;
            while(j < nums.size() && nums[j] > nums[j - 1]) j++;
            segs.push_back(j - i);
            i = j;
        }
        int result = 0;
        for(int i : segs) result = max(result, i / 2);
        for(int i = 0; i < segs.size() - 1; i++) result = max(result, min(segs[i], segs[i + 1]));
        return result >= k;
    }
};",1448188356
jianstanleya,jianstanleya,405,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int i = 0;
        vector<int> segs;
        while(i < nums.size()) {
            int j = i + 1;
            while(j < nums.size() && nums[j] > nums[j - 1]) j++;
            segs.push_back(j - i);
            i = j;
        }
        int result = 0;
        for(int i : segs) result = max(result, i / 2);
        for(int i = 0; i < segs.size() - 1; i++) result = max(result, min(segs[i], segs[i + 1]));
        return result;
    }
};",1448187586
jianstanleya,jianstanleya,405,3631,cpp,"#define LL long long

const static LL MOD = 1000000007;

class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        int w = s.size();
        vector<vector<int>> binom(w + 1, vector<int>(w + 1, 0));
        binom[0][0] = 1;
        for(int i = 1; i <= w; i++) {
            for(int j = 0; j <= i; j++){
                binom[i][j] = j > 0 ? binom[i - 1][j - 1] + binom[i - 1][j] : 1;
                binom[i][j] %= MOD;
            }
        }
        k--;
        vector<int> evo(w + 1, 0);
        for(int i = 0; i <= w; i++) {
            evo[i] = __builtin_popcount(i);
            if(i == 1) evo[i] = -1;
        }
        vector<int> kevo(w + 1, 0);
        for(int i = 0; i <= w; i++) {
            kevo[i] = evo[i];
            for(int j = 0; kevo[i] > -1 && j < k; j++) kevo[i] = evo[kevo[i]];
        }
        vector<LL> freq(w + 1, 0);
        int prefix = 0;
        for(int i = 0; i < w; i++) {
            if(s[i] == '1') {
                for(int j = 0; j < w - i; j++) {
                    freq[j + prefix] += binom[w - i - 1][j];
                    freq[j + prefix] %= MOD;
                }
                prefix++;
            }
        }
        LL result = 0;
        for(int i = 0; i <= w; i++) {
            if(kevo[i] == -1) {
                result += freq[i];
                result %= MOD;
            }
        }
        return result;
    }
};",1448299784
jianstanleya,jianstanleya,405,3646,cpp,"#define LL long long

const LL MOD = 1000000007;

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int cap = 0;
        for(int i : nums) cap = max(cap, i);
        vector<LL> counts(cap + 1, 0);
        vector<LL> evalues(cap + 1, 0);
        vector<LL> values(nums.size(), 0);
        for(int i = 0; i < nums.size(); i++) {
            values[i] += nums[i];
            values[i] %= MOD;
            counts[nums[i]]++;
            counts[nums[i]] %= MOD;
            if(nums[i] > 0) {
                values[i] += evalues[nums[i] - 1];
                values[i] %= MOD;
                values[i] += (counts[nums[i] - 1] * nums[i]) % MOD;
                values[i] %= MOD;
                counts[nums[i]] += counts[nums[i] - 1];
                counts[nums[i]] %= MOD;
            }
            if(nums[i] < cap) {
                values[i] += evalues[nums[i] + 1];
                values[i] %= MOD;
                values[i] += (counts[nums[i] + 1] * nums[i]) % MOD;
                values[i] %= MOD;
                counts[nums[i]] += counts[nums[i] + 1];
                counts[nums[i]] %= MOD;
            }
            evalues[nums[i]] += values[i];
            evalues[nums[i]] %= MOD;
            if(i > 0) {
                values[i] += values[i - 1];
                values[i] %= MOD;
            }
        }
        return values.back();
    }
};",1448242546
leetgoat_dot_dev,leetgoat_dot_dev,406,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        incs = set()
        for start in range(len(nums) - k + 1):
            failSeen = False
            for right in range(start + 1, start + k):
                if nums[right] <= nums[right - 1]:
                    failSeen = True
                    break
            if not failSeen:
                incs.add(start)
        
        
        for leftStart in range(len(nums)):
            rightStart = leftStart + k
            if leftStart in incs and rightStart in incs:
                return True
        
        return False",1448182322
leetgoat_dot_dev,leetgoat_dot_dev,406,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        @cache
        def descent(i):
            if i == 0:
                return 1
            if nums[i - 1] >= nums[i]:
                return 1
            return 1 + descent(i - 1)
        
        @cache
        def ascent(i):
            if i == len(nums) - 1:
                return 1
            if nums[i + 1] <= nums[i]:
                return 1
            return 1 + ascent(i + 1)
        
        res = 0
        
        for rightEdge in range(len(nums) - 1):
            res = max(res, min(descent(rightEdge), ascent(rightEdge + 1)))
            
        descent.cache_clear()
        ascent.cache_clear()
            
        return res",1448185273
leetgoat_dot_dev,leetgoat_dot_dev,406,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        @cache
        def isReducible(numberOfSetBitsFromLastNumber, transformsMade):
            if numberOfSetBitsFromLastNumber == 1:
                return True
            if transformsMade == k:
                return False
            newNum = numberOfSetBitsFromLastNumber
            newCount = newNum.bit_count()
            return isReducible(newCount, transformsMade + 1)
        
        M = 10**9 + 7
        
        # returns (# of ways to make valid subsequence)
        @cache
        def dp(i, isTight, setBits):
            if i == len(s):
                if setBits == 0:
                    return 0
                if isReducible(setBits, 1):
                    return 1
                return 0
            
            anyWaysHere = 0
            # validWaysHere = 0
            
            upperBoundary = int(s[i]) if isTight else 1
            for nextDigit in range(upperBoundary + 1):
                newIsTight = isTight and nextDigit == upperBoundary
                anyWays = dp(i + 1, newIsTight, setBits + nextDigit)
                anyWaysHere += anyWays
                # validWaysHere += validWays
            
            return anyWaysHere % M
        
        
        ans = dp(0, True, 0)
        
        # print(f'inint ans: {ans}')
                
        # dont include n if it is reducible
        num = int(s, 2)
        if num == 1:
            ans -= 1
        else:
            setBits = num.bit_count()
            # print(f'set bits: {setBits}')
            if isReducible(setBits, 1):
                ans -= 1
        
        dp.cache_clear()
        
        return ans
                ",1448269801
leetgoat_dot_dev,leetgoat_dot_dev,406,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        n = len(nums)
        ends = [0] * (max(nums) + 1) # how many subsequences end with x, for ...i as we go, where we must take the `ith`
        # print(ends)
        
        endSaved = [None] * len(nums) # maps an i to how many subsequences end with nums[i] for ...i, where we must take the `ith`
        M = 10**9 + 7
        
        for i in range(len(nums)):
            # print(f'iter on i={i}')
            down = nums[i] - 1
            up = nums[i] + 1
            # print('up down', up, down)
            newWays = 0
            if down >= 0:
                newWays += ends[down]
            if up < len(ends):
                newWays += ends[up]
            # print(f'new ways from prior constructions: {newWays}')
            finalWays = newWays + 1
            # print(f'final ways: {finalWays}')
            endSaved[i] = finalWays % M
            actualFinal = finalWays + ends[nums[i]]
            ends[nums[i]] = actualFinal % M
            # print(f'ends now: {ends}')
        
        # print(endSaved)
        
        starts = [0] * (max(nums) + 1) # how many subsequences start with X, for i... as we go backwards, DONT NEED TO TAKE ITH
        
        startsSaved = [None] * len(nums) # maps an i to how many subsequences start with nums[i] for i..., where we must take the `ith`
        
        for i in range(len(nums) - 1, -1, -1):
            up = nums[i] + 1
            down = nums[i] - 1
            newWays = 0
            if down >= 0:
                newWays += starts[down]
            if up < len(starts):
                newWays += starts[up]
            finalWays = newWays + 1
            startsSaved[i] = finalWays % M
            actualFinal = finalWays + starts[nums[i]]
            starts[nums[i]] = actualFinal % M
        
        res = 0
        
        for i in range(len(nums)):
            res += startsSaved[i] * endSaved[i] * nums[i]
            res %= (10**9 + 7)
        
        return res % (10**9 + 7)
                
            ",1448293133
Lokesh Rajput,lokeshrajput5473,407,3612,cpp,"class Solution {
public:
bool hasIncreasingSubarrays(const vector<int>& nums, int k) {
    int n = nums.size();
    bool prevIncreasing = false;
    vector<bool>arr(n, false);
    for (int i = 0; i <= n - k; ++i) {
        bool isIncreasing = true;
        for (int j = i; j < i + k - 1; ++j) {
            if (nums[j] >= nums[j + 1]) {
                isIncreasing = false;
                break;
            }
        }
        if(i-k>=0) prevIncreasing = arr[i-k];
        else prevIncreasing = false;
        
        if (isIncreasing && prevIncreasing) {
            return true;
        }
        arr[i] = isIncreasing;
    }
    
    return false;
}
};",1448187509
Lokesh Rajput,lokeshrajput5473,407,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        vector<pair<int, int>> increasingSubarrays;
        int n = nums.size();
        
        int start = 0;
        
        for (int i = 1; i < n; ++i) {
            if (nums[i] <= nums[i - 1]) {
                increasingSubarrays.push_back({start, i - 1});
                start = i;
            }
        }
        
        increasingSubarrays.push_back({start, n - 1});

        int ans = 0;

        for(int i=1;i<increasingSubarrays.size();i++) {
            int len1 = increasingSubarrays[i].second - increasingSubarrays[i].first + 1;
            int len2 = increasingSubarrays[i-1].second - increasingSubarrays[i-1].first + 1;
            ans = max(ans, min(len1, len2));
        }

        for(auto i:increasingSubarrays) {
            ans = max(ans, (i.second - i.first + 1)/2);
        }
        
        return ans;
    }
};",1448197486
Lokesh Rajput,lokeshrajput5473,407,3631,cpp,"

class Solution {
public:
    int mod = 1e9 + 7;
    long long fact[801];

    int modInverse(int A, int M) {
        return power(A, M - 2, M);
    }

    int power(int x, int y, int M) {
        if (y == 0)
            return 1;

        long long p = power(x, y / 2, M) % M;
        p = (p * p) % M;

        return (y % 2 == 0) ? p : (x * p) % M;
    }

    int countSetBits(int n) {
        return bitset<32>(n).count();
    }

    int stepsToOne(int n) {
        int steps = 0;
        while (n != 1) {
            n = countSetBits(n);
            steps++;
        }
        return steps;
    }

    int ncr(int n, int r) {
        long long num = fact[n];
        long long den = (fact[r] * fact[n - r]) % mod;
        den = modInverse(den, mod);

        return (num * den) % mod;
    }

    int solve(int currSetBits, map<int, int>& mp, int n, int r, int k) {
        if (mp[currSetBits + r] > k) return 0;
        int cases = ncr(n, r);
        // cout << cases << "" "";
        return cases;
    }

    int countKReducibleNumbers(string s, int k) {
        map<int, int> mp;
        mp[0] = INT_MAX;
        fact[0] = 1;
        
        for (int i = 1; i <= 800; i++) {
            mp[i] = stepsToOne(i);
            fact[i] = (fact[i - 1] * (long long)i) % mod;
        }

        int currSetBits = 0;
        int ans = 0;
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == '1') {
                int left = s.size() - i - 1;
                for (int j = 0; j <= left; j++) {
                    ans = (ans + (long long)solve(currSetBits, mp, left, j, k-1)) % mod; 
                }
                // cout << endl;
                currSetBits++;
            }
        }
        return ans;
    }
};
",1448293336
Lokesh Rajput,lokeshrajput5473,407,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        map<int, vector<int>> indexes;
        for(int i=0;i<nums.size();i++) {
            indexes[nums[i]].push_back(i);
        }
        int n = nums.size(), mod = 1e9 + 7;
        vector<int> dp(n+1, 1);
        vector<int> sum(n+1, 0), inclSum(n+1, 0);

        map<int, int> forDp, forInclSum;
        sum[n-1] = inclSum[n-1] = nums[n-1];
        dp[n-1] = 1;
        forDp[nums[n-1]] += 1;
        forInclSum[nums[n-1]] += nums[n-1];
        for(int i=n-2;i>=0;i--) {
            inclSum[i] = (inclSum[i] + 0ll + nums[i]) % mod;
            int lower = nums[i]-1;
            if(indexes.find(lower) != indexes.end()) {
                dp[i] = (dp[i] + 0ll + forDp[lower]) % mod;
                inclSum[i] = (inclSum[i] + 0ll + forInclSum[lower]) % mod;
                inclSum[i] = (inclSum[i] + 0ll + (nums[i] * 1ll * forDp[lower]) % mod) % mod;
            }

            int upper = nums[i]+1;
            if(indexes.find(upper) != indexes.end()) {
                dp[i] = (dp[i] + 0ll + forDp[upper]) % mod;
                inclSum[i] = (inclSum[i] + 0ll + forInclSum[upper]) % mod;
                inclSum[i] = (inclSum[i] + 0ll + (nums[i] * 1ll * forDp[upper]) % mod) % mod;
            }
            forDp[nums[i]] = (forDp[nums[i]] +0ll + dp[i]) % mod;
            forInclSum[nums[i]] = (forInclSum[nums[i]] + 0ll + inclSum[i]) % mod;
            sum[i] = sum[i+1];
            sum[i] = (sum[i] + 0ll + inclSum[i]) % mod;

            // cout << sum[i] << "" "";
        }
        return sum[0];
    }
};",1448257425
Arnav Goyal,Pikachu0123,408,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        for(int i=0; i<=n-2*k; i++){
            bool flag = true;
            for(int j=i+1; j<i+k; j++){
                if (nums[j] > nums[j-1]) {}
                else flag = false;
            }
            if (flag){
                for(int j=i+k+1; j<i+2*k; j++){
                    if (nums[j] > nums[j-1]) {}
                    else flag = false;
                }
                if (flag) return true;
            }
        }

        return false;
    }
};",1448183195
Arnav Goyal,Pikachu0123,408,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        int ans = 0, low = 0, high = n / 2 + 1;
        while (low <= high) {
            int mid = (low + high) / 2;
            deque<int> dq;
            for (int i = 0; i < mid; i++) {
                while (!dq.empty() and nums[dq.back()] >= nums[i])
                    dq.pop_back();
                dq.push_back(i);
            }

            vector<int> vis(n, 0);
            for (int i = 0; i <= n - mid; i++) {
                if (dq.size() == mid)
                    vis[i] = 1;
                while (!dq.empty() and dq.front() <= i)
                    dq.pop_front();
                if (i + mid >= n)
                    break;
                while (!dq.empty() and nums[dq.back()] >= nums[i + mid])
                    dq.pop_back();
                dq.push_back(i + mid);
            }
            bool flag = false;
            for (int i = 0; i <= n - 2 * mid; i++) {
                if (i + mid < n and vis[i] and vis[i + mid])
                    flag = true;
            }
            if (flag) {
                ans = mid;
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }

        return ans;
    }
};",1448194523
Arnav Goyal,Pikachu0123,408,3631,cpp,"class Solution {
const int mod = 1e9 + 7;
long long dp[801][801][2];
int dfs(string &str, int tight, int i, int k, int one){
    if (i == str.size()){
        int temp = k;
        int cnt = 0;
        int p = k - 1;
        int temp2 = one;
        while(p--){
            if (temp2 == 1) break;
            temp2 = __builtin_popcount(temp2);
        }
        if (temp2 == 1) return 1;
        return 0;
    }
    if (dp[i][one][tight] != -1) return dp[i][one][tight];
    int end = (tight ? str[i] - '0' : 1);
    long long ans = 0;
    for(int st=0; st<=end; st++){
        (ans += dfs(str, tight&(st==end), i+1, k, one + (st == 1))) %= mod;
    }
    return dp[i][one][tight] = ans;
}

public:
    int countKReducibleNumbers(string s, int k) {
        memset(dp, -1, sizeof dp);
        int flag = 0;
        int p = k -1;
        int temp2 = 0;
        for(int j=0; j<s.size(); j++) temp2 += (s[j] == '1');
        while(p--){
            temp2 = __builtin_popcount(temp2);
        }
        if (temp2 == 1) flag = 1;
        return (dfs(s, 1, 0, k, 0) - flag + mod) % mod;
    }
};",1448272484
Arnav Goyal,Pikachu0123,408,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        const int mod = 1e9 + 7;
        int n = nums.size();
        map<int, long long> dp;
        map<int, long long> sum;

        long long ans = 0;
        for(int &x : nums){
            int left = dp[x-1]+dp[x+1]+1;
            (dp[x] += left) %= mod;
            long long nsum = (sum[x-1]+sum[x+1]+(1LL*left*x)%mod) % mod;
            (sum[x] += nsum) %= mod;
            (ans += nsum) %= mod;
        }

        return ans;
    }
};",1448300193
CoolManGame,CoolManGame,409,3612,cpp,"class Solution {
public:
    bool f(vector<int>& nums, int a, int k) {
        for (int i = a; i+1 < a+k; i++) {
            if (nums[i] >= nums[i+1]) return false;
        }   
        return true;
    }

    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        for (int a = 0; a + 2*k - 1 < n; a++) {
            int b = a + k;
            if (f(nums, a, k) && f(nums, b, k)) return true;
        }
        return false;
    }
};",1448181897
CoolManGame,CoolManGame,409,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> a(n); // a[i] = max j such that nums[i..j] is inc

        for (int i = 0; i < n; ) {
            int j = i;
            while (j < n && (j == i || nums[j] > nums[j-1])) {
                j++;
            }

            for (int k = i; k < j; k++) {
                a[k] = j-1;
            }

            i = j;
        }

        

        int ans = 1;
        for (int i = 0; i < n; i++) {
            int j = a[i];

            int evl1 = (j + 1 - i) / 2;

            int i2 = j + 1;
            int evl2 = 0;
            if (i2 < n) {
                int j2 = a[i2];
                evl2 = min(j - i + 1, j2 - i2 + 1);
            }
        
            ans = max({ans, evl1, evl2});
        }

        return ans;
    }
};",1448198699
CoolManGame,CoolManGame,409,3631,cpp,"#include <bits/stdc++.h>
using namespace std;
#define fi first
#define se second
#define all(v) v.begin(),v.end()
#define fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define len(v) (ll((v).size()))
#define mp(a,b) (make_pair((a),(b)))
using ll = long long;
using pii = pair<int,int>;
using ld = long double;
#define x() real()
#define y() imag()

class Solution {
public:
    int M = 1e9 + 7;
    
    int stepReduce2(const string& s) {
        if (s == ""1"") return 0;
        return 1 + stepReduce(count(all(s), '1'));
    }

    int stepReduce(int x) {
        if (x == 1) return 0;
        if (x == __builtin_popcount(x)) return 1e7;
        return 1 + stepReduce(__builtin_popcount(x));
    }

    vector<vector<int>> A = {
        {1},
        {2, 4, 8, 16, 32, 64, 128, 256, 512}, // A[1]
        
        {3, 5, 6, 9, 10, 12, 15, 17, 18, 20, 23, 24, 27, 29, 30, 33, 34, 36, 39, 40, 43, 45, 46, 48, 51, 53, 54, 57, 58, 60, 65, 66, 68, 71, 72, 75, 77, 78, 80, 83, 85, 86, 89, 90, 92, 96, 99, 101, 102, 105, 106, 108, 113, 114, 116, 120, 129, 130, 132, 135, 136, 139, 141, 142, 144, 147, 149, 150, 153, 154, 156, 160, 163, 165, 166, 169, 170, 172, 177, 178, 180, 184, 192, 195, 197, 198, 201, 202, 204, 209, 210, 212, 216, 225, 226, 228, 232, 240, 255, 257, 258, 260, 263, 264, 267, 269, 270, 272, 275, 277, 278, 281, 282, 284, 288, 291, 293, 294, 297, 298, 300, 305, 306, 308, 312, 320, 323, 325, 326, 329, 330, 332, 337, 338, 340, 344, 353, 354, 356, 360, 368, 383, 384, 387, 389, 390, 393, 394, 396, 401, 402, 404, 408, 417, 418, 420, 424, 432, 447, 449, 450, 452, 456, 464, 479, 480, 495, 503, 507, 509, 510, 513, 514, 516, 519, 520, 523, 525, 526, 528, 531, 533, 534, 537, 538, 540, 544, 547, 549, 550, 553, 554, 556, 561, 562, 564, 568, 576, 579, 581, 582, 585, 586, 588, 593, 594, 596, 600, 609, 610, 612, 616, 624, 639, 640, 643, 645, 646, 649, 650, 652, 657, 658, 660, 664, 673, 674, 676, 680, 688, 703, 705, 706, 708, 712, 720, 735, 736, 751, 759, 763, 765, 766, 768, 771, 773, 774, 777, 778, 780, 785, 786, 788, 792},
        
        {7, 11, 13, 14, 19, 21, 22, 25, 26, 28, 31, 35, 37, 38, 41, 42, 44, 47, 49, 50, 52, 55, 56, 59, 61, 62, 63, 67, 69, 70, 73, 74, 76, 79, 81, 82, 84, 87, 88, 91, 93, 94, 95, 97, 98, 100, 103, 104, 107, 109, 110, 111, 112, 115, 117, 118, 119, 121, 122, 123, 124, 125, 126, 131, 133, 134, 137, 138, 140, 143, 145, 146, 148, 151, 152, 155, 157, 158, 159, 161, 162, 164, 167, 168, 171, 173, 174, 175, 176, 179, 181, 182, 183, 185, 186, 187, 188, 189, 190, 193, 194, 196, 199, 200, 203, 205, 206, 207, 208, 211, 213, 214, 215, 217, 218, 219, 220, 221, 222, 224, 227, 229, 230, 231, 233, 234, 235, 236, 237, 238, 241, 242, 243, 244, 245, 246, 248, 249, 250, 252, 259, 261, 262, 265, 266, 268, 271, 273, 274, 276, 279, 280, 283, 285, 286, 287, 289, 290, 292, 295, 296, 299, 301, 302, 303, 304, 307, 309, 310, 311, 313, 314, 315, 316, 317, 318, 321, 322, 324, 327, 328, 331, 333, 334, 335, 336, 339, 341, 342, 343, 345, 346, 347, 348, 349, 350, 352, 355, 357, 358, 359, 361, 362, 363, 364, 365, 366, 369, 370, 371, 372, 373, 374, 376, 377, 378, 380, 385, 386, 388, 391, 392, 395, 397, 398, 399, 400, 403, 405, 406, 407, 409, 410, 411, 412, 413, 414, 416, 419, 421, 422, 423, 425, 426, 427, 428, 429, 430, 433, 434, 435, 436, 437, 438, 440, 441, 442, 444, 448, 451, 453, 454, 455, 457, 458, 459, 460, 461, 462, 465, 466, 467, 468, 469, 470, 472, 473, 474, 476, 481, 482, 483, 484, 485, 486, 488, 489, 490, 492, 496, 497, 498, 500, 504, 511, 515, 517, 518, 521, 522, 524, 527, 529, 530, 532, 535, 536, 539, 541, 542, 543, 545, 546, 548, 551, 552, 555, 557, 558, 559, 560, 563, 565, 566, 567, 569, 570, 571, 572, 573, 574, 577, 578, 580, 583, 584, 587, 589, 590, 591, 592, 595, 597, 598, 599, 601, 602, 603, 604, 605, 606, 608, 611, 613, 614, 615, 617, 618, 619, 620, 621, 622, 625, 626, 627, 628, 629, 630, 632, 633, 634, 636, 641, 642, 644, 647, 648, 651, 653, 654, 655, 656, 659, 661, 662, 663, 665, 666, 667, 668, 669, 670, 672, 675, 677, 678, 679, 681, 682, 683, 684, 685, 686, 689, 690, 691, 692, 693, 694, 696, 697, 698, 700, 704, 707, 709, 710, 711, 713, 714, 715, 716, 717, 718, 721, 722, 723, 724, 725, 726, 728, 729, 730, 732, 737, 738, 739, 740, 741, 742, 744, 745, 746, 748, 752, 753, 754, 756, 760, 767, 769, 770, 772, 775, 776, 779, 781, 782, 783, 784, 787, 789, 790, 791, 793, 794, 795, 796, 797, 798, 800}, // A[3]
        
        {127, 191, 223, 239, 247, 251, 253, 254, 319, 351, 367, 375, 379, 381, 382, 415, 431, 439, 443, 445, 446, 463, 471, 475, 477, 478, 487, 491, 493, 494, 499, 501, 502, 505, 506, 508, 575, 607, 623, 631, 635, 637, 638, 671, 687, 695, 699, 701, 702, 719, 727, 731, 733, 734, 743, 747, 749, 750, 755, 757, 758, 761, 762, 764, 799}
    };
    
    int modadd(int a, int b) {
        return (a + b) % M;
    }

    int countKReducibleNumbers(string s, int k) {
        if (s == ""0"") return 0;

        int n = s.size();
        int maxBit = 800;
        vector<vector<vector<int>>> dp(n+1, vector<vector<int>>(2, vector<int>(maxBit+1, 0)));

        for (int i = n; i >= 0; i--) {
            for (int j = 0; j < 2; j++) {
                for (int k = 0; k <= maxBit; k++) {
                    if (i == n) {
                        dp[i][j][k] = k == 0 ? 1 : 0;
                        continue;
                    }

                    int evl = 0;

                    if (j == 1) {
                        evl = modadd(dp[i+1][j][k], k > 0 ? dp[i+1][j][k-1] : 0);
                    }
                    else {
                        if (s[i] == '0') {
                            evl = dp[i+1][j][k];
                        } else {
                            evl = modadd(k > 0 ? dp[i+1][j][k-1] : 0, dp[i+1][1][k]);
                        }
                    }

                    dp[i][j][k] = evl;
                }
            }
        }

        int ans = 0;
        for (int j = 0; j < k; j++) {
            for (int i : A[j]) {
                (ans += dp[0][0][i]) %= M;
            }
        }

        if (stepReduce2(s) <= k) {
            ans--;
        }
        
        return ans;
    }
};",1448300414
CoolManGame,CoolManGame,409,3646,cpp,"#include <bits/stdc++.h>
using namespace std;
#define fi first
#define se second
#define all(v) v.begin(),v.end()
#define fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define len(v) (ll((v).size()))
#define mp(a,b) (make_pair((a),(b)))
using ll = long long;
using pii = pair<int,int>;
using ld = long double;
#define x() real()
#define y() imag()

class Solution {
public:
    const int M = 1e9 + 7;
    int modmul(vector<ll> a) {
        ll ans = 1;
        for (ll i : a) {
            i %= M;
            (ans *= i) %= M;
        }
        return ans;
    }

    int sumOfGoodSubsequences(vector<int>& a) {
        int m = *max_element(a.begin(), a.end());
        int n = a.size();
        vector<ll> F(m+1), f(n); // f[i] = count how many end at i

        auto betw = [](int l, int x, int r) {
            return l <= x && x <= r;
        };

        for (int i = 0; i < n; i++) {
            f[i] = 1;
            (f[i] += betw(0, a[i]+1, m) ? F[a[i]+1] : 0) %= M;
            (f[i] += betw(0, a[i]-1, m) ? F[a[i]-1] : 0) %= M;
            (F[a[i]] += f[i]) %= M;
        }

        vector<ll> G(m+1), g(n); // g[i] = count how many start at i

        for (int i = n-1; i >= 0; i--) {
            g[i] = 1;
            (g[i] += betw(0, a[i]+1, m) ? G[a[i]+1] : 0) %= M;
            (g[i] += betw(0, a[i]-1, m) ? G[a[i]-1] : 0) %= M;
            (G[a[i]] += g[i]) %= M;
        }

        ll ans = 0;
        for (int i = 0; i < n; i++) {
            ll evl = modmul({a[i], f[i], g[i]});
            (ans += evl) %= M;
        }

        return ans;
    }
};",1448224852
Ratnakar Gautam,ratnakarg,411,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int>pre(n,0);
        pre[0]=1;
        for(int i=1;i<n;i++){
            if(nums[i]> nums[i-1]) pre[i] = pre[i-1]+1;
            else pre[i]=1;
        }
        
        vector<int>suf(n);
        suf[n-1]=1;
        for(int i=n-2;i>=0;i--){
            if(nums[i]<nums[i+1]) suf[i]=1+suf[i+1];
            else suf[i]= 1;
        }
        int ans = 0;
        for(int i=0;i<n-1;i++){
            ans = max(ans,min(pre[i],suf[i+1]));
        }
        return ans >= k;
    }
};",1448196693
Ratnakar Gautam,ratnakarg,411,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int>pre(n,0);
        pre[0]=1;
        for(int i=1;i<n;i++){
            if(nums[i]> nums[i-1]) pre[i] = pre[i-1]+1;
            else pre[i]=1;
        }
        
        vector<int>suf(n);
        suf[n-1]=1;
        for(int i=n-2;i>=0;i--){
            if(nums[i]<nums[i+1]) suf[i]=1+suf[i+1];
            else suf[i]= 1;
        }
        int ans = 0;
        for(int i=0;i<n-1;i++){
            ans = max(ans,min(pre[i],suf[i+1]));
        }
        return ans;
    }
};",1448194973
Ratnakar Gautam,ratnakarg,411,3631,cpp,"#define ll long long
#define mod ((int)1e9+7)
class Solution {
public:
    vector<vector<int>> dp2;
    bool is_valid(int cnt,int k){
        if(cnt==1)return true;
        if(k==0)return false;
        if(dp2[cnt][k]!=-1)return dp2[cnt][k];
        return dp2[cnt][k]=is_valid(__builtin_popcount(cnt),k-1);
    }

    vector<vector<vector<int>>> dp1;
    int rec(string &s,int i,int cnt,int k,int f){
        if(i==s.size()){
            if(cnt==1)return 1;
            return is_valid(cnt,k-1);
        }
        if(dp1[i][cnt][f]!=-1)return dp1[i][cnt][f];
        ll ans = 0;
        if(f){
            for(int j=0;j<=s[i]-'0';j++){
                if(j==s[i]-'0'){
                    ans+=rec(s,i+1,cnt+(j==1),k,1);
                    ans%=mod;
                }else{
                    ans+=rec(s,i+1,cnt+(j==1),k,0);
                    ans%=mod;
                }
            }
        }else{
            for(int j=0;j<2;j++){
                ans+=rec(s,i+1,cnt+(j==1),k,0);
                ans%=mod;
            }
        }
        return dp1[i][cnt][f]=ans;
    }

    bool check(string &s,int k){
        int cnt = 0;
        for(int i=0;i<s.size();i++)cnt+=(s[i]=='1');
        return is_valid(cnt,k-1);
    }

    int countKReducibleNumbers(string s, int k) {
        int n = s.size();
        dp1.resize(n+1,vector<vector<int>> (n+1,vector<int> (2,-1)));
        dp2.resize(n+1,vector<int> (k+1,-1));
        return rec(s,0,0,k,1) - check(s,k);
    }
};",1448300792
Ratnakar Gautam,ratnakarg,411,3646,cpp,"#define ll long long
#define mod ((int)1e9+7)
class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& arr){
        int n = arr.size();
        map<int,ll> mp;
        int mx = *max_element(arr.begin(),arr.end());
        vector<ll> dp1(n+1);
        for(int i=0;i<n;i++){
            dp1[i] = 1;
            if(mp.count(arr[i]-1)==1){
                dp1[i]+= mp[arr[i]-1];
                dp1[i]%=mod;
            }
            if(mp.count(arr[i]+1)==1){
                dp1[i]+= mp[arr[i]+1];
                dp1[i]%=mod;            
            }
            dp1[i]%=mod;
            mp[arr[i]]+=dp1[i];
            mp[arr[i]]%=mod;
        }

        mp.clear();

        vector<ll> dp2(n+1);

        for(int i=n-1;i>=0;i--){
            dp2[i] = 1;
            if(mp.count(arr[i]-1)==1){
                  dp2[i]+= mp[arr[i]-1];
                dp2[i]%=mod;
            }
              
            if(mp.count(arr[i]+1)==1){
                dp2[i]+= mp[arr[i]+1];
                dp2[i]%=mod;
            }
            dp2[i]%=mod;
            mp[arr[i]]+=dp2[i];
            mp[arr[i]]%=mod;
        }

        // for(auto x:dp1){
        //     cout<<x<<"" "";
        // }

        // cout<<endl;

        // for(auto x:dp2){
        //     cout<<x<<"" "";
        // }

        ll ans = 0;

        for(int i=0;i<n;i++){
            ll val = (dp1[i]*dp2[i])%mod;
            ans+=((arr[i]*val)%mod);
            ans%=mod;
        }
        
        return ans;
    }
};",1448233316
Mohit_is_back,Mohit_2k_kukreja,413,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        // 2 1
        for(int i=0; i+2*k<=n; i++){
            bool left = true, right = true;
            
            for(int j = i+1; j < i+k; j++){
                if(nums[j] <= nums[j-1]){
                    left = false;
                    break;
                }
            }
            
            for(int j = i + k + 1; j < i + 2*k; j++){
                if(nums[j] <= nums[j-1]){
                    right = false;
                    break;
                }
            }
            
            if(left && right) return true;
        }
        return false;
    }
};",1448188520
Mohit_is_back,Mohit_2k_kukreja,413,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        int curr = 1;
        vector<int> res = {1};
        for(int i=1; i<n; i++){
            if(nums[i] > nums[i-1]) res.back()++;
            else res.push_back(1);
            
        }
        int ans = 0;
        for(int i=0; i<res.size(); i++){
            ans = max(ans, res[i]/2);
            if(i > 0){
                ans = max(ans, min(res[i], res[i-1]));
            }
        }
        return ans;
    }
};",1448199879
Mohit_is_back,Mohit_2k_kukreja,413,3631,cpp,"class Solution {
    vector<int> cnt;
    int k;
    const int mod = 1e9 + 7;
    int dp[801][2][801];

public:
    int solve(const string& s, int i, bool tight, int setBits) {
        if (i == s.size()) return (tight || setBits == 0) ? 0 : cnt[setBits] < k;
        if(dp[i][tight][setBits] != -1) return dp[i][tight][setBits];
        
        if (tight) {
            if (s[i] == '0') return solve(s, i + 1, true, setBits);
            
            int res = solve(s, i + 1, true, setBits + 1);
            res = (res + solve(s, i + 1, false, setBits)) % mod;
            return dp[i][tight][setBits] = res;
        }
        
        int res = solve(s, i + 1, false, setBits + 1);
        res = (res + solve(s, i + 1, false, setBits)) % mod;
        return dp[i][tight][setBits] = res;
    }

    int countKReducibleNumbers(std::string s, int k) {
        this->k = k;
        this->cnt = std::vector<int>(801, 0);
        memset(dp, -1, sizeof(dp));
        for (int i = 2; i <= 800; i++) {
            int setBits = __builtin_popcount(i);
            cnt[i] = 1 + cnt[setBits];
            // cout << cnt[i] << "" "" ;
        }
        // cout << endl;
        
        return solve(s, 0, true, 0);        
    }
};
",1448294258
Mohit_is_back,Mohit_2k_kukreja,413,3646,cpp,"class Solution {
    const int mod = 1e9 + 7;
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        long long res = 0;
        int n = nums.size();
        map<int, long long> sum, count;
        
        for(int i = 0; i < n; i++) {
            res = (res + nums[i]) % mod;
            int toFind1 = nums[i] + 1;
            int toFind2 = nums[i] - 1;
            
            long long cnt1 = count[toFind1];
            long long sum1 = sum[toFind1];
            res = (res + (cnt1 * nums[i] % mod + sum1) % mod) % mod;
            
            long long cnt2 = count[toFind2];
            long long sum2 = sum[toFind2];
            res = (res + (cnt2 * nums[i] % mod + sum2) % mod) % mod;
            
            count[nums[i]] = (count[nums[i]] + cnt1 + cnt2 + 1) % mod;
            long long curr = ((nums[i]) * (cnt1 + cnt2 + 1)) % mod;
            sum[nums[i]] = (sum[nums[i]] + sum1 + sum2 + curr) % mod;
        }
        return res;
    }
};
",1448239923
h_bugw7,h_bugw7,414,3612,cpp,"class Solution2 {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        int U[200000];
        int D[200000];
        U[0] = 1;
        for(int i = 1; i < n; i++) {
            if(nums[i] > nums[i-1]) U[i] = U[i-1] + 1;
            else U[i] = 1;
        }
        D[n-1] = 1;
        for(int i = n-2; i >= 0; i--) {
            if(nums[i] < nums[i+1]) D[i] = D[i+1] + 1;
            else D[i] = 1;
        }
        int res = 0;
        for(int i = 1; i < n; i++) {
            res = max(res, min(U[i-1], D[i]));
        }
        return res;
    }
};

class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        return Solution2().maxIncreasingSubarrays(nums) >= k;
    }
};",1448188074
h_bugw7,h_bugw7,414,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        int U[200000];
        int D[200000];
        U[0] = 1;
        for(int i = 1; i < n; i++) {
            if(nums[i] > nums[i-1]) U[i] = U[i-1] + 1;
            else U[i] = 1;
        }
        D[n-1] = 1;
        for(int i = n-2; i >= 0; i--) {
            if(nums[i] < nums[i+1]) D[i] = D[i+1] + 1;
            else D[i] = 1;
        }
        int res = 0;
        for(int i = 1; i < n; i++) {
            res = max(res, min(U[i-1], D[i]));
        }
        return res;
    }
};",1448185700
h_bugw7,h_bugw7,414,3631,cpp,"const int MOD = 1e9+7;

// C(n, k) % MOD
class Combination { 
    vector<long long> fact;
    vector<long long> invFact;
    long long power(long long a, long long b, long long mod) {
        long long res = 1;
        while (b > 0) {
            if (b & 1) res = res * a % mod;
            a = a * a % mod;
            b >>= 1;
        }
        return res;
    }
public:
    Combination(int n): fact(n+1), invFact(n+1) {
        fact[0] = 1;
        for(int i = 1; i <= n; i++) {
            fact[i] = fact[i-1] * i % MOD;
        }
        invFact[n] = power(fact[n], MOD-2, MOD);
        for(int i = n-1; i >= 0; i--) {
            invFact[i] = invFact[i+1] * (i+1) % MOD;
        }
    }
    long long operator()(int n, int k) const {
        if (k < 0 || k > n) return 0;
        return fact[n] * invFact[k] % MOD * invFact[n-k] % MOD;
    }
};


class Solution {
    Combination C;
public:
    Solution(): C(801) { }
    int countKReducibleNumbers(string s, int k) {
        int dp[801];
        dp[0] = dp[1] = 0;
        for(int i = 2; i <= 800; i++) {
            dp[i] = dp[bitcnt(i)] + 1;
        }
        int res = 0;
        vector<int> ones;
        for(int i = 0; i < s.length(); i++) {
            if(s[i] == '1') ones.push_back(i);
        }
        // for(int o: ones) cout << o << ' ';
        // cout << endl;
        for(int i = 1; i <= 800; i++) {
            if(dp[i] < k) {
                int r = solve(ones, s.length(), i);
                res = (res + r) % MOD;
            }
        }
        return res;
    }
    int bitcnt(int x) {
        int res = 0;
        while(x) {
            if(x & 1) res++;
            x >>= 1;
        }
        return res;
    }
    int solve(const vector<int>& v, int len, int k) {
        int res = 0;
        for(int i = 0; i < v.size(); i++) {
            // cout << ""C("" << (len-v[i]-1) << "", "" << (k-i) << "")"" << endl;
            res = (res + C(len-v[i]-1, k-i)) % MOD;
        }
        // cout << ""solve "" << k << "" = "" << res << endl;
        return res;
    }
};",1448287875
h_bugw7,h_bugw7,414,3646,cpp,"const int MOD = 1e9+7;

int cnt[100001];
int sum[100001];

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        memset(cnt, 0, sizeof(cnt));
        memset(sum, 0, sizeof(sum));
        int n = nums.size();
        for(int i = 0; i < n; i++) {
            int& c = cnt[nums[i]];
            int& s = sum[nums[i]];
            c = (c + 1) % MOD;
            s = (s + nums[i]) % MOD;
            for(int x = nums[i]-1; x <= nums[i]+1; x += 2) {
                if(x < 0 || x > 100000) continue;
                c = (c + cnt[x]) % MOD;
                s = (s + sum[x]) % MOD;
                s = (s + (long long)cnt[x] * nums[i] % MOD) % MOD;
            }
            // s = (s + (long long)c * nums[i] % MOD) % MOD;
            // cout << i << "": "" << s << endl;
        }
        int res = 0;
        for(int i = 0; i <= 100000; i++) res = (res + sum[i]) % MOD;
        return res;
    }
};",1448243315
Lisa Shi,yinxiashi,416,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        for a in range(n - 2 * k + 1):
            flag = True
            for i in range(a + 1, a + k):
                if nums[i] <= nums[i - 1]:
                    flag = False
                    break
            if flag:
                for i in range(a + k + 1, a + k + k):
                    if nums[i] <= nums[i - 1]:
                        flag = False
                        break
            if flag:
                return True
        return False
                    ",1448273687
Lisa Shi,yinxiashi,416,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        size = []
        n = len(nums)
        count = 1
        pre = nums[0]
        for i in range(1, n):
            if nums[i] > pre:
                count += 1
            else:
                size.append(count)
                count = 1
            pre = nums[i]
        size.append(count)
        ans = 1
        for c in size:
            ans = max(ans, c // 2)
        for i in range(1, len(size)):
            ans = max(ans, min(size[i], size[i - 1]))
        return ans",1448277863
Lisa Shi,yinxiashi,416,3631,python3,"@cache
def getCount(num):
    ans = 0
    while num > 0:
        if num & 1:
            ans += 1
        num >>= 1
    return ans

@cache
def isReducible(num, k):
    if k == 0:
        return num == 1
    if num == 1:
        return True
    return isReducible(getCount(num), k - 1)

class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        n = len(s)
        MOD = 10**9 + 7
        @cache
        def dfs(index, flag, acc):
            if index == n:
                if flag and acc > 0 and isReducible(acc, k - 1):
                    return 1
                else:
                    return 0
            up = int(s[index])
            if flag:
                up = 1
            ans = 0
            for i in range(up + 1):
                newFlag = flag or i < up
                ans += dfs(index + 1, newFlag, acc + i)
            ans %= MOD
            return ans

        return dfs(0, False, 0)",1448307911
Lisa Shi,yinxiashi,416,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        d = {}
        ans = 0
        MOD = 10**9 + 7
        for num in nums:
            curCount = 1
            curSum = num
            diffs = [-1, 1]
            for diff in diffs:
                pre = num + diff
                if pre in d:
                    c, s = d[pre]
                    curCount += c
                    curSum += s + c * num
            curCount %= MOD
            curSum %= MOD
            ans += curSum
            ans = ans % MOD
            cc, cs = 0, 0
            if num in d:
                cc, cs = d[num]
            cc += curCount
            cs += curSum
            cc %= MOD
            cs %= MOD
            d[num] = (cc, cs)
        return ans",1448288979
jachetheboss,jachetheboss,417,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        
        if k == 1:
            return True
        
        # sliding window
        bound = len(nums) - 2 * k
        for L in range(bound + 1):
        
            ok = True
            for i in range(L + 1, L + k):
                if nums[i] <= nums[i - 1]:
                    ok = False
                    break

            if ok:
                for i in range(L + k + 1, L + 2 * k):
                    if nums[i] <= nums[i - 1]:
                        ok = False
                        break
            if ok:
                return True
                        
        return False
                    ",1448196120
jachetheboss,jachetheboss,417,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        
        # binary search + sliding window subroutine?
        # how about RLE, O(n)
        RLE = []
        prev = -10**9 - 1
        streak = 0
        for num in nums:
            if num > prev:
                streak += 1
            else:
                RLE.append(streak)
                streak = 1
            prev = num
            
        RLE.append(streak)
        
        # print(""RLE"", RLE)
        
        ans = 1
        if len(RLE) == 1: # entire array is strictly increasing
            return RLE[0] // 2
        
        for i in range(len(RLE) - 1):
            ans = max(ans, min(RLE[i], RLE[i + 1]))
        for i in range(len(RLE)):
            ans = max(ans, RLE[i] // 2)
        return ans
        ",1448206106
jachetheboss,jachetheboss,417,3631,python3,"class Solution:
    def getSetBits(num):
            b = bin(num)[2 : ]
            set_bits = 0
            for c in b:
                if c == ""1"":
                    set_bits += 1
            return set_bits
        
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        
        # graph, cycle detection, shortest path from each number to 1?
        # then DP on each binary string rep length to get number of strings having that length that are k-reducible,
        # the tough part will be finding # of k-reducible numbers with binary string rep same length as s
        # akin to a Project Euler problem \U0001f5ff
        
        # O(n^3) won't cut it, have to find O(n^2) DP
        
        MOD = 10**9 + 7
        
        reduce_map = dict()
        reduce_map.update( {1 : 0} ) # 1 is k-reducible, guaranteed
        for ori_num in range(2, len(s) + 1):
            iters = 1
            num = ori_num # original number
            while num != 1 and iters < k:
                num = Solution.getSetBits(num)
                if num == 1:
                    reduce_map.update( {ori_num : iters} )
                    break
                iters += 1
        
        # print(""k_reducible:"", k_reducible)
        # print(""reduce_map"", reduce_map)
        
        DP = [[0 for _ in range(len(s) + 1)] for _ in range(len(s))]
        # DP[i][j] is # of unique k-reducible numbers having binary string repr of length (i + 1) and j set_bits
        # we want positive integers LESS than n, >= 1. [1, n)
        DP[0][1] = 1
        for i in range(1, len(DP)):
            for j in range(1, len(s) + 1):
                # appending a ""0""
                DP[i][j] += DP[i - 1][j]
                # appending a ""1""
                DP[i][j] += DP[i - 1][j - 1]
        
        ans = 0
        for i in range(len(DP) - 1): # account for all nums having binary repr length < len(s)
            for j in range(len(DP[i])):
                if j in reduce_map:
                    ans += DP[i][j]
                    ans %= MOD
                    
        # account for all nums having binary repr length == len(s)
        # s[0] == ""1""
        rolling_set_bits = 0
        for i in range(1, len(s)):
            if s[i] == ""1"":
                # try all binary strings having prefix s[0 : i], s[i] = ""0"", then all possible suffixes
                arr = DP[len(s) - i - 1]
                shifted = [0 for _ in range(len(arr))]
                for j in range(len(arr)):
                    if j + rolling_set_bits >= len(shifted):
                        break
                    shifted[j + rolling_set_bits] = arr[j]
                
                for j in range(len(shifted)):
                    if j in reduce_map:
                        ans += shifted[j]
                        ans %= MOD
                
                rolling_set_bits += 1
            else: # s[i] == ""0""
                # must append ""0"" to our constructed strings
                continue
        
        return ans
            
            ",1448280560
jachetheboss,jachetheboss,417,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        
        # DP?
        ans = 0
        MOD = 10**9 + 7
        di = dict() # unique number mapped to [total_sum, count of subseqs]
        for num in nums:
            to_update = []
            cands = [num - 1, num + 1]
            for cand in cands:
                if cand in di:
                    total = di[cand][0]
                    subseqs = di[cand][1]
                    new_total = total + subseqs * num
                    new_total %= MOD
                    to_update.append([new_total, subseqs])
                    
                    ans += new_total
                    ans %= MOD
                
            if num not in di:
                di.update( {num : [0, 0]} )
                
            for update_pair in to_update:
                di[num][0] += update_pair[0]
                di[num][1] += update_pair[1]
                
            di[num][0] += num # consider just the singleton subseq consitsing of num itself, [num]
            di[num][1] += 1
            
            ans += num
            
        return ans
                
        ",1448307966
Xuanxuan Wang,wxxlouisa,418,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        auto n = nums.size();
        
        auto isIncreasing = [&](int start) -> bool {
            for (int i = start; i < start + k - 1; ++i) {
                if (nums[i] >= nums[i+1]) {
                    return false;
                }
            }
            return true;
        };
        
        for (int i = 0; i <= n - 2 * k; ++i) {
            if (isIncreasing(i) && isIncreasing(i + k)) {
                return true;
            }
        }
        return false;
    }
};",1448182964
Xuanxuan Wang,wxxlouisa,418,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        
        auto canFind = [&](int k) {
            int count = 0;
            vector<int> start = {1};
            
            for (int i = 1; i < n; ++i) {
                if (nums[i] > nums[i - 1]) {
                    start.emplace_back( start[i - 1] + 1);
                } else {
                    start.emplace_back(1);
                }
            }
            for (int i = 0; i <= n - 2 * k; ++i) {
                int x1 = i, y1 = i + k - 1;
                int x2 = i + k, y2 = i + 2 * k - 1;
                if (start[y1] - start[x1] == k - 1 && start[y2] - start[x2] == k-1) {
                    return true;
                }
            }
            return false;
        };
        
        int left = 1, right = n / 2;
        int answer = 0;
        
        while (left <= right) {
            int mid = (left + right) / 2;
            
            if (canFind(mid)) {
                answer = mid;  
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return answer;
    }
};",1448219058
Xuanxuan Wang,wxxlouisa,418,3631,cpp,"class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        const int MOD = 1e9 + 7;
        int n = s.size();
        vector<int> steps(900, -1);

        function<int(int)> calc_steps = [&](int cnt) {
            if (steps[cnt] != -1) return steps[cnt];
            if (cnt <= 1) return steps[cnt] = 0;
            int next_cnt = __builtin_popcount(cnt);
            return steps[cnt] = calc_steps(next_cnt) + 1;
        };

        for (int i = 1; i <= 801; ++i) {
            calc_steps(i);
        }

        vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(n + 10, vector<int>(2, 0)));
        dp[0][0][1] = 1;  // pos, cnt, tight
        
        for (int pos = 0; pos < n; ++pos) {
            for (int cnt = 0; cnt <= n; ++cnt) {
                for (int tight = 0; tight <= 1; ++tight) {
                    int limit = tight ? s[pos] - '0' : 1;
                    for (int digit = 0; digit <= limit; ++digit) {
                        int new_cnt = cnt + digit;
                        int new_tight = tight && (digit == limit);
                        dp[pos+1][new_cnt][new_tight] = (dp[pos+1][new_cnt][new_tight] + dp[pos][cnt][tight]) % MOD;
                    }
                }
            }
        }

        int ans = 0;
        for (int cnt = 1; cnt <= n; ++cnt) {
            if (steps[cnt] < k) {
                //cout << cnt << "" "" << steps[cnt] << endl;
                ans = (ans + dp[n][cnt][0]) % MOD;
            }
        }
        return ans;
    }
};",1448308257
Xuanxuan Wang,wxxlouisa,418,3646,cpp,"#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        const int MOD = 1e9 + 7;
        int n = nums.size();
        
        unordered_map<int, long long> cnt;
        unordered_map<int, long long> cc;
        vector<long long> dp(n, 0);
        vector<long long> c(n, 0);
        long long ans = 0;
        
        for (int i = 0; i < n; ++i) {
            c[i] = 1;
            c[i] = (c[i] + cc[nums[i]-1] + cc[nums[i]+1]) % MOD;
            
            dp[i] = c[i] * nums[i] % MOD;
            dp[i] = (dp[i] + cnt[nums[i] - 1]) % MOD;
            dp[i] = (dp[i] + cnt[nums[i] + 1]) % MOD;
            
            cnt[nums[i]] = (cnt[nums[i]] + dp[i]) % MOD;
            cc[nums[i]] = (cc[nums[i]] + c[i]) % MOD;
            ans = (ans + dp[i]) % MOD;
        }
        return ans;
    }
};",1448245962
lcz12345,lcz12345,419,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int p = 0;
        int t = 1;
        int n = nums.size();
        for (int i = 1; i <= n; i++) {
            if (i < n && nums[i] > nums[i - 1]) {
                t++;
            }
            else {
                if (t >= (k << 1) || !(p < k || t < k)) {
                    return true;
                }
                
                p = t;
                t = 1;
            }
        }
        
        return false;
    }
};",1448202910
lcz12345,lcz12345,419,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int p = 0;
        int t = 1;
        int n = nums.size();
        int res = 0;
        for (int i = 1; i <= n; i++) {
            if (i < n && nums[i] > nums[i - 1]) {
                t++;
            }
            else {
                res = max(
                    max((t >> 1), min(p, t)),
                    res
                );
                p = t;
                t = 1;
            }
        }
        
        return res;
    }
};",1448206885
lcz12345,lcz12345,419,3631,cpp,"class Solution {
public:
    long nCr(int n, int r, vector<vector<int>>& c) {
        if (r == 0 || n == r) {
            return 1;
        }
        
        if (c[n][r] > -1) {
            return c[n][r];
        }
        
        long t = (nCr(n - 1, r - 1, c) + nCr(n - 1, r, c)) % M;
        
        c[n][r] = t;
        
        return t;
    }
    
    int countKReducibleNumbers(string s, int k) {
        int n = s.size();
        vector<vector<int>> c(n + 1, vector<int>(n + 1, -1));
        
        vector<int> t(n + 1);
        t[0] = k + 1;
        t[1] = 0;
        
        auto f = [](int v) {
            int w = 0;
            while (v > 0) {
                w += (v & 1);
                v >>= 1;
            }
            
            return w;
        };
        
        for (int i = 2; i <= n; i++) {
            t[i] = t[f(i)] + 1;
        }
        
        int o = 0;
        for (int i = 0; i < n; i++) {
            o += s[i] - '0';
        }
        
        long res = 0;
        int z = 0;
        for (int i = n - 1; i > -1; i--) {
            if (s[i] == '1') {
                o--;
                for (int j = 0; j <= z; j++) {
                    if (t[o + j] < k) {
                        res = (res + nCr(z, j, c)) % M;
                    }
                }
            }
            
            z++;
        }
        
        return res;
    }
private:
    const int M = 1E9 + 7;
};",1448301803
lcz12345,lcz12345,419,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        unordered_map<int, long> m;
        unordered_map<int, long> s;
        int res = 0;
        for (int n: nums) {
            long t = 1;
            t = (t + m[n - 1]) % M;
            t = (t + m[n + 1]) % M;
            
            m[n] = (m[n] + t) % M;
            
            long w = (t * n) % M;
            w = (w + s[n - 1]) % M;
            w = (w + s[n + 1]) % M;
            
            s[n] = (s[n] + w) % M;
            
            res = (w + res) % M;
        }
        
        return res;
    }
    
private:
    const int M = 1E9 + 7;
};",1448226480
Sambhav Jain,Sambhav-Jain,420,3612,cpp,"class Solution {
    bool isIncreasing(const vector<int> &nums, int l, int r)
    {
        for (int i = l + 1; i <= r; i++)
        {
            if (nums[i] <= nums[i - 1])
            {
                return false;
            }
        }
        return true;
    }
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) 
    {
        for (int i = 0; i + 2 * k - 1 < nums.size(); i++)
        {
            if (isIncreasing(nums, i, i + k - 1) && isIncreasing(nums, i + k, i + 2 * k - 1))
            {
                return true;
            }
        }
        return false;
    }
};",1448185146
Sambhav Jain,Sambhav-Jain,420,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) 
    {
        vector<int> max_len(nums.size(), 1);
        for (int i = 0; i < nums.size();)
        {
            int j = i + 1;
            while (j < nums.size() && nums[j] > nums[j - 1])
            {
                j++;
            }
            for (int k = i; k < j; k++)
            {
                max_len[k] = j - k;
            }
            i = j;
        }
        int ans = 1;
        for (int start = 0, end = nums.size(), mid; start <= end;)
        {
            mid = (start + end) / 2;
            bool flag = false;
            for (int i = 0; i + 2 * mid - 1 < nums.size(); i++)
            {
                if (max_len[i] >= mid && max_len[i + mid] >= mid)
                {
                    flag = true;
                    break;
                }
            }
            if (flag)
            {
                ans = mid; start = mid + 1;
            }
            else
            {
                end = mid - 1;
            }
        }
        return ans;
    }
};",1448193402
Sambhav Jain,Sambhav-Jain,420,3631,cpp,"class Solution {
    const int MOD = 1e9 + 7;
    long long powerMod(long long a,long long b)
    {
        a %= MOD;
        long long ans = 1;
        while (b)
        {
            if (b & 1)
            {
                ans = (ans * a)% MOD;
            }
            a = (a * a) % MOD;
            b >>= 1;
        }
        return ans;
    } 
    
    long long *num,*den;
    void factorialMods(int n)
    {
        num=new long long[n+1],den=new long long[n+1];
        num[0]=1,den[0]=1;
        for(int i=1;i<=n;i++)
        {
            num[i]=(num[i-1]*i) % MOD;
            den[i]=powerMod(num[i], MOD-2);
        }
    }
    long long ncr(const int &n, const int &r)
    {
        long long res = 1;
        res = (res * num[n]) % MOD;
        res = (res * den[r]) % MOD;
        res = (res * den[n - r]) % MOD;
        return res;
    }
public:
    int countKReducibleNumbers(string s, int k) 
    {
        factorialMods(s.size());
        vector<long long> steps(801, 0);
        for (int i = 1; i <= 800; i++)
        {
            int n = i;
            while (n != 1)
            {
                steps[i]++;
                n = __builtin_popcount(n);
            }
        }
        vector<long long> curr(801, 0);
        curr[0] = 1;
        int cnt = 0;
        for (int i = s.size() - 1; i >= 0; i--)
        {
            if (s[i] == '1') cnt++;
            if (s[i] == '1' && i != s.size() - 1)
            {
                if (cnt != 1)
                {                
                    for (int j = curr.size() - 1; j >= 1; j--)
                    {
                        curr[j] = curr[j - 1]; 
                    }
                }
                // for (int i = 0; i <= 6; i++)    
                // {
                //     cout << curr[i] << "" "";
                // }
                // cout << ""\n"";
                for (int j = 1; j + i <= s.size() - 1; j++)
                {
                    curr[j] = (curr[j] + ncr(s.size() - 1 - i, j));
                }
            }
            // for (int i = 0; i <= 6; i++)    
            // {
            //     cout << curr[i] << "" "";
            // }
            // cout << ""\n\n"";
        }
        long long ans = 0;
        for (int i = 1; i <= 800; i++)
        {
            if (steps[i] <= k - 1)
            {
                ans = (ans + curr[i]) % MOD;
            }    
        } 
        return ans;
    }
};",1448288578
Sambhav Jain,Sambhav-Jain,420,3646,cpp,"class Solution {
    const int MOD = 1e9 + 7;
public:
    int sumOfGoodSubsequences(vector<int>& nums) 
    {
        long long sum = 0;
        vector<long long> dp(1e5 + 1, 0), freq (1e5 + 1, 0);
        for (auto &i : nums)
        {
            long long temp = 0;
            long long mult = 1;
            if (i + 1 <= 1e5) mult += freq[i + 1], temp = (temp + dp[i + 1]) % MOD;
            if (i - 1 >= 0) mult += freq[i - 1], temp = (temp + dp[i - 1]) % MOD;
            temp = (temp + mult * i) % MOD;
            sum = (sum + temp) % MOD;
            dp[i] = (dp[i] + temp) % MOD;
            freq[i] = (freq[i] + mult) % MOD;
            cout << sum << "" "";
        }
        return sum;
    }
};",1448210332
Ying-Tu Chen,st993201,421,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        for(int i = 0; i <= n-2*k; i++){
            bool suc = true;
            for(int j = 0; j < k-1; j++){
                if(nums[i+j] >= nums[i+j+1]){
                    suc = false;
                    break;
                }
            }
            if(suc){
                bool b_suc = true;
                int cur = i + k;
                for(int j = 0; j < k-1; j++){
                    if(nums[cur+j] >= nums[cur+j+1]){
                        b_suc = false;
                        break;
                    }
                }
                if(b_suc) return true;
            }
        }
        return false;
    }
};",1448189841
Ying-Tu Chen,st993201,421,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int dp[200010];
        int n = nums.size();
        nums.push_back(INT_MIN);
        memset(dp, 0, sizeof(dp));
        for(int l = 0, r = 0; r < n; r++){
            if(nums[r+1] > nums[r]) continue;
            else{
                while(l <= r){
                    dp[l] = r - l + 1;
                    l++;
                }
            }
        }
        int ans = 0;
        for(int i = 0; i < n; i++){
            int next = i + dp[i];
            ans = max(ans, dp[i]/2);
            if(next < n) ans = max(ans, min(dp[i], dp[next]));
        }
        return ans;
    }
};",1448203170
Ying-Tu Chen,st993201,421,3631,cpp,"class Solution {
public:
    long long table[880];

    long long combine[880][880];

    int mod = 1e9+7;

    long long c(int x, int y){
        if(x < 0 || y < 0 || y > x) return 0;
        if(y == 0 || y == x) return 1;
        if(combine[x][y] != -1) return combine[x][y];
        return combine[x][y] = (c(x-1, y-1) + c(x-1, y)) % mod;
    }



    int countKReducibleNumbers(string s, int k) {
        memset(table, 0, sizeof(table));
        for(int i = 1; i <= 800; i++){
            int tmp = i;
            int cnt = 0;
            while(tmp != 1){
                tmp = __builtin_popcount(tmp);
                cnt++;
            }
            table[i] = cnt;
        }

        long long ans = 0, cnt = 0;
        int n = s.length();
        memset(combine, -1, sizeof(combine));
        for(int i = 0; i < n; i++){
            if(s[i] == '1'){
                for(int j = 1; j <= n; j++){
                    if(table[j] < k){
                        ans = (ans + c(n-1-i, j-cnt)) % mod;
                    }
                }
                cnt++;
            }
        }

        return ans;
        
        
    }
};",1448275092
Ying-Tu Chen,st993201,421,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        long long dp[100010], cnt[100010];
        int mod = 1e9+7;
        int n = nums.size();
        memset(dp, 0, sizeof(dp));
        memset(cnt, 0, sizeof(cnt));
        for(int i = n-1; i >= 0; i--){
            cnt[nums[i]]++;
            dp[nums[i]] += nums[i];
            dp[nums[i]]  = (dp[nums[i]] + dp[nums[i]+1]) % mod;
            dp[nums[i]] = (dp[nums[i]] + ((nums[i] * 1ll * cnt[nums[i]+1]) % mod)) % mod;
            cnt[nums[i]] += cnt[nums[i]+1];
            if(nums[i] - 1 >= 0){
                dp[nums[i]]  = (dp[nums[i]] + dp[nums[i]-1]) % mod;
                dp[nums[i]] = (dp[nums[i]] + ((nums[i] * 1ll * cnt[nums[i]-1]) % mod)) % mod;  
                cnt[nums[i]] += cnt[nums[i]-1];
            }
            cnt[nums[i]] %= mod;
        }

        int ans = 0;
        for(int i = 0; i <= 100000; i++) ans = (ans + dp[i]) % mod;

        return ans;
        
    }
};",1448230735
Prateek8696,Prateek8696,423,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int prev = -1,prev_cc=0,cc=0;
        for(auto t:nums) {
            if(t>prev) {
                cc++;
                prev=t;
            } else {
                prev_cc=cc;
                cc=1;
                prev=t;
            }
            // cout<<prev<<"" ""<<cc<<"" ""<<prev_cc<<"" ""<<endl;
            if(cc>=2*k) {
                return true;
            }
            if(cc>=k&&prev_cc>=k) {
                return true;
            }
        }
        return false;
    }
};",1448198757
Prateek8696,Prateek8696,423,3619,cpp,"class Solution {
public:
    bool check(vector<int>& nums, int k) {
        int prev = -1,prev_cc=0,cc=0;
        for(auto t:nums) {
            if(t>prev) {
                cc++;
                prev=t;
            } else {
                prev_cc=cc;
                cc=1;
                prev=t;
            }
            if(cc>=2*k) {
                return true;
            }
            if(cc>=k&&prev_cc>=k) {
                return true;
            }
        }
        return false;
    }

    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        int i=1,j=n,ans=-1;
        while(i<=j) {
            int mid = (i+j)/2;
            if(check(nums,mid)) {
                i=mid+1;
                ans=mid;
            } else {
                j=mid-1;
            }
        }
        return ans;
    }
};",1448201440
Prateek8696,Prateek8696,423,3631,cpp,"#pragma GCC optimize(""Ofast"")
#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,fma"")
#pragma GCC optimize(""unroll-loops"")
#include <algorithm>
#include <bits/stdc++.h>
#include <chrono>
#include <cmath>
#include <complex>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <list>
#include <map>
#include <queue>
#include <random>
#include <set>
#include <stack>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <vector>

using namespace std;
using namespace __gnu_pbds;
typedef long long ll;
// use less_equal to make it multiset
typedef tree<ll, null_type, less<ll>, rb_tree_tag,
             tree_order_statistics_node_update>
    pbds;
typedef unsigned long long ull;
typedef long double ld;
typedef pair<int, int> p32;
typedef pair<ll, ll> p64;
typedef pair<double, double> pdd;
typedef vector<ll> v64;
typedef vector<int> v32;
typedef vector<vector<int>> vv32;
typedef vector<vector<ll>> vv64;
typedef vector<vector<p64>> vvp64;
typedef vector<p64> vp64;
typedef vector<p32> vp32;
typedef vector<pair<p64, ll>> vpp64;
typedef set<ll> s64;
typedef set<p64> sp64;
typedef multiset<ll> ms64;
typedef multiset<p64> msp64;
typedef map<ll, ll> m64;
typedef map<ll, v64> mv64;
typedef unordered_map<ll, v64> uv64;
typedef unordered_map<ll, ll> u64;
typedef unordered_map<p64, ll> up64;
typedef unordered_map<ll, vp64> uvp64;
typedef priority_queue<ll> pq64;
typedef priority_queue<ll, v64, greater<ll>> pqs64;
const int MOD = 1000000007;
double eps = 1e-12;
#define forn(i, n) for (ll i = 0; i < n; i++)
#define forsn(i, s, e) for (ll i = s; i < e; i++)
#define rforn(i, s) for (ll i = s; i >= 0; i--)
#define rforsn(i, s, e) for (ll i = s; i >= e; i--)
struct custom_hash {
    static uint64_t splitmix64(uint64_t x) {
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        return x ^ (x >> 31);
    }

    size_t operator()(p64 x) const {
        static const uint64_t FIXED_RANDOM =
            chrono::steady_clock::now().time_since_epoch().count();
        return splitmix64(x.first + FIXED_RANDOM) ^
               splitmix64(x.second + FIXED_RANDOM);
    }
    size_t operator()(ll x) const {
        static const uint64_t FIXED_RANDOM =
            chrono::steady_clock::now().time_since_epoch().count();
        return splitmix64(x + FIXED_RANDOM);
    }
};
typedef gp_hash_table<ll, ll, custom_hash> fm64;
typedef gp_hash_table<p64, ll, custom_hash> fmp64;

#define ln ""\n""
#define mp make_pair
#define ie insert
#define pb push_back
#define fi first
#define se second
#define INF 2e18
#define fast_cin()                                                             \
    ios_base::sync_with_stdio(false);                                          \
    cin.tie(NULL);                                                             \
    cout.tie(NULL)
#define all(x) (x).begin(), (x).end()
#define al(arr, n) arr, arr + n
#define sz(x) ((ll)(x).size())
#define dbg(a) cout << a << endl;
#define dbg2(a) cout << a << ' ';
using ld = long double;
using db = double;
using str = string; // yay python!
// INPUT
#define tcT template <class T
#define tcTU tcT, class U
#define tcTUU tcT, class... U
tcT > void re(T& x) { cin >> x; }
tcTUU > void re(T& t, U&... u) {
    re(t);
    re(u...);
}

int find_set(int v, v64& parent) {
    if (-1 == parent[v])
        return v;
    return parent[v] = find_set(parent[v], parent);
}

void union_sets(int a, int b, v64& parent) {
    a = find_set(a, parent);
    b = find_set(b, parent);
    if (a != b)
        parent[b] = a;
}

// function for prime factorization
vector<pair<ll, ll>> pf(ll n) {
    vector<pair<ll, ll>> prime;
    for (int i = 2; i <= sqrt(n); i++) {
        if (n % i == 0) {
            int count = 0;
            while (n % i == 0) {
                count++;
                n = n / i;
            }
            prime.pb(mp(i, count));
        }
    }
    if (n > 1) {
        prime.pb(mp(n, 1));
    }
    return prime;
}

// sum of digits of a number
ll sumofno(ll n) {
    ll sum = 0;
    while (n != 0) {
        sum += n % 10;
        n = n / 10;
    }
    return sum;
}

// modular exponentiation
long long modpow(long long x, long long n, long long p) {

    if (n == 0)
        return 1 % p;

    ll ans = 1, base = x;
    while (n > 0) {
        if (n % 2 == 1) {
            ans = (ans * base) % p;
            n--;
        } else {
            base = (base * base) % p;
            n /= 2;
        }
    }
    if (ans < 0)
        ans = (ans + p) % p;
    return ans;
}

// const int N = 1e6 + 100;
// long long fact[N];
//  initialise the factorial
// void initfact(){
// fact[0] = 1;
// for (int i = 1; i < N; i++)
//{
// fact[i] = (fact[i - 1] * i);
// fact[i] %= MOD;
// }}

// formula for c
// ll C(ll n, ll i)
//{
// ll res = fact[n];
// ll div = fact[n - i] * fact[i];
// div %= MOD;
// div = modpow(div, MOD - 2, MOD);
// return (res * div) % MOD;
// }

long long CW(ll n, ll m) {
    if (m > n - m)
        m = n - m;
    long long ans = 1;
    for (int i = 0; i < m; i++) {
        ans = ans * (n - i) / (i + 1);
    }
    return ans;
}

// function for fast expo
ll fastexpo(ll a, ll b) {
    if (b == 0) {
        return 1;
    }
    if (a == 0) {
        return 0;
    }
    ll y = fastexpo(a, b / 2);
    if (b % 2 == 0) {
        return y * y;
    } else {
        return a * y * y;
    }
}

ll popcount(ll n) {
    ll c = 0;
    for (; n; ++c)
        n &= n - 1;
    return c;
}

ll ce(ll x, ll y) {
    ll res = x / y;
    if (x % y != 0) {
        res++;
    }
    return res;
}

bool pow2(ll x) {
    ll res = x & (x - 1);
    if (res == 0) {
        return true;
    }
    return false;
}

bool isPrime(int x) {
    for (int d = 2; d * d <= x; d++) {
        if (x % d == 0)
            return false;
    }
    return true;
}

int countSetBits(int n) {
    return __builtin_popcount(n);
}

int rs(int n) {
    int cc = 1;
    while(n!=1) {
        n = countSetBits(n);
        cc++;
    }
    return cc;
}

vector<int> res(801);

string s;
ll k;
ll dp[801][2][801][2];
ll sum(ll idx, bool last, ll bits, bool start) {
    if (idx == s.length()) {
        if(bits) {
            return res[bits] <= k;
        }
        return 0;
    }
    auto &x=dp[idx][last][bits][start];
    if(x!=-1) {
        return x;
    }
    ll ans = 0;
    ll till = last ? (s[idx] - '0') : 1;
    forsn(i, 0, till + 1) {
        if(i==0 && start==false) {
            ans+=sum(idx+1,last && (i == till),bits,start);
            ans%=MOD;
        } else {
            ans+=sum(idx+1,last && (i == till),bits+(i==1?1:0),start|(i==1?true:false));
            ans%=MOD;
        }
    }
    return x = ans;
}

ll f() {
    for(int i=1;i<res.size();i++) {
        res[i]=rs(i);
    }
    
    int cc = 0;
    for(auto t:s) {
        cc+=(t=='1'?1:0);
    }
    memset(dp,-1,sizeof(dp));
    ll ans = sum(0,true,0,false);
    if(res[cc]<=k) {
        ans--;
    }
    ans+=MOD;
    ans%=MOD;
    
    return ans;
}

class Solution {
public:
    int countKReducibleNumbers(string p, int kk) {
        s = p;
        k = kk;
        // cout << s << endl;
        return f();
    }
};",1448263412
Prateek8696,Prateek8696,423,3646,cpp,"typedef long long ll;
const int MOD = 1e9 + 7;
class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        ll totalSum = 0; // To accumulate the final sum of good subsequences
        unordered_map<ll, ll>
            frequency; // To track frequency of contributions for each number
        unordered_map<ll, ll>
            subsequenceSum; // To track the sum contributions for each number

        for (ll number : nums) {
            ll count = 1;                  // Initialize count for this number
            ll valueContribution = number; // Initialize the value contribution

            // Handle previous number (number - 1)
            if (number > 0) {
                // Increment count and adjust value contribution based on
                // previous number's data
                count += frequency[number - 1];
                valueContribution +=
                    subsequenceSum[number - 1] + frequency[number - 1] * number;
                count%=MOD;
                valueContribution%=MOD;
            }

            // Handle next number (number + 1)
            if (number < 1e5) { // Ensure we stay within bounds of the map
                count += frequency[number + 1];
                valueContribution +=
                    subsequenceSum[number + 1] + frequency[number + 1] * number;
                count%=MOD;
                valueContribution%=MOD;
            }

            // Update maps with new counts and contributions
            frequency[number] = (frequency[number] + count) % MOD;
            subsequenceSum[number] =
                (subsequenceSum[number] + valueContribution) % MOD;

            // Accumulate the total sum of good subsequences
            totalSum = (totalSum + valueContribution) % MOD;
        }

        return totalSum; // Return the final accumulated sum
    }
};
",1448308973
tomarin,tomarint,425,3612,rust,"impl Solution {
    pub fn has_increasing_subarrays(nums: Vec<i32>, k: i32) -> bool {
        let n = nums.len();
        let mut inc = vec![0; n];
        for i in 1..n {
            if nums[i] > nums[i - 1] {
                inc[i] = inc[i - 1] + 1;
            }
        }
        let k = k as usize;
        for i in k..n {
            if inc[i] >= k-1 && inc[i-k] >= k-1 {
                return true;
            }
        }
        false
    }
}",1448184346
tomarin,tomarint,425,3619,rust,"impl Solution {
    pub fn max_increasing_subarrays(nums: Vec<i32>) -> i32 {
        let n = nums.len();
        let mut inc = vec![];
        let mut cur = 1;
        let mut ans = 1;
        for i in 1..n {
            if nums[i] > nums[i - 1] {
                cur += 1;
                ans = ans.max(cur / 2);
            } else {
                inc.push(cur);
                cur = 1;
            }
        }
        inc.push(cur);
        for i in 1..inc.len() {
            ans = ans.max(inc[i - 1].min(inc[i]));
        }
        ans
    }
}
",1448193796
tomarin,tomarint,425,3631,rust,"const MOD: i64 = 1_000_000_007; // 10**9 + 7

#[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct Mint {
    val: i64,
}

impl Mint {
    pub fn new(n: i64) -> Self {
        let mut new_val = n % MOD + MOD;
        if new_val >= MOD {
            new_val -= MOD;
        }
        Self { val: new_val }
    }

    pub fn pow(&self, n: i64) -> Self {
        if n == 0 {
            Self { val: 1 }
        } else {
            let mut ret = self.pow(n >> 1);
            ret *= ret;
            if (n & 1) != 0 {
                ret *= *self;
            }
            ret
        }
    }

    pub fn inv(&self) -> Self {
        self.pow(MOD - 2)
    }
}

impl std::fmt::Display for Mint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, ""{}"", self.val)
    }
}

impl std::fmt::Debug for Mint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, ""{}"", self.val)
    }
}

impl std::ops::Add for Mint {
    type Output = Self;
    fn add(self, other: Self) -> Self::Output {
        let mut new_val = self.val + other.val;
        if new_val >= MOD {
            new_val -= MOD;
        }
        Self { val: new_val }
    }
}

impl std::ops::Sub for Mint {
    type Output = Self;
    fn sub(self, other: Self) -> Self::Output {
        let mut new_val = self.val + MOD - other.val;
        if new_val >= MOD {
            new_val -= MOD;
        }
        Self { val: new_val }
    }
}

impl std::ops::Mul for Mint {
    type Output = Self;
    fn mul(self, other: Self) -> Self::Output {
        Self {
            val: (self.val * other.val) % MOD,
        }
    }
}

impl std::ops::Div for Mint {
    type Output = Self;
    fn div(self, other: Self) -> Self::Output {
        if other.val == 0 {
            panic!(""0 division occured."");
        }
        self * other.inv()
    }
}

impl std::ops::AddAssign for Mint {
    fn add_assign(&mut self, other: Self) {
        *self = *self + other;
    }
}

impl std::ops::SubAssign for Mint {
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}

impl std::ops::MulAssign for Mint {
    fn mul_assign(&mut self, other: Self) {
        *self = *self * other;
    }
}

impl std::ops::DivAssign for Mint {
    fn div_assign(&mut self, other: Self) {
        *self = *self / other;
    }
}

impl Solution {
    pub fn count_k_reducible_numbers(s: String, k: i32) -> i32 {
        // x が 1 になるまでの回数
        fn calc(x0: usize) -> usize {
            let mut x = x0 as u32;
            let mut cnt = 0;
            while x != 1 {
                x = x.count_ones();
                cnt += 1;
            }
            // println!(""calc {} = {}"", x0, cnt);
            cnt
        }
        let s = s.chars().map(|c| c.to_digit(10).unwrap()).collect::<Vec<_>>();
        let n = s.len();
        // dp[i桁まで見た][k未満か][ビット数] := 通り数
        let mut dp = vec![vec![vec![Mint::new(0); n + 1]; 2]; n + 1];
        if s[0] == 0 {
            dp[0][0][0] = Mint::new(1);
        } else {
            dp[0][0][1] = Mint::new(1);
            dp[0][1][0] = Mint::new(1);
        }
        for i in 1..n {
            if s[i] == 0 {
                for b in 0..n {
                    dp[i][0][b] = dp[i][0][b] + dp[i - 1][0][b];
                }
                for b in 0..n {
                    // 0 にする
                    dp[i][1][b] = dp[i][1][b] + dp[i - 1][1][b];
                    // 1 にする
                    dp[i][1][b + 1] = dp[i][1][b + 1] + dp[i - 1][1][b];
                }
            } else {
                // 1 にする
                for b in 0..n {
                    dp[i][0][b + 1] = dp[i][0][b + 1] + dp[i - 1][0][b];
                }
                // 0 にする
                for b in 0..n {
                    dp[i][1][b] = dp[i][1][b] + dp[i - 1][0][b];
                }
                for b in 0..n {
                    // 0 にする
                    dp[i][1][b] = dp[i][1][b] + dp[i - 1][1][b];
                    // 1 にする
                    dp[i][1][b + 1] = dp[i][1][b + 1] + dp[i - 1][1][b];
                }
            }
        }
        // println!(""dp = {:?}"", dp);
        let mut ans = Mint::new(0);
        for i in 1..=n {
            if calc(i) < k as usize {
                ans += dp[n - 1][1][i];
                // println!(""i={}, dp[n-1][1][i]={}"", i, dp[n - 1][1][i]);
            }
        }
        ans.val as i32
    }
}",1448309351
tomarin,tomarint,425,3646,rust,"const MOD: i64 = 1_000_000_007; // 10**9 + 7

#[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct Mint {
    val: i64,
}

impl Mint {
    pub fn new(n: i64) -> Self {
        let mut new_val = n % MOD + MOD;
        if new_val >= MOD {
            new_val -= MOD;
        }
        Self { val: new_val }
    }

    pub fn pow(&self, n: i64) -> Self {
        if n == 0 {
            Self { val: 1 }
        } else {
            let mut ret = self.pow(n >> 1);
            ret *= ret;
            if (n & 1) != 0 {
                ret *= *self;
            }
            ret
        }
    }

    pub fn inv(&self) -> Self {
        self.pow(MOD - 2)
    }
}

impl std::fmt::Display for Mint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, ""{}"", self.val)
    }
}

impl std::fmt::Debug for Mint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, ""{}"", self.val)
    }
}

impl std::ops::Add for Mint {
    type Output = Self;
    fn add(self, other: Self) -> Self::Output {
        let mut new_val = self.val + other.val;
        if new_val >= MOD {
            new_val -= MOD;
        }
        Self { val: new_val }
    }
}

impl std::ops::Sub for Mint {
    type Output = Self;
    fn sub(self, other: Self) -> Self::Output {
        let mut new_val = self.val + MOD - other.val;
        if new_val >= MOD {
            new_val -= MOD;
        }
        Self { val: new_val }
    }
}

impl std::ops::Mul for Mint {
    type Output = Self;
    fn mul(self, other: Self) -> Self::Output {
        Self {
            val: (self.val * other.val) % MOD,
        }
    }
}

impl std::ops::Div for Mint {
    type Output = Self;
    fn div(self, other: Self) -> Self::Output {
        if other.val == 0 {
            panic!(""0 division occured."");
        }
        self * other.inv()
    }
}

impl std::ops::AddAssign for Mint {
    fn add_assign(&mut self, other: Self) {
        *self = *self + other;
    }
}

impl std::ops::SubAssign for Mint {
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}

impl std::ops::MulAssign for Mint {
    fn mul_assign(&mut self, other: Self) {
        *self = *self * other;
    }
}

impl std::ops::DivAssign for Mint {
    fn div_assign(&mut self, other: Self) {
        *self = *self / other;
    }
}

impl Solution {
    pub fn sum_of_good_subsequences(nums: Vec<i32>) -> i32 {
        let mut cnt = vec![Mint::new(0); 100005];
        let mut sum = vec![Mint::new(0); 100005];
        let n = nums.len();
        for i in 0..n {
            let a = nums[i] as usize;
            cnt[a] += Mint::new(1);
            sum[a] += Mint::new(a as i64);
            cnt[a] = cnt[a] + cnt[a+1];
            sum[a] = sum[a] + sum[a+1] + Mint::new(a as i64) * cnt[a+1];
            if a > 0 {
                cnt[a] = cnt[a] + cnt[a-1];
                sum[a] = sum[a] + sum[a-1] + Mint::new(a as i64) * cnt[a-1];
            }
            // println!(""i={}, a={}, cnt[0..5]={:?}, sum[0..5]={:?}"", i, a, &cnt[0..5], &sum[0..5]);
        }
        let mut ans = Mint::new(0);
        for i in 0..=100000 {
            ans += sum[i];
        }
        ans.val as i32
    }
}
",1448247967
codelelouch0,codelelouch0,426,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        int count = 1;
        for (int i = 1; i < n; i++) {
            if (nums[i] > nums[i-1]) {
                count++;
            } else {
                count = 1;
            }
            if (count >= k) {
                int count2 = 1;
                for (int j = i+2; j < n; j++) {
                    if (nums[j] > nums[j-1]) {
                        count2++;
                    } else {
                        break;
                    }
                }
                if (count2 >= k) return true;
            }
        }
        return false;
    }
};",1448184707
codelelouch0,codelelouch0,426,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp(n, 1);
        for (int i = 1; i < n; i++) {
            if (nums[i] > nums[i-1]) {
                dp[i] = dp[i-1]+1;
            }
        }
        int l = 1, r = n/2+1;
        int res = 1;
        while (l < r) {
            int m = l+(r-l)/2;
            bool f = false;
            for (int i = 0; i < n; i++) {
                if (dp[i] >= m) {
                    if (i+m < n && dp[i+m] >= m) {
                        res = max(res, m);
                        f = true;
                        break;
                    }
                }
            }
            if (f) {
                l = m+1;
            } else {
                r = m;
            }
        }
        return res;
        
    }
};",1448195949
codelelouch0,codelelouch0,426,3631,cpp,"class Solution {
public:
#define ll long long
    ll mod = 1e9+7;
    ll fac[801];
    ll inv[801];
    void f() {
        fac[0] = 1;
        inv[0] = 1;
        for (int i = 1; i <= 800; i++) {
            fac[i] = fac[i-1] * i % mod;
            inv[i] = qinv(fac[i], mod-2);
        }
    }
    ll qinv(ll base, ll exp) {
        ll res = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                res = (res*base) % mod;
            }
            base = (base*base) % mod;
            exp /= 2;
        }
        return res;
    }
    int countKReducibleNumbers(string s, int k) {
        f();
        ll count[801] = {0};
        for (int i = 2; i <= 800; i++) {
            int cnt = 1;
            int tmp = i;
            while (tmp > 1) {
                int tmp2 = tmp;
                int bc = 0;
                while (tmp2) {
                    tmp2 = tmp2 & (tmp2-1);
                    bc++;
                }
                tmp = bc;
                cnt++;
            }
            count[i] = cnt;
        }
        int n = s.size();
        ll res = 0;
        ll cc = 0;
        for (int i = 0; i < n; i++) {
            if (s[i] == '1') {
                int m = n-i-1;
                for (int j = 1; j <= m; j++) {
                    if (count[j+cc] <= k) {
                        res = (res + (fac[m] * inv[j]) % mod * inv[m-j] % mod) % mod;
                    }
                }
                cc++;
            }
        }
        int rc = 0;
        for (int i = 0; i < n; i++) {
            if (s[i] == '1' && cc > 1) {
                if (count[rc+1] <= k) res = (res+1) % mod;
                rc++;
                cc--;
            }
        }
        return res;
    }
};",1448296275
codelelouch0,codelelouch0,426,3646,cpp,"class Solution {
public:
#define ll long long
    int sumOfGoodSubsequences(vector<int>& nums) {
        ll res = 0;
        ll mod = 1e9+7;
        int n = nums.size();
        vector<ll> dp(n, 0);
        unordered_map<int, ll> mp;
        unordered_map<int, int> mp2;
        dp[0] = nums[0];
        mp[nums[0]] = nums[0];
        mp2[nums[0]] = 1;
        for (int i = 1; i < n; i++) {
            dp[i] = (dp[i-1]) % mod;
            ll tmp = nums[i];
            ll x = nums[i];
            tmp = (tmp + mp2[nums[i]-1] * x) % mod;
            tmp = (tmp + mp[nums[i]-1]) % mod;
            tmp = (tmp + mp2[nums[i]+1] * x) % mod;
            tmp = (tmp + mp[nums[i]+1]) % mod;
            dp[i] = (dp[i] + tmp) % mod;
            mp[nums[i]] += tmp;
            mp[nums[i]] %= mod;
            mp2[nums[i]] += 1;
            mp2[nums[i]] += mp2[nums[i]-1];
            mp2[nums[i]] %= mod;
            mp2[nums[i]] += mp2[nums[i]+1];
            mp2[nums[i]] %= mod;
        }
        return dp[n-1];
    }
};",1448230629
JerryGu1,JerryGu1,428,3612,java,"class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        int count = 0;
        int h = -1000000001;
        ArrayList<Integer> l = new ArrayList<>();
        for (Integer i : nums) {
            if (i>h) {
                count++;
                
            } else {
                l.add(count);
                count=1;
            }
            h=i;
            //System.out.println(count);
        }
        l.add(count);
        int ans = l.get(0)/2;
        for (int i=1; i<l.size(); i++) {
            ans=Math.max(ans,Math.min(l.get(i),l.get(i-1)));
            ans=Math.max(ans,l.get(i)/2);
        }
        return (ans>=k);
    }
}",1448196742
JerryGu1,JerryGu1,428,3619,java,"class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        int count = 0;
        int h = -1000000001;
        ArrayList<Integer> l = new ArrayList<>();
        for (Integer i : nums) {
            if (i>h) {
                count++;
                
            } else {
                l.add(count);
                count=1;
            }
            h=i;
            //System.out.println(count);
        }
        l.add(count);
        int ans = l.get(0)/2;
        for (int i=1; i<l.size(); i++) {
            ans=Math.max(ans,Math.min(l.get(i),l.get(i-1)));
            ans=Math.max(ans,l.get(i)/2);
        }
        return ans;
    }
}",1448195115
JerryGu1,JerryGu1,428,3631,java,"class Solution {
    public int countKReducibleNumbers(String s, int k) {
        int n = s.length()+1;
        int[][] count = new int[n][n];
        int[] rem = new int[n];
        count[0][0]=1;
        rem[0]=1;
        int ssum=0;
        int m = 1000000007;
        
        int[] map = new int[n];
        
        for (int i=1; i<n; i++) {
            
            count[i][0]=1;
            for (int j=1; j<=i; j++) {
                count[i][j]=count[i-1][j-1]+count[i-1][j];
                count[i][j]%=m;
            }
            
            if (s.charAt(n-1-i)=='1') {
                //System.out.println(i);
                ssum++;
                int[] newrem = new int[n];
                newrem[0]=1;
                for (int j=1; j<=i; j++) {
                    newrem[j]=rem[j-1]+count[i-1][j];
                    newrem[j]%=m;
                }
                rem=newrem;
            }
            //System.out.println(Arrays.toString(rem));
            
            int bitsum = 0;
            for (int j=0; j<12; j++) {
                if (((1<<j)&i)!=0) bitsum++;
            }
            map[i]=bitsum;
        }
        rem[ssum]--;
        //System.out.println(Arrays.toString(map));
        
        
        //System.out.println(Arrays.toString(rem));
        
        for (int i=1; i<k; i++) {
            int[] newrem = new int[n];
            for (int j=1; j<n; j++) {
                newrem[map[j]]+=rem[j];
                newrem[map[j]]%=m;
            }
            rem=newrem;
            //System.out.println(Arrays.toString(rem));
        }
        
        System.out.println();
        return rem[1];
    }
}",1448296763
JerryGu1,JerryGu1,428,3646,java,"class Solution {
    public int sumOfGoodSubsequences(int[] nums) {
        int n = nums.length;
        int m = 1000000007;
        int[] sums = new int[100002];
        int[] mult = new int[100002];
        for (int i=0; i<n; i++) {
            
            if (nums[i]!=0) sums[nums[i]]+=(sums[nums[i]-1])%m;
            sums[nums[i]]%=m;
            sums[nums[i]]+=(sums[nums[i]+1])%m;
            sums[nums[i]]%=m;
            
            int newmult = 1;
            if (nums[i]!=0) newmult+=(mult[nums[i]-1])%m;
            newmult%=m;
            newmult+=(mult[nums[i]+1])%m;
            newmult%=m;
            
            
            sums[nums[i]]+=(int)( ((long)newmult*nums[i])%m);
            sums[nums[i]]%=m;
            
            mult[nums[i]]+=newmult;
            mult[nums[i]]%=m;
            
            //System.out.println(Arrays.toString(sums).substring(0,50));
            //System.out.println(Arrays.toString(mult).substring(0,50));
        }
        int ans = 0;
        for (int i=0; i<100001; i++) {
            ans+=sums[i];
            ans%=m;
        }
        return ans;
    }
}",1448230115
sunsq,sunsq,430,3612,java,"class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        for (int i = 0; i <= nums.size() - k * 2; i++) {
            if (can(nums, i, i + k - 1) && can(nums, i + k, i + k * 2 - 1)) {
                return true;
            }
        }
        return false;
    }

    private boolean can(List<Integer> nums, int lo, int hi) {
        for (int i = lo + 1; i <= hi; i++) {
            if (nums.get(i) <= nums.get(i - 1)) {
                return false;
            }
        }
        return true;
    }
}",1448183192
sunsq,sunsq,430,3619,java,"class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        int res = 1;
        int cur = 1;
        int pre = 0;
        for (int i = 1; i < nums.size(); i++) {
            if (nums.get(i) > nums.get(i - 1)) {
                cur++;
            } else {
                res = Math.max(res, Math.max(cur / 2, Math.min(cur, pre)));
                pre = cur;
                cur = 1;
            }
        }
        res = Math.max(res, Math.max(cur / 2, Math.min(cur, pre)));
        return res;
    }
}",1448188873
sunsq,sunsq,430,3631,java,"class Solution {
    private static final int MOD = (int) 1e9 + 7;
    private static int[] steps = new int[801];
    static {
        for (int i = 2; i < steps.length; i++) {
            steps[i] = steps[Integer.bitCount(i)] + 1;
        }
    }

    private int k;
    private char[] s;
    private Integer[][] dp;
    
    public int countKReducibleNumbers(String str, int k) {
        this.k = k;
        s = str.toCharArray();
        dp = new Integer[s.length][s.length];
        int res = dfs(0, 0, true, false);
        int cnt = 0;
        for (char c : s) {
            if (c == '1') {
                cnt++;
            }
        }
        if (steps[cnt] <= k - 1) {
            res = (res + MOD - 1) % MOD;
        }
        return res;
    }

    private int dfs(int i, int count, boolean isLimit, boolean isNum) {
        if (i == s.length) {
            if (isNum && steps[count] <= k - 1) {
                return 1;
            }
            return 0;
        }
        if (isNum && !isLimit && dp[i][count] != null) {
            return dp[i][count];
        }
        int res = 0;
        if (!isNum) {
            res = dfs(i + 1, count, false, false);
        }
        int dmin = isNum ? 0 : 1;
        int dmax = isLimit ? s[i] - '0' : 1;
        for (int d = dmin; d <= dmax; d++) {
            res += dfs(i + 1, count + d, isLimit && d == dmax, true);
            res %= MOD;
        }
        if (isNum && !isLimit) {
            dp[i][count] = res;
        }
        return res;
    }
}",1448283640
sunsq,sunsq,430,3646,java,"class Solution {
    private static final int MOD = (int) 1e9 + 7;
    
    public int sumOfGoodSubsequences(int[] nums) {
        int n = nums.length;
        Map<Integer, Long> right = new HashMap<>();
        Map<Integer, Long> left = new HashMap<>();
        long[] r = new long[n];
        for (int i = n - 1; i >= 0; i--) {
            r[i] = right.getOrDefault(nums[i] - 1, 0L) + right.getOrDefault(nums[i] + 1, 0L) + 1;
            long cur = right.getOrDefault(nums[i], 0L);
            right.put(nums[i], (r[i] + cur) % MOD);
        }
        // System.out.println(Arrays.toString(r));
        long res = 0L;
        for (int i = 0; i < n; i++) {
            long l = left.getOrDefault(nums[i] - 1, 0L) + left.getOrDefault(nums[i] + 1, 0L) + 1;
            long cur = left.getOrDefault(nums[i], 0L);
            left.put(nums[i], (l + cur) % MOD);
            res += ((l * r[i]) % MOD) * nums[i];
            res %= MOD;
        }
        return (int) res;
    }
}

// [6,7,7] 46",1448252417
alterdra_1,jerksundertaker,431,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        // dp[i]: longest increasing subarray ending at nums[i]
        int dp[n];
        dp[0] = 1;
        for(int i = 1; i < n; i++){
            dp[i] = nums[i] > nums[i - 1] ? dp[i - 1] + 1 : 1;
        }
        // check dp[i] >= k && dp[i + k] >= k
        for(int i = 0; i < n - k; i++){
            if(dp[i] >= k && dp[i + k] >= k)
                return true;
        }
        return false;
    }
};",1448208126
alterdra_1,jerksundertaker,431,3619,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        // dp[i]: longest increasing subarray ending at nums[i]
        int dp[n];
        dp[0] = 1;
        for(int i = 1; i < n; i++){
            dp[i] = nums[i] > nums[i - 1] ? dp[i - 1] + 1 : 1;
        }
        // check dp[i] >= k && dp[i + k] >= k
        for(int i = 0; i < n - k; i++){
            if(dp[i] >= k && dp[i + k] >= k)
                return true;
        }
        return false;
    }
    int maxIncreasingSubarrays(vector<int>& nums) {
        // If k is valid, then k - 1 is valid
        int n = nums.size();
        int l = 1, r = n;
        while(l < r){
            int mid = (l + r + 1) / 2;
            if(hasIncreasingSubarrays(nums, mid))
                l = mid;
            else
                r = mid - 1;
        }
        return l;
    }
};",1448214158
alterdra_1,jerksundertaker,431,3631,cpp,"class Solution {
public:
    bool valid[801] = {false};
    int memo[801][801][2];
    int mod = 1e9 + 7;
    int dfs(int i, string& s, int cnt, bool tight){
        if(i == s.size())
            return valid[cnt];
        int& ans = memo[i][cnt][tight];
        if(ans != -1)
            return ans;
        ans = 0;
        if(s[i] == '1'){
            ans = (ans + dfs(i + 1, s, cnt + 1, tight)) % mod;
            ans = (ans + dfs(i + 1, s, cnt, false)) % mod;
        }
        else{
            if(!tight)
                ans = (ans + dfs(i + 1, s, cnt + 1, false)) % mod;
            ans = (ans + dfs(i + 1, s, cnt, tight)) % mod;
        }
        return ans;
    }
    int countKReducibleNumbers(string s, int k) {
        // 1st-transform: num <= 800
        // Reducable table for transformed(s), k - 1
        for(int i = 1; i <= 800; i++){
            int val = i;
            if(val == 1) valid[i] = true;
            for(int j = 0; j < k - 1; j++){
                val = __builtin_popcount(val);
                if(val == 1){
                    valid[i] = true;
                    break;
                }
            }
        }
        
        // less than n (s)
        int n = s.size();
        for(int i = n - 1; i >= 0; i--){
            if(s[i] == '1'){
                s[i] = '0';
                break;
            }
            else{
                s[i] = '1';
            }
        }
        
        // backtracking for all num < s, after first transformation is valid
        // digit dp, cnt of one
        memset(memo, -1, sizeof(memo));
        return dfs(0, s, 0, 1);
    }
};",1448303560
alterdra_1,jerksundertaker,431,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int n = nums.size();
        unordered_map<int, pair<int, int>> dp;  // {sum, cnt}
        // dp[i][val]: sum of all subsequences from nums[0..i] endding at val
        // # of subsequence ending at val +- 1 * nums[i] + dp[i - 1][val +- 1] + dp[i - 1][val] + nums[i]
        dp[nums[0]] = {nums[0], 1};
        int mod = 1e9 + 7;
        for(int i = 1; i < n; i++){
            dp[nums[i]].first = (dp[nums[i]].first + nums[i]) % mod;
            dp[nums[i]].second = (dp[nums[i]].second + 1) % mod;
            if(dp.count(nums[i] - 1)){
                auto [prev_sum, prev_cnt] = dp[nums[i] - 1];
                dp[nums[i]].first += (prev_sum + 1LL * nums[i] * prev_cnt) % mod;
                dp[nums[i]].first %= mod;
                dp[nums[i]].second += prev_cnt;
                dp[nums[i]].second %= mod;
            }
            if(dp.count(nums[i] + 1)){
                auto [prev_sum, prev_cnt] = dp[nums[i] + 1];
                dp[nums[i]].first += (prev_sum + 1LL * nums[i] * prev_cnt) % mod;
                dp[nums[i]].first %= mod;
                dp[nums[i]].second += prev_cnt;
                dp[nums[i]].second %= mod;
            }
        }
        
        int ans = 0;
        for(auto& [val, sum_cnt]: dp)
            ans = (ans + sum_cnt.first) % mod;
        return ans;
    }
};",1448260445
Lin,alexlin87,434,3612,java,"import java.util.*;

class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> a, int k) {
        if(k == 1) {
            return true;
        }
        for(int i = 0; i <= a.size() - k * 2; i++) {
            boolean f = true;
            for(int j = i; j < i + k - 1; j++) {
                f &= a.get(j) < a.get(j + 1);
            }
            for(int j = i + k; j < i + k * 2 - 1; j++) {
                f &= a.get(j) < a.get(j + 1);
            }
            if(f) {
                return true;
            }
        }
        return false;
    }
}",1448184916
Lin,alexlin87,434,3619,java,"import java.util.*;

class Solution {
    public int maxIncreasingSubarrays(List<Integer> a) {
        int n = a.size();
        int[] b = new int[n];
        for(int i = 0; i < a.size() - 1; i++) {
            if(a.get(i) >= a.get(i + 1)) {
                b[i] = 1;
            }
            else {
                b[i] = 0;
            }
        }
        int[] c = new int[n];
        for(int i = 0; i < n; i++) {
            c[i] = (i > 0 ? c[i - 1] : 0 ) + b[i];
        }
        int l = 1, r = a.size() / 2;
        while(l < r - 1) {
            int mid = l + (r - l) / 2;
            if(check(a, c, mid)) {
                l = mid;
            }
            else {
                r = mid - 1;
            }
        }
        return check(a, c, r) ? r : l;
    }
    private boolean check(List<Integer> a, int[] c, int k) {
        if(k == 1) {
            return true;
        }
        for(int i = 0; i <= a.size() - k * 2; i++) {
            int l = i, r = l + k * 2 - 1;
            int d = c[r - 1] - (l > 0 ? c[l - 1] : 0);
            if(d == 0 || (d == 1 && a.get(i + k - 1) >= a.get(i + k))) {
                return true;
            }
        }
        return false;
    }
}",1448206453
Lin,alexlin87,434,3631,java,"import java.util.*;

class Solution {
    private int m = (int)1e9 + 7;
    private char[] c;
    private int[] ps;
    private long[][] cf;
    public int countKReducibleNumbers(String s, int k) {
        if(s.equals(""0"")) {
            return 0;
        }
        c = s.toCharArray();
        int n = c.length;
        ps = new int[n];
        ps[0] = c[0] - '0';
        for(int i = 1; i < ps.length; i++) {
            ps[i] = ps[i - 1] + (c[i] - '0');
        }
        cf = binomialCoefficientForSmallInputWithMod(n, m);
        //boolean[] good = new boolean[n + 1];
        int ans = 0;
        for(int bitCnt = 1; bitCnt <= n; bitCnt++) {
            if(apply(bitCnt, k)) {
                ans = (ans + compute(bitCnt)) % m;
            }
        }
        return ans;
    }
    private int compute(int bitCnt) {
        long sum = 0;
        for(int i = 0; i < c.length; i++) {
            if(c[i] == '1') {
                int usedOne = (i > 0 ? ps[i - 1] : 0);
                int remainPosCnt = c.length - (i + 1);
                //pick bitCnt - usedOne from remainPosCnt
                if(bitCnt >= usedOne && bitCnt - usedOne <= remainPosCnt) {
                    sum = (sum + cf[remainPosCnt][bitCnt - usedOne]) % m;
                }
            }
        }
        return (int)sum;
    }
    private boolean apply(int v, int k) {
        int op = 1;
        while(v != 1 && op <= k) {
            v = Integer.bitCount(v);
            op++;
        }
        return op <= k;
    }
    private long[][] binomialCoefficientForSmallInputWithMod(int n, long mod) {
        long[][] binomial = new long[n + 1][n + 1];
        for(int i = 0; i <= n; i++) {
            for(int j = 0; j <= i; j++) {
                if(j == 0 || j == i) {
                    binomial[i][j] = 1;
                }
                else {
                    //either choose the ith item or do not choose the ith item
                    binomial[i][j] = (binomial[i - 1][j - 1] + binomial[i - 1][j]) % mod;
                }
            }
        }
        return binomial;
    }
}",1448297218
Lin,alexlin87,434,3646,java,"import java.util.*;

class Solution {
    private int m = (int)1e9 + 7;
    public int sumOfGoodSubsequences(int[] a) {
        long ans = 0;
        long[] dp1 = new long[100005];
        long[] dp2 = new long[100005];
        for(int x : a) {
            long sum = x;
            if(x > 0) {
                sum = (sum + dp1[x - 1] * x) % m;
                sum = (sum + dp2[x - 1]) % m;
            }
            sum = (sum + dp1[x + 1] * x) % m;
            sum = (sum + dp2[x + 1]) % m;
            ans = (ans + sum) % m;
            if(x > 0) {
                dp1[x] = (dp1[x] + dp1[x - 1]) % m;
            }
            dp1[x] = (dp1[x] + dp1[x + 1]) % m;
            dp1[x] = (dp1[x] + 1) % m;
            dp2[x] = (dp2[x] + sum) % m;
        }
        return (int)ans;
    }
    public static void main(String[] args) {
        Solution solution = new Solution();
        int[] a = new int[]{1,2,1};
        solution.sumOfGoodSubsequences(a);
    }
}",1448257714
mark93192,mark93192,435,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        bool ans=0;
        for(int i=0;i<=nums.size()-2*k;i++){
            int check1=0,check2=0;
            for(int j=i;j<=i+k-2;j++){
                if(nums[j]>=nums[j+1]){
                    check1=1;
                }
            }
            for(int j=i+k;j<=i+2*k-2;j++){
                if(nums[j]>=nums[j+1]){
                    check1=1;
                }
            }
            if(check1==0&&check2==0){
                ans=1;
            }
        }
        return ans;
    }
};",1448183465
mark93192,mark93192,435,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int last_zero=0,last_last_zero=0;
        int ans=0;
        for(int i=1;i<nums.size();i++){
            if(nums[i]<=nums[i-1]){
                last_last_zero=last_zero;
                last_zero=i;
            }
            if(i-last_zero+1>=last_zero-last_last_zero){
                if(last_zero-last_last_zero>ans){
                    ans=last_zero-last_last_zero;
                }
            }
            if(last_zero-last_last_zero>i-last_zero+1){
                if(i-last_zero+1>ans){
                    ans=i-last_zero+1;
                }
            }
            if((i-last_zero+1)/2>ans){
                ans=(i-last_zero+1)/2;
            }
 //           printf(""%d %d\n"",last_zero,last_last_zero);
        }
        return ans;
    }
};",1448210939
mark93192,mark93192,435,3631,cpp,"class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        int MOD=1e9+7;
        vector<int> check_num(s.length()+1,0);
        for(int i=0;i<=s.length();i++){
            int temp=i;
            for(int j=0;j<k-1;j++){
                int temp2=1;
                int temp3=0;
                for(int m=0;m<=29;m++){
                    if((temp2&temp)!=0){
                        temp3++;
                    }
                    temp2=temp2<<1;
                }
                temp=temp3;
            }
            if(temp==1){
                check_num[i]=1;
            }
        }
        
        long long ans=0;
        vector<vector<long long>> dp(s.length(),vector<long long>(s.length()+1,0));
        
        
            
                
                int nums_of_one_now=1;
                dp[0][0]=1;
                for(int j=1;j<s.length();j++){
                    for(int m=0;m<=s.length();m++){                        
                        dp[j][m]+=dp[j-1][m];
                        dp[j][m]%=MOD;
                        if(m>=1){
                            dp[j][m]+=dp[j-1][m-1];
                            dp[j][m]%=MOD;
                        }                      
                    }
                    if(s[j]=='1'){
                        if(nums_of_one_now<=s.length()){
                            dp[j][nums_of_one_now]++;
                            dp[j][nums_of_one_now]%=MOD;
                        }
                        nums_of_one_now++;
                    }
                }

        for(int i=0;i<=s.length();i++){
            if(check_num[i]==1){
                ans+=dp[s.length()-1][i];
                ans%=MOD;
            }
        }
            
        
        return static_cast<int>(ans);
    }
};",1448304019
mark93192,mark93192,435,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int nums_max=-1e9;
        for(int i=0;i<nums.size();i++){
            if(nums[i]>nums_max){
                nums_max=nums[i];
            }
        }
        vector<long long> dp_1(nums_max+1,0);
        vector<long long> dp_2(nums_max+1,0);
        long long ans=0;
        long long MOD=1e9+7;
        for(int i=0;i<nums.size();i++){            
            if(nums[i]!=0){
                dp_1[nums[i]]+=dp_1[nums[i]-1];
                dp_2[nums[i]]+=dp_2[nums[i]-1]+dp_1[nums[i]-1]*static_cast<long long>(nums[i]);
                dp_1[nums[i]]%=MOD;
                dp_2[nums[i]]%=MOD;
            }
            if(nums[i]!=nums_max){
                dp_1[nums[i]]+=dp_1[nums[i]+1];
                dp_2[nums[i]]+=dp_2[nums[i]+1]+dp_1[nums[i]+1]*static_cast<long long>(nums[i]);
                dp_1[nums[i]]%=MOD;
                dp_2[nums[i]]%=MOD;
            }
            dp_1[nums[i]]++;
            dp_1[nums[i]]%=MOD;
            dp_2[nums[i]]+=static_cast<long long>(nums[i]);
            dp_2[nums[i]]%=MOD;
        }
        for(int i=0;i<=nums_max;i++){
            ans+=dp_2[i];
            ans%=MOD;
        }
        return static_cast<int>(ans);
    }
};",1448235278
ToTea,ToTea,437,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        for (int i = 0; i+2*k-1 < nums.size(); ++i) {
            bool valid = true;
            for (int j = 0; j+1 < k; ++j) {
                if (nums[i+j] >= nums[i+j+1]) {
                    valid = false;
                    break;
                }
            }
            if (!valid) continue;
            for (int j = 0; j+1 < k; ++j) {
                if (nums[i+k+j] >= nums[i+k+j+1]) {
                    valid = false;
                    break;
                }
            }
            if (valid) return true;
        }
        return false;
    }
};",1448187158
ToTea,ToTea,437,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        vector<int> leftLens(nums.size(), 1);
        for (int i = 1; i < nums.size(); ++i) {
            if (nums[i] > nums[i-1]) leftLens[i] = leftLens[i-1]+1;
        }
        vector<int> rightLens(nums.size(), 1);
        for (int i = nums.size()-2; i >= 0; --i) {
            if (nums[i] < nums[i+1]) rightLens[i] = rightLens[i+1]+1;
        }
        int ans = 1;
        for (int i = 0; i+1 < nums.size(); ++i) {
            ans = max(ans, min(leftLens[i], rightLens[i+1]));
        }
        return ans;
    }
};",1448196669
ToTea,ToTea,437,3631,cpp,"class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        constexpr int kMod = 1e9 + 7;
        auto bitCount = [](int num){
            int count = 0;
            while (num) {
                count += 1;
                num -= (num & -num);
            }
            return count;
        };
        vector<int> needReduces(s.size()+1);
        for (int i = 2; i < needReduces.size(); ++i) {
            needReduces[i] = needReduces[bitCount(i)] + 1;
        }

        vector<vector<int>> combCaches(s.size()+1, vector<int>(s.size()+1, -1)); // c^n_k dp
        function<int(int,int)> comb = [&](int n, int k){
            int& result = combCaches[n][k];
            if (result != -1) return result;
            if (n == k || k == 0) return 1;
            result = (comb(n-1, k) + comb(n-1, k-1)) % kMod;
            return result;
        };

        int ans = 0;
        int sBitCount = count(s.begin(), s.end(), '1');
        for (int len = 1; len <= s.size(); ++len) {
            if (s[s.size() - len] == '0') continue;
            sBitCount -= 1;
            for (int i = 0; i < len; ++i) {
                if (needReduces[sBitCount+i] >= k) continue;
                ans = (ans + comb(len-1, i)) % kMod;
            }
        }
        return ans - 1;
    }
};",1448304220
ToTea,ToTea,437,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        constexpr int kMod = 1e9 + 7;
        auto addMod = [&](int a, int b){
            return (a + b) % kMod;
        };
        auto mulMod = [&](long a, long b) {
            return (a * b) % kMod;
        };
        unordered_map<int,pair<int,int>> endSumCount;
        int ans = 0;
        for (int num : nums) {
            ans = addMod(ans, num);
            endSumCount[num].first = addMod(endSumCount[num].first, num);
            endSumCount[num].second = addMod(endSumCount[num].second, 1);

            ans = addMod(ans, endSumCount[num-1].first);
            ans = addMod(ans, mulMod(num, endSumCount[num-1].second));
            endSumCount[num].first = addMod(endSumCount[num].first, endSumCount[num-1].first);
            endSumCount[num].first = addMod(endSumCount[num].first, mulMod(num, endSumCount[num-1].second));
            endSumCount[num].second = addMod(endSumCount[num].second, endSumCount[num-1].second);
            
            ans = addMod(ans, endSumCount[num+1].first);
            ans = addMod(ans, mulMod(num, endSumCount[num+1].second));
            endSumCount[num].first = addMod(endSumCount[num].first, endSumCount[num+1].first);
            endSumCount[num].first = addMod(endSumCount[num].first, mulMod(num, endSumCount[num+1].second));
            endSumCount[num].second = addMod(endSumCount[num].second, endSumCount[num+1].second);
        }
        return ans;
    }
};",1448226475
Rakshit Kadam,rax_coder,438,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        for(int i=0;i<n;i++) {
            bool ok = true;
            if(i+2*k-1>=n)break;
            for(int j=i+1;j<i+k;j++) {
                if(nums[j]<=nums[j-1]) ok =false;
            }
            for(int j=i+k+1;j<i+2*k;j++) {
                 if(nums[j]<=nums[j-1]) ok =false;
            }
            if(ok==true)return true;
        }
        return false;
    }
};",1448183963
Rakshit Kadam,rax_coder,438,3619,cpp,"class Solution {
public:
    // bool hasIncreasingSubarrays(vector<int>& nums, int k) {
    //     int n = nums.size();
    //     if(2*k>=n)return false;
    //     for(int i=0;i<n;i++) {
    //         bool ok = true;
    //         if(i+2*k-1>=n)break;
    //         for(int j=i+1;j<i+k;j++) {
    //             if(nums[j]<=nums[j-1]) ok =false;
    //         }
    //         for(int j=i+k+1;j<i+2*k;j++) {
    //              if(nums[j]<=nums[j-1]) ok =false;
    //         }
    //         if(ok==true)return true;
    //     }
    //     return false;
    // }
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        int pref[n];
        int suf[n];
        int ans = 1;
        memset(pref,0,sizeof(pref));
        memset(suf,0,sizeof(suf));
        for(int i=0;i<n;i++) {
            pref[i] = 1;
            if(i && nums[i-1]<nums[i]) pref[i] += pref[i-1];
        }
        for(int i=n-1;i>=0;i--) {
            suf[i] = 1;
            if((i!=n-1) && nums[i+1]>nums[i]) suf[i] += suf[i+1];
            if( i>0) {
                ans = max(ans, min(pref[i-1],suf[i]));
            }
        }
        
        
        return ans;
    }
};",1448215562
Rakshit Kadam,rax_coder,438,3631,cpp,"class Solution {
public:
      int arr[801];
const int MOD = 1e9 + 7; 

long long mod_pow(long long x, long long y, int MOD) {
    long long result = 1;
    while (y > 0) {
        if (y % 2 == 1)
            result = (result * x) % MOD;
        x = (x * x) % MOD;
        y /= 2;
    }
    return result;
}

void precompute_factorials(int n, vector<long long>& fact, vector<long long>& inv_fact, int MOD) {
    fact[0] = 1;
    for (int i = 1; i <= n; i++) {
        fact[i] = (fact[i - 1] * i) % MOD;
    }
    
    inv_fact[n] = mod_pow(fact[n], MOD - 2, MOD); 
    for (int i = n - 1; i >= 0; i--) {
        inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD;
    }
}


long long nCr(int n, int r, const vector<long long>& fact, const vector<long long>& inv_fact, int MOD) {
    if (r > n || r < 0) return 0; 
    return (fact[n] * inv_fact[r] % MOD) * inv_fact[n - r] % MOD;
}

    int calc(int num) {
        if(arr[num]!=-1) return arr[num];
        return arr[num] = 1 + calc(__builtin_popcount(num));
    }

    long long rec(string& s, int k, int bits, const vector<long long>& fact, const vector<long long>& inv_fact )  {
        int n = s.length();
        long long ans = 0;
        int bits_count = 0;
        for(int i=0;i<n;i++) {
            if(s[i]=='1') {
                ans += nCr( n-i-1, bits-bits_count, fact, inv_fact, MOD);
                ans %= MOD;
                bits_count++;
            } 
        }
        return ans;
    }
    int countKReducibleNumbers(string s, int k) {
        int n = 1000;  
        vector<long long> fact(n + 1), inv_fact(n + 1);
    
        precompute_factorials(n, fact, inv_fact, MOD);
        memset(arr,-1,sizeof(arr));
        arr[1] = 0 ;
        for(int i=800;i>1;i--) {
            calc(i);
        }
        long long ans = 0;
        for(int i=0;i<=800;i++) {
            if(arr[i]<=k-1) {
                ans += rec(s,k,i, fact, inv_fact);
                ans %= MOD;
            }
        }
        ans--;
        ans+=MOD;
        ans%=MOD;
        return ans;
        
    }
};",1448297618
Rakshit Kadam,rax_coder,438,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
       int n = nums.size();
        long long pref[n+1];
        long long ans = 0;
        memset(pref,0,sizeof(pref));
        long long mod = 1e9 + 7;
        pref[0] = 1;
        long long seq[n];
        memset(seq,0,sizeof(seq));
        for(int i =1;i<=n;i++) {
            pref[i] = pref[i-1]*2;
            pref[i] %= mod;
        }
        unordered_map<int,int>a,b;
        
        for(int i=n-1;i>=0;i--) {
            seq[i] = (1 +  b[nums[i]-1] + b[nums[i]+1])%mod;
            b[nums[i]] += seq[i];
            b[nums[i]]%=mod;
        }
        for(int i=0;i<n;i++) {
            long long cur = ( 1+ a[nums[i]-1] + a[nums[i]+1])%mod;
            long long yy = (cur * seq[i] )%mod;
            ans += ((yy*nums[i])%mod);
            ans %= mod;
            
            a[nums[i]] += cur;
            a[nums[i]] %= mod;
             
        }
        return ans;
        
    }
};",1448260447
nipunjain099,nipunjain099,439,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int ct=1;
        vector<int> cm(nums.size(),0);
        cm[0]=1;
        for(int it=1;it<nums.size();it++){
            if(nums[it]>nums[it-1]) ct++;
            else ct=1;
            cm[it] = ct;
            if(ct>=k){
                if(it>=k && cm[it-k]>=k) return true;
            }
        }
        return false;
    }
};",1448188185
nipunjain099,nipunjain099,439,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int ct=1;
        vector<int> cm(nums.size(),0);
        cm[0]=1;
        int mx=1;
        for(int it=1;it<nums.size();it++){
            if(nums[it]>nums[it-1]) ct++;
            else ct=1;
            cm[it] = ct;
            if(ct!=it+1){
                if(cm[it-ct]>=ct) mx = max(mx,ct);
            }
            mx = max(mx,ct/2);
        }
        return mx;
    }
};",1448201055
nipunjain099,nipunjain099,439,3631,cpp,"class Solution {
int MOD = 1000000007;

void construct_req(vector<int> &v, int len){
    v[1] = 1;
    int t;
    for(int it=1;it<5;it++){
        for(int it2 = 2;it2<=len;it2++){
            if(v[it2] != 10) continue;
            t= popcount((unsigned int)it2);
            if(v[t] != 10) v[it2] = v[t]+1;
        }
    }
    // for(auto x:v) cout<< x<<"" "";
    // cout<<""\n"";
}
public:
    int countKReducibleNumbers(string s, int k) {
        int len = s.size();
        vector<int> req_k(len+1,10);
        construct_req(req_k,len);
        // unordered_map<int,int> eq_freqs[2];
        int eq_ct=0;
        unordered_map<int,int> less_freqs[2];
        int cur;
        for(int it=0;it<len;it++){
            cur = (it&1);
            less_freqs[cur].clear();
            for(const auto &x:less_freqs[1-cur]){
                less_freqs[cur][x.first+1]+= x.second;
                less_freqs[cur][x.first+1] %= MOD;
                less_freqs[cur][x.first]+= x.second;
                less_freqs[cur][x.first] %= MOD;
            }
            if(s[it] == '1'){
                less_freqs[cur][eq_ct]++;
                eq_ct++;
            }
        }
        int ans=0;
        for(const auto &x:less_freqs[cur]){
            // cout<<x.first<<"" ""<<x.second<<""\n"";
            if(req_k[x.first]<=k){
                ans+= x.second;
                ans %=MOD;
            }
        }
        return ans;
    }
};",1448304393
nipunjain099,nipunjain099,439,3646,cpp,"class Solution {
int mod = 1000000007;
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        unordered_map<long long,pair<long long,long long>> freqs;
        long long sm,ct;
        for(auto num:nums){
            sm = num;
            ct = 1;
            if(freqs.contains(num-1)){
                sm += num*(freqs[num-1].second);
                sm %= mod;
                sm += freqs[num-1].first;
                sm %= mod;
                ct += freqs[num-1].second;
                ct %= mod;
            }
            if(freqs.contains(num+1)){
                sm += num*(freqs[num+1].second);
                sm %= mod;
                sm += freqs[num+1].first;
                sm %= mod;
                ct += freqs[num+1].second;
                ct %= mod;
            }
            freqs[num].first += sm;
            freqs[num].first %= mod;
            freqs[num].second += ct;
            freqs[num].second %= mod;
        }
        sm=0;
        for(const auto &x: freqs){
            // cout<<num<<"" ""<<sm<<"" ""<<ct<<endl;
            sm+= x.second.first;
            sm%= mod;
        }
        return (int)sm;
    }
};",1448229617
Monolith,Hidded_Monolith,440,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n=nums.size();
        for(int i=0;i<n-2*k+1;i++)
        {

            bool res=1;
            int ptr1=i;
            int ptr2=i+k;
            int cnt=k;
            int prev1=-100000;
            int prev2=-100000;
            while(cnt--)
            {
                res&=(nums[ptr1]>prev1 && nums[ptr2]>prev2);
                prev1=nums[ptr1];
                prev2=nums[ptr2];
                ptr1++;
                ptr2++;
            }
            cout<<ptr1<<"" ""<<ptr2<<""\n"";
            if(res)
            {
                return res;
            }
        }
        return 0;
    }
};",1448187461
Monolith,Hidded_Monolith,440,3619,cpp,"class Solution {
public:

    int maxIncreasingSubarrays(vector<int>& nums) {
        int n=nums.size();
        vector<int>score(n,0);
        int cnt=0;
        int prev=INT_MIN;
        for(int i=0;i<n;i++)
        {
            if(nums[i]>prev)
            {
                prev=nums[i];
                cnt++;
            }
            else
            {
                prev=nums[i];
                cnt=1;
            }
            score[i]=cnt;
            // cout<<cnt<<"" "";
        }
        int l=1;
        int r=n;
        int ans=1;
        while(l<=r)
        {
            int mid=l+(r-l)/2;
            bool res=0;
            for(int i=0;i<n;i++)
            {
                // cout<<i<<""\n"";
                if(i+mid<n)
                {
                   res|=(score[i]>=mid && score[i+mid]>=mid);
                }
            }
            // cout<<l<<"" ""<<r<<"" ""<<res<<""\n"";
            if(res)
            {
                ans=mid;
                l=mid+1;
            }
            else
            {
                r=mid-1;
            }
            // cout<<l<<"" ""<<r<<""\n"";
        }
        return ans;
    }
};",1448216077
Monolith,Hidded_Monolith,440,3631,cpp,"class Solution {
public:
    const int mod=1e9+7;
    int recursion(int i, int j,int flag, string &s, vector<vector<vector<int>>>&dp)
    {
        if(i>=s.size())
        {
            return (j==0 && flag);
        }
        if(dp[i][j][flag]!=-1)
        {
            return dp[i][j][flag];
        }
        long long  ans=recursion(i+1,j,(flag|(s[i]=='1')),s,dp);
        if(j)
        {
            if(flag)
            {
               ans+=recursion(i+1,j-1,flag,s,dp);
            }
            else if(s[i]=='1')
            {
                ans+=recursion(i+1,j-1,flag,s,dp);
            }
        }
        ans%=mod;
        return dp[i][j][flag]=(int)ans;
        
    }
    int countKReducibleNumbers(string s, int k) {
        int n=s.size();
        long long ans=0;
        vector<vector<vector<int>>>dp(n,vector<vector<int>>(n+1,vector<int>(2,-1)));
        for(int cnt=1;cnt<=n;cnt++)
        {
            int moves=0;
            int number=cnt;
            while(number>1)
            {
                number=__builtin_popcount(number);
                moves++;
            }
            if(moves<k)
            {
                ans+=recursion(0,cnt,0,s,dp);
                ans%=mod;
            }
        }
        return ans;
    }
};",1448284931
Monolith,Hidded_Monolith,440,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        const int mod=1e9+7;
        map<int,long long>dp;
        map<int,long long>cnt;
        int n=nums.size();
        long long ans=0;
        for(int i=n-1;i>=0;i--)
        {
            dp[nums[i]]+=(dp[nums[i]+1]+dp[nums[i]-1]+(1ll*cnt[nums[i]+1]+cnt[nums[i]-1]+1)*nums[i])%mod;
            // cout<<dp[nums[i]]<<""\n"";
            cnt[nums[i]]+=(cnt[nums[i]+1]+cnt[nums[i]-1]+1);
            cnt[nums[i]]%=mod;
        }
        for(auto it:dp)
        {
            // cout<<it.second<<"" "";
            ans+=it.second;
            ans%=mod;
        }
        return (int)ans;
    }
};",1448246437
Orz,retired_kid,441,3612,java,"class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        return check(nums, k);
    }
    public boolean check(List<Integer> nums, int k) {
        int n = nums.size();
        boolean res = false;
        for (int i = 0; i <= n - 2 * k; i++) {
            boolean flg = true;
            int prev = -(1<<30);
            for (int j = i; j < i + k; j++) {
                if (nums.get(j) <= prev) {
                    flg = false; break; 
                }
                prev = nums.get(j);
            }
            prev = -(1<<30);
            for (int j = i + k; j < i + 2 * k; j++) {
                if (nums.get(j) <= prev) {
                    flg = false; break;
                }
                prev = nums.get(j);
            }
            res |= flg;
        }
        return res;
    }
}",1448184218
Orz,retired_kid,441,3619,java,"class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        List<Integer> cnt = new ArrayList<>();
        int c = 1, prev = nums.get(0);
        for (int i = 1; i < nums.size(); i++) {
            if (prev < nums.get(i)) {
                c++;
            } else {
                cnt.add(c);
                c = 1;
            }
            prev = nums.get(i);
        }
        cnt.add(c);
        int ans = 0;
        for (int i = 0; i < cnt.size(); i++) {
            int v = cnt.get(i);
            ans = Math.max(v / 2, ans);
            if (i + 1 < cnt.size()) {
                ans = Math.max(ans, Math.min(cnt.get(i), cnt.get(i + 1)));
            }
        }
        return ans;
    }
}",1448190490
Orz,retired_kid,441,3631,java,"class Solution {
    static boolean[][] reducible;
    static boolean init = false;
    static int MOD = (int) 1e9 + 7, MM = 805;
    public Integer[][][] dp;
    public int countKReducibleNumbers(String s, int k) {
        int n = s.length();
        if (!init) {
            func();
        }
        dp = new Integer[n + 1][3][n + 1]; // first i bits, equal(0),smaller(1)/larger(2), set bits count
        return dfs(0, 0, 0, s, k);
    }
    public int dfs(int i, int flg, int cnt, String s, int k) {
        if (i == s.length()) {
            return (flg == 1) && check(cnt, k - 1) ? 1 : 0;
        } else if (dp[i][flg][cnt] != null) return dp[i][flg][cnt];
        int ret = check(cnt, k - 1) ? 1 : 0; // stop here
        // set bit to 0
        if (cnt > 0) {
            if (s.charAt(i) == '1' && flg == 0) {
                ret += dfs(i + 1, 1, cnt, s, k);
            } else {
                ret += dfs(i + 1, flg, cnt, s, k);
            }
        }
        // set bit to 1
        if (flg == 0) { // equal
            if (s.charAt(i) == '1') {
                ret += dfs(i + 1, 0, cnt + 1, s, k);
            } else {
                ret += dfs(i + 1, 2, cnt + 1, s, k);
            }
        } else { // smaller/larger
            ret += dfs(i + 1, flg, cnt + 1, s, k);
        }
        ret %= MOD;
        return dp[i][flg][cnt] = ret;
    }
    static boolean check(int v, int k) {
        for (int i = 0; i <= k; i++) {
            if (reducible[v][i]) return true;
        }
        return false;
    }
    static void func() {
        reducible = new boolean[MM][10]; // digit count whether is reducible to 1
        for (int i = 1; i < MM; i++) {
            for (int j = 0; j <= 5; j++) {
                int val = i, req = 0;
                while (val != 1) {
                    int cnt = 0;
                    for (char c : int2binary(val).toCharArray()) {
                        if (c == '1') cnt++;
                    }
                    val = cnt;
                    req++;
                }
                if (req == j) {
                    reducible[i][j] = true;
                }
            }
        }
    }
    static String int2binary(long v){
        StringBuilder sb = new StringBuilder();
        while (v!=0){
            sb.append(v%2);
            v/=2;
        }
        return sb.reverse().toString();
    }
}",1448291485
Orz,retired_kid,441,3646,java,"class Solution {
    int MOD = (int) 1e9 + 7;
    public int sumOfGoodSubsequences(int[] nums) {
        int n = nums.length;
        long[] l = new long[n + 5];
        long[] r = new long[n + 5];
        Map<Integer, Long> mp = new HashMap<>();
        for (int i = 1; i <= n; i++) {
            int v = nums[i - 1];
            l[i] = 1;
            l[i] += mp.getOrDefault(v, 0L); l[i] %= MOD;
            l[i] += mp.getOrDefault(v - 1, 0L); l[i] %= MOD;
            l[i] += mp.getOrDefault(v + 1, 0L) - mp.getOrDefault(v, 0L); l[i] += MOD; l[i] %= MOD;
            mp.put(v, (mp.getOrDefault(v, 0L) % MOD + l[i] % MOD) % MOD);
        }
        mp.clear();
        for (int i = n; i >= 1; i--) {
            int v = nums[i - 1];
            r[i] = 1;
            r[i] += mp.getOrDefault(v, 0L); r[i] %= MOD;
            r[i] += mp.getOrDefault(v - 1, 0L); r[i] %= MOD;
            r[i] += mp.getOrDefault(v + 1, 0L) - mp.getOrDefault(v, 0L); r[i] += MOD; r[i] %= MOD;
            mp.put(v, (mp.getOrDefault(v, 0L) % MOD + r[i] % MOD) % MOD);
        }
        // System.out.println(Arrays.toString(l));
        // System.out.println(Arrays.toString(r));
        long ans = 0;
        for (int i = 1; i <= n; i++) {
            long val = (((l[i] % MOD * r[i] % MOD) % MOD)) % MOD;
            val = ( val % MOD * nums[i - 1] % MOD) % MOD;
            ans += val;
            ans %= MOD;
            // System.out.println(i + "" "" + val);
        }
        return (int) ans;
    }
}",1448235188
Feng W,wddd,442,3612,java,"class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        boolean[] increasing = new boolean[nums.size() - k + 1];

        for (int i = 0; i < increasing.length; i++) {
            boolean temp = true;
            for (int j = i + 1; j < i + k; j++) {
                if (nums.get(j) <= nums.get(j - 1)) {
                    temp = false;
                    break;
                }
            }

            increasing[i] = temp;
            if (increasing[i] && i - k >= 0 && increasing[i - k]) {
                return true;
            }
        }
        // System.out.println(Arrays.toString(increasing));
        return false;
    }
}",1448185432
Feng W,wddd,442,3619,java,"class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        int[] increasing = new int[nums.size()];
        for (int i = 0; i < increasing.length; i++) {
            increasing[i] = i;
        }

        int p = 0;
        int max = 0;

        while (p < nums.size()) {
            int right = p;
            while (right + 1 != nums.size() && nums.get(right) < nums.get(right + 1)) {
                right++;
            }

            max = Math.max(max, (right - p + 1) / 2);

            increasing[p] = right;

            p = right + 1;
        }

        for (int i = 0; i < increasing.length; i++) {
            int right = increasing[i];
            if (right + 1 < increasing.length) {
                int temp = Math.min(right - i + 1, increasing[right + 1] - (right + 1) + 1);
                max = Math.max(max, temp);
            }
        }
        
        // System.out.println(Arrays.toString(increasing));

        return max;
    }
}",1448205932
Feng W,wddd,442,3631,java,"class Solution {
    public int countKReducibleNumbers(String s, int k) {
        int[] reducible = new int[s.length() + 1];
        reducible[1] = 1;
        for (int i = 2; i < reducible.length; i++) {
            reducible[i] = 1 + reducible[Integer.bitCount(i)];
        }

        int n = s.length();

        int mod = (int) (1e9 + 7);

        BCMod bcMod = new BCMod(n, mod);

        long result = 0;
        for (int i = 1; i <= n - 1; i++) {
            int r = reducible[i];

            if (r <= k) {
                result += bcMod.comb(n - 1, i); //comb1(n - 1, i);
                result %= mod;
            }
        }

        int one = 1;
        for (int i = 1; i < s.length(); i++) {
            if (s.charAt(i) == '1') {
                if (one == 1 && i == s.length() - 1) {
                    result++;
                } else {
                    for (int j = 0; j <= s.length() - 1 - i; j++) {
                        int r = reducible[j + one];
                        if (r <= k) {
                            result += bcMod.comb(n - 1 - i, j); // comb1(s.length() - 1 - i, j);
                            result %= mod;
                        }
                    }
                }
                one++;
            }
        }

        return (int) (result % mod);
    }

    public class BCMod {
        private long[][] triangle;

        public BCMod(int maxN, int mod) {
            triangle = new long[maxN + 1][maxN + 1];
            triangle[0][0] = 1;

            for (int i = 1; i <= maxN; i++) {
                triangle[i][0] = 1;
                for (int j = 1; j <= i; j++) {
                    triangle[i][j] = triangle[i - 1][j] + triangle[i - 1][j - 1];
                    triangle[i][j] %= mod;
                }
            }
        }

        public long comb(int n, int r) {
            if (n < 0 || r < 0) {
                return 0;
            }

            return triangle[n][r];
        }
    }

}",1448298132
Feng W,wddd,442,3646,java,"class Solution {
    public int sumOfGoodSubsequences(int[] nums) {
        int mod = (int) (1e9 + 7);
        
        Map<Integer, long[]> processed = new HashMap<>();

        for (int i = nums.length - 1; i >= 0; i--) {
            long[] curr = processed.getOrDefault(nums[i], new long[] {0, 0});
            curr[0] += nums[i];
            curr[1] += 1;

            long sum = 0;
            long count = 0;

            long[] prev1 = processed.getOrDefault(nums[i] - 1, new long[] {0, 0});
            sum += prev1[0];
            sum %= mod;
            count += prev1[1];
            count %= mod;

            long[] prev2 = processed.getOrDefault(nums[i] + 1, new long[] {0, 0});
            sum += prev2[0];
            sum %= mod;
            count += prev2[1];
            count %= mod;

            curr[0] += sum;
            curr[0] %= mod;
            curr[0] += nums[i] * count;
            curr[0] %= mod;
            curr[1] += count;
            curr[1] %= mod;

            processed.put(nums[i], curr);
        }

        long result = 0;
        for (long[] values : processed.values()) {
            result += values[0];
            result %= mod;
        }
        return (int) (result % mod);
    }
}",1448236675
yunjiexiao13,yunjiexiao13,443,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> inc(n);
        int cur = 0;
        int last = INT_MIN;
        for(int i = 0;i < n;i++)
            {
                if(nums[i] > last) cur++;
                else cur = 1;
                last = nums[i];
                inc[i] = cur;
            }
        for(int i = k - 1;i + k < n;i++)
            {
                if(inc[i] >= k && inc[i + k] >= k) return true;
            }
        return false;
    }
};",1448194782
yunjiexiao13,yunjiexiao13,443,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> inc(n);
        int cur = 0;
        int last = INT_MIN;
        for(int i = 0;i < n;i++)
            {
                if(nums[i] > last) cur++;
                else cur = 1;
                last = nums[i];
                inc[i] = cur;
            }
        auto check = [&](int x)
        {
            for(int i = x - 1;i + x < n;i++)
                {
                    if(inc[i] >= x && inc[i + x] >= x) return true;
                }
            return false;
        };
        int l = 1,r = n/2 + 1;
        while(l < r - 1)
            {
                int mid = (l + r)>>1;
                if(check(mid)) l = mid;
                else r = mid;
            }
        return l;
    }
};",1448192699
yunjiexiao13,yunjiexiao13,443,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        mod = int(1e9 + 7)
        d = defaultdict(list)
        n = len(s)
        for i in range(1,801):
            cnt = 0
            t = i
            while i > 1:
                i = sum(1 for i in bin(i) if i == '1')
                cnt += 1
            i = t
            d[cnt].append(i)
        L = []
        ans = 0
        for i in range(k): L += d[i]
        print(L)
        cur = 0
        for i in range(n):
            if s[i] == '0': continue
            for x in L:
                if cur <= x and n - 1 - i >= 0:
                    # print(x)
                    # print(n - 1 - cur,x - cur)
                    ans += comb(n - 1 - i,x - cur)
            cur += 1
        return ans%mod",1448298522
yunjiexiao13,yunjiexiao13,443,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int mod = 1e9 + 7;
        long long ans = 0;
        unordered_map<int,long long> mp1,mp2;
        for(int x:nums)
        {
            long long temp = (long long)(1 + mp1[x - 1] + mp1[x + 1])*x%mod;
            long long sum = (mp2[x - 1] + mp2[x + 1])%mod;
            ans = (ans + sum + temp)%mod;
            mp1[x] = (mp1[x] + 1 + mp1[x - 1] + mp1[x + 1])%mod;
            mp2[x] = (mp2[x] + sum + temp)%mod;
            // cout<<x<<"" ""<<ans<<endl;
        }
        return ans;
    }
};",1448238083
kakumanisaiprem,kakumanisaiprem,444,3612,cpp,"class Solution {
    bool isInc(int i,vector<int> &nums,int k){
        for(int j = i+1;j < i+k;j ++){
            if(nums[j] <= nums[j-1]) return false;
        }
        return true;
    }
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        for(int i = 0;i+2*k <= n;i ++){
            if(isInc(i,nums,k) and isInc(i+k,nums,k)){
                return true;
            }
        }
        return false;
    }
};",1448188257
kakumanisaiprem,kakumanisaiprem,444,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> suf(n,1);
        
        for(int i = n-2;i >= 0;i --){
            if(nums[i] < nums[i+1]){
                suf[i] = 1+suf[i+1];
            }
            cout<<suf[i]<<"" "";
        }
        cout<<endl;
        
        int mx = 1;
        for(int i = 0;i < n;i ++){
            int j = i+suf[i];
            if(j < n and suf[j] >= suf[i]){
                mx = max(mx,suf[i]);
            }
            mx = max(mx,suf[i]/2);
        }
        return mx;
    }
};",1448199188
kakumanisaiprem,kakumanisaiprem,444,3631,cpp,"using ll = long long;
class Solution{
    int N = 1e9+7;
    ll fact[801];
    ll binPow(ll a,ll b){
        ll res = 1;
        while(b){
            if(b&1){
                res = (res*a)%N;
            }
            a = (a*a)%N;
            b >>= 1;
        }
        return res;
    }
    
    ll nCr(int n,int r){
        ll res = (fact[n-r]*fact[r])%N;
        res = binPow(res,N-2);
        res = (res * fact[n])%N;
        
        return res;
    }
    
    public:
    int countKReducibleNumbers(string s, int k){
        int n = s.size();
        
        ll red[n+1];
        red[1] = 0ll;
        
        vector<int> v = {1};
        
        for(int i = 2;i <= n;i ++){
            int val = __builtin_popcount(i);
            red[i] = 1+red[val];
            
            if(red[i] < k){
                v.push_back(i);
            }
        }
        fact[0] = 1ll;
        fact[1] = 1ll;
        for(ll i = 2;i <= 800;i ++){
            fact[i] = (i*fact[i-1])%N;
        }
        
        int cnt = 0;
        for(int i = n-1;i >= 0;i --){
            if(s[i] == '1') cnt += 1;
        }
        
        
        int sz = v.size();
        // for(int i = 0;i < sz;i ++){
        //     cout<<v[i]<<"" "";
        // }
        // cout<<endl;
        
        ll res = 0ll;
        for(int i = n-1;i >= 0;i --){
            if(s[i] == '1'){
                cnt --;
                for(int j = 0;j < sz;j ++){
                    if((v[j] >= cnt) and (n-i-1) >= (v[j]-cnt)){
                        // cout<<i<<"" ""<<(n-i-1)<<"" ""<<(v[j]-cnt)<<endl;
                        res = (res + nCr(n-i-1,v[j]-cnt))%N;
                    }
                }
            }
        }
        
        return res;
    }
};",1448305181
kakumanisaiprem,kakumanisaiprem,444,3646,cpp,"using ll = long long;
class Solution {
    ll freq[100002];
    ll sum[100002];
    int N = 1e9+7;
    public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int n = nums.size();
        for(int i = 0;i <= 100001;i ++){
            freq[i] = 0ll;
            sum[i] = 0ll;
        }
        ll tot = 0;
        for(int i = n-1;i >= 0;i --){
            ll cur = 1+freq[nums[i]+1];
            if(nums[i] > 0) cur += freq[nums[i]-1];
            
            freq[nums[i]] = (freq[nums[i]] + cur)%N;
            
            ll cur_sum = ((cur*nums[i])%N + sum[nums[i]+1])%N;
            if(nums[i] > 0) cur_sum = (cur_sum + sum[nums[i]-1])%N;
            
            sum[nums[i]] = (sum[nums[i]] + cur_sum)%N;
            
            tot = (tot+cur_sum)%N;
        }
        return tot;
    }
};",1448230602
Shady Mansour,shadymansour19,446,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        incLen = [1 for i in range(n)]
        for i in range(n-2, -1, -1):
            if nums[i] < nums[i+1]:
                incLen[i] += incLen[i+1]

        for i in range(n-k):
            if incLen[i] >= k and incLen[i+k] >= k:
                return True
        return False",1448185212
Shady Mansour,shadymansour19,446,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        incLen = [1 for i in range(n)]
        for i in range(n-2, -1, -1):
            if nums[i] < nums[i+1]:
                incLen[i] += incLen[i+1]
        
        l = 0
        r = n//2
        maxK = 0

        while l <= r:
            k = (l + r) // 2
            val = False
            for i in range(n-k):
                if incLen[i] >= k and incLen[i+k] >= k:
                    val = True
                    break

            if val:
                maxK = k
                l = k+1
            else:
                r = k-1
        
        return maxK",1448190266
Shady Mansour,shadymansour19,446,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        if s == '1':
            return 0
        
        steps = [0 for i in range(801)]
        steps[1] = 1
        for i in range(2, 800):
            sb = sum([((i>>j) & 1) for j in range(20)])
            steps[i] = 1 + steps[sb]

        onesPos = []
        for i in range(len(s)):
            if s[i] == '1':
                onesPos.append(len(s) - 1 - i)
        ones = len(onesPos)

        ncr = [[0 for j in range(len(s)+1)] for i in range(len(s)+1)]
        for i in range(len(s)+1):
            ncr[i][0] = 1
            for j in range(1, i+1):
                ncr[i][j] = (ncr[i][j-1] * (i-j+1)) // (j)
        
        m = 10**9 + 7
        ways = 0
        for i in range(1, len(s)+1):
            if steps[i] <= k:
                for o in range(ones):
                    if i-o < 0 or i-o > onesPos[o]:
                        break
                    ways += ncr[onesPos[o]][i-o]
                    ways %= m

        return ways",1448279324
Shady Mansour,shadymansour19,446,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        numSeq = {}
        sumSeq = {}
        m = 10**9 + 7

        for i in range(len(nums)-1, -1, -1):
            if nums[i] not in numSeq:
                numSeq[nums[i]] = 0
                sumSeq[nums[i]] = 0
                
            numSeq[nums[i]] += 1
            sumSeq[nums[i]] += nums[i]

            if nums[i]+1 in numSeq:
                numSeq[nums[i]] += numSeq[nums[i]+1]
                sumSeq[nums[i]] += sumSeq[nums[i]+1] + nums[i] * numSeq[nums[i]+1]
            if nums[i]-1 in numSeq:
                numSeq[nums[i]] += numSeq[nums[i]-1]
                sumSeq[nums[i]] += sumSeq[nums[i]-1] + nums[i] * numSeq[nums[i]-1]

            sumSeq[nums[i]] %= m
            numSeq[nums[i]] %= m

        return sum(sumSeq[num] for num in sumSeq) % m",1448206590
Denys Gubar,DenisGubar,447,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int const N = nums.size();
        for (int a = 0; a + 2 * k <= N; ++a)
        {
            bool isOk = true;
            for (int i = 1; i < k; ++i)
                isOk &= nums[a + i - 1] < nums[a + i];
            if (!isOk) continue;
            int b = a + k;
            {
                isOk = true;
                for (int i = 1; i < k; ++i)
                    isOk &= nums[b + i - 1] < nums[b + i];
                if (isOk)
                    return true;
            }
        }
        return false;
    }
};
",1448184372
Denys Gubar,DenisGubar,447,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int result = 1;
        int const N = nums.size();
        nums.push_back(nums.back() - 1);
        vector<int> A;
        A.reserve(N);
        for (int i = 1, count = 1; i <= N; ++i)
            if (nums[i - 1] >= nums[i])
                A.push_back(count), count = 1;
            else
                ++count;
        int const M = A.size();
        for (int x : A)
            result = max(result, x / 2);
        for (int i = 1; i < M; ++i)
            result = max(result, min(A[i - 1], A[i]));
        return result;
    }
};
",1448191838
Denys Gubar,DenisGubar,447,3631,cpp,"static int const MOD = 1'000'000'007;
static int G[801];
static bool isInit = false;
static void init()
{
    if (!isInit)
    {
        isInit = true;
        memset(G, 0, sizeof(G));
        auto bitCount = [](int x)
            {
                int result = 0;
                while (x > 0)
                    ++result, x &= x - 1;
                return result;
            };
        for (int i = 2; i <= 800; ++i)
        {
            int x = bitCount(i);
            G[i] = 1;
            while (x > 1)
                ++G[i], x = bitCount(x);
        }
    }
}
static int F[801][801][2];
class Solution {
public:
    int countKReducibleNumbers(string s, int K) {
        init();
        int const N = s.size();
        memset(F, 0, sizeof(F));
        F[0][0][true] = 1;
        auto add = [](int& x, int y) -> void
            {
                x += y;
                if (x >= MOD)
                    x -= MOD;
            };
        for (int i = 0; i < N; ++i)
            for(int sum = 0; sum <= i; ++sum)
                for (int isB = 0, b = s[i] - '0'; isB < 2; ++isB)
                    if (F[i][sum][isB])
                        for (int d = 0; d < 2; ++d)
                            if (!isB || d <= b)
                                add(F[i + 1][sum + d][isB && d == b], F[i][sum][isB]);
        long long result = 0;
        for (int sum = 1; sum <= N; ++sum)
            if (G[sum] < K)
                result += F[N][sum][false];
        return result % MOD;
    }
};
",1448279507
Denys Gubar,DenisGubar,447,3646,cpp,"static int const MOD = 1'000'000'007;
class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int const N = nums.size();
        long long result = 0;
        unordered_map<int, int> M, C;
        auto add = [](int& x, int y) -> void
            {
                x += y % MOD;
                if (x >= MOD)
                    x -= MOD;
            };
        for (int i = 0; i < N; ++i)
        {
            int const& x = nums[i];
            int fx = 0, cx = 0;
            if (M.find(x - 1) != M.end())
                fx += M[x - 1], cx += C[x - 1];
            if (M.find(x + 1) != M.end())
                fx += M[x + 1], cx += C[x + 1];
            add(C[x], 1 + cx);
            int delta = (1LL * x * (1 + cx) + fx) % MOD;
            add(M[x], delta);
            result += delta;
        }
        return result % MOD;
    }
};
",1448218202
ConnectedPuddle,ConnectedPuddle,450,3612,csharp,"public class Solution {
    public bool HasIncreasingSubarrays(IList<int> nums, int k) {
        int n = nums.Count();
        for (int i = 0; i + 2 * k <= n; i++)
        {
            bool good = true;
            for (int j = i+1; j < i + k; j++)
            {
                if (nums[j-1] >= nums[j])
                {
                    good = false;
                    break;
                }
            }
            if (!good)
            {
                continue;
            }
            for (int j = i + k + 1; j < i + 2*k; j++)
            {
                if (nums[j-1] >= nums[j])
                {
                    good = false;
                    break;
                }
            }
            if (good)
            {
                return true;
            }
        }
        return false;
    }
}",1448183936
ConnectedPuddle,ConnectedPuddle,450,3619,csharp,"public class Solution {
    public int MaxIncreasingSubarrays(IList<int> nums) {
        int n = nums.Count();
        int left = 1;
        int right = n / 2;
        while (left <= right)
        {
            int mid = left + (right - left) / 2;
            if (HasIncreasingSubarrays(mid))
            {
                left = mid + 1;
            }
            else
            {
                right = mid - 1;
            }
        }
        return right;

        bool HasIncreasingSubarrays(int len)
        {
            int lastIncreasing = 0;
            int thisIncreasing = 1;
            for (int i = 1; i < n; i++)
            {
                if (nums[i] > nums[i-1])
                {
                    thisIncreasing++;
                    if (thisIncreasing >= 2*len)
                    {
                        return true;
                    }
                }
                else
                {
                    if (lastIncreasing >= len && thisIncreasing >= len)
                    {
                        return true;
                    }
                    lastIncreasing = thisIncreasing;
                    thisIncreasing = 1;
                }
            }
            return (thisIncreasing >= 2*len) || (thisIncreasing >= len && lastIncreasing >= len);
        }
    }
}",1448195247
ConnectedPuddle,ConnectedPuddle,450,3631,csharp,"public class Solution {
    public int CountKReducibleNumbers(string s, int k) {
        int mod = 1_000_000_007;
        int m = s.Length;
        int[,] choose = new int[m+1, m+1];
        for (int i = 0; i <= m; i++)
        {
            for (int j = 0; j <= m; j++)
            {
                if (i == 0 || j == 0)
                {
                    choose[i, j] = 1;
                }
                else
                {
                    choose[i, j] = choose[i-1, j] + choose[i, j-1];
                    choose[i, j] %= mod;
                }
            }
        }
        int totalBits = 0;
        for (int i = 0; i < m; i++)
        {
            if (s[i] == '1')
            {
                totalBits++;
            }
        }
        int[] bitCounts = new int[m];
        int leadingOnes = 0;
        for (int i = 0; i < m; i++)
        {
            if (leadingOnes == totalBits)
            {
                break;
            }
            if (s[i] == '0')
            {
                continue;
            }
            int availableSlots = m - i - 1;
            for (int numBits = 0; numBits <= availableSlots; numBits++)
            {
                bitCounts[leadingOnes + numBits] += choose[numBits, availableSlots - numBits];
                bitCounts[leadingOnes + numBits] %= mod;
            }
            leadingOnes++;
        }
        int[] reduceNumber = new int[m];
        for (int i = 2; i < m; i++)
        {
            Reduce(i);
        }
        int result = 0;
        for (int i = 1; i < m; i++)
        {
            if (reduceNumber[i] < k)
            {
                result += bitCounts[i];
                result %= mod;
            }
        }
        return result;

        int Reduce(int x)
        {
            if (x <= 1)
            {
                return 0;
            }
            if (reduceNumber[x] > 0)
            {
                return reduceNumber[x];
            }
            reduceNumber[x] = 1 + Reduce(int.PopCount(x));
            return reduceNumber[x];
        }
    }
}
",1448286943
ConnectedPuddle,ConnectedPuddle,450,3646,csharp,"public class Solution {
    public int SumOfGoodSubsequences(int[] nums) {
        int mod = 1_000_000_007;
        int m = 100_002;
        long[] counts = new long[m];
        long[] sums = new long[m];
        foreach(int num in nums)
        {
            sums[num] += num * (1 + counts[num+1]);
            sums[num] %= mod;
            sums[num] += sums[num+1];
            sums[num] %= mod;
            if (num > 0)
            {
                sums[num] += num * (counts[num-1]);
                sums[num] %= mod;
                sums[num] += sums[num-1];
                sums[num] %= mod;
            }
            counts[num]++;
            counts[num] += counts[num+1];
            counts[num] %= mod;
            if (num > 0)
            {
                counts[num] += counts[num-1];
                counts[num] %= mod;
            }
            // for (int i = 0; i < 10; i++)
            // {
            //     Console.Write($""{sums[i]}, {counts[i]} | "");
            // }
            // Console.WriteLine();
        }
        long result = 0;
        for (int i = 0; i < m; i++)
        {
            result += sums[i];
            result %= mod;
        }
        return (int)result;
    }
}",1448220744
Ankur Kumar,Ankur_8789,452,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> dp(n+1);
        dp[0] = 1;
        for(int i=1;i<n;i++){
            if(nums[i] > nums[i-1])
                dp[i] = 1 + dp[i-1];
            else
                dp[i] = 1;
        }
        for(int i=2*k-1;i<n;i++){
            if(dp[i] >= 2*k)
                return 1;
            if(dp[i] >=k && dp[i-k] >= k)
                return 1;
        }
        return 0;
    }
};",1448186317
Ankur Kumar,Ankur_8789,452,3619,cpp,"class Solution {
public:
    bool check(int k,vector<int>& dp){
        int n = dp.size();
        for(int i=2*k-1;i<n && i>=0;i++){
            if(dp[i] >= 2*k)
                return 1;
            if(dp[i] >=k && i-k>=0 && dp[i-k] >= k)
                return 1;
        }
        return 0;
    }
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp(n);
        dp[0] = 1;
        for(int i=1;i<n;i++){
            if(nums[i] > nums[i-1])
                dp[i] = 1 + dp[i-1];
            else
                dp[i] = 1;
            // cout<<dp[i]<<"" "";
        }
        int l=1,r=n/2,ans=0;
        while(l <= r){
            int mid = (l+r)/2;
            // cout<<mid<<"" "";
            if(check(mid,dp))
                ans = mid , l = mid + 1;
            else 
                r = mid - 1;
        }
        return ans;
    }
};",1448199046
Ankur Kumar,Ankur_8789,452,3631,cpp,"class Solution {
public:
    const int mod = 1e9 + 7;
    int dpx[801][801][2][2];
    int f(int i,int zr , int cnt , int tight , string& s,int k,vector<int>& dp){
        if(i == s.size()){
            // cout<<(dp[cnt])<<"" ""<<cnt<<endl;
            return (cnt > 0 && (dp[cnt] <= k) && (tight == 0) && zr);
        }
        auto& x=dpx[i][cnt][zr][tight];
        if(x!=-1)
            return x;
        int ans = 0;
        int ub = 1;
        if(tight)
            ub=s[i]-'0';
        for(int idx=0;idx<=ub;idx++){
            if(zr==0){
                if(idx==0){
                    ans += f(i+1,zr,cnt,(tight && (idx == ub)),s,k,dp);
                    ans %= mod;
                }
                else{
                    ans += f(i+1,zr^1,cnt+1,(tight && (idx == ub)),s,k,dp);
                    ans %= mod;
                }
            }
            else{
                if(idx == 0){
                    ans += f(i+1,zr,cnt,(tight && (idx==ub)),s,k,dp);
                    ans %= mod;
                }
                else{
                    ans += f(i+1,zr,cnt+1,(tight && (idx==ub)),s,k,dp);
                    ans %= mod;
                }
            }
        }
        return x=ans;
    }
    int countKReducibleNumbers(string s, int k) {
        vector<int> dp(801);
        dp[1] = 0;
        for(int i=2;i<800;i++){
            int val = i , rem = 0;
            while(val > 1){
                int x = val, cnt = 0;
                while(x){
                    cnt += 1;
                    x = (x & (x-1));
                }
                val = cnt;
                rem += 1;
            }
            dp[i] = rem;
        }
        // for(int i=1;i<=7;i++)
        //     cout<<dp[i]<<"" "";
        memset(dpx,-1,sizeof(dpx));
        int ans = f(0,0,0,1,s,k-1,dp);
        return ans;
    }
};",1448272084
Ankur Kumar,Ankur_8789,452,3646,cpp,"class Solution {
public:
    typedef long long ll;
    const int mod = 1e9 + 7;
    int sumOfGoodSubsequences(vector<int>& nums) {
        ll ans = 0;
        vector<ll> fre(100001,0),sub(100001,0);
        for(auto x : nums){
            ll cnt = 1 , val = x;
            if(x > 0){
                 cnt += fre[x-1];
                 cnt %= mod;
                 val +=sub[x-1]+fre[x-1]*x;
                 val%=mod;
            }
            if(x < 100000){
                cnt += fre[x+1];
                cnt %= mod;
                val +=sub[x+1]+fre[x+1]*x;
                val %= mod;
            }
            fre[x] += cnt;
            fre[x] %= mod;
            sub[x] += val;
            sub[x] %= mod;
            ans += val;
            ans %= mod;   
        }
        return ans;
    }
};",1448300495
RankOnly-Young,RankOnly-Young,454,3612,java,"class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        int cnt = 1;
        int pre1 = nums.get(0);
        int pre2 = nums.get(k);
        int index = 0;
        while (index + k < nums.size()) {
            if (nums.get(index) <= pre1 || nums.get(index + k) <= pre2) {
                cnt = 1;
                pre1 = nums.get(index);
                pre2 = nums.get(index + k);
            } else {
                cnt++;
                pre1 = nums.get(index);
                pre2 = nums.get(index + k);
            }
            if (cnt == k) {
                return true;
            }
            index++;
        }
        return false;
    }
}",1448191583
RankOnly-Young,RankOnly-Young,454,3619,java,"class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        return binarySearch(1, nums.size() / 2, nums);
    }

    private int binarySearch(int start, int end, List<Integer> nums) {
        while (start <= end) {
            int mid = start + (end - start) / 2;
            if (checkValid(nums, mid)) {
                start = mid + 1;
            } else {
                end = mid - 1;
            }
        }
        return start - 1;
    }

    public boolean checkValid(List<Integer> nums, int k) {
        int cnt = 1;
        int pre1 = nums.get(0);
        int pre2 = nums.get(k);
        int index = 0;
        while (index + k < nums.size()) {
            if (nums.get(index) <= pre1 || nums.get(index + k) <= pre2) {
                cnt = 1;
                pre1 = nums.get(index);
                pre2 = nums.get(index + k);
            } else {
                cnt++;
                pre1 = nums.get(index);
                pre2 = nums.get(index + k);
            }
            if (cnt == k) {
                return true;
            }
            index++;
        }
        return false;
    }
}",1448201128
RankOnly-Young,RankOnly-Young,454,3631,java,"class Solution {
    int[] nOperation = new int[801];
    int[][] memo;
    int k;
    int MOD = (int) 1e9 + 7;

    public int countKReducibleNumbers(String s, int k) {
        initArray();
        this.k = k;
        memo = new int[s.length()][s.length() + 1];
        for (int i = 0; i < memo.length; i++) {
            Arrays.fill(memo[i], -1);
        }
        return dfs(0, 0, true, s.toCharArray());
    }

    private int dfs(int step, int sum, boolean isLimit, char[] chars) {
        if (step == chars.length) {
            if (sum == 0 || isLimit || nOperation[sum] + 1 > k) {
                return 0;
            }
            return 1;
        }
        if (!isLimit && memo[step][sum] != -1) return memo[step][sum];
        int ret = 0;
        if (isLimit) {
            if (chars[step] == '1') {
                ret = (ret + dfs(step + 1, sum + 1, true, chars)) % MOD;
                ret = (ret + dfs(step + 1, sum, false, chars)) % MOD;
            } else {
                ret = (ret + dfs(step + 1, sum, true, chars)) % MOD;
            }
        } else {
            ret = (ret + dfs(step + 1, sum + 1, false, chars)) % MOD;
            ret = (ret + dfs(step + 1, sum, false, chars)) % MOD;
        }
        if (!isLimit) memo[step][sum] = ret;
        return ret;
    }

    private void initArray() {
        Arrays.fill(nOperation, -1);
        nOperation[0] = 0;
        nOperation[1] = 0;
        for (int i = 2; i <= 800; i++) {
            find(i);
        }
    }

    private void find(int num) {
        int bitCount = Integer.bitCount(num);
        if (nOperation[bitCount] == -1) {
            find(bitCount);
        }
        nOperation[num] = nOperation[bitCount] + 1;
    }
}",1448301976
RankOnly-Young,RankOnly-Young,454,3646,java,"class Solution {
    int MOD = (int) 1e9 + 7;

    public int sumOfGoodSubsequences(int[] nums) {
        int max = 0;
        for (int num : nums) {
            max = Math.max(max, num);
        }
        long[] f = new long[max + 1];
        long[] s = new long[max + 1];
        for (int num : nums) {
            if (num - 1 >= 0) {
                f[num] = (f[num] + f[num - 1]) % MOD;
                s[num] = (s[num] + s[num - 1] + f[num - 1] * num % MOD) % MOD;
            }
            if (num + 1 <= max) {
                f[num] = (f[num] + f[num + 1]) % MOD;
                s[num] = (s[num] + s[num + 1] + f[num + 1] * num % MOD) % MOD;
            }
            f[num] = (f[num] + 1) % MOD;
            s[num] = (s[num] + num) % MOD;
        }
        long res = 0;
        for (long v : s) {
            res = (res + v) % MOD;
        }
        return (int) res;
    }
}",1448255720
Mintu Jupally,mintujupally,456,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n=nums.size();
        for(int i=0; i<n; i++)
        {
            if(i+k-2+k+1>=n) break;
            int j=0;
            while(j<k-1 && nums[i+j]<nums[i+j+1] && nums[i+j+k]<nums[i+j+k+1]) ++j;
            if(j==k-1) return true;
        }
        return false;
    }
};",1448184626
Mintu Jupally,mintujupally,456,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n=nums.size();
        vector<int> dp(n+1, 0);
        for(int i=0; i<n-1; i++)
        {
            dp[i+1]=dp[i];
            if(nums[i]<nums[i+1]) dp[i+1]+=1;
            // cout<<i+1<<"" - ""<<dp[i+1]<<endl;
        }

        int l=1, r=n;
        int k=1;
        while(l<=r)
        {
            int m=l+(r-l)/2;
            // cout<<l<<"" - ""<<m<<"" - ""<<r<<endl;
            bool flag=false;
            for(int i=0; i+m+m-1<=n-1; i++)
            {
                // i...(i+k-1)
                // (i+k)...(i+k+k-1)
                // cout<<i<<"" : ""<<dp[i+m-1]-dp[i]<<"" ""<<dp[i+m+m-1]-dp[i+m]<<endl;
                if(dp[i+m-1]-dp[i]==m-1 && dp[i+m+m-1]-dp[i+m]==m-1)
                {
                    flag=true;
                    break;
                }
            }

            if(flag) 
            {
                k=max(k, m);
                l=m+1;
            }
            else r=m-1;
        }

        return k;
    }
};",1448204469
Mintu Jupally,mintujupally,456,3631,cpp,"int req[801];
bool pre=false;

int mod=1e9+7;

void preprocess()
{
    pre=true;
    for(int i=1; i<=800; i++)
    {
        int n=i;
        int count=0;
        if(n>1) count=req[(int)__builtin_popcount(n)]+1;
        req[i]=count;
    }
}

unsigned long long power(unsigned long long x, int y, int p) {
    unsigned long long res = 1;
 
    x = x % p;
    while (y > 0) 
    {
        if (y & 1)
            res = (res * x) % p;
    
        y = y >> 1;
        x = (x * x) % p;
    }
    return res;
}
 
unsigned long long modInverse(unsigned long long n, int p) {
    return power(n, p - 2, p);
}
 
unsigned long long nCr(unsigned long long n, int r, int p) {
    if (n < r)
        return 0;

    if (r == 0)
        return 1;

    unsigned long long fac[n + 1];
    fac[0] = 1;
    for (int i = 1; i <= n; i++)
        fac[i] = (fac[i - 1] * i) % p;
 
    return (fac[n] * modInverse(fac[r], p) % p
            * modInverse(fac[n - r], p) % p)
           % p;
}

long long count(int m, int k, int n)
{
    long long ans=0;
    for(int i=max(n, 1); i<=800 && i-n<=m; i++)
    {
        // cout<<""i = ""<<i<<"" : ""<<req[i]<<endl;
        if(req[i]>k) continue;
        // cout<<m<<""C""<<i-n<<"" - ""<<nCr(m, i-n, mod)<<endl;
        ans=(ans+nCr(m, i-n, mod))%mod;
    }
    // cout<<m<<"" places - ""<<k<<"" ops - ""<<n<<"" bits: ""<<ans<<endl;
    return ans;
}

class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        if(!pre)
        {
            preprocess();
        }
        // cout<<req[0]<<"" - ""<<req[1]<<"" - ""<<req[2]<<"" - ""<<req[3]<<endl;
        int m=s.size();
        int n=0;
        for(int i=0; i<m; i++) n+=(s[i]=='1');
        --k;

        long long ans=0;
        for(int i=m-1; i>=0; i--)
        {
            if(s[i]=='1')
            {
                --n;
                ans=(ans+count(m-i-1, k, n))%mod;
            }
        }

        return ans;
    }
};",1448308669
Mintu Jupally,mintujupally,456,3646,cpp,"int tree1[100003];
int tree2[100003];

int mod=1e9+7;

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        memset(tree1, 0, sizeof(tree1));
        memset(tree2, 0, sizeof(tree2));

        int ans=0;
        for(auto &num:nums)
        {
            long long curr=0;
            curr=(curr+tree2[num+1])%mod;
            if(num>0) curr=(curr+tree2[num-1])%mod;
            long long count=1;
            count=(count+tree1[num+1])%mod;
            if(num>0) count=(count+tree1[num-1])%mod;
            curr=(curr+(num*count)%mod)%mod;
            ans=(ans+curr)%mod;
            tree1[num]=(tree1[num]+count)%mod;
            tree2[num]=(tree2[num]+curr)%mod;
        }

        return ans;
    }
};",1448252197
Ajit,Ajit123,459,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> dp(n,1), dp1(n,1);
        for(int i=1; i<n; i++) {
            if(nums[i]> nums[i-1]) {
                dp[i] = dp[i-1] + 1;
            }
        }

        for(int i=n-2; i>=0; i--) {
            if (nums[i] < nums[i+1]) {
                dp1[i] = dp1[i+1] + 1;
            }
        }

        int ans = 1;
        for(int i=0; i+1<n; i++) {
            ans = max(ans, min(dp[i], dp1[i+1]));
        }

        return ans >= k;
    }
};",1448309534
Ajit,Ajit123,459,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp(n,1), dp1(n,1);
        for(int i=1; i<n; i++) {
            if(nums[i]> nums[i-1]) {
                dp[i] = dp[i-1] + 1;
            }
        }

        for(int i=n-2; i>=0; i--) {
            if (nums[i] < nums[i+1]) {
                dp1[i] = dp1[i+1] + 1;
            }
        }

        int ans = 1;
        for(int i=0; i+1<n; i++) {
            ans = max(ans, min(dp[i], dp1[i+1]));
        }

        return ans;
    }
};",1448308319
Ajit,Ajit123,459,3631,cpp,"class Solution {
    const int MOD = 1e9 + 7;
public:
    bool ok (int x, int k) {
        if (k <= 0) {
            return false; 
        }
        
        int tot = 0;
        for(int i=20; i>=0; i--) {
            if ((1<<i) & x) {
                tot++;
            }
        }

        if (tot == 1) {
            return true;
        }

        return ok(tot, k-1);
    }

    int solve(int i, int sum, int less, vector<vector<vector<int>>>& dp, vector<int>& poss, string& s) {
        if (i == s.size()) {
            return sum == 1 || poss[sum];
        }

        if (dp[i][sum][less] != -1) {
            return dp[i][sum][less];
        }

        int dig = s[i] - '0';
        int& ans = dp[i][sum][less];
        ans = 0;
        for(int d=0; d<=1; d++) {
            int less1 = less;
            int sum1 = sum + d;
            if (!less && d > dig) {
                break;
            }

            if (d < dig) {
                less1 = true;
            }

            ans += solve(i+1, sum1, less1, dp, poss, s);
            if (ans >= MOD) {
                ans -= MOD;
            }
        }

        return ans;
    }

    int countKReducibleNumbers(string s, int k) {
        vector<int> poss(s.size()+1);
        vector<vector<vector<int>>> dp(s.size(), vector<vector<int>>(s.size()+1, vector<int>(2, -1)));
        for(int i=1; i<=s.size(); i++) {
            poss[i] = ok(i, k-1);
        }

        return solve(0, 0, 0, dp, poss, s) - (count(s.begin(), s.end(), '1') ==1 || poss[count(s.begin(), s.end(), '1')]);
    }
};",1448295280
Ajit,Ajit123,459,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int MOD = 1e9 + 7;
        int n = nums.size();
        map<int, int> dp, poss;
        int ans = 0;
        for(int i=0; i<n; i++) {
            dp[nums[i]]++;
            dp[nums[i]] %= MOD;
            dp[nums[i]] += dp[nums[i]-1];
            dp[nums[i]] %= MOD;
            dp[nums[i]] += dp[nums[i]+1];
            dp[nums[i]] %= MOD;
            poss[nums[i]] += nums[i];
            poss[nums[i]] %= MOD;
            poss[nums[i]] += (poss[nums[i]-1] + (1ll * dp[nums[i]-1] * nums[i]) % MOD) % MOD;
            poss[nums[i]] %= MOD;
            poss[nums[i]] += (poss[nums[i]+1] + (1ll * dp[nums[i]+1] * nums[i]) % MOD) % MOD;
            poss[nums[i]] %= MOD;
        }

        for(auto it: poss) {
            ans += it.second;
            ans %= MOD;
        }

        return ans;
    }
};",1448305057
BZH110,BZH110,460,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size(), ans = 0;
        vector<int> a(n, 0);
        a[0] = 1;
        int l = 0;
        for(int i=1;i<n;i++){
            if(nums[i] <= nums[i-1]) {
                l = i;
            }
            a[i] = i - l + 1;
        }
        for(int i=0;i<n;i++){
            ans = max(ans, a[i] / 2);
            // cout << i << "" "" << a[i] << endl;
            ans = max(ans, min(a[i], i >= a[i] ? a[i - a[i]] : 0));
        }
        return ans >= k;
    }
};",1448283316
BZH110,BZH110,460,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size(), ans = 0;
        vector<int> a(n, 0);
        a[0] = 1;
        int l = 0;
        for(int i=1;i<n;i++){
            if(nums[i] <= nums[i-1]) {
                l = i;
            }
            a[i] = i - l + 1;
        }
        for(int i=0;i<n;i++){
            ans = max(ans, a[i] / 2);
            // cout << i << "" "" << a[i] << endl;
            ans = max(ans, min(a[i], i >= a[i] ? a[i - a[i]] : 0));
        }
        return ans;
    }
};",1448282246
BZH110,BZH110,460,3631,cpp,"int pre[801]{0};

auto ttt = []()->int {
    pre[0] = 6;
    for (int i = 1; i <= 800; i++) {
        int t = i;
        while (t != 1) {
            t = __builtin_popcount(t);
            pre[i]++;
        }
    }
    return 0;
}();

class Solution {
public:
    using ll = long long;
    int countKReducibleNumbers(string s, int k) {
        ll mod = 1e9 + 7, n = s.size(), ans = 0;
        unordered_map<int, ll> m[n];
        function<ll(int,bool,int)> dfs = [&](int index, bool limit, int cnt) -> ll {
            if (index == n) {
                return pre[cnt] < k ? 1 : 0;
            }
            if(!limit && m[index].count(cnt))
                return m[index][cnt];
            ll ret = 0;
            if(!limit || s[index] == '1') {
                ret += dfs(index + 1, limit, cnt + 1);
            }
            ret += dfs(index + 1, limit && s[index] == '0', cnt);
            ret %= mod;
            if(!limit)
                m[index][cnt] = ret;
            return ret;
        };
        ans = dfs(0, true, 0);
        auto check = [&](string& t) {
            int cnt = 0;
            for(auto c:t) {
                if(c == '1')
                    cnt++;
            }
            return pre[cnt] < k;
        };
        ans = (ans - check(s) + mod) % mod;
        return ans;
    }
};",1448244927
BZH110,BZH110,460,3646,cpp,"class Solution {
public:
    using ll = long long;
    int sumOfGoodSubsequences(vector<int>& nums) {
        ll ans = 0, mod = 1e9 + 7, n = nums.size();
        unordered_map<int,ll> post, pre;
        for(int i=n-1;i>=0;i--){
            post[nums[i]] += post[nums[i] + 1] + post[nums[i] - 1] + 1;
            post[nums[i]] %= mod;
        }
        for(int i=0;i<n;i++){
            pre[nums[i]] += pre[nums[i] - 1] + pre[nums[i] + 1] + 1;
            pre[nums[i]] %= mod;
            ans += (pre[nums[i] - 1] + pre[nums[i] + 1] + 1) * (post[nums[i] - 1] + post[nums[i] + 1] + 1) % mod * nums[i] % mod;
            ans %= mod;
            post[nums[i]] -= post[nums[i] + 1] + post[nums[i] - 1] + 1;
            post[nums[i]] = (post[nums[i]] % mod + mod) % mod;
        }
        return ans;
    }
};",1448263216
iPGx5cnGw7,iPGx5cnGw7,462,3612,cpp,"class Solution {
   public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        for (int i = 0; i <= (int)nums.size() - 2 * k; i++) {
            bool ok = 1;
            for (int j = i + 1; j <= i + k - 1; j++) {
                if (nums[j] <= nums[j - 1]) {
                    ok = 0;
                    break;
                }
            }
            for (int j = i + k + 1; j <= i + 2 * k - 1; j++) {
                if (nums[j] <= nums[j - 1]) {
                    ok = 0;
                    break;
                }
            }
            if (ok) {
                return true;
            }
        }
        return false;
    }
};
",1448184474
iPGx5cnGw7,iPGx5cnGw7,462,3619,cpp,"class Solution {
   public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = (int)nums.size();
        vector<int> dp(n, 1);
        for (int i = 1; i < n; i++) {
            if (nums[i] > nums[i - 1]) {
                dp[i] = dp[i - 1] + 1;
            }
        }
        int ans = 0;
        for (int i = 0; i < n; i++) {
            int l = dp[i];
            ans = max(ans, dp[i] / 2);
            if (i - l >= 0) {
                ans = max(ans, min(dp[i], dp[i - l]));
            }
        }
        return ans;
    }
};
",1448203782
iPGx5cnGw7,iPGx5cnGw7,462,3631,cpp,"class Solution {
   public:
    vector<int> cnt;
    const long long mod = (long long)1e9 + 7;
    long long dp[805][805][3];

    Solution() {
        cnt.resize(805);
        cnt[1] = 0;
        for (int i = 2; i < (int)cnt.size(); i++) {
            cnt[i] = cnt[__builtin_popcount(i)] + 1;
        }
    }

    int countKReducibleNumbers(string s, int k) {
        int n = (int)s.size();
        for (int i = 0; i < n; i++) {
            for (int j = 0; j <= n; j++) {
                for (int state = 0; state <= 2; state++) {
                    dp[i][j][state] = 0;
                }
            }
        }
        dp[0][1][1]++;
        for (int i = 1; i < n; i++) {
            for (int j = 0; j <= i; j++) {
                for (int state = 0; state <= 2; state++) {
                    if (!dp[i - 1][j][state]) {
                        continue;
                    }
                    for (char c = '0'; c <= '1'; c++) {
                        int newState = state;
                        if (state == 1) {
                            if (c < s[i])
                                newState = 0;
                            if (c == s[i])
                                newState = 1;
                            if (c > s[i])
                                newState = 2;
                        }
                        dp[i][j + (c == '1')][newState] += dp[i -
                        1][j][state]; dp[i][j + (c == '1')][newState] %= mod;
                    }
                }
            }
        }
        long long ans = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j <= i + 1; j++) {
                for (int state = 0; state <= (i == n - 1 ? 0 : 2); state++) {
                    if (cnt[j] + 1 <= k) {
                        ans += dp[i][j][state];
                        ans %= mod;
                    }
                }
            }
        }
        return ans;
    }
};",1448296602
iPGx5cnGw7,iPGx5cnGw7,462,3646,cpp,"class Solution {
   public:
    const long long mod = (long long)1e9 + 7;

    int sumOfGoodSubsequences(vector<int>& nums) {
        int mx = ranges::max(nums);
        vector<long long> dp(mx + 5);
        vector<long long> cnt(mx + 5);
        for (auto& e : nums) {
            cnt[e]++;
            dp[e] += 1LL * e;
            cnt[e] %= mod;
            if (e > 0) {
                dp[e] +=
                    (dp[e - 1] + (1LL * (cnt[e - 1] % mod) * e) % mod) % mod;
                dp[e] %= mod;
                cnt[e] += cnt[e - 1];
                cnt[e] %= mod;
            }
            dp[e] += (dp[e + 1] + (1LL * (cnt[e + 1] % mod) * e) % mod) % mod;
            dp[e] %= mod;
            cnt[e] += cnt[e + 1];
            cnt[e] %= mod;
        }
        long long ans = 0;
        for (auto& e : dp) {
            ans += e % mod;
            ans %= mod;
        }
        return ans;
    }
};
",1448241101
Facundo Galán,facug91,463,3612,cpp,"static const int fastIO = [] {
	std::ios_base::sync_with_stdio(false), std::cin.tie(nullptr), std::cout.tie(nullptr);
	return 0;
}();

class Solution {
public:
	bool hasIncreasingSubarrays(vector<int>& nums, int k) {
		if (k == 1) return true;
		int n = (int)nums.size();
		for (int i=0; i<n-k*2+1; i++) {
			bool ok = true;
			for (int j=i+1; j<i+k && ok; j++) if (nums[j-1] >= nums[j]) ok = false;
			for (int j=i+k+1; j<i+k+k && ok; j++) if (nums[j-1] >= nums[j]) ok = false;
			if (ok) return true;
		}
		return false;
	}
};",1448198220
Facundo Galán,facug91,463,3619,cpp,"static const int fastIO = [] {
	std::ios_base::sync_with_stdio(false), std::cin.tie(nullptr), std::cout.tie(nullptr);
	return 0;
}();

class Solution {
public:
	int maxIncreasingSubarrays(vector<int>& nums) {
		vector<int> lens;
		int cnt = 1;
		for (int i = 1; i < nums.size(); i++) {
			if (nums[i - 1] < nums[i]) {
				cnt++;
			} else {
				lens.push_back(cnt);
				cnt = 1;
			}
		}
		lens.push_back(cnt);
		int ans = 1;
		for (int l: lens) ans = max(ans, l / 2);
		for (int i = 1; i < lens.size(); i++) ans = max(ans, min(lens[i - 1], lens[i]));
		return ans;
	}
};",1448206657
Facundo Galán,facug91,463,3631,cpp,"static const int fastIO = [] {
	std::ios_base::sync_with_stdio(false), std::cin.tie(nullptr), std::cout.tie(nullptr);
	return 0;
}();

class Solution {
private:
	vector<int> kreducible;
	vector<vector<int>> nCk;
	int n;
	const int MOD = 1e9 + 7;

	int solve(const string& s, int idx, int ones, int k) {
		if (idx == n) return 0;
		if (s[idx] == '0') {
			return solve(s, idx + 1, ones, k);
		} else {
			int res = 0;
			int mx = n - idx - 1;
			for (int i = 1; i <= mx; i++) {
				int bitsInOne = i + ones;
				if (kreducible[bitsInOne] >= k) continue;
				res = (res + nCk[mx][i]) % MOD;
			}
			if (ones > 0 && kreducible[ones] < k) res++;
			res = (res + solve(s, idx + 1, ones + 1, k)) % MOD;
			return res;
		}
	}


public:
	int countKReducibleNumbers(string s, int k) {
		kreducible.assign(801, 0);
		for (int i = 2; i < 801; i++)
			kreducible[i] = kreducible[std::popcount((unsigned)i)] + 1;
		n = (int)s.length();
		nCk.assign(n + 1, vector<int>(n + 1, 0));
		nCk[0][0] = 1;
		for (int i = 1; i <= n; i++) {
			nCk[i][0] = nCk[i][i] = 1;
			for (int j = 1; j < i; j++)
				nCk[i][j] = (nCk[i - 1][j - 1] + nCk[i - 1][j]) % MOD;
		}
		return solve(s, 0, 0, k);
	}
};",1448309867
Facundo Galán,facug91,463,3646,cpp,"static const int fastIO = [] {
	std::ios_base::sync_with_stdio(false), std::cin.tie(nullptr), std::cout.tie(nullptr);
	return 0;
}();

class Solution {
public:
	int sumOfGoodSubsequences(vector<int>& nums) {
		const int n = (int)nums.size();
		const long long MOD = 1e9 + 7;
		vector<long long> cnt(100005, 0), sum(100005, 0);
		for (int num: nums) {
			long long c = 1 + cnt[num + 1], s = sum[num + 1];
			if (num > 0) {
				c = (c + cnt[num - 1]) % MOD;
				s = (s + sum[num - 1]) % MOD;
			}
			s = (s + c * num) % MOD;
			cnt[num] = (cnt[num] + c) % MOD;
			sum[num] = (sum[num] + s) % MOD;
		}
		long long ans = 0;
		for (int i = 0; i < 100005; i++)
			if (sum[i])
				ans = (ans + sum[i]) % MOD;
		return ans;
	}
};",1448238502
nazeeeef007,nazeeeef007,464,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, a: List[int], k: int) -> bool:
        n = len(a)
        for i in range(n-2*k+1):
            ok = True
            for j in range(i+1,k+i):
                if a[j]<=a[j-1]:
                    ok = False
            for j in range(k+i+1,i+2*k):
                if a[j]<=a[j-1]:
                    ok = False
            if ok:
                # print(i)
                return True
        return False",1448184621
nazeeeef007,nazeeeef007,464,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, a: List[int]) -> int:
        n = len(a)
        res = 1
        cur = 1 
        prev = 0
        for i in range(1,n):
            if a[i]>a[i-1]:
                cur +=1
            else:
                if prev == 0:
                    prev = cur 
                    cur = 1
                    res = max(res,prev//2)
                else:
                    # print(i,prev,cur)
                    
                    res = max(res, min(prev,cur))
                    res = max(res,cur//2)
                    prev = cur 
                    cur = 1
        res = max(res, min(prev,cur))
        res = max(res,cur//2)
        return res",1448223209
nazeeeef007,nazeeeef007,464,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        if s == ""1"":
            return 0
        n = len(s)
        maxi = 0
        p = [False]*(n+2)
        p[1] = True
        mod = 10**9+7
        for i in range(n):
            if s[i] ==""1"":
                maxi = i 
                break 
        for i in range(2,n+2):
            c = i
            big = 0
            for j in range(k-1):
                cnt = 0
                for d in range(10):
                    if c & (1<<d):
                        cnt += 1
              
                c = cnt 
            for d in range(10,-1,-1):
                if i & (1<<d):
                    big = d
                    break
            if c == 1:
                p[i] = True 
            if big < maxi:
                res +=1
        
        # whats my dp state ? i need index im at, how many se tbits i have, and wheteher im tight or not 
        dp = [[[-1]*2 for i in range(n+1)] for i in range(n+1)]
        
        def dfs(i,j,tight):
            if i == n:
                if p[j] and not tight:
                    # print(j)
                    return 1
                return 0
            if dp[i][j][tight]!=-1:
                return dp[i][j][tight]
            if tight:
                if s[i] == ""0"":
                    # print(i)
                    dp[i][j][tight] = dfs(i+1,j,tight)%mod
                else:
                    dp[i][j][tight] = (dfs(i+1,j,False) + dfs(i+1,j+1,tight))%mod
            else:
                 dp[i][j][tight] = (dfs(i+1,j,False) + dfs(i+1,j+1,False))%mod
            return dp[i][j][tight]
        return dfs(0,0,True)     
#         i can only reduce x to its number of set bits at most k times, k is at most 5 also lol wtf 
#         every power of 2 can be reduced 
        
#         111111111 = 511, 9 set bits,  k = 5
        
#         111111111111111111 18 set bits 
        
#         10010 
        
        
        
#         1000000000
        
#         everytime i apply an operation, the number of set bits will decrease significantly, ",1448303464
nazeeeef007,nazeeeef007,464,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, a: List[int]) -> int:
        n = len(a)
        res = 0
        mod = 10**9+7
        dp = [0]*(max(a)+2)
        s = [0]*(max(a)+2)
        for i in range(n):
            dp[a[i]] = (dp[a[i]]+dp[a[i]-1]+1 + dp[a[i]+1])%mod
            res = (res+a[i])%mod
            res = (res+s[a[i]-1]+dp[a[i]-1]*a[i])%mod
            res = (res+dp[a[i]+1]*a[i] + s[a[i]+1])%mod
            s[a[i]] = (s[a[i]]+s[a[i]-1]+dp[a[i]-1]*a[i]+dp[a[i]+1]*a[i] + s[a[i]+1]+a[i])%mod
            # print(dp,res,s)
        return res",1448244328
Jayant Sharma,thedark_JS,466,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        
        int n = nums.size();
        
        int dp[n + 1];
        dp[n - 1] = 1;
        
        for(int i = n - 2 ; i >= 0 ; i--){
            if(nums[i] < nums[i + 1]){
                dp[i] = dp[i + 1] + 1;
            }
            else{
                dp[i] = 1;
            }
        }
        int ans = 0;
        for(int i = 0 ; i < n ; i++){
            int val = dp[i];
            ans = max(ans, val/2);
            if(i + dp[i] < n){
                ans = max(ans, min(dp[i], dp[i + dp[i]]));
                
            }
        }
        if(ans < k) return false;
        return true;
    }
};",1448297102
Jayant Sharma,thedark_JS,466,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        
        int dp[n + 1];
        dp[n - 1] = 1;
        
        for(int i = n - 2 ; i >= 0 ; i--){
            if(nums[i] < nums[i + 1]){
                dp[i] = dp[i + 1] + 1;
            }
            else{
                dp[i] = 1;
            }
        }
        int ans = 0;
        for(int i = 0 ; i < n ; i++){
            int val = dp[i];
            ans = max(ans, val/2);
            if(i + dp[i] < n){
                ans = max(ans, min(dp[i], dp[i + dp[i]]));
                
            }
        }
        return ans;
    }
};",1448294356
Jayant Sharma,thedark_JS,466,3631,cpp,"#define ll long long

class Solution {
public:
     ll MOD = 1e9 + 7;
    ll fac[805], ifac[805]; 
 
ll PowerMod(ll a, ll n){
	ll ret = 1;
	while (n){
		if (n & 1){
			ret *= a;
			ret %= MOD;
		}
		a *= a;
		a %= MOD;
		n /= 2;
	}
	return ret;
}
 
void precompute(){
	int i;
	fac[0] = 1;
	for (i = 1; i < 805; i++){
		fac[i] = (i * fac[i - 1]) % MOD;
	}
	ifac[805 - 1] = PowerMod(fac[805 - 1], MOD - 2);
	for (i = 805 - 2; i >= 0; i--){
		ifac[i] = ((i + 1) * ifac[i + 1]) % MOD;
	}
}
 
ll com(int n, int r){
	ll ret = fac[n];
	ret *= ifac[r];
	ret %= MOD;
	ret *= ifac[n - r];
	ret %= MOD;
	return ret;
}
    
    
    
    int find_red_val(int x){
        int cnt = 0;
        while(x){
            cnt += (x & 1);
            x >>= 1;
        }
        return cnt;
    }
    
    int countKReducibleNumbers(string s, int k) {
        // is it possible to reduce a number i with j ops to 1
        bool poss[805][6];
        
        memset(poss, 0, sizeof(poss));
        memset(fac, 0, sizeof(fac));
        memset(ifac, 0, sizeof(ifac));
        
        precompute();
        
        for(int j = 0 ; j <= 5 ; j++){
            poss[1][j] = 1;
        }
        
        for(int i = 2 ; i <= 800 ; i++){
            int el = i;
            int nx = find_red_val(el);
            for(int j = 1 ; j <= 5 ; j++){
                poss[i][j] = (poss[i][j - 1] | poss[nx][0]);
                el = nx;
                nx = find_red_val(el);
            }
        }
        
        // for(int i = 1 ; i <= 10 ; i++){
        //     cout<<""okay for ""<<i<<"": "";
        //     for(int j = 1 ; j <= 5 ; j++){
        //         cout<<poss[i][j]<<"" "";
        //     }
        //     cout<<endl;
        // }
        int n = s.size();
        int cnt[805];
        memset(cnt, 0, sizeof(cnt));
        
        int bits_rem = n;
        int set_bits = 0;
        for(int i = 0 ; i < n ; i++){
            if(s[i] == '0'){
                bits_rem--;
                continue;
            } 
            set_bits++;
            int alpha = bits_rem - 1;
            //cout<<""okay for ""<<i<<"" ""<<set_bits<<""  ""<<alpha<<endl;
            for(int j = 0 ; j <= alpha ; j++){
                cnt[j + set_bits - 1] += com(alpha, j);
                cnt[j + set_bits - 1] %= MOD;
            }
            bits_rem--;
        }
        ll ans = 0;
        
        for(int i = 1 ; i <= 800 ; i++){
            if(cnt[i]){
                //cout<<""alright ""<<i<<""  ""<<cnt[i]<<endl;
                if(poss[i][k - 1]) ans += cnt[i];
            }
            ans %= MOD;
        }
        
        return ans;
        
    }
};",1448287133
Jayant Sharma,thedark_JS,466,3646,cpp,"class Solution {
public:
    long long mod = 1000000007;
    int sumOfGoodSubsequences(vector<int>& nums) {
        
        long long pref[100005], suff[100005], pref_val[100005], suff_val[100005];
        for(int i = 0 ; i < 100005 ; i++){
            pref[i] = 0;
            pref_val[i] = 0;
            suff[i] = 0;
            suff_val[i] = 0;
            
        }
        int n = nums.size();
        
        for(int i = 0 ; i < n ; i++){
            int el = nums[i];
            if(el == 0){
                pref_val[i] =  1 + pref[el + 1];
                pref[el] += (1 + pref[el + 1]);
            }
            else{
                pref_val[i] = pref[el - 1] + 1 + pref[el + 1];
                pref[el] += (pref[el - 1] + 1 + pref[el + 1]);
            }
            pref[el] %= mod;
            pref_val[i] %= mod;
        }
        long long ans = 0;
        for(int i = n - 1 ; i >= 0 ; i--){
            int el = nums[i];
            if(el == 0){
                suff_val[i] = suff[el + 1] + 1;
                suff[el] += (suff[el + 1] + 1);
            }
            else{
                suff_val[i] = suff[el + 1] + 1 + suff[el - 1];
                suff[el] += (suff[el + 1] + 1 + suff[el - 1]);
            }
            suff[el] %= mod;
            suff_val[i] %= mod;
            ans += (el * (suff_val[i] % mod * pref_val[i]%mod) % mod)%mod;
            ans %= mod;
        }
        return ans;
        
    }
};",1448213930
Anshul Pandey,ansh_iet_22,467,3612,cpp,"class Solution {
public:
    
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
    
        bool flag = false;
        
        for(int i = 0 ; i <= nums.size() - 2*k; i++){
                
                bool chk = true;
            
                for(int j = i+1 ; j <= i + k - 1; j++){
                    chk &= (nums[j] > nums[j-1]);
                    
                    // cout << nums[j] << "" "";
                }
                // cout << endl;
            
                for(int j = i+k+1 ; j <= i + 2*k - 1; j++){
                    chk &= (nums[j] > nums[j-1]);
                    // cout << nums[j] << "" "";
                }
            
                // cout << ""\n"";
            
                flag |= chk;
            
            
        }
        
        return flag;
        
    }
    
};",1448186811
Anshul Pandey,ansh_iet_22,467,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& vec) {
        int prev = 0;
            
        int curr = 1;
        
        int ans = 0;
        
        for(int i = 1; i < vec.size() ; i++){
            
            
            if(vec[i] > vec[i-1]){
                curr++;
            }
            else{
                ans = max(ans,min(prev,curr));
                ans = max(ans,curr/2);
                prev = curr;
                curr = 1;
            }
            
            // cout << curr << "" "" << prev << ""\n"";
        }
        
        ans = max(ans,min(prev,curr));
        ans = max(ans,curr/2);

        return ans;
        
    }
};",1448203356
Anshul Pandey,ansh_iet_22,467,3631,cpp,"
#include<bits/stdc++.h>
using namespace std;
// #include<ext/pb_ds/assoc_container.hpp>
// #include<ext/pb_ds/tree_policy.hpp>
// using namespace __gnu_pbds;

/*---------------------------------------------------------------------------------------------------------------------------*/

#define ff first
#define ss second
#define all(x) (x).begin(), (x).end()
typedef long long ll;
typedef unsigned long long ull;
// typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;

/*---------------------------------------------------------------------------------------------------------------------------*/




// cout << ""Anshul Pandey\n"";

class Solution {
public:
    
    // map<ll,ll> mp;
    
    ll cnt = 0 , mod = 1e9 + 7;
    
    ll func(ll sum, ll k){
        while(k){
            sum = __builtin_popcount(sum);
            k--;
        }
        
        if(sum == 1){
            return 1;
        }
        else{
            return 0;
        }
    }
    
    ll helper(ll i , ll sum , ll prev , string &s , int &k , vector<vector<vector<ll>>> &dp){
            
        if(i == s.size()){
            
            ll val = sum;
            if(val == cnt && prev == 0){
                return 0;
            }
            
            if(func(val,k-1)){
                return 1;
            }
            else{
                return 0;
            } 
        }
      
        if(dp[i][sum][prev] != -1){
            return dp[i][sum][prev];
        }
        
        
        
        ll ans = 0;
        
        if(prev == 0){
            if(s[i] == '1'){
                ans = (ans + helper(i+1,sum,1,s,k,dp))%mod;
                ans = (ans + helper(i+1,sum+1,0,s,k,dp))%mod;
            }
            else{
                ans = (ans + helper(i+1,sum,0,s,k,dp))%mod;
            }
        }
        else{
            ans = (ans + helper(i+1,sum+1,1,s,k,dp))%mod;;
            ans = (ans + helper(i+1,sum,1,s,k,dp))%mod;
        }
        
        
        return dp[i][sum][prev] = ans;
        
    }
    
    int countKReducibleNumbers(string& s, int k) {
        
        cnt = 0;
        
        ll n = s.size();
        
        for(auto x : s){
            if(x == '1'){
                cnt++;
            }
        }
        
        vector<vector<vector<ll>>> dp(n,vector<vector<ll>> (n+1,vector<ll> (2,-1)));
        
        
        
        ll ans = helper(0,0,0,s,k,dp);
        
        return ans;
        
    }
};
",1448303787
Anshul Pandey,ansh_iet_22,467,3646,cpp,"#include<bits/stdc++.h>
using namespace std;
// #include<ext/pb_ds/assoc_container.hpp>
// #include<ext/pb_ds/tree_policy.hpp>
// using namespace __gnu_pbds;

/*---------------------------------------------------------------------------------------------------------------------------*/

#define ff first
#define ss second
#define all(x) (x).begin(), (x).end()
typedef long long ll;
typedef unsigned long long ull;
// typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;

/*---------------------------------------------------------------------------------------------------------------------------*/




// cout << ""Anshul Pandey\n"";

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        map<ll,ll> mp , mm;
        
        ll ans = 0;
        ll mod = 1e9+7;
        
        for(int i = 0 ; i < nums.size() ; i++){
            ll lc = 0;
            
            lc += nums[i];
            
            
            
            if(mp.find(nums[i]-1) != mp.end()){
                    
                lc = (lc + mp[nums[i]-1] + (mm[nums[i]-1]*nums[i])%mod)%mod;
                
                mm[nums[i]] = (mm[nums[i]] +  mm[nums[i]- 1])%mod;
            }
            
            if(mp.find(nums[i]+1) != mp.end()){
                
                lc = (lc + mp[nums[i]+1] + (mm[nums[i]+1]*nums[i])%mod)%mod;
                
                mm[nums[i]] = (mm[nums[i]] +  mm[nums[i] + 1])%mod;
            }
            
            mm[nums[i]]++;
            
            ans = (ans + lc)%mod;
            
            mp[nums[i]] = (mp[nums[i]] + lc)%mod;
        }
        
        return ans%mod;
    }
};",1448274960
Arucade,Arucade,469,3612,java,"class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        for (int i = 0, n = nums.size(); i + k + k <= n; i++) {
            boolean b1 = true, b2 = true;
            for (int j = i + 1; b1 && j < i + k; j++) {
                if (nums.get(j) <= nums.get(j - 1)) b1 = false;
            }
            for (int j = i + k + 1; b2 && j < i + k + k; j++) {
                if (nums.get(j) <= nums.get(j - 1)) b1 = false;
            }
            if (b1 && b2) return true;
        }
        
        return false;
    }
}",1448185409
Arucade,Arucade,469,3619,java,"class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        int n = nums.size(), lo = 1, hi = n >> 1, mid;
        int[] count = new int[n];
        count[0] = 1;
        for (int i = 1, j = 1; i < n; i++) {
            if (nums.get(i) > nums.get(i - 1)) count[i] = count[i - 1] + 1;
            else count[i] = 1;
        }
        while (lo <= hi) {
            mid = (lo + hi) >> 1;
            boolean b = false;
            for (int i = mid + mid - 1; !b && i < n; i++) {
                if (count[i] >= mid && count[i - mid] >= mid) b = true;
            }
            if (b) lo = mid + 1;
            else hi = mid - 1;
        }
        return hi;
    }
}",1448192737
Arucade,Arucade,469,3631,java,"class Solution {
    public int countKReducibleNumbers(String s, int k) {
        int n = s.length(), mod = 1000000007, res = 0;
        int[] count = new int[n + 1], ones = new int[n];
        int[][] dp = new int[n + 1][n + 1];
        dp[0][0] = 1;

        for (int i = 0; i < n; i++) {
            if (i > 0) ones[i] = ones[i - 1];
            if (s.charAt(i) == '1') ones[i]++;
        }
        
        for (int i = 1; i < n; i++) {
            for (int j = 0; j <= i; j++) {
                if (j == 1) dp[i][j] = i;
                else if (j + j > i) dp[i][j] = dp[i][i - j];
                else if (j == i || j == 0) dp[i][j] = 1;
                else if (i > 1) {
                    for (int l = j - 1; l < i; l++) {
                        dp[i][j] = (dp[i][j] + dp[l][j - 1]) % mod;
                    }
                }
            }
        }
        
        for (int i = 1; i < count.length; i++) {
            int j = i, c = 0, b;
            if (i > 1) {
                while (j > 0) {
                    c++;
                    j -= j & -j;
                }
                count[i] = 1 + count[c];
            }
            
            if (count[i] < k) {         
                for (int l = n - 1; l >= 0; l--) {
                    if (s.charAt(l) == '1') {
                        int left = ones[l] - 1;
                        if (left > i || (i - left > n - l - 1)) continue;
                        res = (res + dp[n - l - 1][i - left]) % mod;
                        // System.out.println(""##"" + l + "","" + res);
                    }
                }
            }

            // System.out.println(i + "":"" + count[i] + "","" + res);
        }
        return res;
    }
}",1448310428
Arucade,Arucade,469,3646,java,"class Solution {
    public int sumOfGoodSubsequences(int[] nums) {
        int res = 0, mod = 1000000007, n = nums.length;
        Map<Integer, Integer> map = new HashMap<>(), map2 = new HashMap<>();
        for (int i = 0; i < n; i++) {
            int v = nums[i], v1 = v - 1, v2 = v + 1, c = 1, sum = nums[i],
                c1 = map.getOrDefault(v1, 0), c2 = map.getOrDefault(v2, 0),
                c3 = map.getOrDefault(v, 0),
                sum1 = map2.getOrDefault(v1, 0), sum2 = map2.getOrDefault(v2, 0),
                sum3 = map2.getOrDefault(v, 0);
                
            c = (c + c1) % mod;
            c = (c + c2) % mod;

            sum1 = (sum1 + (int)((((long)c1) * ((long)nums[i])) % ((long)mod))) % mod;
            sum2 = (sum2 + (int)((((long)c2) * ((long)nums[i])) % ((long)mod))) % mod;
            sum = (sum + sum1) % mod;
            sum = (sum + sum2) % mod;
            res = (res + sum) % mod;

            // System.out.println(c + "","" + sum);
            
            map.put(v, (c + c3) % mod);
            map2.put(v, (sum + sum3) % mod);
        }
        return res;
    }
}",1448225658
Amit Pandey,pandey__amit,471,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        if(k==1){
            return true;
        }
        int n=nums.size();
        bool flag=false;
        for(int i=0;i<n;i++){
            bool f=true;
            if(i+2*k>n){
                continue;
            }
            for(int j=i+1;j<i+k;j++){
                if(nums[j]<=nums[j-1]){
                    f=false;
                }
            }
            if(f){
                for(int j=i+k+1;j<i+2*k;j++){
                    if(nums[j]<=nums[j-1]){
                        f=false;
                    }
                }
            }
            // cout<<f<<""?\n"";
            if(f){
                flag=true;
            }
        }
        return flag;
    }
};",1448194591
Amit Pandey,pandey__amit,471,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int ans=0;
        int  n=nums.size();
        int cnt=1;
        int prev=0;
        for(int i=1;i<n;i++){
            if(nums[i]>nums[i-1]){
                cnt++;
            }
            else{
                ans=max(ans,cnt/2);
                ans=max(ans,min(cnt,prev));
                prev=cnt;
                cnt=1;
            }
        }
        ans=max(ans,cnt/2);
        ans=max(ans,min(cnt,prev));
        return ans;
    }
};",1448204309
Amit Pandey,pandey__amit,471,3631,cpp,"
typedef long long ll;
typedef unsigned long long ull;




class Solution {
public:
    
    
    const int MODU = 1e9 + 7;

    int cnt = 0;
    
    int tumhiho(ll sum, ll k){
        while(k){
            int val = 0;

            for(int j = 0 ; j <= 25 ; j++){
                if((1<<j)&sum){
                    val++;
                }
            }

            sum = val;
            k--;
        }
        
       return (sum == 1);
    }
    
    ll recur(ll i , ll sum , ll prev , string &s , int &k , vector<vector<vector<ll>>> &dp){
            
        ll n = s.size();

        if(i == n){
            
            int val = sum;
            if(val == cnt && prev == 0){
                return 0;
            }
            
            if(tumhiho(val,k-1)){
                return 1;
            }
            else{
                return 0;
            } 
        }
      
        if(dp[i][sum][prev] != -1){
            return dp[i][sum][prev];
        }
        
        
        
        ll ans = 0;
        
        if(prev == 0){
            if(s[i] == '1'){
                ans = (ans + recur(i+1,sum,1,s,k,dp))%MODU;
                ans = (ans + recur(i+1,sum+1,0,s,k,dp))%MODU;
            }
            else{
                ans = (ans + recur(i+1,sum,0,s,k,dp))%MODU;
            }
        }
        else{
            ans = (ans + recur(i+1,sum+1,1,s,k,dp))%MODU;;
            ans = (ans + recur(i+1,sum,1,s,k,dp))%MODU;
        }
        
        
        return dp[i][sum][prev] = ans;
        
    }
    
    int countKReducibleNumbers(string& s, int k) {
        
        cnt = 0;
        
        ll n = s.size();
        
        for(auto x : s){
            if(x == '1'){
                cnt++;
            }
        }
        
        vector<vector<vector<ll>>> dp(n,vector<vector<ll>> (n+1,vector<ll> (2,-1)));
        
        
        
        ll ans = recur(0,0,0,s,k,dp);
        
        return ans;
        
    }
};",1448310673
Amit Pandey,pandey__amit,471,3646,cpp,"class Solution {
public:
    const long long mod=1e9+7;
    int sumOfGoodSubsequences(vector<int>& nums) {
        int n=nums.size();
        map<int,long long> mp;
        map<int,long long> mp2;
        long long ans[n];
        long long finl=0;
        for(int i=0;i<n;i++){
            ans[i]=nums[i];
            if(mp.find(nums[i]+1)!=mp.end()){
                (ans[i]+=(mp[nums[i]+1]+mp2[nums[i]+1]*nums[i]))%=mod;
                (mp2[nums[i]]+=mp2[nums[i]+1])%=mod;
            }
            if(mp.find(nums[i]-1)!=mp.end()){
                (ans[i]+=(mp[nums[i]-1]+mp2[nums[i]-1]*nums[i]))%=mod;
                (mp2[nums[i]]+=mp2[nums[i]-1])%=mod;
            }
            (mp[nums[i]]+=ans[i])%=mod;
            mp2[nums[i]]++;
            (finl+=ans[i])%=mod;
            cout<<ans[i]<<"" "";
        }
        cout<<""\n"";
        return (int)(finl%=mod);
        
    }
};",1448254991
Daksh Valecha,dakshmv14,472,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& v, int k) {
        int n=v.size();
        vector<int>inc(n);
        inc[n-1]=1;
        for(int i=n-2;i>=0;i--){
            if(v[i]<v[i+1])inc[i]=inc[i+1]+1;
            else inc[i]=1;
        }
        bool ans=false;
        for(int i=0;i<n-k;i++){
            // cout<<inc[i]<<"" "";
            if(inc[i]>=k && inc[i+k]>=k )ans=true;
        }
        // cout<<endl;
        return ans;
    }
};",1448185560
Daksh Valecha,dakshmv14,472,3619,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& v, int k) {
            int n=v.size();
            vector<int>inc(n);
            inc[n-1]=1;
            for(int i=n-2;i>=0;i--){
                if(v[i]<v[i+1])inc[i]=inc[i+1]+1;
                else inc[i]=1;
            }
            bool ans=false;
            for(int i=0;i<n-k;i++){
                // cout<<inc[i]<<"" "";
                if(inc[i]>=k && inc[i+k]>=k )ans=true;
            }
            // cout<<endl;
            return ans;
        }
    
    int maxIncreasingSubarrays(vector<int>& v) {
        int l=1,r=v.size()/2;
        while(l<=r){
            int mid=(l+r)>>1;
            if(hasIncreasingSubarrays(v,mid)){
                l=mid+1;
            }
            else{
                r=mid-1;
            }
        }
        return r;
    }
};",1448190768
Daksh Valecha,dakshmv14,472,3631,cpp,"class Solution {
public:
    int mod=1e9+7;
    static vector<long long>fact,count;
    void fill(int n){
        fact.resize(n+1,0);
        fact[0]=1;
        for(int i=1;i<=n;i++){
            fact[i]=1ll*fact[i-1]*i;
            fact[i]%=mod;
        }
        count.resize(n+1);
        for(int i=2;i<=800;i++){
            count[i]=1+count[__builtin_popcount(i)];
        }
    }
    int inv(int n){
        return power(n,mod-2,mod);
    }
    long long power(long long x, unsigned int y, int p){
       int res = 1; 
       x = x % p; 
       if (x == 0) return 0;
       while (y > 0){
           if (y & 1)
           res = (res*x) % p;
           y = y>>1;
           x = (x*x) % p;
       }
       return res;
    }
    long long ncr(int n,int k){
        if(k>n)return 0;
        return (1ll*fact[n]*inv(fact[k] * fact[n - k] % mod)%mod)%mod;
    }
    int countKReducibleNumbers(string s, int k) {
        if(fact.size()==0){
            fill(801);
        }
        int n=s.length();
        long long ans=0,t=0,l=n-1;
        while(l>=0 && s[l]!='1')l--;
        
        for(int i=0;i<n;i++){
            if(s[i]=='1'){
                int f=n-i-1;
                // cout<<t+f<<endl;
                for(int j=t+1;j<=800;j++){
                    if(count[j]+1<=k){
                        // cout<<j<<endl;
                        // int prev=ans;
                        ans+=ncr(f,j-t);
                        // if(ans>prev)cout<<j<<endl;
                        ans%=mod;
                    }
                }
                t++;
                if(i==l)break;                // cout<<ans<<endl;
                if(count[t]+1<=k)ans++;
                // cout<<ans<<endl;
            }
        }
        
        return ans;
    }
};
vector<long long> Solution::fact;
vector<long long> Solution::count;",1448304729
Daksh Valecha,dakshmv14,472,3646,cpp,"class Solution {
public:
    int mod=1e9+7;
    int sumOfGoodSubsequences(vector<int>& v) {
        int n=v.size();
        vector<long long>dp(n,1);
        // for(int i=0;i<n;i++){
        //     dp[i]=v[i];
        // }
        vector<long long>pre(1e5+3,0),sum(1e5+3,0);
        for(int i=0;i<n;i++){
            // sum[v[i]]+=v[i];
            if(v[i]>0)
            dp[i]+=pre[v[i]-1];
            dp[i]+=pre[v[i]+1];
            dp[i]%=mod;
            pre[v[i]]+=dp[i];
            pre[v[i]]%=mod;
            if(v[i]==0){
                sum[v[i]]+=(0ll+sum[v[i]+1]+(1ll*dp[i]*v[i])%mod)%mod;
            }
            else
            sum[v[i]]+=(0ll+sum[v[i]-1]+sum[v[i]+1]+(1ll*dp[i]*v[i])%mod)%mod;

        }
        // cout<<""here""<<endl;
        long long ans=0;
        // cout<<sum[1]<<"" ""<<sum[2]<<endl;
        for(auto i:sum){
            // cout<<i<<"" "";
            ans+=i;
            ans%=mod;
        }
        return (int)ans;
    }
};",1448233577
Chaitanya Bhutada,_chaitanya99,474,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        for (int i = 0; i < n; i++) {
            int till = i + 2*k - 1;
            if (till >= n) break;
            bool u = true;
            for (int j = i+1; j < i+k; j++) {
                if (nums[j] <= nums[j-1]) {
                    u = false;
                    break;
                }
            }
            for (int j = i+k+1; j < i+2*k; j++) {
                if (nums[j] <= nums[j-1]) {
                    u = false;
                    break;
                }
            }
            if (u) return true;
        }
        return false;
    }
};",1448183758
Chaitanya Bhutada,_chaitanya99,474,3619,cpp,"class Solution {
public:
    vector<int> pref;
    void prep(vector<int>& nums) {
        pref.push_back(0);
        for (int i = 1; i < nums.size(); i++) pref.push_back(nums[i] <= nums[i-1]? 0: 1);
        for (int i = 1; i < pref.size(); i++) pref[i] += pref[i-1];
    }
    bool check(vector<int>& nums, int k) {
        int n = nums.size();
        for (int i = 0; i < n; i++) {
            // i -> i+k-1
            // i+k -> i+2*k-1
            if ((i+2*k-1) >= pref.size()) break;
            int h = pref[i+k-1] - pref[i];
            int o = pref[i+2*k-1] - pref[i+k];
            if (h == (k-1) && o == (k-1)) return true;
        }
        return false;
    }
    int maxIncreasingSubarrays(vector<int>& nums) {
        prep(nums);
        int l = 1, r = (nums.size()/2);
        while (l < r) {
            int md = (l+r+1)/2;
            if (check(nums, md)) l = md;
            else r = md-1;
        }
        return l;
    }
};",1448217026
Chaitanya Bhutada,_chaitanya99,474,3631,cpp,"class Solution {
public:
    int mod = 1000000007;
    vector<int> fact;
    int exp(int a, int b)
    {
    	if (b == 0)
    		return 1;
    	long long x = exp(a, (b / 2));
    	x *= x;
    	x %= mod;
    	if (b % 2)
    		x *= a;
    	x %= mod;
    	return x;
    }

    int inverse(int a)
    {
    	return exp(a, mod - 2);
    }

    int red(int x) {
        if (x == 1) return 0;
        int y = __builtin_popcount(x);
        return 1 + red(y);
    }
    void pre(int n) {
        fact.push_back(1);
        for (int i = 1; i <= n; i++) {
            long long tmp = 1;
            tmp *= fact[i-1];
            tmp *= i;
            tmp %= mod;
            fact.push_back(tmp);
        }
    }
    int nCr(int a, int b) {
        long long ret = fact[a];
        ret *= inverse(fact[b]);
        ret %= mod;
        ret *= inverse(fact[a-b]);
        ret %= mod;
        return ret;
    }
    int countKReducibleNumbers(string s, int k) {
        int n = s.length();
        pre(n+5);
        vector<int> kr(n+1);
        for (int i = 1; i <= n; i++) kr[i] = red(i);
        int ans = 0;
        for (int i = 1; i <= (n-1); i++) {
            if (kr[i] <= (k-1)) {
                ans += nCr(n-1, i);
                ans %= mod;
            }
        }
        int prev = 1;
        for (int i = 1; i < n; i++) {
            int lf = (n-i-1);
            if (s[i] == '1') {
                for (int j = 0; j <= (lf); j++) {
                    if (kr[j+prev] <= (k-1)) {
                        ans += nCr(lf, j);
                        ans %= mod;
                    }
                }
                prev++;
            }
        }
        return ans;
    }
};",1448286141
Chaitanya Bhutada,_chaitanya99,474,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int mx = *max_element(nums.begin(), nums.end());
        vector<int> dp(mx+3, 0);
        vector<int> n(mx+3, 0);
        int mod = 1000000007;
        for (auto &i: nums) {
            i++;
            // dp[i] += (dp[i-1] + n[i-1]*i);
            dp[i] += dp[i-1];
            dp[i] %= mod;
            long long tmp = 1;
            tmp *= n[i-1];
            tmp %= mod;
            tmp *= (i-1);
            tmp %= mod;
            dp[i] += tmp;
            dp[i] %= mod;
            // dp[i] += (dp[i+1] + n[i+1]*i);
            dp[i] += dp[i+1];
            dp[i] %= mod;
            tmp = 1;
            tmp *= n[i+1];
            tmp %= mod;
            tmp *= (i-1);
            tmp %= mod;
            dp[i] += tmp;
            dp[i] %= mod;
            dp[i] += (i-1);
            dp[i] %= mod;
            n[i] += 1;
            n[i] %= mod;
            n[i] += n[i-1];
            n[i] %= mod;
            n[i] += n[i+1];
            n[i] %= mod;
        }
        int ans = 0;
        for (int i = 0; i < mx+3; i++) {
            ans += dp[i];
            ans %= mod;
        }
        return ans;
    }
};",1448239505
Tanguilol,Tanguilol,475,3612,java,"class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {        
        boolean prevK = false;
        
        int prevIndex = 0;
        int prev = nums.get(0);
        int len = 1;
        
        for (int i = 1; i < nums.size(); i++) {
            int cur = nums.get(i);
            
            if (cur > prev) {
                len++;
                
                if (prevK && len >= k || len >= 2 * k) {
                    return true;
                }
                
            } else {
                if (len >= k) {
                    prevK = true;
                } else {
                    prevK = false;
                }
                
                prevIndex = i;
                len = 1;
                
                if (prevK && len >= k || len >= 2 * k) {
                    return true;
                }
            }
            
            prev = cur;
        }
        
        return false;
    }
}",1448188414
Tanguilol,Tanguilol,475,3619,java,"class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        int max = 0;
        
        int prevLen = 0;
        
        int prev = nums.get(0);
        int len = 1;
        
        for (int i = 1; i < nums.size(); i++) {
            int cur = nums.get(i);
            
            if (cur > prev) {
                len++;
                
            } else {
                prevLen = len;
                len = 1;
            }
            
            max = Math.max(max, Math.max(Math.min(prevLen, len), len / 2));
            prev = cur;
        }
        
        return max;
    }
}",1448192471
Tanguilol,Tanguilol,475,3631,java,"class Solution {
    
    private static final int MOD = 1_000_000_007;
    
    private static class Count {
        
        int max;
        long[] counts;
        
        public Count(int max, long[] counts) {
            this.max = max;
            this.counts = counts;
        }
        
    }
    
    public int countKReducibleNumbers(String s, int k) {
        if (s.length() == 1) {
            return 0;
        }
        
        long[] counts = new long[800];
        int start = 1;
        
        for (int i = 1; i < s.length(); i++) {                
            // start here with a 1
            Count innerCounts = getCounts(s.length() - i - 1);

            for (int j = 0; j <= innerCounts.max; j++) {
                counts[j + 1] += innerCounts.counts[j];
                counts[j] %= MOD;
            }
            
            if (s.charAt(i) == '1') {
                // turn the 1 to a 0
                innerCounts = getCounts(s.length() - i - 1);
                
                for (int j = 0; j <= innerCounts.max; j++) {
                    counts[j + start] += innerCounts.counts[j];
                    counts[j] %= MOD;
                }
                
                start++;
            }
        }
        
        long result = 0;
        
        for (int i = 0; i < counts.length; i++) {
            /*
            if (counts[i] > 0) {            
                System.out.println(i + "" "" + counts[i] + "" "" + isKReducible(i, k - 1));
            }
            */
            
            if (isKReducible(i, k - 1)) {    
                result += counts[i];
                result %= MOD;
            }
        }
        
        return (int) result;
    }
    
    private Count[] cache = new Count[800];
    
    private Count getCounts(int remaining) {
        Count result = cache[remaining];
        
        if (result == null) {
            result = getCountsInternal(remaining);
            cache[remaining] = result;
        }
        
        return result;
    }
    
    private Count getCountsInternal(int remaining) {
        long[] result = new long[800];
        result[0] = 1;
        
        if (remaining <= 0) {
            return new Count(0, result);
        }
        
        int max = 0;
        
        for (int i = 0; i < remaining; i++) {
            for (int j = max + 1; j > 0; j--) {
                result[j] += result[j - 1];
                result[j] %= MOD;
            }
            
            max++;
        }
        
        /*
        System.out.println(""getCount("" + start + "", "" + remaining + "")"");
        for (int i = 0; i < result.length; i++) {
            if (result[i] > 0) {
                System.out.println(i + "" "" + result[i]);
            }
        }
        */
        
        return new Count(max, result);
    }
    
    private boolean isKReducible(int v, int k) {
        if (v == 1) {
            return true;
        }
        
        if (k <= 0) {
            return false;
        }
        
        String s = Integer.toBinaryString(v);
        int ones = 0;
        
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '1') {
                ones++;
            }
        }
        
        return isKReducible(ones, k - 1);
    }
}",1448299735
Tanguilol,Tanguilol,475,3646,java,"class Solution {
    
    private static final int MOD = 1_000_000_007;
    
    private static class Group {
        
        long sum;
        long count;
        
        public Group(long sum, long count) {
            this.sum = sum;
            this.count = count;
        }
        
    }
    
    public int sumOfGoodSubsequences(int[] nums) {
        Map<Integer, Group> groups = new HashMap<>();
        long result = 0;
        
        for (int i = 0; i < nums.length; i++) {
            Group upGroup = groups.get(nums[i] - 1);
            Group downGroup = groups.get(nums[i] + 1);
            Group currentGroup = groups.getOrDefault(nums[i], new Group(0, 0));
            
            if (upGroup != null) {
                long newSum = (upGroup.sum + upGroup.count * nums[i]) % MOD;
                
                result += newSum;
                result %= MOD;
                
                currentGroup.sum += newSum;
                currentGroup.sum %= MOD;
                currentGroup.count += upGroup.count;
                currentGroup.count %= MOD;
            }
            
            if (downGroup != null) {
                long newSum = (downGroup.sum + downGroup.count * nums[i]) % MOD;
                
                result += newSum;
                result %= MOD;
                
                currentGroup.sum += newSum;
                currentGroup.sum %= MOD;
                currentGroup.count += downGroup.count;
                currentGroup.count %= MOD;
            }
            
            result += nums[i];
            result %= MOD;
            
            currentGroup.sum += nums[i];
            currentGroup.sum %= MOD;
            currentGroup.count++;
            currentGroup.count %= MOD;
            
            groups.put(nums[i], currentGroup);

            //System.out.println(nums[i] + "" "" + result);
        }
        
        return (int) result;
    }
}",1448239225
Yuwen Yan,yuwen-yan,476,3612,python3,"class Solution:
    def maxIncreasingSubarrays2(self, nums: List[int]) -> int:
        increasing_len = [1 for _ in range(len(nums))]

        current_increasing_len = 0
        for i in range(len(nums)):
            if i == 0 or nums[i] <= nums[i - 1]:
                current_increasing_len = 1
            else:
                current_increasing_len += 1
            increasing_len[i] = current_increasing_len
        
        left = 1
        right = len(nums)

        while left < right:
            mid = (left + right) // 2

            def is_bad():
                if len(nums) < 2 * mid:
                    return True
                
                for i in range(len(nums) + 1 - 2 * mid):
                    if increasing_len[i + mid - 1] >= mid and increasing_len[i + mid * 2 - 1] >= mid:
                        return False
                return True
            
            if is_bad():
                right = mid
            else:
                left = mid + 1

        return right - 1
        
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        return self.maxIncreasingSubarrays2(nums) >= k
    ",1448194928
Yuwen Yan,yuwen-yan,476,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        increasing_len = [1 for _ in range(len(nums))]

        current_increasing_len = 0
        for i in range(len(nums)):
            if i == 0 or nums[i] <= nums[i - 1]:
                current_increasing_len = 1
            else:
                current_increasing_len += 1
            increasing_len[i] = current_increasing_len
        
        left = 1
        right = len(nums)

        while left < right:
            mid = (left + right) // 2

            def is_bad():
                if len(nums) < 2 * mid:
                    return True
                
                for i in range(len(nums) + 1 - 2 * mid):
                    if increasing_len[i + mid - 1] >= mid and increasing_len[i + mid * 2 - 1] >= mid:
                        return False
                return True
            
            if is_bad():
                right = mid
            else:
                left = mid + 1

        return right - 1",1448193141
Yuwen Yan,yuwen-yan,476,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        MOD = 10 ** 9 + 7

        @cache
        def is_good(m, n):
            if m == 0:
                return False
            if m == 1:
                return True
            if n == 0:
                return False

            next_ans = 0
            while m > 0:
                next_ans += (m % 2)
                m = m // 2
            return is_good(next_ans, n - 1)

        @cache
        def f(n):
            if n <= 1:
                return 1
            ans = 1
            for i in range(1, n + 1):
                ans *= i
                ans %= MOD
            return ans
            
        def count_num_of_ones(n):
            if n == 0:
                return {0: 1}
            ans = collections.Counter()
            for i in range(n + 1):
                ans[i] = f(n)
                ans[i] *= pow(f(n-i), -1, MOD)
                ans[i] %= MOD
                ans[i] *= pow(f(i), -1, MOD)
                ans[i] %= MOD
            return ans

        final_ans = 0
        num_of_ones = 0
        for i in range(len(s)):
            if s[i] == '0':
                continue
            sub_count = count_num_of_ones(len(s) - i - 1)
            for n, c in sub_count.items():
                total_ones = n + num_of_ones
                if total_ones == 0:
                    continue
                elif total_ones == 1:
                    final_ans += c
                    final_ans %= MOD
                else:
                    if is_good(total_ones, k-1):
                        final_ans += c
                        final_ans %= MOD
            num_of_ones += 1
        return final_ans
            
        # def count_num_of_ones_with_index():
        #     counter = collections.Counter()
        #     num_of_ones = 0
        #     for i in range(len(s)):
        #         if s[i] == '0':
        #             continue
        #         sub_count = count_num_of_ones(len(s) - i - 1)
        #         for n, c in sub_count.items():
        #             counter[n + num_of_ones] += c
        #             counter[n + num_of_ones] %= MOD
        #         num_of_ones += 1
        #     return counter

        # final_ans = 0
        # counters = count_num_of_ones_with_index()
        # for n, c in counters.items():
        #     if n == 0:
        #         continue
        #     if n == 1:
        #         final_ans += c
        #         final_ans %= MOD
        #         continue
        #     if is_good(n, k-1):
        #         final_ans += c
        #         final_ans %= MOD
        # return final_ans",1448307888
Yuwen Yan,yuwen-yan,476,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        MOD = 10 ** 9 + 7


        suffix_count = collections.Counter()
        for i in reversed(range(len(nums))):
            suffix_count[nums[i]] += suffix_count[nums[i] - 1]
            suffix_count[nums[i]] += suffix_count[nums[i] + 1]
            suffix_count[nums[i]] += 1
            suffix_count[nums[i]] %= MOD

        ans = 0
        
        prefix_count = collections.Counter()
        for i in range(len(nums)):
            suffix_count[nums[i]] -= suffix_count[nums[i] - 1]
            suffix_count[nums[i]] -= suffix_count[nums[i] + 1]
            suffix_count[nums[i]] -=1
            suffix_count[nums[i]] %= MOD
            
            p_cnt = prefix_count[nums[i] - 1] + prefix_count[nums[i] + 1] + 1
            p_cnt %= MOD
            s_cnt = suffix_count[nums[i] - 1] + suffix_count[nums[i] + 1] + 1
            s_cnt %= MOD
            ans += ((p_cnt * s_cnt * nums[i]) % MOD)
            ans %= MOD

            prefix_count[nums[i]] += p_cnt
        return ans",1448218869
Procodgok,Procodgok,477,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        bool poss=false;
        int n=nums.size();
        for(int i=0;(i+2*k)<=n;i++){
            bool p1=true,p2=true;
            for(int j=i+1;j<i+k;j++){
                if(nums[j]<=nums[j-1]){
                    p1=false;
                }
            }
            for(int j=i+k+1;j<i+2*k;j++){
                if(nums[j]<=nums[j-1]){
                    p2=false;
                }
            }
            if(p1 && p2){
                poss=true;
                break;
            }
        }
        return poss;
    }
};",1448190826
Procodgok,Procodgok,477,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int ans=0;
        int n=nums.size();
        vector <int> prev(n);
        for(int i=0;i<n;i++){
            prev[i] = (i==0) || (nums[i]<=nums[i-1]) ? i : prev[i-1];
        }
        int l=1,r=n/2;
        while(l<=r){
          int mid=(l+r)/2;
          bool poss=false;
          // i ... i+mid-1   , i+mid .... ind+2*mid -1
          for(int i=0;i+2*mid<=n;i++){
              if(prev[i+mid-1]<=i && prev[i+2*mid-1]<=(i+mid)){
                  poss=true;
                  break;
              }
          }
          if(poss){
              ans=mid;
              l=mid+1;
          }  else {
              r=mid-1;
          }
        }
        return ans;
    }
};",1448204906
Procodgok,Procodgok,477,3631,cpp,"#define ll long long int 
#define mod 1000000007
#define modsum(a,b) ((a%mod)+(b%mod))%mod
#define moddif(a,b) ((a%mod)-(b%mod)+mod)%mod
#define modpro(a,b) ((a%mod)*(b%mod))%mod
ll modularExponentiation(ll x,ll n,ll M)
{
    ll result=1;
    while(n>0)
    {
        if(n % 2 ==1)
            result=modpro(result,x);
        x=modpro(x,x);
        n=n/2;
    }
    return result;
}
ll  modInverse(ll n, ll p) 
{ 
    return modularExponentiation(n, p - 2, p); 
} 
class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        int n=s.size();
        vector <ll> steps(805,0);
        vector <ll> fact(805);
        vector <ll> modfact(805);
        fact[0]=1;
        for(ll i=1;i<805;i++) fact[i]=(fact[i-1]*i)%mod;
        for(ll i=0;i<805;i++) modfact[i]=modInverse(fact[i],mod);
        for(ll i=2;i<=800;i++){
            int c=0;
            for(int j=0;j<=10;j++){
                if(i & (1<<j)) c++;
            }
            steps[i]=1+steps[c];
        }
        vector <int> poss;
        for(int bits=1;bits<=800;bits++){
            if(bits==1 || (1+steps[bits])<=k) poss.push_back(bits);
        }
        ll A=0;
        for(auto z:poss){
            ll c=z;
            //cout<<c<<'\n';
            for(int i=0;i<s.size();i++){
                if(s[i]=='1' && (i+c)<n){
                    //cout<<i<<' '<<c<<""\n"";
                    A=modsum(A,modpro(fact[n-i-1],modpro(modfact[c],modfact[n-i-1-c])));
                    c--;
                }
                if(c==0){
                    bool one=false;
                    for(int j=i+1;j<n;j++){
                        if(s[j]=='1'){
                            one=true;
                            break;
                        }
                    }
                    if(one){
                        A=modsum(A,1ll);
                    }
                    break;
                }
            }
        }
        int a=A;
        return a;
    }
};",1448302167
Procodgok,Procodgok,477,3646,cpp,"#define ll long long int 
#define mod 1000000007
#define modsum(a,b) ((a%mod)+(b%mod))%mod
#define moddiff(a,b) ((a%mod)-(b%mod)+mod)%mod
#define modpro(a,b) ((a%mod)*(b%mod))%mod
class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        vector <ll> ans(100005,0);
        vector <ll> count(100005,0);
        int n=nums.size();
        ans[nums[0]]=nums[0];
        count[nums[0]]=1;
        ll A=nums[0];
        for(int i=1;i<n;i++){
            if(nums[i]>=1){
            ll x=modsum(1,modsum(count[nums[i]-1],count[nums[i]+1]));
            count[nums[i]]=modsum(count[nums[i]],1);
            count[nums[i]]=modsum(count[nums[i]],count[nums[i]+1]);
            count[nums[i]]=modsum(count[nums[i]],count[nums[i]-1]);
            ll val=modsum(modpro(x,nums[i]),modsum(ans[nums[i]-1],ans[nums[i]+1]));
            A=modsum(A,val);
            ans[nums[i]]=modsum(ans[nums[i]],val);
            }
            else{
                 ll x=modsum(1,count[nums[i]+1]);
            count[nums[i]]=modsum(count[nums[i]],1);
            count[nums[i]]=modsum(count[nums[i]],count[nums[i]+1]);
            ll val=modsum(modpro(x,nums[i]),ans[nums[i]+1]);
            A=modsum(A,val);
            ans[nums[i]]=modsum(ans[nums[i]],val);  
            }
            //cout<<i<<' '<<x<<' '<<count[nums[i]]<<' '<<ans[nums[i]]<<""\n"";
        }
        int a=A;
        return a;
    }
};",1448247591
Wake,wakeliu,478,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        vector<int> incr;
        int cnt = 1;
        for (int i = 1; i < nums.size(); ++i) {
            if (nums[i] > nums[i - 1]) {
                ++cnt;
            } else {
                incr.push_back(cnt);
                cnt = 1;
            }
        }
        incr.push_back(cnt);
        for (int i = 0; i < incr.size(); ++i) {
            // cout << incr[i] << "", "";
            if (incr[i] >= 2 * k)
                return true;
            if (i > 0 && incr[i] >= k && incr[i - 1] >= k)
                return true;
            
        }
        return false;
    }
};",1448186552
Wake,wakeliu,478,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        vector<int> incr;
        int cnt = 1;
        for (int i = 1; i < nums.size(); ++i) {
            if (nums[i] > nums[i - 1]) {
                ++cnt;
            } else {
                incr.push_back(cnt);
                cnt = 1;
            }
        }
        incr.push_back(cnt);
        int maxK = 0;
        for (int i = 0; i < incr.size(); ++i) {
            maxK = max(maxK, incr[i] / 2);
            
            if (i > 0) {
                maxK = max(maxK, min(incr[i], incr[i - 1]));
            }
        }        
        return maxK;
    }
};",1448191114
Wake,wakeliu,478,3631,cpp,"class Solution {
public:
    using ll = long long;
    const int MOD = 1e9 + 7;
    int countKReducibleNumbers(string s, int k) {
        
        // first op
        k -= 1;
        vector<int> dp = countOnesInSmallerNumbers(s);
        vector<int> preCal(801, 0);
        for (int i = 2; i <= 800; ++i) {
            int num = i;
            int cnt = 0;
            while (num > 0) {
                cnt += num & 1;
                num >>= 1;
            }
            if (cnt == 1) {
                preCal[i] = 1;
            } else {
                preCal[i] = preCal[cnt] + 1;
            }
        }
        ll sum = 0;
        for (int i = 1; i < dp.size(); ++i) {
            // cout << i << "": "" << dp[i] << "", "" << preCal[i] << endl;
            if (preCal[i] <= k) {
                sum += dp[i];
                sum %= MOD;
            }
        }
        // for (int num: res) {
        //     cout << num << "", "";
        // }
        // cout << endl;
        // return 0;
        return sum;
        
    }


    vector<int> countOnesInSmallerNumbers(const string &s) {
    int n = s.size();  // Length of the binary string `s`
    
    // DP table to count binary numbers with specific Hamming weights less than `s`
    vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(n + 1, vector<int>(2, 0)));
    dp[0][0][1] = 1;  // Base case: 0 '1's and equal to `s` at the start
    
    // Fill DP table
    for (int pos = 0; pos < n; ++pos) {
        int bit = s[pos] - '0';  // Current bit in `s`
        for (int count1 = 0; count1 <= pos; ++count1) {
            // Transition: Choose '0' at position `pos`
            dp[pos + 1][count1][0] = (dp[pos + 1][count1][0] + dp[pos][count1][0]) % MOD;
            if (bit == 1) 
                dp[pos + 1][count1][0] = (dp[pos + 1][count1][0] + dp[pos][count1][1]) % MOD;
            else 
                dp[pos + 1][count1][1] = (dp[pos + 1][count1][1] + dp[pos][count1][1]) % MOD;
            
            // Transition: Choose '1' at position `pos`
            dp[pos + 1][count1 + 1][0] = (dp[pos + 1][count1 + 1][0] + dp[pos][count1][0]) % MOD;
            if (bit == 1) 
                dp[pos + 1][count1 + 1][1] = (dp[pos + 1][count1 + 1][1] + dp[pos][count1][1]) % MOD;
        }
    }
    
    // Collect results excluding the count that is exactly equal to `s`
    vector<int> result(n + 1, 0);
    for (int count1 = 0; count1 <= n; ++count1) {
        result[count1] = (dp[n][count1][0]) % MOD;  // Only count numbers strictly less than `s`
    }
    
    // Remove trailing zero counts
    while (!result.empty() && result.back() == 0) {
        result.pop_back();
    }
    
    return result;
}

};",1448308680
Wake,wakeliu,478,3646,cpp,"class Solution {
public:
    using ll = long long;
    const int MOD = 1e9 + 7;
    int sumOfGoodSubsequences(vector<int>& nums) {
        // dp[last] = cnt
        vector<ll> dp(1e5 + 5), dpSum(1e5 + 5);
        
        for (int num: nums) {
            dpSum[num] += dpSum[num + 1] + (dp[num + 1] * num) + num;
            if (num > 0)
                dpSum[num] += dpSum[num - 1] + (dp[num - 1] * num);
            dpSum[num] %= MOD;
            dp[num] = dp[num] + dp[num + 1] + 1;
            if (num > 0)
                dp[num] += dp[num - 1];
            dp[num] %= MOD;
            
        }          
        ll total = 0;
        for (int num: dpSum) {
            total += num;
            total %= MOD;
        }
        return total;
    }
};",1448229371
ANINDYA DAS,anindyadas,479,3612,cpp,"class Solution {
    int countInc(vector<int>& nums, int start) {
        if (start >= nums.size()) {
            return 0;
        }
        int count = 1;
        for (int i = start + 1; i < nums.size(); i++) {
            if (nums[i] > nums[i - 1]) {
                count++;
            } else {
                break;
            }
        }
        return count;
    }
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        for (int i = 0; i < nums.size(); ) {
            int found = countInc(nums, i);
            if (found >= 2 * k) {
                return true;
            }
            int found2 = countInc(nums, i + found);
            if (found >= k && found2 >= k) {
                return true;
            }
            i = i + found;
            if (found2 < k) {
                i += found2;
            }
        }
        return false;
    }
};",1448198340
ANINDYA DAS,anindyadas,479,3619,cpp,"class Solution {
    int countInc(vector<int>& nums, int start) {
        if (start >= nums.size()) {
            return 0;
        }
        int count = 1;
        for (int i = start + 1; i < nums.size(); i++) {
            if (nums[i] > nums[i - 1]) {
                count++;
            } else {
                break;
            }
        }
        return count;
    }
    
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        vector<int> inc;
        for (int i = 0; i < nums.size(); ) {
            int found = countInc(nums, i);
            inc.push_back(found);
            i += found;
        }
        int ret = 0;
        for (int i = 0; i < inc.size(); i++) {
            ret = max(ret, inc[i] / 2);
            ret = max(ret, min(inc[i], (i + 1) < inc.size() ? inc[i + 1]: 0));
        }
        return ret;
    }
};",1448208808
ANINDYA DAS,anindyadas,479,3631,cpp,"class Solution {
    #define MOD 1000000007
    inline int addMod(int a) {
        return (a >= MOD) ? (a - MOD) : a;
    }
    int calc(int pos, bool isEq, int rem, vector<vector<vector<int>>>& dp, string& s) {
        if (pos == s.size()) {
            return (isEq == 0 && !rem);
        }
        int val = s[pos] - '0';
        if (dp[pos][rem][isEq] != -1) {
            return dp[pos][rem][isEq];
        }
        //cout << pos << "" "" << rem << endl;
        dp[pos][rem][isEq] = calc(pos + 1, isEq && (val == 0), rem, dp, s);
        if (!isEq || val == 1) {
            if (rem > 0) {
                dp[pos][rem][isEq] += calc(pos + 1, isEq && (val == 1), rem - 1, dp, s);
                dp[pos][rem][isEq] = addMod(dp[pos][rem][isEq]);
            }
        }
        return dp[pos][rem][isEq];
    }
public:
    int countOps(int n) {
        int count = 0;
        if (n == 1) {
            return count;
        }
        for (int i = 0; i < 12; i++) {
            if (n & (1<<i)) {
                count++;
            }
        }
        return countOps(count) + 1;
    }
    int countKReducibleNumbers(string s, int k) {
        int len = s.size();
        int ans = 0;
        vector<vector<vector<int>>> dp(len + 1, vector<vector<int>>(len + 1, vector<int>(2, -1)));
        for (int i = 1; i <= len; i++) {
            if (countOps(i) < k) {
                ans += calc(0, true, i, dp, s);
                ans = addMod(ans);
            }
        }
        return ans;
    }
};",1448308720
ANINDYA DAS,anindyadas,479,3646,cpp,"class Solution {
    #define MOD 1000000007
    int ret;
    void update(vector<pair<int, int>>& sum, int now, int prev) {
        sum[now].first += sum[prev].first;
        ret += sum[prev].first;
        ret %= MOD;
        if (sum[now].first >= MOD) {
            sum[now].first -= MOD;
        }
        sum[now].second += sum[prev].second;
        if (sum[now].second >= MOD) {
            sum[now].second -= MOD;
        }
        sum[now].first += ((long long)sum[prev].second * now) % MOD;
        if (sum[now].first >= MOD) {
            sum[now].first -= MOD;
        }
        ret += ((long long)sum[prev].second * now) % MOD;
        if (ret >= MOD) {
            ret -= MOD;
        }
    }
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int maxVal = 0;
        for (auto& num: nums) {
            maxVal = max(num, maxVal);
        }
        vector<pair<int, int>> sum(maxVal + 2, {0, 0});
        ret = 0;
        for (auto& num: nums) {
            if (num - 1 >= 0) {
                update(sum, num, num - 1);
            }
            update(sum, num, num + 1);
            sum[num].first += num;
            sum[num].first %= MOD;
            sum[num].second++;
            sum[num].second %= MOD;
            ret += num;
            if (ret >= MOD) {
                ret -= MOD;
            }
        }
        return ret;
    }
};",1448261698
Kyle,LayzerK,480,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        if k == 1:
            return True
        def check(start):
            if start + k > len(nums):
                return False
            
            for i in range(start+1, start+k):
                if nums[i] <= nums[i-1]:
                    return False
            return True
        
        for i in range(len(nums)):
            if check(i) and check(i+k):
                return True
        return False",1448182527
Kyle,LayzerK,480,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        
        def check(k):
            if k == 1:
                return True
            
            l = 0
            r = k 
            
            for i in range(1, len(nums)):
                diff = i - l
                if diff == 0:
                    continue
                if r + diff >= len(nums):
                    return False
                if nums[i] <= nums[i-1]:
                    l = i
                    r = i + k
                elif nums[r+diff] <= nums[r+diff-1]:
                    l = i
                    r = i + k
                
                elif i - l + 1 == k:
                    return True
            return False
        
        left = 1
        right = len(nums)//2
        res = 0
        while left <= right:
            mid = (left+right)//2
            
            if check(mid):
                left = mid + 1
                res = mid
            else:
                right = mid - 1
        return res",1448195091
Kyle,LayzerK,480,3631,python3,"import gc
class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        n = len(s)
        MOD = 10**9 + 7
        ans = 0
        
        @cache
        def dfs(num, rem):
            if num == 1 or rem == 0:
                return num == 1
            
            x = num.bit_count()
            
            return dfs(x, rem-1)
        
        
        v = {0:True}
        for i in range(1, n+1):
            v[i] = dfs(i, k-1)
        
            
        @cache
        def dp(i, placed, hi):
            #print(i, placed, hi)
            if i == n:
                return placed != 0 and not hi and v[placed]
            
            if hi:
                one = 0 if s[i] == ""0"" else dp(i+1, placed+1, True)
                zero = dp(i+1, placed, False) if s[i] == ""1"" else dp(i+1, placed, True)
                return (one + zero) % MOD
            
            else:
                return (dp(i+1, placed+1, False) + dp(i+1, placed, False))  % MOD
        ans = dp(0, 0, True) % MOD
        gc.collect()
        return ans",1448296613
Kyle,LayzerK,480,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        MOD = 10**9 + 7
        n = len(nums)
        
        dp = [nums[i] for i in range(len(nums))]
        cnt = defaultdict(int)
        
        totals = defaultdict(int)
        
        for i,num in enumerate(nums):
            if num - 1 in cnt:
                cnt[num] += cnt[num-1]
                totals[num] += totals[num-1]
                dp[i] += totals[num-1] + cnt[num-1] * num
            
            if num + 1 in cnt:
                cnt[num] += cnt[num + 1]
                totals[num] += totals[num+1]

                dp[i] += totals[num+1] + cnt[num+1] * num
            
            cnt[num] += 1
            
            totals[num] += num + num * (cnt[num+1] + cnt[num-1])
            
            dp[i] %= MOD
            totals[num] %= MOD
            cnt[num] %= MOD
        
        ans = 0
        for val in dp:
            ans = (ans + val) % MOD
            
        
        #10
        #10
        #1
        #10, 9
        #10, 9
        #9
        print(dp)
        return ans
                ",1448250898
SDAIa9ahLf,SDAIa9ahLf,482,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> dp(n, 1);
        for(int i=1; i<n; i++){
            if(nums[i] > nums[i-1]) dp[i] += dp[i-1];
        }

        int ans = 1;
        for(int i=0;  i<n; i++){
            int x = dp[i];
            ans = max(ans, x/2);
            if(i - 2*x >= -1){
                ans = max(ans, min(x, dp[i-x] ));
            }
        }

        return ans >= k;
    }
};",1448194704
SDAIa9ahLf,SDAIa9ahLf,482,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp(n, 1);
        for(int i=1; i<n; i++){
            if(nums[i] > nums[i-1]) dp[i] += dp[i-1];
        }

        int ans = 1;
        for(int i=0;  i<n; i++){
            int x = dp[i];
            ans = max(ans, x/2);
            if(i - 2*x >= -1){
                ans = max(ans, min(x, dp[i-x] ));
            }
        }

        return ans;
    }
};",1448192880
SDAIa9ahLf,SDAIa9ahLf,482,3631,cpp,"class Solution {

int mod = 1e9 + 7;

int dp[805][2][805];  
int func(int ind, int flag, int sum, string& a) {
    if(sum < 0) return 0;
    if (ind == a.size()) {
        if (sum == 0) return 1;
        else return 0;
    }
    if (dp[ind][flag][sum] != -1) return dp[ind][flag][sum];

    char limit = '1';
    if (flag == 0) limit = a[ind];
 
    int cnt = 0;
    for (char num = '0'; num <= limit; num++) {
  
        if (flag == 0 && num == a[ind]) {
            cnt += func(ind + 1, 0, sum - (num - '0'), a);
            cnt %= mod;
        }
        else {
            cnt += func(ind + 1, 1, sum - (num - '0'), a);
            cnt %= mod;
        }
    }
    return dp[ind][flag][sum] = cnt;
}


public:
    int countKReducibleNumbers(string s, int k) {
        int len = s.length();
        int mx = 805;
        vector<int> req(mx);
        req[1] = 0;
        for(int i=2; i<mx; i++){
            bitset<12> b1(i);
            req[i] = 1 + req[b1.count()];
        }

        // vector<vector<int>> cnt(mx, vector<int>(6, 0));

        // for(int i=1; i<mx; i++){
        //     for(int j=0; j<6; j++){
        //         cnt[i][j] = cnt[i-1][j];
        //     }
        //     if(req[i] > 5) continue;
        //     cnt[i][req[i]]++;
        // }

        memset(dp, -1, sizeof dp); 
        int ans = 0;
        for(int i=1; i<=800; i++){
            int val = func(0, 0, i, s);
            //cout << val <<"" "";

            if(req[i] <= k-1){
                ans += val;
                ans %= mod;
            }
        }

        int x = 0;
        for(int i=0; i<s.length(); i++){
            if(s[i] == '1') x++;
        }
        if(req[x] <= k-1) ans--;
        if(ans < 0) ans += mod;

        return ans;
        
    }
};",1448310100
SDAIa9ahLf,SDAIa9ahLf,482,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        long long mod = 1e9 + 7;
        int n = nums.size();
        int mx = 1e5 + 5;
        vector<long long> sum(mx, 0), tot(mx, 0);

        long long ans = 0;

        for(int i=0; i<n; i++){
            int x = nums[i];
            long long v1 = 0;
            if(x > 0) v1 = tot[x-1];
            long long len = 1 + v1 + tot[x+1];
            long long v2 = 0;
            if(x > 0) v2 = sum[x-1];
            long long val = ((v2 + sum[x+1] + len * x) % mod );  
            
            sum[x] += val;
            sum[x] %= mod;
            
            tot[x] += len;
            tot[x] %= mod;

            ans = ((ans + val) % mod ); 
        }

        return ans;
        
    }
};",1448223130
Cecilia Chan,cecilia5,483,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        ranges = []
        count = 1
        for i in range(1, n):
            if nums[i] > nums[i - 1]:
                count += 1
            else:
                ranges.append(count)
                count = 1
        ranges.append(count)
        m = len(ranges)
        if ranges[0] >= 2 * k:
            return True
        for i in range(1, m):
            if ranges[i] >= 2 * k:
                return True
            if ranges[i - 1] >= k and ranges[i] >= k:
                return True
        return False",1448190997
Cecilia Chan,cecilia5,483,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        ranges = []
        count = 1
        for i in range(1, n):
            if nums[i] > nums[i - 1]:
                count += 1
            else:
                ranges.append(count)
                count = 1
        ranges.append(count)
        m = len(ranges)
        best = ranges[0] // 2
        for i in range(1, m):
            best = max(best, ranges[i] // 2)
            best = max(best, min(ranges[i], ranges[i - 1]))
        return best",1448196080
Cecilia Chan,cecilia5,483,3631,python3,"mod = 10**9 + 7

def eea(p, q):
    r = p % q
    if r == 0:
        return (0, 1, q)
    else:
        (m, n, g) = eea(q, r)
        m1 = n
        m2 = m - n * ((p-r)//q)
        return (m1, m2, g)

def modular_inverse(i, mod):
    (m, _, _) = eea(i, mod)
    return m % mod

def reduce_k(n, k):
    for i in range(k):
        n = n.bit_count()
    return n

factorials = [1]
factorial_inverses = [1]
for i in range(1, 801):
    factorials.append(factorials[-1] * i % (mod))
    factorial_inverses.append((factorial_inverses[-1] * modular_inverse(i, mod)) % mod)

reducible = [[] for _ in range(6)]
reducible[0].append(1)
for k in range(1, 6):
    for n in range(1, 801):
        if reduce_k(n, k) == 1:
            reducible[k].append(n)

class Solution:
    def countLessThan(self, s, i, requiredOneBits, memo, indent):
        # print(' ' * indent, s[i:], requiredOneBits)
        n = len(s)
        if i == n:
            return 0
        key = (i, requiredOneBits)
        if key not in memo:
            if s[i] == '0':
                # print(' ' * indent, ""Starting with 0"")
                answer = self.countLessThan(s, i + 1, requiredOneBits, memo, indent + 2)
            else:
                # print(' ' * indent, ""Starting with 1"")
                if requiredOneBits == 0:
                    if len([c for c in s if c == '1']) > 0:
                        answer = 1
                    else:
                        answer = 0
                else:
                    # print(' ' * indent, ""Take case"")
                    take = self.countLessThan(s, i + 1, requiredOneBits - 1, memo, indent + 2)
                    remainder_length =  n - i - 1
                    if remainder_length >= requiredOneBits:
                        drop = factorials[remainder_length] * factorial_inverses[remainder_length - requiredOneBits] * factorial_inverses[requiredOneBits]
                        # print(' ' * indent, ""Drop case"", remainder_length, requiredOneBits, drop)
                    else:
                        drop = 0
                    answer = take + drop
            memo[key] = answer
        return memo[key]


    def countKReducibleNumbers(self, s: str, k: int) -> int:
        result = 0
        for required in reducible[k-1]:
            memo = {}
            count = self.countLessThan(s, 0, required, memo, 0)
            result += count
            # print(required, count)
        return result % mod

",1448310112
Cecilia Chan,cecilia5,483,3646,python3,"
class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        mod = 10 ** 9 + 7
        index_sums = {}
        index_counts = {}
        n = len(nums)
        sums = [None] * n
        counts = [None] * n
        for i in reversed(range(n)):
            # take it
            # There is always 1 sum subsequence that starts with me
            v = nums[i]
            sums[i] = v
            counts[i] = 1
            # for each latter value that starts with v + 1, we can take them all
            if v + 1 in index_sums:
                sum_plus = index_sums[v+1]
                count_plus = index_counts[v+1]
                sums[i] += sum_plus + v * count_plus
                sums[i] %= mod
                counts[i] += count_plus
            if v - 1 in index_sums:
                sum_plus = index_sums[v - 1]
                count_plus = index_counts[v - 1]
                sums[i] += sum_plus + v * count_plus
                sums[i] %= mod
                counts[i] += count_plus

            if v not in index_sums:
                index_sums[v] = 0
            if v not in index_counts:
                index_counts[v] = 0
            index_sums[v] += sums[i]
            index_counts[v] += counts[i]
        return sum(sums) % mod
",1448231380
luck,papaya,484,3612,cpp,"#include<bits/stdc++.h>
using namespace std ; 
using int64 = long long ; 

const int64 INF = 1e18 ; 

class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        
        auto &a = nums ; 
        int n = a.size() ; 
        vector<int> aft( n + 1 , 0 ) ; 

        aft[ n - 1 ] = 1 ; 
        for( int j = n - 2 ; j >= 0 ; j-- ) {
            if( a[j] < a[j+1] ) {
                aft[j] = 1 + aft[j+1] ; 
            } else {
                aft[j] = 1 ; 
            }
        }

        for( int i = 0 , j = k ;  j + k - 1 <= n - 1 ;  i++ , j++ ) {

            if( aft[i] >= k && aft[j] >= k ) {
                return true ; 
            }
        }
        return false ; 
    }
};




int mai2n( )  { 
    Solution  t; 

    vector<int> a ;
    int n ; 

    int k ; 
    a = { 2,5,7,8,9,2,3,4,3,1 } ; 
    k = 3 ; 


    a = { 1,2,3,4,4,4,4,5,6,7 } ; 
    k = 5 ; 


    auto ans = t.hasIncreasingSubarrays (  a , k ) ; 
    cout << ans << ""\n"" ;


    return 0 ; 
}
",1448185132
luck,papaya,484,3619,cpp,"#include<bits/stdc++.h>
using namespace std ; 
using int64 = long long ; 

const int64 INF = 1e18 ; 

class Solution {
public:
    vector<int> a ; 
    vector<int> pre , aft ; 
    int n ; 

    void init_aft ( ) { 
    
        aft.assign( n + 1 , 0 ) ; 

        aft[ n - 1 ] = 1 ; 
        for( int j = n - 2 ; j >= 0 ; j-- ) {
            if( a[j] < a[j+1] ) {
                aft[j] = 1 + aft[j+1] ; 
            } else {
                aft[j] = 1 ; 
            }
        }
    }

    void init_pre ( ) { 
    
        pre.assign( n + 1 , 0 ) ; 

        pre[0] = 1 ; 

        for( int j = 1 ; j < n ; j++ ) {
            if( a[j] > a[j-1] ) {
                pre[j] = 1 + pre[j-1] ; 
            } else {
                pre[j] = 1 ; 
            }
        }
    }
    void init() {
        init_pre() ;
        init_aft( ) ; 
    }
    int solve() {
        init( ) ; 

        int ans = 0 ; 

        for( int j = 0 ; j <= n - 2 ;  j++ ) {
            int xlen_1 = pre[j] ; 
            int xlen_2 = aft[ j + 1 ] ; 

            int min_len = min( xlen_1 , xlen_2 ) ; 
            ans = max( ans , min_len ) ; 
        }
        return ans ; 
    }

    int maxIncreasingSubarrays(vector<int>& nums) {
        
        a = nums ; 
        n = a.size() ;
        return solve() ; 
    }

};




int ma2in( )  { 
    Solution  t; 

    vector<int> a ;
    int n ; 

    int k ; 
    a = { 2,5,7,8,9,2,3,4,3,1 } ; 
    k = 3 ; 


    a = { 1,2,3,4,4,4,4,5,6,7 } ; 

    auto ans = t.maxIncreasingSubarrays (  a ) ; 
    cout << ans << ""\n"" ;


    return 0 ; 
}
",1448194342
luck,papaya,484,3631,cpp,"#include<bits/stdc++.h>
using namespace std ; 
using int64 = long long ; 



auto __OI_INIT__ = []() {
    ios::sync_with_stdio(0), cin.tie(0) , cout.tie(0);
    cout << fixed << setprecision(12); return 0 ; 
}();



const int64 MOD = 1e9 + 7 ; 

class Solution {
public:

    vector< vector<int> > f ; 
    int M = 1000; 
    int K ; 
    vector< int > a ; 

    int count_ones( int val ) { 
        if( val == 0 ) {
            return 0 ; 
        }
        int cnt = 0 ; 
        while( val > 0 ) {
            ++cnt ; 
            val = ( val & (val-1 )) ; 
        }
        return cnt ; 
    }
    int calc( int val , int dK ) { 
        
        while( dK > 0 ) {
            val = count_ones( val ) ; 
            dK-- ; 
        }
        if( val == 1 ) {
            return 1 ; 
        } else {
            return 0 ; 
        }
    }
    void init( ) { 

        f.assign( M + 1 , vector<int>( K + 1 , 0 )) ; 
        for( int val = M ; val >= 1 ; val-- ) {
            for( int dk = 0 ; dk <= K ; dk++ ) { 
                f[val] [ dk ] = calc ( val , dk ) ; 

                // cout << "" val: "" << val << "" dk: "" << dk << "" ""  << f[val][dk] << ""\n"" ; 
            }
        }
    }
    int n ; 

    // using Key = tuple< int , int , int > ; 
    using Key = int ; 
    vector< int64 > cache ; // < Key , int64 > cache ; 
    int XD = 801 ; 

    int dp( int i , int is_equal , int cnt_ones ) { 

        if( i >= n ) { 
            if( is_equal ) {
                return 0 ; 
            }
            return  f[ cnt_ones ][ K - 1  ]  ; 
        }
        // auto key = make_tuple( i , is_equal , cnt_ones ) ; 
        
        int key = ( i * XD + cnt_ones ) * 2 + is_equal ; 
        

        if( cache[ key ] != -1 ) {
            return cache[ key ] ; 
        }
        auto &ret = cache[ key ] ; 
        ret = 0 ; 

        int d = a[i] ; 
        if( is_equal == 1 ) { 
            
            if( d == 1 ) {
                ret += dp( i + 1 , 0 , cnt_ones ) ; 
                ret += dp( i + 1 , 1 , cnt_ones + 1 ) ; 
            }
            else { 
                ret += dp( i + 1 , 1 , cnt_ones ) ; 
            }
        } else { 
            ret += dp( i + 1 , 0 , cnt_ones ) ; 
            ret += dp( i + 1 , 0 , cnt_ones + 1 ) ; 
        }
        ret %= MOD ; 
        return ret ; 
    }
    int solve( ) { 
        init( ) ; 
        
        auto ans = dp( 0 ,  1 , 0 ) ; 
        return ans ; 
    }
    int countKReducibleNumbers(string s, int k) {
        
        n = s.size() ; 

        XD = n + 2 ; 
        cache.assign( XD * XD * 3 + 10  , -1 ) ; 

        K = k ; 
        
        a.assign( n , 0 ) ; 
        for( int i = 0 ; i < n ; i++ ) {
            a[i] = int( s[i] ) - int( '0' ) ; 
        }
        return solve() ; 
    }
};



int main22( )  { 
    Solution  t; 

    vector<int> a ;
    string s ; 
    int k ; 

    s = ""111"" ; 
    k = 1 ; 

    s = ""1000"" ; 
    k = 2 ; 
    

    // s = ""1"" ; 
    // k = 3 ; 

    s = ""100"" ; 
    k = 1 ; 

    auto ans = t.countKReducibleNumbers (  s , k ) ; 
    cout << ans << ""\n"" ;


    return 0 ; 
}
",1448304045
luck,papaya,484,3646,cpp,"#include <bits/stdc++.h>
using namespace std ; 
using int64 = long long ; 

const int64 MOD = 1e9 + 7 ; 

class Tongji_Cnt_Of_Diff_Subsequence { 

private:
    int n , M ; 
    vector< pair< int64 , int64 > > f ; 

    int64 global_ans ; 
    vector<int> a ; 

public:
    /*
    tM 是不同字符的个数，一般如果是小写字母， tM=26
    返回本质不同的子序列的个数
    */

 
    int64 tongji_cnt_of_diff_subsequence(  vector<int> &a  ) {  
       
        n = a.size() ; 

        int base = 10 ; 
        f.assign( 1e5 + 100  , make_pair( -1 , -1 ) ) ; 
        
        int64 global_ans = 0 ; 
        for( int i = n - 1 ; i >= 0 ; i-- ) { 
            int64 val = a[i] ; 
            int64 cnt = 1 ; 
            int64 sum = val  ; 

            for(int delta : { -1 , 1 } ) {
                int key = val + delta ; 
                
                key += base ; 
                if( f[key].first != -1  ) {
                    auto [cnt2 , sum2 ] = f[key] ;

                    cnt += cnt2 ; 

                    sum += ( val  ) * cnt2  ; 
                    sum += sum2 ; 
                    sum %= MOD ; 
                }
            }
            global_ans = ( global_ans + sum ) % MOD ; 

            int key2 = val + base ; 
            auto &p = f[key2] ; 

            if( p.first == -1 ) { 
                p = make_pair( cnt , sum ) ; 
            }
            else {
                p.first = ( p.first + cnt ) % MOD ; 
                p.second = ( p.second + sum ) % MOD ;
            }
        }
       
        return global_ans %MOD  ; 
    }
} ; 

class Solution {
public:
    Tongji_Cnt_Of_Diff_Subsequence t ; 

    int sumOfGoodSubsequences(vector<int>& a ) {
        auto ans = t.tongji_cnt_of_diff_subsequence( a ) ; 
        return ans ; 
    }
};



int ma33in( )  { 
    Solution  t; 

    vector<int> a ;

    a = { 1 , 2 , 1 } ; 
    
    a = { 3 , 4 , 5 } ; 

    a = { 6 , 7 , 7 } ; 
    
    a = { 0 , 1 } ; 

    auto ans = t.sumOfGoodSubsequences ( a ) ; 
    cout << ans << ""\n"" ;


    return 0 ; 
}
",1448261191
10akshat02,10akshat02,487,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        for i in range(0, n-2*k+1):
            flag = True
            for j in range(i+1, i+k):
                if nums[j] <= nums[j-1]:
                    flag = False
                    break

            for j in range(i+k+1, i+2*k):
                if nums[j] <= nums[j-1]:
                    flag = False
                    break
            if flag:
                return True

        return False
                    
        ",1448190988
10akshat02,10akshat02,487,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        pre = [1]
        for i in range(n-2, -1, -1):
            if nums[i] < nums[i+1]:
                pre.append(pre[-1] + 1)
            else:
                pre.append(1)
        pre.reverse()
        
        post = [1]
        for i in range(1, n):
            if nums[i] > nums[i-1]:
                post.append(post[-1] + 1)
            else:
                post.append(1)

        res = []
        for i in range(n-1):
            res.append(min(post[i], pre[i+1]))

        return max(res)",1448210149
10akshat02,10akshat02,487,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:

        preComp = defaultdict(int)
        for i in range(1, 800):
            count = i.bit_count()
            preComp[i] = preComp[count] + 1
        
        n = len(s)
        dp = [[[-1 for i in range(n+1)] for j in range(2)] for k in range(n)]
        
        def state(i, fix, count):
            if i == n:
                if count == 0 or fix: return 0
                return 1 if preComp[count] <= k else 0

            if dp[i][fix][count] != -1:
                return dp[i][fix][count]

            _count = 0
            if fix:
                if s[i] == ""1"":
                    _count += state(i+1, 1, count+1) + state(i+1, 0, count)
                else:
                    _count += state(i+1, 1, count)
            else:
                _count += state(i+1, 0, count+1) + state(i+1, 0, count)

            dp[i][fix][count] = _count
            return _count

        return state(0, 1, 0) % (10**9 + 7)
        ",1448306327
10akshat02,10akshat02,487,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:

        dp = defaultdict(int)
        _sum = defaultdict(int)
        res = 0

        for num in nums:
            low, high = num - 1, num + 1
            count, sum = 1, num
            if low in dp:
                count += dp[low]
                sum += _sum[low] + num*dp[low]
            if high in dp:
                count += dp[high]
                sum += _sum[high] + num*dp[high]

            dp[num] += count
            _sum[num] += sum

            res += sum

        return res % (10**9 + 7)",1448239972
RC137,RC137,488,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        inc = [1] * n

        for i,x in enumerate(nums):
            if i == 0:
                continue

            if x > nums[i-1]:
                inc[i] = 1 + inc[i-1]


        for i in range(n-k):
            if inc[i] >= k and inc[i+k] >= k:
                return True 

        return False",1448193449
RC137,RC137,488,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        inc = [1] * n

        for i,x in enumerate(nums):
            if i == 0:
                continue

            if x > nums[i-1]:
                inc[i] = 1 + inc[i-1]

        ans = 1
        # print(inc)
        for i in range(n):
            r = inc[i]
            if r <= ans:
                continue

            j = i+r
            if j >= n:
                j = n-1

            if inc[j] >= inc[i]:
                ans = max(ans, min(inc[i], inc[j], j-i))
            print(i, ans)

            j = i-r
            if j <= 0:
                j = 0

            if inc[j] >= inc[i]:
                ans = max(ans, min(inc[i], inc[j], i-j))
            
        return ans
                
            
            ",1448191058
RC137,RC137,488,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        def count_bits(n):
            i = 1
            res = 0
            while n:
                if n & 1:
                    res += 1

                n >>= 1
            
            return res
                    
        @cache
        def ops(n):
            if n == 1:
                return 0

            return 1 + ops(count_bits(n))

        length = len(s)
        mod = 10**9+7

        valid_bits = {bits for bits in range(1,length+1) if ops(bits) < k}

        # count # of pos integers <= int(s) with exactly $bits set bits
        @cache
        def dp(i, count, prefix):
            # end case
            if i == length:
                return int(count in valid_bits)

            # tup = (i, count, prefix)
            # if tup in memo:
            #     return memo[tup]

            # select 0
            zero = dp(i+1, count, prefix and s[i] == '0')
            
            # select 1
            one = 0
            if not prefix or s[i] == '1':
                one = dp(i+1, count+1, prefix and s[i] == '1')

            # memo[tup] = (zero+one) % mod
            # return memo[tup]
            return (zero+one) % mod

        ans = 0
        
        # b is number of 1s in the number
        # for b in range(1, length+1):
        #     if ops(b) >= k: 
        #         continue

        # print(b, dp(b, 0, 0, True))
        ans += dp(0, 0, True)
        # memo = {}

        c = s.count('1')
        if ops(c) < k:
            ans -= 1

        return ans % mod
    
        ",1448285775
RC137,RC137,488,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        mod = 10**9+7
        n = len(nums)

        ans = 0

        dp = defaultdict(int)
        total = defaultdict(int)
        for x in nums:
            dp[x] += x*(1+total[x-1]+total[x+1]) + dp[x-1] + dp[x+1]
            total[x] += 1+total[x-1]+total[x+1]
            
            dp[x] %= mod
            total[x] %= mod
        
        return sum(dp.values()) % mod",1448307480
HumbleRobo,HumbleRobo,489,3612,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        prefix = [0] * n
        postfix = [0] * n
        prefix[0] = 1
        for i in range(1, n):
            if nums[i]>nums[i-1]:
                prefix[i] = prefix[i-1]+1
            else:
                prefix[i] = 1
        postfix[n-1] = 1
        for i in range(n-2, -1, -1):
            if nums[i]<nums[i+1]:
                postfix[i] = postfix[i+1]+1
            else:
                postfix[i] = 1
        ans = 1
        for i in range(1, n):
            ans = max(ans, min(prefix[i-1], postfix[i]))
        # print(prefix)
        # print(postfix)
        return ans
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        return self.maxIncreasingSubarrays(nums) >= k",1448231444
HumbleRobo,HumbleRobo,489,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        prefix = [0] * n
        postfix = [0] * n
        prefix[0] = 1
        for i in range(1, n):
            if nums[i]>nums[i-1]:
                prefix[i] = prefix[i-1]+1
            else:
                prefix[i] = 1
        postfix[n-1] = 1
        for i in range(n-2, -1, -1):
            if nums[i]<nums[i+1]:
                postfix[i] = postfix[i+1]+1
            else:
                postfix[i] = 1
        ans = 1
        for i in range(1, n):
            ans = max(ans, min(prefix[i-1], postfix[i]))
        # print(prefix)
        # print(postfix)
        return ans",1448194289
HumbleRobo,HumbleRobo,489,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        def bits(n):
            ret = 0
            while n:
                ret += n&1
                n >>= 1
            return ret
        mod = 10**9 + 7
        limit = len(s)+1
        reducible = [0] * (limit)
        reducible[0] = float('inf')
        for i in range(2, limit):
            reducible[i] = reducible[bits(i)] + 1
        # print(max(reducible))

        n = len(s)
        # dp[prefix][ones][upperbounded]
        dp = [[[0]*2 for j in range(limit)] for i in range(n+1)]
        dp[0][0][1] = 1
        
        for i in range(1, n+1):
            if s[i-1] == '1':
                for j in range(limit-1, -1, -1):
                    if j-1>=0:
                        # choose 1
                        dp[i][j][1] += dp[i-1][j-1][1]
                        dp[i][j][0] += dp[i-1][j-1][0]
                    # choose 0
                    dp[i][j][0] += dp[i-1][j][1]
                    dp[i][j][0] += dp[i-1][j][0]
                    
                    dp[i][j][0] %= mod
                    dp[i][j][1] %= mod
            else:
                for j in range(limit-1, -1, -1):
                    if j-1>=0:
                        # choose 1
                        dp[i][j][0] += dp[i-1][j-1][0]
                    # choose 0
                    dp[i][j][1] += dp[i-1][j][1]
                    dp[i][j][0] += dp[i-1][j][0]
                    
                    dp[i][j][0] %= mod
                    dp[i][j][1] %= mod

        ones = sum(c=='1' for c in s)
        dp[n][ones][1] -= 1
        
        ans = 0
        for i in range(1, limit):
            if reducible[i] < k:
                ans += dp[n][i][0]
                ans += dp[n][i][1]
                ans %= mod
                # print(f'{i,0}: {dp[n][i][0]}')
                # print(f'{i,1}: {dp[n][i][1]}')
        return ans",1448307561
HumbleRobo,HumbleRobo,489,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        n = len(nums)
        count = defaultdict(int)
        curr_sum = defaultdict(int)
        ans = 0
        mod = 10**9 + 7
        for i in nums:
            if i+1 in count:
                ans += curr_sum[i+1] + i * count[i+1]
                curr_sum[i] += curr_sum[i+1] + i * count[i+1]
                count[i] += count[i+1]
            if i-1 in count:
                ans += curr_sum[i-1] + i * count[i-1]
                curr_sum[i] += curr_sum[i-1] + i * count[i-1]
                count[i] += count[i-1]
            ans += i
            curr_sum[i] += i
            count[i] += 1
            ans %= mod
        return ans",1448228363
Eugene Chereshnev,echeresh,490,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        def has(k):
            if k == 1: return True
            i = 0
            while i <= n - 2 * k:
                ok = True
                for j in range(1, k):
                    if nums[i + j] <= nums[i + j - 1] or nums[i + j + k] <= nums[i + j + k - 1]:
                        ok = False
                        i = i + j
                        break
                if ok: return True
            return False
        return has(k)",1448231396
Eugene Chereshnev,echeresh,490,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        def has(k):
            if k == 1: return True
            i = 0
            while i <= n - 2 * k:
                ok = True
                for j in range(1, k):
                    if nums[i + j] <= nums[i + j - 1] or nums[i + j + k] <= nums[i + j + k - 1]:
                        ok = False
                        i = i + j
                        break
                if ok: return True
            return False
        l, r = 1, n
        while l < r:
            m = (l + r + 1) // 2
            if has(m):
                l = m
            else:
                r = m - 1
        return l",1448231813
Eugene Chereshnev,echeresh,490,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        M = 10**9 + 7
        L = len(s)
        @functools.cache
        def count_full(n, bits):
            if n == 0: return 1 if bits == 0 else 0
            if n < bits: return 0
            res = count_full(n - 1, bits)
            if bits > 0:
                res = (res + count_full(n - 1, bits - 1)) % M
            return res
        @functools.cache
        def count(idx, bits):
            if idx == L: return 0 if bits != 0 else 1
            if L - idx < bits: return 0
            if s[idx] == '0': return count(idx + 1, bits)
            res = count_full(L - idx - 1, bits)
            if bits > 0:
                res = (res + count(idx + 1, bits - 1)) % M
            return res 
        def steps(value):
            if value <= 1: return 0
            return 1 + steps(value.bit_count())
        r = [steps(i) for i in range(L)]
        s_bits = sum(c == '1' for c in s)
        res = 0
        for i in range(1, L):
            if r[i] >= k: continue
            cnt = count(0, i)
            if i == s_bits:
                cnt -= 1
            res = (res + cnt) % M
        return res",1448308710
Eugene Chereshnev,echeresh,490,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        M = 10**9 + 7
        n = len(nums)
        cnt = collections.defaultdict(int)
        S = collections.defaultdict(int)
        for i in range(n - 1, -1, -1):
            v = nums[i]
            S[v] = (S[v] + v) % M
            cnt[v] = (cnt[v] + 1) % M
            for nxt in (v - 1, v + 1):
                S[v] = (S[v] + cnt[nxt] * v + S[nxt]) % M
                cnt[v] = (cnt[v] + cnt[nxt]) % M
        return sum(S.values()) % M
        ",1448256468
李霁,4irmelt,491,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        for a in range(n - (k << 1) + 1):
            if all(nums[i] > nums[i - 1] for i in range(a + 1, a + k)) and all(nums[i] > nums[i - 1] for i in range(a + k + 1 , a + (k << 1))):
                return True
        return False",1448188206
李霁,4irmelt,491,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        if n < 2:
            return 0
        pre = [0] * n
        pre[n - 1] = 1
        for i in range(n - 2, -1, -1):
            if nums[i] < nums[i + 1]:
                pre[i] = pre[i + 1] + 1
            else:
                pre[i] = 1
        left, right = 1, n >> 1
        r = 0
        while left <= right:
            mid = (left + right) // 2
            found = False
            for i in range(n - 2 * mid + 1):
                if pre[i] >= mid and pre[i + mid] >= mid:
                    found = True
                    break
            if found:
                r = mid
                left = mid + 1
            else:
                right = mid - 1
        return r
",1448205189
李霁,4irmelt,491,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        MOD = 10 ** 9 + 7
        bits = [int(c) for c in s]
        n = len(bits)
        m = n * 2
        c = {}
        def helper(h):
            if h in c:
                return c[h]
            if h == 0:
                c[h] = inf
            elif h == 1:
                c[h] = 0
            else:
                c[h] = 1 + helper(bin(h).count('1'))
            return c[h]
        for h in range(1, m + 1):
            helper(h)
        st = set()
        for h in range(1, m + 1):
            if c[h] <= k - 1:
                st.add(h)
        if not st:
            return 0
        @lru_cache(None)
        def dp(pos, cnt, flag):
            if pos == n:
                if cnt == 0:
                    return 0
                if cnt in st and not flag:
                    return 1
                else:
                    return 0
            r = 0
            limit = bits[pos] if flag else 1
            for digit in range(0, limit + 1):
                nxt = cnt + digit
                if flag and digit < limit:
                    tight_new = False
                else:
                    tight_new = flag and (digit == limit)
                r = (r + dp(pos + 1, nxt, tight_new)) % MOD
            return r
        return dp(0, 0, True) % MOD",1448295729
李霁,4irmelt,491,3646,python3,"# class Solution:
#     def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        # 1 n
        # 1 + 2 + 2 + 2 + 1 2 * (n - 1)
        # 1 + 2 + 3 + 2 + 1 3 * (n - 2)
        # 2 * (n - 1)
        # 3 * (n - 2)
        # n
        # [1] [2] [3] [4] [5]
        # [1, 2] [2, 3] [3, 4] [4, 5]
        # [1, 2, 3] [2, 3, 4] [3, 4, 5]
        # [1, 2, 3, 4] [2, 3, 4, 5]
        # [1, 2, 3, 4, 5]
        # 5, 8, 9, 8, 5
        # 4 6 6 4
        # 3 4 3
        # 2 2
        # 1
        # [1]
        # [2, 2]
        # [1, 2, 2] + [2, 2, 1]
        # [4, 4 * 3 / 2, 4 * 3 / 2, 4] C41 C42 C42 C43
        # [1, 2, 2, 1]
        # 4, 12, 18, 16
class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        MOD = 10 ** 9 + 7
        c = defaultdict(int)  
        pre = defaultdict(int)
        r = 0
        for x in nums:
            cur = 1
            nxt = x
            if x - 1 in c:
                cur = (cur + c[x - 1]) % MOD
                nxt = (nxt + pre[x - 1] + c[x - 1] * x) % MOD
            if x + 1 in c:
                cur = (cur + c[x + 1]) % MOD
                nxt = (nxt + pre[x + 1] + c[x + 1] * x) % MOD
            c[x] = (c[x] + cur) % MOD
            pre[x] = (pre[x] + nxt) % MOD
            r = (r + nxt) % MOD
        return (r % MOD)",1448282142
Xu Cao,yurikaka,492,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> start(n), end(n);
        end[0] = 1;
        for (int i = 1; i < n; ++i) {
            if (nums[i] > nums[i-1])
                end[i] = end[i-1]+1;
            else
                end[i] = 1;
        }
        start.back() = 1;
        for (int i = n-2; i >= 0; --i) {
            if (nums[i] < nums[i+1])
                start[i] = start[i+1]+1;
            else
                start[i] = 1;
        }
        for (int i = 1; i < n; ++i)
            if (end[i-1] >= k && start[i] >= k)
                return true;
        return false;
    }
};",1448183722
Xu Cao,yurikaka,492,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> start(n), end(n);
        end[0] = 1;
        for (int i = 1; i < n; ++i) {
            if (nums[i] > nums[i-1])
                end[i] = end[i-1]+1;
            else
                end[i] = 1;
        }
        start.back() = 1;
        for (int i = n-2; i >= 0; --i) {
            if (nums[i] < nums[i+1])
                start[i] = start[i+1]+1;
            else
                start[i] = 1;
        }
        int ans;
        for (int i = 1; i < n; ++i)
            ans = max(ans, min(start[i], end[i-1]));
        return ans;
    }
};",1448185315
Xu Cao,yurikaka,492,3631,cpp,"class Solution {
public:
    unordered_set<int> x;
    int countKReducibleNumbers(string s, int k) {
        if (s == ""0"")
            return 0;
        x.clear();
        x.insert(1);
        for (int y = 0; y < k-1; ++y) {
            unordered_set<int> xx = x;
            for (int i = 1; i <= 800; ++i) {
                if (x.contains(i))
                    continue;
                int cnt = 0;
                int ii = i;
                while (ii != 0) {
                    ii = (ii & (ii - 1));
                    ++cnt;
                }
                if (xx.contains(cnt))
                    x.insert(i);
            }
        }
        vector<vector<long long>> cc(801, vector<long long>(801, -1));
        return go(s, 0, 0, cc) % 1000000007;
    }

    long long go(string& s, int i, int cur,  vector<vector<long long>>& cc) {
        if (i >= s.size())
            return 0;
        if (s[i] == '0')
            return go(s, i + 1, cur, cc);
        long long ans = 0;
        for (int ii = s.size() - i - 1; ii >= 0 ; --ii) {
            if (!x.contains(cur + ii))
                continue;
            ans += c(s.size() - i - 1, ii, cc);
            ans %= 1000000007;
        }
        ans += go(s, i + 1, cur + 1, cc);
        ans %= 1000000007;
        return ans;
    }

    long long c(long long a, long long b,  vector<vector<long long>>& cc) {
        if (cc[a][b] != -1) return cc[a][b];
        if (a == b || b == 0)return 1;
        long long ans = c(a-1, b,cc) + c(a-1, b-1, cc);
        ans %= 1000000007;
        cc[a][b] = ans;
        return ans;
        vector<long long> dp(b+1);
        for (long long i = 0; i <= a; ++i)
            for (long long j = min(i,b); j >= 0; --j)
                if (i ==j || j == 0) dp[j] = 1;
        else dp[j] = (dp[j] + dp[j-1]) % 1000000007;
        cc[a][b] = dp[b];
        return dp[b];
    }
};",1448302869
Xu Cao,yurikaka,492,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        long long ans = 0;
        vector<long long> sum(100005), cnt(100005);
        for (long long i: nums) {
            long long x = 1;
            long long y = i;
            if (i > 0) {
                x += cnt[i-1];
                y += sum[i-1] + cnt[i-1]*i;
                y %= 1000000007;
            }
            x += cnt[i+1];
            y += sum[i+1] + cnt[i+1]*i;
            y %= 1000000007;
            sum[i] += y;
            sum[i] %= 1000000007;
            cnt[i] += x;
            cnt[i] %= 1000000007;
            ans += y;
            ans %= 1000000007;
        }
        return ans;
    }
};",1448208118
Anurag Srivastava,invincible_0,493,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n=nums.size();
        int lst=-100000,cnt=0;
        for(int i=0;i<n;i++){
            if(nums[i]>lst){
                cnt++;
            }
            else{
                cnt=1;
            }
            if(cnt>=k){
                int lst2=-100000,cnt2=0;
                for(int j=i+1;j<n;j++){
                    if(nums[j]>lst2){
                        cnt2++;
                    }
                    else
                        break;
                    lst2=nums[j];
                }
                if(cnt2>=k){
                    
                    return true;
                }
            }
            lst=nums[i];
        }
        return false;
    }
};",1448194455
Anurag Srivastava,invincible_0,493,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n=nums.size();
        int k=1,lst=INT_MIN,cnt=0;
        vector<int> dp(n,1);
        for(int i=0;i<n;i++){
            if(nums[i]>lst){
                cnt++;
            }
            else{
                cnt=1;
            }
            lst=nums[i];
            dp[i]=cnt;
            k=max(k,dp[i]/2);
            if(i-dp[i]>=0)
                k=max(k,min(dp[i],dp[i-dp[i]]));
        }
        return k;
    }
};",1448199460
Anurag Srivastava,invincible_0,493,3631,cpp,"bool f=false;
const int N=805,mod=1e9 +7;
vector<long long> fact(N,1),invfact(N,1),dp(N,0);

class Solution {
public:
    
    long long exp(long long x, long long n, long long m = mod) {
        long long r = 1;
        while(n) {
            if(n & 1LL) r = r * x % m;
            x = x * x % m, n >>= 1LL;
        }
        return r;
    }
    
    long long ncr(int n,int r){
        if(n<r)
            return 0;
        long long ans = (fact[n]*1LL*invfact[r])%mod;
        ans = (ans * 1LL* invfact[n-r])%mod;
        return ans;
    }
    
    int countKReducibleNumbers(string s, int k) {
        int n=s.size();
        if(f==false){
            for(int i=2;i<N;i++){
                dp[i]=dp[__builtin_popcount(i)]+1;
            }
            dp[0]=100000;
            for(int i=2;i<N;i++){
                fact[i]=(fact[i-1]*1LL*i)%mod;
            }
            invfact[N-1]=exp(fact[N-1],mod-2);
            for(int i=N-2;i>=2;i--){
                invfact[i]=(invfact[i+1]*1LL*(i+1))%mod;
            }
            f=true;
        }
        long long cnt=0,rem=0;
        long long cnt2=0;
        long long ans = 0;
        for(int i=0;i<n;i++){
            if(s[i]=='0')
                continue;
            rem=n-i-1;
            for(int j=0;j<=rem;j++){
                cnt2=ncr(rem,j);
                if(dp[j+cnt]+1<=k){
                    ans=(ans + cnt2)%mod;
                }
            }
            cnt++;
        }
        return (int)(ans);
    }
};",1448297201
Anurag Srivastava,invincible_0,493,3646,cpp,"const int mod=1e9 +7;
vector<long long> dp(100005,0),cnt(100005,0);

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int n=nums.size();
        long long ans=0,temp;
        for(int i=0;i<n;i++){
            nums[i]++;
            temp = ((nums[i]-1)*1LL*(cnt[nums[i]-1]+cnt[nums[i]+1]))%mod;
            temp = (temp + dp[nums[i]-1] + dp[nums[i]+1])%mod;
            temp = (temp + nums[i]-1)%mod;
            cnt[nums[i]]=(cnt[nums[i]] + 1 + cnt[nums[i]-1] + cnt[nums[i]+1])%mod;
            dp[nums[i]] = (temp + dp[nums[i]])%mod;
            ans = (ans + temp)%mod;
        }
        for(int i=0;i<n;i++){
            dp[nums[i]]=0;
            cnt[nums[i]]=0;
        }
        return (int)(ans);
    }
};",1448221591
Sukhbat Amartugs,syhee,494,3612,java,"class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        int n = nums.size();
        for(int i=0; i<n; i++){
            if(i+k+k <= n){
                boolean valid = true;
                for(int j=i+1; j<i+k; j++){
                    if(nums.get(j) <= nums.get(j-1)) {
                        valid=false;
                        break;
                    }
                }
                if(valid){
                    for(int j=i+k+1; j<i+k+k; j++){
                        if(nums.get(j) <= nums.get(j-1)) {
                            valid=false;
                            break;
                        }
                    }
                    if(valid) return true;
                }
            }
        }
        return false;
    }
}",1448187376
Sukhbat Amartugs,syhee,494,3619,java,"class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        int n = nums.size();
        List<Integer> batch = new ArrayList<>();
        int cnt = 1;
        for(int i=1; i<n; i++){
            if(nums.get(i) > nums.get(i-1)) cnt++;
            else {
                batch.add(cnt);
                // System.out.print(cnt+"", "");
                cnt = 1;
            }
        }
        batch.add(cnt);
        // System.out.print(cnt+"", "");
        int max = Math.max(batch.get(0)/2, 1);
        for(int i=1; i<batch.size(); i++){
            max = Math.max(batch.get(i)/2, max);
            max = Math.max( 
                max, 
                Math.min( batch.get(i-1), batch.get(i) )
            );
        }
        return max;
    }
}",1448208001
Sukhbat Amartugs,syhee,494,3631,java,"class Solution {
    public int mod = (int) 1e9+7;
    public int countKReducibleNumbers(String s, int k) {
        boolean[] arr= new boolean[801];
        for(int i=1; i<=800; i++){
            arr[i] = reducable(i,k-1,0);
        }
        System.out.println(reducable(4,1,0));
        int MAX_N = 800;
        long[][] C = new long[MAX_N + 1][MAX_N + 1];
        
        for (int n = 0; n <= MAX_N; n++) {
            C[n][0] = 1;  // C(n, 0) is 1 for all n
            C[n][n] = 1;  // C(n, n) is 1 for all n
        }

        for (int n = 1; n <= MAX_N; n++) {
            for (int t = 1; t < n; t++) {
                C[n][t] = (C[n - 1][t - 1] + C[n - 1][t])%mod;
            }
        }
        
        int len = s.length();
        int secOne = 1+s.substring(1).indexOf(""1"");
        long sum = 0L;
        for(int i=1; i<800;i++){
            // System.out.println(arr[i]);
            if(arr[i]==false) continue;
            sum = (sum+ C[len-1][i])%mod;
            int oneCount = 1;
            for(int j=1; j<len;j++){
                if(s.charAt(j) == '1'){
                    if(i-oneCount >= 0){
                        sum = (sum + C[len-j-1][i-oneCount])%mod;
                    }
                    oneCount++;
                }
            }
        }
        return (int)(sum%mod);
    }

    public boolean reducable(int n, int k, int cur){
        if(n == 1) return true;
        if(cur >= k) return false;
        int sum = 0;
        // int bit = 1;
        while(n > 0){
            sum += (n%2);
            n /=2;
        }
        return reducable(sum, k, cur+1);
    }
}",1448311042
Sukhbat Amartugs,syhee,494,3646,java,"class Solution {
    public final static int mod = (int) 1e9+7;
    public int sumOfGoodSubsequences(int[] nums) {
        int n = nums.length;
        // long[][] dp = new long[100002][2];
        //1->tusgultei subsequence iin sum, 2->count;
        // dp[nums[0]][0] = nums[0];
        // dp[nums[0]][1] = 1;
        Map<Integer, Long> map = new HashMap<>();
        Map<Integer, Long> cnt = new HashMap<>();
        long sum = nums[0];
        map.put(nums[0], (long) nums[0]);
        cnt.put(nums[0], 1L);
        for(int i=1; i<n; i++){
            // long prev = dp[nums[i]][0];
            long prev = map.getOrDefault(nums[i], 0L);
            long cur = 0L;
            // dp[nums[i]][1] += 1L;
            // dp[nums[i]][1] = (dp[nums[i]][1] + dp[nums[i]+1][1])%mod; 
            // if(nums[i]-1 >= 0) dp[nums[i]][1] =(dp[nums[i]][1] + dp[nums[i]-1][1])%mod;
            long curcnt = (cnt.getOrDefault(nums[i]-1,0L) + cnt.getOrDefault(nums[i]+1,0L)+1L)%mod;
            cnt.put(nums[i], cnt.getOrDefault(nums[i], 0L) + curcnt);
            // dp[nums[i]][0] = (dp[nums[i]][0] + (long) nums[i])%mod;
            // dp[nums[i]][0] = (dp[nums[i]][0] + (dp[nums[i]+1][1]*nums[i]%mod + dp[nums[i]+1][0] )%mod)%mod;
            // if(nums[i]-1 >= 0) 
            //     dp[nums[i]][0] = (dp[nums[i]][0] + (dp[nums[i]-1][1]*nums[i]%mod + dp[nums[i]-1][0])%mod)%mod;
            // cur = (cur + nums[i])%mod;
            cur = (cur + curcnt*nums[i]%mod)%mod;
            cur = (cur+map.getOrDefault(nums[i]-1, 0L) + map.getOrDefault(nums[i]+1,0L))%mod;
            map.put(nums[i], (map.getOrDefault(nums[i],0L) + cur)%mod);
            sum = (sum + cur)%mod;
        }
        // System.out.println(dp[10][0] + "" "" + dp[10][1]);
        // System.out.println(dp[1][0] + "" "" + dp[1][1]);
        // System.out.println(dp[9][0] + "" "" + dp[9][1]);
        return (int)(sum%mod);
    }
}",1448281749
saijaswanth25,saijaswanth25,495,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& a, int k) {
        int n=a.size();
        vector<int> mx(n,1);
        for(int i=n-2;i>=0;i--){
            if(a[i+1]>a[i])
            mx[i]=mx[i+1]+1;
        }
        int l=k,h=k;
        while(l<=h){
            int m=l+(h-l)/2;
            int ok=0;
            for(int i=0;i+2*m<=n;i++){
                if(mx[i]>=m && mx[i+m]>=m){
                    ok=1;
                    break;
                }
            }
            if(ok)
                l=m+1;
            else
                h=m-1;
        }
        return h==k;
    }
};",1448304093
saijaswanth25,saijaswanth25,495,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& a) {
        int n=a.size();
        vector<int> mx(n,1);
        for(int i=n-2;i>=0;i--){
            if(a[i+1]>a[i])
            mx[i]=mx[i+1]+1;
        }
        int l=1,h=n/2;
        while(l<=h){
            int m=l+(h-l)/2;
            int ok=0;
            for(int i=0;i+2*m<=n;i++){
                if(mx[i]>=m && mx[i+m]>=m){
                    ok=1;
                    break;
                }
            }
            if(ok)
                l=m+1;
            else
                h=m-1;
        }
        return h;
    }
};",1448302698
saijaswanth25,saijaswanth25,495,3631,cpp,"class Solution {
public:
    const int m=1e9+7;
#define ll long long
ll dp2[805][805][2];
    int fx2(int i,int j,int k,string &s){
        if(j==s.size()){
            if(i==0)
                return 1-k;
            return 0;
        }
        if(dp2[i][j][k]!=-1)
            return dp2[i][j][k];
        ll ans=0;
        if(!k){
            if(i)
                ans+=fx2(i-1,j+1,0,s),ans%=m;
            ans+=fx2(i,j+1,0,s),ans%=m;
            
        }
        else{
            if(s[j]=='1'){
                if(i)
                ans+=fx2(i-1,j+1,1,s),ans%=m;
                ans+=fx2(i,j+1,0,s),ans%=m;
            }
            else{
                ans+=fx2(i,j+1,1,s);
                ans%=m;
            }
        }
        return dp2[i][j][k]=ans;
    }
    int fx(int i,int j,vector<vector<int>> &dp){
        if(j==0)
            return dp[i][j]=0;
        if(i==1)
            return dp[i][j]=1;
        if(dp[i][j]!=-1)
            return dp[i][j];
        int x=__builtin_popcount(i);
        return dp[i][j]=fx(x,j-1,dp);
    }
    int countKReducibleNumbers(string s, int k) {
        int n=s.size();
        int l=n-1;
        memset(dp2,-1,sizeof(dp2));
        vector<vector<int>> dp(l+5,vector<int> (k+5,-1));
        int ans=0;
        for(int i=1;i<=l;i++){
            fx(i,k,dp);
        }
        for(int i=1;i<=l;i++){
            
            if(dp[i][k]==1){
                ans+=fx2(i,0,1,s);
                ans%=m;
            }
        }
        return ans;
    }
};",1448311334
saijaswanth25,saijaswanth25,495,3646,cpp,"class Solution {
public:
        long long dp[100005];
        long long ct[100005];
    int sumOfGoodSubsequences(vector<int>& nums) {
        long long ans=0,m=1e9+7;
        int n=nums.size();
        for(int i=0;i<n;i++){
            if(nums[i]>0){
                dp[nums[i]]+=dp[nums[i]-1]+(nums[i]*ct[nums[i]-1]);
                ct[nums[i]]+=ct[nums[i]-1];
                ct[nums[i]]%=m;
                
                dp[nums[i]]%=m;
            }
            dp[nums[i]]+=dp[nums[i]+1]+(nums[i]*ct[nums[i]+1])%m;
            ct[nums[i]]+=ct[nums[i]+1];
            ct[nums[i]]%=m;
            
            dp[nums[i]]%=m;
            dp[nums[i]]+=nums[i];
            dp[nums[i]]%=m;
            ct[nums[i]]++;
        }
        for(long long i=0;i<=100000;i++)
        {
            // cout<<dp[i]<<"" "";
            ans+=(dp[i]),ans%=m;
        }
        return ans;
    }
};",1448295853
maivankien,maivankien,498,3612,python3,"class Solution:
    def isStrictlyIncreasing(self, nums: List[int], start: int, k: int):
        for i in range(start, start + k - 1):
            if nums[i] >= nums[i + 1]:
                return False

        return True
        
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        for index in range(n - 2 * k + 1):
            if self.isStrictlyIncreasing(nums, index, k) and self.isStrictlyIncreasing(nums, index + k, k):
                return True

        return False
            ",1448192266
maivankien,maivankien,498,3619,python3,"class Solution:
    def checkAdjacentSubarrays(self, nums: List[int], k: int):
        n = len(nums)
        inc = [1] * n

        for i in range(1, n):
            if nums[i] > nums[i - 1]:
                inc[i] = inc[i - 1] + 1

        for i in range(n - 2 * k + 1):
            if inc[i + k - 1] >= k and inc[i + 2 * k - 1] >= k:
                return True

        return False
    
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        result = 0
        n = len(nums)
        left, right = 1, n // 2

        while left <= right:
            mid = (left + right) // 2

            if self.checkAdjacentSubarrays(nums, mid):
                result = mid
                left = mid + 1

            else:
                right = mid - 1

        return result

        ",1448208468
maivankien,maivankien,498,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        MOD = 10 ** 9 + 7
        n = s
        max_len = len(n)

        # Precompute popcount(s) for s in [1, max_len * 2]
        popcount = [0] * (max_len * 2 + 2)
        for i in range(1, max_len * 2 + 2):
            popcount[i] = bin(i).count('1')

        # Precompute f(s) for s in [1, max_len * 2]
        f = [-1] * (max_len * 2 + 2)

        def compute_f(s):
            if s == 0:
                return -1  # Not a valid sum
            if s == 1:
                return 0
            if f[s] != -1:
                return f[s]
            f[s] = compute_f(popcount[s]) + 1
            return f[s]

        for s_val in range(1, max_len * 2 + 2):
            compute_f(s_val)

        valid_sums = []
        for s_val in range(1, max_len * 2 + 2):
            if compute_f(s_val) <= k - 1:
                valid_sums.append(s_val)

        from functools import lru_cache

        @lru_cache(maxsize=None)
        def dp(pos, tight, sum_so_far, leading_zero):
            if pos == len(n):
                if sum_so_far in valid_sums and not leading_zero:
                    if tight:
                        return 0  # Exclude n itself
                    else:
                        return 1
                else:
                    return 0
            total = 0
            max_digit = int(n[pos]) if tight else 1
            for digit in range(0, max_digit + 1):
                new_tight = tight and (digit == max_digit)
                new_leading_zero = leading_zero and (digit == 0)
                new_sum = sum_so_far
                if not new_leading_zero:
                    new_sum += digit
                total += dp(pos + 1, new_tight, new_sum, new_leading_zero)
            return total % MOD

        ans = dp(0, True, 0, True)
        if n == '1':
            ans = 0
        return ans % MOD",1448285776
maivankien,maivankien,498,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        cnt = {}
        sum_dict = {}
        MOD = 10**9 + 7
        for x in nums:
            cnt_x_prev = cnt.get(x, 0)
            sum_x_prev = sum_dict.get(x, 0)
    
            cnt_x_new = (cnt_x_prev + 1) % MOD
            sum_x_new = (sum_x_prev + x) % MOD
    
            for delta in [-1, 1]:
                y = x + delta
                cnt_y_prev = cnt.get(y, 0)
                sum_y_prev = sum_dict.get(y, 0)
    
                cnt_x_new = (cnt_x_new + cnt_y_prev) % MOD
                sum_x_new = (sum_x_new + sum_y_prev + cnt_y_prev * x) % MOD
    
            cnt[x] = cnt_x_new
            sum_dict[x] = sum_x_new
    
        total_sum = sum(sum_dict.values()) % MOD
        return total_sum",1448257630
lebron87,lebron87,500,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        dp = [1 for _ in range(len(nums))]
        for i in range(len(nums)-1,-1,-1):
            dp[i] = 1 + (dp[i+1] if i+1 < len(nums) and nums[i] < nums[i+1] else 0)

        for i in range(len(dp)):
            if i+k < len(dp):
                if dp[i] >= k and dp[i+k] >= k:
                    return True
        return False",1448182137
lebron87,lebron87,500,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:

        dp = [1 for _ in range(len(nums))]
        for i in range(len(nums)-1,-1,-1):
            dp[i] = 1 + (dp[i+1] if i+1 < len(nums) and nums[i] < nums[i+1] else 0)

        lo = 1
        hi = len(nums) //2
        
        while(lo < hi):
            med = lo + hi + 1
            med >>=1
            if self.check(dp, med):
                lo = med
            else:
                hi = med-1
        return lo
    def check(self, dp, k):
        
            
        for i in range(len(dp)):
            if i+k < len(dp):
                if dp[i] >= k and dp[i+k] >= k:
                    return True
            else:
                return False
        return False",1448184411
lebron87,lebron87,500,3631,python3,"class Solution:
    def count(self, n):
        ans = 1
        while(n > 1):
            cc = collections.Counter(bin(n)[2:])
            n = cc['1']
            ans += 1
        return ans
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        v = 1
        ans = 0
        mod = 10 ** 9 + 7
        for i in range(len(s)-1,-1,-1):
            if s[i] == '1':
                ans += v
            ans %= mod
            v *= 2
            v %= mod
        ans -=1
        ans %= mod
        mem = {}
        for nsb in range(0, len(s)+1):
            if self.count(nsb) > k:
                #how many integers less then n (s is n in binary form)
                #with set 'nsb' set bits
                ans -= self.dfs(0, True, nsb, s, mem)
                ans %= mod
        return ans

    def dfs(self, i, needstobeless, nsb, s,mem):
        if i == len(s):
            return 1 if ((nsb == 0) and (needstobeless is False)) else 0

        if (i, needstobeless, nsb) in mem:
            return mem[(i, needstobeless, nsb)]
        ans = 0
        mod = (10 ** 9) + 7
        if needstobeless is False:
            if nsb > 0:
                ans += self.dfs(i+1, False, nsb-1 ,s, mem)
                # put a 1 
            ans += self.dfs(i+1 , False, nsb, s, mem)
            # put a 0
            ans %= mod 
        else:
            val = int(s[i])
            if val == 1:
                ans += self.dfs(i+1 , False, nsb, s,mem) # put a 0
                if nsb > 0:
                    ans += self.dfs(i+1 , needstobeless, nsb-1, s, mem) # put a 1
            elif val == 0:
                ans += self.dfs(i+1 , needstobeless, nsb, s, mem) # put a 0
                # cant put a 1
            ans %= mod
        mem[(i, needstobeless, nsb)] = ans
        return ans
            ",1448294213
lebron87,lebron87,500,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        cc = collections.defaultdict(list)
        for i,e in enumerate(nums):
            cc[e].append(i)

        cc = {}
        ans = 0
        mod = 10 ** 9 + 7
        for i in range(len(nums))[::-1]:
            ans += self.dfs(i, nums,cc)[1]
            ans %= mod
        return ans
    def dfs(self, i, nums, cc):

        mod = 10 ** 9 + 7

        count = 1
        sum = nums[i]

        for v in [nums[i]+1, nums[i]-1]:
            if v in cc:
                a,b = cc[v]
                count += a
                sum += a * nums[i]
                sum += b
                
                sum %= mod
                count %= mod
        '''
        for j in range(i+1, len(nums)):
            if abs(nums[j] - nums[i]) == 1:
                a,b = self.dfs(j, nums, cc)
                count +=a
                sum += a * nums[i]
                sum += b
                sum %= mod
                count %= mod
        '''
        if nums[i] not in cc:
            cc[nums[i]] = [count, sum]
        else:
            c,s = cc[nums[i]]
            cc[nums[i]] = [c+count, s + sum]
        
        return (count, sum)
        ",1448238855
powervic08,powervic08,501,3612,java,"class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        for (int i = 0; i <= nums.size() - 2 * k; i++) {
            boolean bad = false;
            for (int j = i; j < i + k - 1; j++) {
                if (nums.get(j + 1) <= nums.get(j)) {
                    bad = true;
                }
            }
            for (int j = i + k; j < i + 2 * k - 1; j++) {
                if (nums.get(j + 1) <= nums.get(j)) {
                    bad = true;
                }
            }
            if (!bad) return true;
        }
        return false;
    }
}",1448185777
powervic08,powervic08,501,3619,java,"class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        ArrayList<Integer> dec = new ArrayList<>();
        dec.add(-1);
        for (int i = 0; i < nums.size() - 1; i++) {
            if (nums.get(i) >= nums.get(i + 1)) {
                dec.add(i);
            }
        }
dec.add(nums.size() - 1);
        int ans = 1;
        for (int i = 0; i < dec.size() - 2; i++) {
            int x = dec.get(i + 1) - dec.get(i);
            int y = dec.get(i + 2) - dec.get(i + 1);
            ans = Math.max(ans, Math.min(x, y));
            ans = Math.max(ans, x / 2);
            ans = Math.max(ans, y / 2);
        }
        for (int i = 0; i < dec.size() - 1; i++) {
            int x = dec.get(i + 1) - dec.get(i);
            ans = Math.max(ans, x / 2);
        }
        return ans;
    }
}",1448197074
powervic08,powervic08,501,3631,java,"class Solution {
    public int countKReducibleNumbers(String s, int a) {
        long[][][] dp = new long[s.length() + 1][2][s.length() + 1];
        long mod = (long) 1e9 + 7;
        dp[0][1][0] = 1;
        for (int i = 0; i < s.length(); i++) {
            for (int j = 0; j < 2; j++) {
                for (int k = 0; k < s.length(); k++) {
                    int ni = i + 1;
                    if (j == 0) {
                        dp[ni][0][k] += dp[i][j][k];
                        dp[ni][0][k + 1] += dp[i][j][k];
                    }
                    else {
                        if (s.charAt(i) == '0') {
                            dp[ni][1][k] += dp[i][j][k];
                        }
                        else {
                            dp[ni][0][k] += dp[i][j][k];
                            dp[ni][1][k + 1] += dp[i][j][k];
                        }
                    }
                    dp[ni][0][k] %= mod;
                    dp[ni][1][k] %= mod;
                    dp[ni][0][k + 1] %= mod;
                    dp[ni][1][k + 1] %= mod;
                }
            }
        }
        a--;
        long[] arr = new long[s.length() + 1];
        long ans = 0;
        for (int i = 1; i <= s.length(); i++) {
            arr[i] = dp[s.length()][0][i] % mod;
            int x = i;
            for (int j = 0; j < a; j++) {
                x = Integer.bitCount(x);
            }
            if (x == 1) ans += arr[i];
            ans %= mod;
        }
        return (int) ans;
        
    }
}",1448268699
powervic08,powervic08,501,3646,cpp,"using namespace std;

class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        long mod = 1e9 + 7;
        pair<long, long> freq[100001] = {};

        for (int i = 1; i <= nums.size(); i++) {
            int num = nums[i - 1];
            if (num + 1 < 100001) {
                freq[num].first = (freq[num].first + freq[num + 1].first + num * freq[num + 1].second % mod) % mod;
                freq[num].second = (freq[num].second + freq[num + 1].second) % mod;
            }
            if (num - 1 >= 0) {
                freq[num].first = (freq[num].first + freq[num - 1].first + num * freq[num - 1].second % mod) % mod;
                freq[num].second = (freq[num].second + freq[num - 1].second) % mod;
            }
            freq[num].first = (freq[num].first + num) % mod;
            freq[num].second = (freq[num].second + 1) % mod;
        }

        long ans = 0;
        for (int i = 0; i < 100001; i++) {
            ans = (ans + freq[i].first) % mod;
        }
        
        return (int) ans;
    }
};",1448242005
lee_218,lee_218,502,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        
        
            n=len(nums)
            
            
            def check(nums):
                
                return all(j-i>0 for i,j in zip(nums[:-1],nums[1:]))
            
            
            for i in range(n):
                
                if i+2*k-1<n and check(nums[i:i+k]) and check(nums[i+k:i+2*k]) :                               
                                return True
            return False",1448192361
lee_218,lee_218,502,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        
        
        n=len(nums)

        bc=[1]*n
        fr=[1]*n


        for i in range(n-2,-1,-1):

            if nums[i]<nums[i+1]:
                bc[i]=bc[i+1]+1

        for i in range(1,n):    
            if nums[i-1]<nums[i]:
                fr[i]=fr[i-1]+1

        res=1
        for i in range(1,n):
            res=max(res,min(bc[i],fr[i-1]))

        return res
        ",1448203502
lee_218,lee_218,502,3631,python3,"class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        
        
        mod=10**9+7
        n=len(s)

        @cache
        def dp(i,j):  
            if i==n:        
                return Counter([0]) if j else Counter()

            res=Counter()
            for k in range(0,[int(s[i])+1,2][j]):
                    nxt= dp(i+1,j or k<int(s[i]))
                    if nxt:
                        for val in nxt:
                            res[val+k]=(res[val+k]+nxt[val])%mod
            return res   

        res=dp(0,0)

        @cache
        def t(nums):

             if nums==1:
                return 0

             return 1+t(bin(nums).count('1'))   
        
        ans=0
        for i in res:
            if i:
                ans=(ans+res[i]*(t(i)<=k-1))%mod
            
        return ans
                
            
        ",1448289403
lee_218,lee_218,502,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        
        mod=10**9+7
        val=Counter()
        ct=Counter()

        res=0
        for i in nums:

            if  val[i-1]:
                res+=ct[i-1]+i*val[i-1]
                ct[i]+=ct[i-1]+i*val[i-1]
                val[i]+=val[i-1]

            if val[i+1]:
                res+=ct[i+1]+i*val[i+1]
                ct[i]+=ct[i+1]+i*val[i+1]
                val[i]+=val[i+1]

            ct[i]=(ct[i]+i)%mod
            val[i]=(val[i]+1)%mod
            res=(res+i)%mod


        return res    
    
        ",1448245986
Bhavy,BhavyRamani,504,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
    
        vector<bool> dp(n, false);
        for (int i = 0; i <= n - k; ++i) {
            bool flg = true;
            for (int j = i; j < i + k - 1; ++j) {
                if (nums[j] >= nums[j + 1]) {
                    flg = false;
                    break;
                }
            }
            dp[i] = flg;
        }
    
        for (int i = 0; i <= n - 2 * k; ++i) {
            if (dp[i] && dp[i + k]) {
                return true;
            }
        }
        return false;
    }
};",1448186228
Bhavy,BhavyRamani,504,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> r(n);
    
        r[n - 1] = n - 1;
        for (int i = n - 2; i >= 0; --i) {
            if (nums[i] < nums[i + 1]) {
                r[i] = r[i + 1]; 
            } else {
                r[i] = i; 
            }
        }
        
        vector<bool> vis(n);
        vector<pair<int, int>> vp;
        for(int i = 0; i < n; i++){
            if(vis[r[i]])
                continue;
            vp.push_back({i, r[i]});
            vis[r[i]] = true;
        }

        int mx = (vp[0].second - vp[0].first + 1) >> 1;
        for(int i = 0; i < int(vp.size()-1); i++){
            int mn = min(vp[i].second-vp[i].first+1, vp[i+1].second-vp[i+1].first+1);
            mx = max(mx, mn);
            mx = max(mx, (vp[i+1].second - vp[i+1].first + 1) >> 1);
        }
        return mx;
    }
};",1448201162
Bhavy,BhavyRamani,504,3631,cpp,"class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        int n = s.size(), m = 1e9+7;
        const int N = 810;
        vector<int> pre(N);
        
        // Precompute k-reducible numbers for each count of set bits up to 809
        for(int i = 0; i < N; i++){
            int x = i;
            for(int j = 0; j < k-1; j++) {
                x = __builtin_popcount(x);
            }
            pre[i] = (x == 1);
        }
        
        // DP array
        int dp[N][N][2];
        memset(dp, -1, sizeof dp);
        
        // Recursive function with digit DP
        auto rec = [&](int i, int cnt, int tight, auto &&self) -> int {
            if(i == n) return pre[cnt];  // Base case: check if count of set bits is k-reducible
            
            if(dp[i][cnt][tight] != -1) return dp[i][cnt][tight];
            
            int ans = 0;
            int limit = tight ? (s[i] - '0') : 1;
            
            for(int j = 0; j <= limit; j++) {
                ans = (ans + self(i + 1, cnt + j, tight && (j == limit), self)) % m;
            }
            
            return dp[i][cnt][tight] = ans;
        };
        
        // Start recursion with the initial values
        int ans = rec(0, 0, 1, rec);
        
        // Adjust for overcount if `s` itself is k-reducible
        int c = 0;
        for(char ch : s) {
            c += (ch - '0');
        }
        if(pre[c]) {
            ans = (ans - 1 + m) % m;
        }
        
        return ans;
    }
};
",1448311343
Bhavy,BhavyRamani,504,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int n = nums.size(), m = 1e9+7;
        const int N = 1e5+10;
        int cnt[N], dp[N];
        memset(cnt, 0, sizeof cnt);
        memset(dp, 0, sizeof dp);
        for(int i = 0; i < n; i++){
            if(nums[i]-1 >= 0)
                dp[nums[i]] += ((1ll * cnt[nums[i]-1] * nums[i]) % m + (dp[nums[i]-1]) % m) % m;
            dp[nums[i]] %= m;
            dp[nums[i]] += ((1ll * cnt[nums[i]+1] * nums[i]) % m + (dp[nums[i]+1]) % m) % m;
            dp[nums[i]] = (dp[nums[i]] + nums[i]) % m;
            
            cnt[nums[i]] += ((nums[i]-1 >= 0 ? cnt[nums[i]-1] : 0) + cnt[nums[i]+1] + 1) % m;
            cnt[nums[i]] %= m;
        }
        int ans = 0;
        for(int i = 0; i < N; i++)
            ans = (ans + dp[i]) % m;
        return ans;
    }
};",1448249029
Xiaoping Hu,xiaoping3418,505,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> left(n, 1), right(n, 1);
        
        for (int i = 1; i < n; ++i) {
            if (nums[i - 1] >= nums[i]) continue; 
            left[i] = left[i - 1] + 1;
        }
        
        for (int i = n - 2; i >= 0; --i) {
            if (nums[i] >= nums[i + 1]) continue; 
            right[i] = right[i + 1] + 1;
        }
        
        int ret = 1;
        for (int i = 0; i + 1 < n; ++i) {
            ret = max(ret, min(left[i], right[i + 1]));
        }
                      
        return ret >= k;
    }
};",1448189817
Xiaoping Hu,xiaoping3418,505,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> left(n, 1), right(n, 1);
        
        for (int i = 1; i < n; ++i) {
            if (nums[i - 1] >= nums[i]) continue; 
            left[i] = left[i - 1] + 1;
        }
        
        for (int i = n - 2; i >= 0; --i) {
            if (nums[i] >= nums[i + 1]) continue; 
            right[i] = right[i + 1] + 1;
        }
        
        int ret = 1;
        for (int i = 0; i + 1 < n; ++i) {
            ret = max(ret, min(left[i], right[i + 1]));
        }
                      
        return ret;
    }
};",1448187924
Xiaoping Hu,xiaoping3418,505,3631,cpp,"class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        const int mod = 1000000007, n = s.size();
        
        vector<int> a(n + 1);
        vector<int> f(n + 1, 1);
        
        for (int i = 2; i <= n; ++i) {
            f[i] = (int64_t)f[i - 1] * i % mod;
        }
        
        auto divide = [&](int a) -> int {
            if (a == 0) return 1;
            
            int64_t ret = 1, pw = mod - 2, base = a;
            
            while (pw > 0) {
                if (pw&1) ret = ret * base % mod;
                base = base * base % mod;
                pw /= 2;
            }
            
            return ret;
        };
        
        for (int i = 1; i <= n; ++i) {
            int t = i;
            for (int it = 1; it < k and t > 1; ++it) {
                int cnt = 0;
                for (int d = 0; d < 10; ++d) {
                    if (~t>>d&1) continue;
                    cnt += 1;
                }
                t = cnt;
            }
            if (t == 1) a[i] = 1;
        }
        
        int64_t ret = 0;
        int cnt = 0;
        
        for (int i = 0; i < n; ++i) {
            if (s[i] == '0') continue;
            if (i + 1 == n and cnt == 0) break;
            
            for (int d = 0; d < n - i; ++d) {
                if (a[cnt + d] == 0) continue;    
                int64_t t = f[n - 1 - i];
                t = t * divide(f[d]) % mod;
                t = t * divide(f[n - 1 - i - d]) % mod;
                ret = (ret + t) % mod;
            }
            cnt += 1;
        }
        
        return ret;
    }
};",1448298094
Xiaoping Hu,xiaoping3418,505,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        const int mod = 1000000007;
        int ret = 0;
        unordered_map<int, pair<int, int>> mp;
        
        for (auto it: nums) {
            int64_t t = it;
            int total = 1;
            
            if (mp.find(it + 1) != mp.end()) {
                auto [cnt, a] = mp[it + 1];
                
                t = (t + a) % mod;
                t = (t + (int64_t) it * cnt % mod) % mod;
                total += cnt;
            }
            
            if (mp.find(it - 1) != mp.end()) {
                auto [cnt, a] = mp[it - 1];
                t = (t + a) % mod;
                t = (t + (int64_t) it * cnt % mod) % mod;
                total = (total + cnt) % mod;
            }
            
            mp[it].first = (mp[it].first + total) % mod;
            mp[it].second = (mp[it].second + t) % mod; 
            ret = (ret + t) % mod;
        }
       
        return ret;
    }
};",1448234650
Spryzen,Spryzen,506,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        // want to find if there are tow subarrays, such that both are strictly increasing
        bool works;
        for(int i=0;i<nums.size();i++){
            works=1;
            int j=i+k;
            int l=j+k;

            cout << i << "" ""<<j <<"" ""<<l;
            if (l>nums.size())
                return 0;

            for(int p=i;p<j-1;p++)
                works &= (nums[p]<nums[p+1]);

            for(int p=j;p<l-1;p++)
                works &= (nums[p]<nums[p+1]);
            if (works)
                return 1;
        }
        return 0;
    }
};",1448195421
Spryzen,Spryzen,506,3619,cpp,"class Solution {
public:
    // runs in O(nlogn)
    int maxIncreasingSubarrays(vector<int>& nums) {
    	int lo=0;
        int hi=nums.size();
    	while (lo < hi) {
    		// find the middle of the current range (rounding up)
    		int mid = lo + (hi - lo + 1) / 2;
    		if (hasIncreasingSubarrays(nums,mid)) {
    			// if mid works, then all numbers smaller than mid also work
    			lo = mid;
    		} else {
    			// if mid does not work, greater values would not work either
    			hi = mid - 1;
    		}
    	}
    	return lo;
    }
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        if (nums.size()<2*k)
            return 0;

        bool works;
    
        vector<bool> isIncreasing(nums.size() - k + 1, false);
        int increasingCount = 0;
    
        for (int i = 0; i < k - 1; ++i) {
            if (nums[i] < nums[i + 1]) ++increasingCount;
        }
        isIncreasing[0] = (increasingCount == k - 1);
    
        for (int i = 1; i <= nums.size() - k; ++i) {

            if (nums[i + k - 2]<nums[i+k-1]) ++increasingCount;
            if (nums[i - 1]<nums[i]) --increasingCount;
    
            isIncreasing[i] = (increasingCount == k - 1);
        }

        if (k==1)
            cout << isIncreasing[0]<<"" ""<<isIncreasing[1];

        
        for (int i = 0; i <= nums.size() - 2*k; ++i) {
            if (isIncreasing[i] & isIncreasing[i+k])
                return 1;
        }
        return 0;
    }
};",1448219100
Spryzen,Spryzen,506,3631,cpp,"class Solution {
public:
    // time taken to reduce it
    vector<int> dpArr;//(900,-1);
    vector<vector<int>> binom;

const int MOD=(int)1e9+7;
    int countKReducibleNumbers(string s, int k) {
        // want to find the number of integers that can be reduced in less than k steps
        // so need to compute it to 800 times basically
        // if I need to find how many times it takes
        // so this is going to be 800
        // then after that find out how many ways there are
        // so s.size()-1 C k-1
        // then add all of that 
        // no leading 0s so set that one as first
        // compute how many 0s there are
        dpArr.assign(900,-1);
        binom.assign(901, vector<int>(901, 0));

        int n=s.size();


    	for (int i = 0; i <= n; i++) {
    		binom[i][0] = 1;
    		binom[i][i] = 1;
    	}
    
    	for (int i = 0; i <= n; i++) {
    		for (int j = 1; j <= i; j++) {
    			if (i ^ j) { 
    				binom[i][j] = (binom[i - 1][j - 1] + binom[i - 1][j]) % MOD;
    			}
    		}
    	}
        long long ans=0;
        dpArr[1]=0;
        for(int i=1;i<=s.size();i++){
            if (dp(i)<k){
                //cout << i <<"" "";
                ans+=countLexicographicallySmallerStrings(s,i);
                ans%=MOD;
            }
        }
        // now want to find the number of ones that are less than this
        // so we've computed for each one how many k times it can have
        // obviously if the one is at a higher position then the 
        // find
        return ans;

    }
    int dp(int a){
        if (dpArr[a]!=-1)
            return dpArr[a];
        int b=a;
        int j=0;
        while (a){
            j+=(a&1);
            a>>=1;
        }
        return dpArr[b]=dp(j)+1;
    }

    // find nCk
    
    // Function to count bit strings lexicographically smaller than s
    // Then it needs to have everything with either a 1 or a 0
    long long countLexicographicallySmallerStrings(const string& s, int numOnes) {
        int n = s.length();
        long long count = 0;
    
        // Traverse each position in the string `s`
        for (int i = 0; i < n; ++i) {
            if (s[i] == '1') {
                count += binom[n - i - 1][numOnes];
                count %= MOD;
                numOnes--; 
            }
            if (numOnes < 0) break;
        }
    
        return count;
    }
};",1448254559
Spryzen,Spryzen,506,3646,cpp,"class Solution {
public:
    const int MOD=(int)1e9+7;
    int sumOfGoodSubsequences(vector<int>& nums) {
        // want to find sum of all possible good subsequences
        // so want to go either 
        // since greatest

        // want to find the sum of all possible good subsequences
        // so all of the individual elements are of course one then

        // so want to compute this in O(n) time

        int n=nums.size();

        // store the number of sequences that are starting and ending here
        map<int,long long> num_ending;
        map<int,long long> sum_ending;
        long long ans=0;

        for(int i=0;i<n;i++){
            // now let us include this as the first element of the subsequence
            // then we would need to sum up all possible later ones with <1 gap from it
            // or the other way, in which you choose whether or not to extend based on that
            // find num ending with it
            
            // stores the number of subsequences, where this extends, but the problem is that it is
            // going to be the same subsequence again

            // so I'm going to have to keep track of the new ones
            // so what to deal with repeats is the hard thing
            
            // now need to account for duplicates, basically what 
            
            long long b=num_ending[nums[i]];
            long long c;
            num_ending[nums[i]] = (1+num_ending[nums[i]-1] + num_ending[nums[i]+1])%MOD;
            ans+=(c = (num_ending[nums[i]] * ((long long)nums[i]))%MOD + sum_ending[nums[i]-1] + sum_ending[nums[i]+1])%MOD;
            sum_ending[nums[i]]+=c;
            num_ending[nums[i]]+=b;
            num_ending[nums[i]]%=MOD;
            sum_ending[nums[i]]%=MOD;
            //cout << num_ending[nums[i]]<<"" ""<<sum_ending[nums[i]]<<""\n"";

            ans%=MOD;
        }/*
        unordered_set<int> seen;
        for(int j=0;j<n;j++){
            if (seen.count(nums[j]))
                continue;
            seen.insert(nums[j]);
            ans+=sum_ending[nums[j]];
            ans%=MOD;
            
        }*/
        return ans;
        
    }
};",1448294621
yashaswi,Techie_Chic,507,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        for(int i=0;i<=nums.size()-2*k;i++)
        {
            bool x=true;
             for(int j=i+1;j<i+k && x;j++)
             {
                 if(nums[j]<=nums[j-1]) x=false;
             }
             for(int j=i+k+1;j<i+2*k && x;j++)
             {
                 if(nums[j]<=nums[j-1]) x=false;
             }
            if(x) return true;
        }
        return false;
    }
};",1448199861
yashaswi,Techie_Chic,507,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n=nums.size();
        vector<int>vb(n,1),vf(n,1);
        int c=1,ans=0;
        for(int i=1;i<n;i++)
        {
            if(nums[i]>nums[i-1]) c++;
            else c=1;
            vb[i]=c;
            ans=max(ans,c/2);
        }
        c=1;
         for(int i=n-2;i>=0;i--)
        {
            if(nums[i]<nums[i+1]) c++;
            else c=1;
            vf[i]=c;
            ans=max(ans,c/2);
        }
        for(int i=0;i<n;i++)
        {
            if(i>0) ans=max(ans,min(vf[i],vb[i-1]));
            if(i<n-1) ans=max(ans,min(vb[i],vf[i+1]));
          //  cout<<i<<"" ""<<vf[i]<<"" ""<<vb[i]<<""\n"";
        }
        return ans;
    }
};",1448235468
yashaswi,Techie_Chic,507,3631,cpp,"
class Solution {
public:
    static const int MOD = 1e9 + 7;
    vector<int> fact, invFact;

    // Function to count set bits in a number
    int countSetBits(int num) {
        int count = 0;
        while (num > 0) {
            count += num & 1;
            num >>= 1;
        }
        return count;
    }

    // Function to precompute factorials and modular inverses up to maxN
    void precomputeFactorials(int maxN) {
        fact.resize(maxN + 1, 1);
        invFact.resize(maxN + 1, 1);
        for (int i = 2; i <= maxN; ++i) {
            fact[i] = (1LL * fact[i - 1] * i) % MOD;
        }
        invFact[maxN] = modInverse(fact[maxN], MOD);
        for (int i = maxN - 1; i >= 1; --i) {
            invFact[i] = (1LL * invFact[i + 1] * (i + 1)) % MOD;
        }
    }

    // Calculate combination (n choose r) % MOD using precomputed factorials
    int combination(int n, int r) {
        if (r > n || r < 0) return 0;
        return (1LL * fact[n] * invFact[r] % MOD * invFact[n - r] % MOD) % MOD;
    }

    // Helper function to calculate modular inverse using Fermat's Little Theorem
    int modInverse(int a, int mod) {
        int res = 1, b = mod - 2;
        while (b) {
            if (b & 1) res = (1LL * res * a) % mod;
            a = (1LL * a * a) % mod;
            b >>= 1;
        }
        return res;
    }

    int countKReducibleNumbers(string s, int k) {
        int n = s.size();
        precomputeFactorials(n);  // Precompute factorials and inverses up to n

        vector<int> v(n + 1, 0);
        v[1] = 0;

        // Populate `v` array based on the number of set bits
        for (int i = 2; i <= n; i++) {
            int x = countSetBits(i);
            v[i] = v[x] + 1;
        }

        int ans = -1;
        int c = 0;

        // Process each '1' in the string `s`
        for (int i = 0; i < n; i++) {
            if (s[i] == '1') {
                for (int j = 0; j <= n - i - 1; j++) {
                    if (v[c + j] < k) {
                        ans = (ans + combination(n - i - 1, j)) % MOD;
                    }
                }
                c++;
            }
        }
        return ans;
    }
};
",1448307960
yashaswi,Techie_Chic,507,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int n = nums.size();
        const int MOD = 1e9 + 7;
        vector<int> v(1e5 + 1, 0);
        vector<int> f(1e5 + 1, 0);
        
        for (int i = 0; i < n; i++) {
            int x = nums[i] - 1, y = nums[i] + 1;
            
            if (x >= 0) {
                v[nums[i]] = ((v[nums[i]] + v[x])% MOD + (f[x] * 1LL * nums[i]) % MOD) % MOD;
                f[nums[i]] = (f[nums[i]] + f[x]) % MOD;
            }
            if (y <= 1e5) {
                v[nums[i]] = ((v[nums[i]] +  v[y])% MOD  + (f[y] * 1LL * nums[i]) % MOD) % MOD;
                f[nums[i]] = (f[nums[i]] + f[y]) % MOD;
            }
            
            v[nums[i]] = (v[nums[i]] + nums[i]) % MOD;
            f[nums[i]] = (f[nums[i]] + 1) % MOD;
           // cout<<i<<"" ""<<v[nums[i]]<<""\n"";
        }
        
        int sum = 0;
        for (int i = 0; i <= 1e5; i++) {
            sum = (sum + v[i]) % MOD;
        }
        
        return sum;
    }
};
",1448263111
Ankit sisodya,Ankitsisodya,509,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {

        int n = nums.size();
        for (int i = 0; i + 2 * k - 1 < n; ++i) {
            int cnt1 = 0;
            int cnt2 = 0;
            for (int j = i + 1; j < i + k; ++j) {
                cnt1 += nums[j] > nums[j - 1];
            }
            for (int j = i + k + 1; j < i + 2*k; ++j) {
                cnt2 += nums[j] > nums[j - 1];
            }
            if (cnt1 == k - 1 && cnt2 == k - 1)
                return true;
            // cout << i << "" "" << cnt1 << "" "" << cnt2 << ""\n"";
        }
        return false;
    }
};",1448193851
Ankit sisodya,Ankitsisodya,509,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int> nums) {
        int n = nums.size();
        nums.insert(nums.begin(), 0);
        vector pref(n + 1, 0ll);
        for (int i = 2; i <= n; ++i)
            pref[i] = nums[i] > nums[i - 1];
        for (int i = 2; i <= n; ++i)
            pref[i] += pref[i - 1];
        int l = 1, r = n;
        auto check = [&](int x) -> bool {
            for (int i = 1; i + 2 * x - 1 <= n; ++i) {
                if (pref[i + x - 1] - pref[i] >= x - 1 &&
                    pref[i + 2 * x - 1] - pref[i + x] >= x - 1) {

                    return true;
                }
            }
            return false;
        };

        while (r - l > 1) {
            (check((l + r) >> 1) ? l : r) = (l + r) >> 1;
        }
        return l;
    }
};",1448209459
Ankit sisodya,Ankitsisodya,509,3631,cpp,"
const int MOD = (int)1e9 + 7;

int add(int x, int y) { return (((x) % MOD + (y) % MOD) % MOD + MOD) % MOD; }

int mul(int x, int y) { return ((x % MOD) * 1ll * (y % MOD)) % MOD; }

int binpow(int x, int y) {
    int z = 1;
    while (y) {
        if (y % 2 == 1)
            z = mul(z, x);
        x = mul(x, x);
        y /= 2;
    }
    return z;
}

int inv(int x) { return binpow(x, MOD - 2); }

int divide(int x, int y) { return mul(x, inv(y)); }

class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        vector<long long> fac(801, 1);
        for (int i = 2; i <= 800; ++i)
            fac[i] = (fac[i - 1] * 1ll * i) % MOD;
        vector<long long> invfac(801, 0);
        invfac[800] = inv(fac[800]);
        for (int i = 799; i >= 0; --i)
            invfac[i] = (invfac[i + 1] * (long long)(i + 1ll)) % MOD;
        auto ncr = [&](int n, int r) {
            if (n < r)
                return 0ll;
            else
                return (long long)mul(fac[n], mul(invfac[n - r], invfac[r]));
        };
        vector dp(801, 0ll);
        dp[1] = 1;
        for (int i = 2; i <= 800; ++i) {
            dp[i] = dp[__builtin_popcount(i)] + 1;
        }
        int msb = -1;
        int n = s.size();
        for (int i = 0; i < n; ++i)
            if (s[i] == '1') {
                msb = i;
                break;
            }

        int cnt = 0;
        long long ans = 0;
        for (int i = n - 1; i >= msb + 1; --i) {
            cnt += s[i] == '1';
            int len = n - 1 - i + 1;
            for (int j = 1; j <= len; ++j) {
                if (dp[j] <= k) {
                    // cout << i << "" "" << j <
                    ans = add(ans, ncr(len - 1, j - 1));
                }
            }
            // cout << ans << "" "" << i << ""\n"";
        }
        // cout << ans << ""\n"";
        bool flag = false;
        int cnta = 1;
        for (int e = msb + 1; e < n; ++e) {
            if (s[e] == '0')
                continue;
            cnta++;
            // if(e + 1 == n)
            // {
                // ans = add(ans, dp[cnta - 1] <= k);

                int len = n - 1 - e;
                for (int j = 0; j <= len; ++j) {
                    if (dp[j + cnta - 1] <= k) {
                        ans = add(ans, ncr(len, j));
                    }
                }
        
        }

        // ans--;
        return (int)ans;
    }
};",1448308744
Ankit sisodya,Ankitsisodya,509,3646,cpp,"class Solution {
public:
    const int MOD = 1e9 + 7;
    int sumOfGoodSubsequences(vector<int>& nums) {
        map<long long, long long> last, last_ans;
        last[nums[0]] = 1;
        last_ans[nums[0]] = nums[0];
        int n = nums.size();
        long long ans = 0;

        for (int i = 1; i < n; ++i) {
            last_ans[nums[i]] = (last_ans[nums[i]] + last_ans[nums[i] - 1] 
                + last_ans[nums[i] + 1] 
                + nums[i] * (last[nums[i] - 1] + last[nums[i] + 1]) % MOD) % MOD;

            last[nums[i]] = (last[nums[i]] + last[nums[i] - 1] 
                + last[nums[i] + 1] + 1) % MOD;

            last_ans[nums[i]] = (last_ans[nums[i]] + nums[i]) % MOD;
        }

        for (auto& [x, y] : last_ans)
            ans = (ans + y) % MOD;

        return (int)ans;
    }
};",1448244835
berkeleyColin,berkeleyColin,510,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n=nums.size();
        int streak=0;
        int prev=INT_MIN;
        int found=0;
        for(int v:nums){
            if(v>prev){
                streak++;
            }else {
                if(streak<k)found=0;
                streak=1;
            }
            if(streak%k==0){
                found++;
            }
            prev=v;
            if(found==2)return true;
        }
        return false;
    }
};",1448195657
berkeleyColin,berkeleyColin,510,3619,cpp,"class Solution {
public:
    typedef long long ll;
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n=nums.size();
        int streak=0;
        int prev=INT_MIN;
        int found=0;
        for(int v:nums){
            if(v>prev){
                streak++;
            }else {
                if(streak<k)found=0;
                streak=1;
            }
            if(streak%k==0){
                found++;
            }
            prev=v;
            if(found==2)return true;
        }
        return false;
    }
    int maxIncreasingSubarrays(vector<int>& nums) {
        ll l=1;
        ll r=nums.size()-1;
        ll mid;
        ll best=1;
        while(l<=r){
            mid=(l+r)/2;
            if(hasIncreasingSubarrays(nums,mid)){
                best=mid;
                l=mid+1;
            }else r=mid-1;
        }
        return best;
    }
};",1448199268
berkeleyColin,berkeleyColin,510,3631,cpp,"class Solution {
public:
    typedef long long ll;
    ll mod=1e9+7;
    bool isPossible[801][6];
    ll dp[801][801][2];
    int countKReducibleNumbers(string s, int k) {
        int n=s.size();

        // solve for each integer 1 through n inclusive
        isPossible[1][0]=true;
        for(int K=1;K<=k;K++){
            isPossible[1][K]=true;
            for(int v=2;v<=n;v++){
                int numBits=0;
                for(int i=0;i<32;i++)numBits+=((v&(1<<i))>0);
                isPossible[v][K]=isPossible[v][K-1]|isPossible[numBits][K-1];
            }
        }

        dp[0][0][1]=1;
        for(int pos=0;pos<n;pos++){
            for(int count=0;count<=n;count++){
                for(int tight=0;tight<=1;tight++){
                    int limit=tight?(s[pos]-'0'):1;
                    dp[pos+1][count][tight&&(limit==0)]=(dp[pos+1][count][tight&&(limit==0)]+dp[pos][count][tight])%mod;
                    if(count+1<=n&&limit>=1){
                        dp[pos+1][count+1][tight&&(limit==1)]=(dp[pos+1][count+1][tight&&(limit==1)]+dp[pos][count][tight])%mod;
                    }
                }
            }
        }
        
        ll ret=0;
        for(int i=1;i<n;i++){
            ret=(ret+(dp[n][i][0])*((ll)isPossible[i][k-1]))%mod;
        }
        return ret;
    }
};",1448309462
berkeleyColin,berkeleyColin,510,3646,cpp,"class Solution {
public:
    typedef long long ll;
    ll dp[100005][2];
    ll mod=1e9+7;
    int sumOfGoodSubsequences(vector<int>& nums) {
        ll mx=0;
        for(ll v:nums){
            mx=max(mx,v);
            if(v==0){
                dp[v][0]=(dp[v][0]+1LL)%mod;
                dp[v][0]=(dp[v][0]+dp[v+1][0])%mod;
                dp[v][1]=(dp[v][1]+dp[v+1][1])%mod;
            }else {
                dp[v][0]=(dp[v][0]+1LL+dp[v-1][0])%mod;
                dp[v][1]=(dp[v][1]+v+dp[v-1][0]*v + dp[v-1][1])%mod;
                dp[v][0]=(dp[v][0]+dp[v+1][0])%mod;
                dp[v][1]=(dp[v][1]+dp[v+1][0]*v + dp[v+1][1])%mod;
            }
        }
        ll ret=0;
        for(int i=0;i<=mx;i++){
            ret=(ret+dp[i][1])%mod;
        }
        return ret;
    }
};

/**
dp[0][0]=1
dp[0][1]=1
dp[1][0]=2
dp[1][1]=2
dp[]


**/",1448227740
Tianzhou Gao,gtzafw,516,3612,python3,"class Solution:
    def hasIncreasingSubarrays(self, nums: List[int], k: int) -> bool:
        ans = False
        n = len(nums)

        def check(nums, i, k):
            if i + k > len(nums):
                return False
            for j in range(i, i + k - 1):
                if nums[j] >= nums[j + 1]:
                    return False
            return True

        for i in range(n - k):
            if check(nums, i, k) and check(nums, i + k, k):
                ans = True
                break
            
        return ans
        ",1448183673
Tianzhou Gao,gtzafw,516,3619,python3,"class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)

        len_inc = [1] * n
        for i in range(1, n):
            if nums[i] > nums[i - 1]:
                len_inc[i] = len_inc[i - 1] + 1

        def can_find_two_adjacent_subarrays(k):
            for i in range(n - 2 * k + 1):
                if len_inc[i + k - 1] >= k and len_inc[i + 2 * k - 1] >= k:
                    return True
            return False

        left, right = 1, n // 2
        ans = 0
        while left <= right:
            mid = (left + right) // 2
            if can_find_two_adjacent_subarrays(mid):
                ans = mid
                left = mid + 1
            else:
                right = mid - 1
    
        return ans",1448218948
Tianzhou Gao,gtzafw,516,3631,python3,"MOD = 10**9 + 7
dp = [[1], [1, 1]]
for i in range(2, 801):
    dp.append([1])
    for j in range(1, i):
        dp[i].append((dp[i-1][j-1] + dp[i-1][j]) % MOD)
    dp[i].append(1)

# print(dp)

transforms = [0] * 802
for i in range(1, 801):
    cnt = 0
    t = i
    while t > 1:
        t = bin(t).count('1')
        cnt += 1
    transforms[i] = cnt
transforms[0] = 10000

# print(transforms)

class Solution:
    def countKReducibleNumbers(self, s: str, k: int) -> int:
        n = len(s)
        ans = 0
        count1 = 0
        for i in range(n):
            if s[i] == '0': continue

            dpi = [0] * count1 + dp[n-i-1]

            for j in range(len(dpi)):
                #print(i, j, dpi, transforms[j], ans)
                if transforms[j] < k:
                    ans = (ans + dpi[j]) % MOD

            count1 += 1

        return ans",1448300931
Tianzhou Gao,gtzafw,516,3646,python3,"class Solution:
    def sumOfGoodSubsequences(self, nums: List[int]) -> int:
        dp = [[0, 0] for _ in range(100003)]
        # dp[i] = [m,n] means the number of good subsequences ending with i is m, and the sum of good subsequences ending with i is n

        for num in nums:
            dp[num][0] += dp[num-1][0]
            dp[num][1] += dp[num-1][1] + dp[num-1][0] * num
            dp[num][0] += dp[num+1][0]
            dp[num][1] += dp[num+1][1] + dp[num+1][0] * num
            dp[num][0] += 1
            dp[num][1] += num

            dp[num][0] %= 10**9 + 7
            dp[num][1] %= 10**9 + 7


        ans = 0

        for i in range(100001):
            ans += dp[i][1]
            ans %= 10**9 + 7

        return ans",1448244744
hieupy2k5,hieupy2k5,519,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        vector<int> p;
        int pre = -(1 << 30), count = 0;
        for (auto val: nums) {
            if (val > pre) {
                count++;
                p.push_back(count);
            } else {
                count = 1;
                p.push_back(count);
            }
            pre = val;

            cout<<count<<'\n';
            if (count >= k && p.size() >= 2 * k && p[p.size() - k - 1] >= k) return true; 
           
        }
        return false;
    }
};",1448196560
hieupy2k5,hieupy2k5,519,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        vector<int> p;
        int res = 0, count = 0, pre = nums[0] - 1;
        for (auto val: nums) {
            if (val > pre) {
                count++;
            } else {
                p.push_back(count);
                count = 1;
            }
            pre = val;
        }

        p.push_back(count);

        for (int i = 0 ; i < p.size() ; i++) {
            res = max(res, p[i] / 2);
            if (i) res = max(res, min(p[i], p[i - 1]));
        }
        
        return res;
    }
};",1448203256
hieupy2k5,hieupy2k5,519,3631,cpp,"class Solution {
public:
    long long d[1000], fact[1235], invFact[1234];
    const int MOD = 1e9 + 7;

    // Hàm tính lũy thừa a^b % p
    long long power(long long a, long long b, int p) {
        long long result = 1;
        a = a % p;
        while (b > 0) {
            if (b % 2 == 1)
                result = (result * a) % p;
            a = (a * a) % p;
            b /= 2;
        }
        return result;
    }

    // Chuẩn bị trước mảng giai thừa và giai thừa nghịch đảo modulo p
    void prepareFactorials(int p) {
        fact[0] = 1;
        for (int i = 1; i <= 1000; ++i)
            fact[i] = fact[i - 1] * i % p;

        invFact[1000] = power(fact[1000], p - 2, p);
        for (int i = 1000 - 1; i >= 0; --i)
            invFact[i] = invFact[i + 1] * (i + 1) % p;
    }

    // Hàm tính tổ hợp C(n, k) % p sử dụng mảng đã chuẩn bị trước
    long long binomialCoefficient(int n, int k, int p) {
        if (k > n) return 0;
        return fact[n] * invFact[k] % p * invFact[n - k] % p;
    }

    int countKReducibleNumbers(string s, int k) {
        prepareFactorials(MOD);
        long long res = 0;

        // Tính d[i] trước cho các giá trị từ 1 đến s.size()
        for (int i = 2; i <= s.size(); i++) {
            d[i] = d[__builtin_popcount(i)] + 1;
        }

        int count = 0;

        for (int i = 0; i < s.size(); i++) {
            if (s[i] == '0') {
                continue;
            }

            // Duyệt qua các giá trị j có thể từ 0 đến s.size() - i - 1
            for (int j = 0; j <= s.size() - i - 1; j++) {
                if (d[j + count] < k && count + j > 0) {
                    res = (res + binomialCoefficient(s.size() - 1 - i, j, MOD)) % MOD;
                }
            }
            count++;
        }
        return res % MOD;
    }
};",1448293675
hieupy2k5,hieupy2k5,519,3646,cpp,"class Solution {
public:
    const int Mod = 1e9 + 7;
    const int N = 1e5 + 123;

    long long sum[123456], count[123456];

    int sumOfGoodSubsequences(vector<int>& nums) {
        long long res = 0;

        
        
        for (auto val: nums) {
            count[val]++;
            res = (res + Mod - sum[val]) % Mod;
            if (count[val - 1]) sum[val] += sum[val - 1], (count[val] += count[val - 1]) %= Mod;
            if (count[val + 1]) sum[val] += sum[val + 1], (count[val] += count[val + 1]) %= Mod;
            sum[val] += (val * (1 + count[val - 1] + count[val + 1]) % Mod);
            sum[val] %= Mod;
            (res += sum[val]) %= Mod;
        }
        return res;
    }
};",1448241583
QYHamster,QYHamster,520,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        for(int i = 0; i <= n-k*2; i++) {
            int ok = 1;
            for(int j = i+1; j < i+k; j++) {
                if(nums[j] <= nums[j-1]) {
                    ok = 0;
                    break;
                }
            }
            if(!ok) continue;
            for(int j = i+k+1; j < i+k+k; j++) {
                if(nums[j] <= nums[j-1]) {
                    ok = 0;
                    break;
                }
            }
            if(ok) return true;
        }
        return false;
    }
};",1448186835
QYHamster,QYHamster,520,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        vector<int> l, r;
        int n = nums.size();
        l.resize(n);
        r.resize(n);
        for(int i = 1; i < n; i++) {
            if(nums[i] > nums[i-1]) l[i] = l[i-1]+1;
        }
        for(int i = n-2; i >= 0; i--) {
            if(nums[i] < nums[i+1]) r[i] = r[i+1]+1;
        }
        int mx = 0;
        for(int i = 0; i < n-1; i++) {
            mx = max(mx, min(l[i], r[i+1]));
        }
        return mx+1;
    }
};",1448204160
QYHamster,QYHamster,520,3631,cpp,"class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        const int MOD = 1e9 + 7;
        int C[805][805];
        for(int i = 0; i < 805; i++) C[i][0] = C[i][i] = 1;
        for(int i = 1; i < 805; i++) {
            for(int j = 1; j < i; j++) {
                C[i][j] = (C[i-1][j] + C[i-1][j-1]) % MOD;
            }
        }
        int ans[805];
        ans[0] = ans[1] = 0;
        for(int i = 2; i < 805; i++) {
            int x = i, d = 0;
            while(x) {
                d += x%2;
                x /= 2;
            }
            ans[i] = ans[d] + 1;
        }
        int n = s.length();
        int x = n, y = 0;
        long long res = -1;
        for(int i = 0; i < n; i++) {
            x--;
            if(s[i] == '0') 
                continue;
            for(int j = 0; j <= x; j++) {
                //cout << y << ""..."" << j << endl;
                if(ans[y+j] < k) {
                    res = (res + C[x][j]) % MOD;
                    //cout << x << "" "" << j << endl;
                }
            }
            y++;
            //cout << res << endl;
        }
        int g = 0;
        if(s[n-1] == '1') {
            for(int i = 0; i < n-1; i++) if(s[i] == '1') g++;
            //if(ans[g] < k && g != 0) res++;
        }
        return res;
    }
};",1448308187
QYHamster,QYHamster,520,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        const int MOD = 1e9 + 7;
        vector<int> cnt, sum;
        cnt.resize(100005);
        sum.resize(100005);
        long long ans = 0;
        for(auto k: nums) {
            long long c = cnt[k+1]+1;
            long long s = sum[k+1];
            if(k) {
                c += cnt[k-1];
                s += sum[k-1];
            }
            s += c*k;
            cnt[k] = (cnt[k] + c) % MOD;
            sum[k] = (sum[k] + s) % MOD;
            ans = (ans+s) % MOD;
            //cout << ans << endl;
        }
        return ans;
    }
};",1448232364
Jacky Chen,jacky3627,521,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        if (k == 1) return true;
        for (int i = 0; i <= nums.size() - 2 * k; i++) {
            bool valid = true;
            int first = nums[i];
            for (int j = 1; j < k; j++) {
                if (nums[i+j] <= nums[i+j-1]) {
                    valid = false;
                    break;
                }
            }
            if (!valid) continue;
            valid = true;
            first = nums[i+k];
            for (int j = 1; j < k; j++) {
                if (nums[i+k+j] <= nums[i+k+j-1]) {
                    valid = false;
                    break;
                }
            }
            
            if (!valid) continue;
            return true;
        }
        return false;
    }
};",1448186836
Jacky Chen,jacky3627,521,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int> maxInc(n, 1);
        for (int i = 1; i < n; i++) {
            if (nums[i] > nums[i-1]) {
                maxInc[i] = maxInc[i-1] + 1;
            }
        }
        int result = 1;
        for (int i = 0; i < n; i++) {
            result = max(result, maxInc[i]/2); 
            if (i > maxInc[i]) {
                result = max(result, min(maxInc[i], maxInc[i-maxInc[i]]));
            }
        }
        return result;
    }
};",1448196601
Jacky Chen,jacky3627,521,3631,cpp,"class Solution {
public:
    int countKReducibleNumbers(string s, int k) {
        int n = s.size();
        if (s == ""1"") return 0;

        vector<long long> counts(n+1);
        vector<long long> fact(n+1, 1ll);
        vector<long long> inv_fact(n+1, 1ll);
        for (int i = 1; i < n; i++) {
            fact[i] = fact[i-1] * i;
            fact[i] %= MOD;
        }

        for (int i = 1; i < n; i++) {
            inv_fact[i] = power(fact[i], MOD-2);
        }

        int b = 0;
        for (int i = 1; i < n; i++) {
            if (s[i] == '0') continue;
            b++; 
            for (int j = 0; j <= n-i-1; j++) {
                counts[b+j] += ((fact[n-i-1] * inv_fact[j]) % MOD) * inv_fact[n-i-1-j];
                counts[b+j] %= MOD;
            }
        } 
        
        for (int i = 1; i <= n-1; i++) {
            counts[i] += ((fact[n-1] * inv_fact[i]) % MOD) * inv_fact[n-1-i];
            counts[i] %= MOD;
        }

        vector<int> upper(n+1);
        upper[1] = 1;
        for (int i = 2; i <= n; i++) {
            bitset<10> bits(i); 
            int c = 2;
            while (bits.count() > 1) {
                bits = bitset<10>(bits.count()); 
                c++;
            }
            upper[i] = c;
        }

        long long result = 0;
        for (int i = 1; i <= n; i++) {
            if (upper[i] <= k) {
                result += counts[i];
                result %= MOD;
            }    
        }

        for (int u : upper) {
            cout << u << ""; "";
        }
        cout << endl;
        for (int c : counts) {
            cout << c << "", "";
        }
        cout << endl;
        return result;
    }
private:
    int MOD = 1e9 + 7;

    long long power(long long a, int p) {
        long long result = 1ll;
        while (p > 0) {
            if (p % 2 == 1) {
                result *= a;
                result %= MOD;
            }
            a *= a;
            a %= MOD;
            p >>= 1;
        }
        return result;
    }
};",1448309707
Jacky Chen,jacky3627,521,3646,cpp,"class Solution {
public:
    int sumOfGoodSubsequences(vector<int>& nums) {
        int n = nums.size(); 
        vector<long long> currentSum(1e5+2);
        vector<long long> currentCount(1e5+2);

        long long result = 0;
        for (int i = 0; i < n; i++) {
            int d = nums[i];
            currentSum[d] += d;
            currentCount[d]++;

            // -1
            if (d > 0) {
                currentSum[d] += currentSum[d - 1] + (currentCount[d - 1] % MOD) * d;
                currentCount[d] += currentCount[d - 1];
            }
            
            // +1
            currentSum[d] += currentSum[d + 1] + (currentCount[d + 1] % MOD) * d;
            currentCount[d] += currentCount[d + 1];
            currentSum[d] %= MOD;
            currentCount[d] %= MOD;
        }
        
        return accumulate(currentSum.begin(), currentSum.end(), 0ll) % MOD;
    }
private:
    long long MOD = 1e9 + 7;
};",1448225895
forwarding7,forwarding7,522,3619,cpp,"class Solution {
  public:
    int maxIncreasingSubarrays(vector<int> &nums) {
        int n = (int)nums.size();
        vector<int> maxSeq(n, 0);
        for (int i = 0; i < n; i++) {
            if (i == 0 || nums[i] <= nums[i - 1]) {
                maxSeq[i] = 1;
            } else {
                maxSeq[i] = maxSeq[i - 1] + 1;
            }
        }
        int curr = 0, res = 0;
        for (int i = 0; i < n;) {
            int j = i;
            while (j + 1 < n && maxSeq[j + 1] > maxSeq[j]) {
                j++;
            }
            res = max(res, min(curr, j - i + 1));
            res = max(res, (j - i + 1) / 2);

            curr = j - i + 1;
            i = j + 1;
        }
        return res;
    }
};
",1448199211
forwarding7,forwarding7,522,3631,cpp,"class Solution {
  public:
    static constexpr int mod = 1e9 + 7;
    using ll = long long;
    int countKReducibleNumbers(string s, int k) {
        int n = (int)s.size();

        vector<int> kth;
        for (int i = 1; i <= ((int)s.size()); i++) {
            auto target = i;

            for (int j = 0; j < k - 1; j++) {
                if (target == 1) {
                    break;
                }
                target = __builtin_popcount(target);
            }
            if (target == 1) {
                kth.push_back(i);
            }
        }

        ll res = 0;
        vector<vector<ll>> memo(801, vector<ll>(801, -1));

        function<ll(int, bool, int)> dfs = [&](int pos, bool limit,
                                               int tofill) -> ll {
            if (pos == n) {
                if (!limit && tofill == 0) {
                    return 1;
                }
                return 0;
            }
            if (!limit && memo[pos][tofill] != -1) {
                return memo[pos][tofill];
            }

            ll result = 0;
            if (limit) {
                if (s[pos] == '1') {
                    if (tofill > 0) {
                        result += dfs(pos + 1, true, tofill - 1);
                    }
                    result += dfs(pos + 1, false, tofill);
                } else {
                    result += dfs(pos + 1, true, tofill);
                }
            } else {
                result += dfs(pos + 1, false, tofill);
                if (tofill > 0) {
                    result += dfs(pos + 1, false, tofill - 1);
                }
            }
            if (!limit) {
                memo[pos][tofill] = result % mod;
            }
            return result % mod;
        };

        for (auto ones : kth) {
            res = (res + dfs(0, true, ones)) % mod;
        }
        return (int)res;
    }

  private:
};
",1448267061
forwarding7,forwarding7,522,3646,cpp,"class Solution {
  public:
    static constexpr int mod = 1e9 + 7;
    using ll = long long;

    int sumOfGoodSubsequences(vector<int> &nums) {
        int n = (int)nums.size();

        unordered_map<int, pair<ll, int>> mp;
        for (auto num : nums) {
            mp[num] = {(mp[num].first + num) % mod, (mp[num].second + 1) % mod};
            if (mp.contains(num - 1)) {
                mp[num] = {(mp[num].first + mp[num - 1].first +
                            (long long)num * mp[num - 1].second) %
                               mod,
                           (mp[num].second + mp[num - 1].second) % mod};
            }
            if (mp.contains(num + 1)) {
                mp[num] = {(mp[num].first + mp[num + 1].first +
                            (long long)num * mp[num + 1].second) %
                               mod,
                           (mp[num].second + mp[num + 1].second) % mod};
            }
        }

        ll res = 0;
        for (auto &[k, v] : mp) {
            res = (res + v.first) % mod;
        }
        return (int)res;
    }
};",1448221239
jeremykalilin,jeremykalilin,523,3612,java,"import java.util.List;

class Solution {
    private boolean isIncreasing(List<Integer> nums, int start, int k) {
        for (int i = start; i < start + k - 1; i++) {
            if (nums.get(i) >= nums.get(i + 1)) {
                return false;
            }
        }
        return true;
    }

    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        int n = nums.size();
        for (int i = 0; i <= n - 2 * k; i++) {
            if (isIncreasing(nums, i, k) && isIncreasing(nums, i + k, k)) {
                return true;
            }
        }
        return false;
    }
}
",1448278476
jeremykalilin,jeremykalilin,523,3631,java,"import java.util.*;
import java.io.*;

class Solution {
    public int countKReducibleNumbers(String s, int k) {
        final int MOD = 1_000_000_007;
        int len = s.length();
        int MAX_M = len; 

        
        int[] t = new int[MAX_M + 1];
        Arrays.fill(t, -1);
        t[1] = 0; 

        for(int m = 2; m <= MAX_M; m++) {
            if(t[m] == -1) {
                t[m] = computeT(m, t, MAX_M);
            }
        }

        
        Set<Integer> validMs = new HashSet<>();
        for(int m = 1; m <= MAX_M; m++) {
            if(t[m] <= (k - 1)) {
                validMs.add(m);
            }
        }

        
        
        
        
        
        
        long[][][][] dp = new long[len + 1][MAX_M + 1][2][2];
        dp[0][0][1][0] = 1; 

        for(int pos = 0; pos < len; pos++) {
            for(int cnt = 0; cnt <= MAX_M; cnt++) {
                for(int tight = 0; tight <= 1; tight++) {
                    for(int started = 0; started <=1; started++) {
                        if(dp[pos][cnt][tight][started] == 0) {
                            continue;
                        }
                        int limit = (tight == 1) ? (s.charAt(pos) - '0') : 1;
                        for(int bit = 0; bit <= limit; bit++) {
                            int newTight = (tight == 1 && bit == limit) ? 1 : 0;
                            int newStarted = started;
                            if(started == 0 && bit ==1){
                                newStarted =1;
                            }
                            int newCnt = cnt;
                            if(newStarted ==1){
                                newCnt += bit;
                                if(newCnt > MAX_M){
                                    continue;
                                }
                            }
                            dp[pos +1][newCnt][newTight][newStarted] = (dp[pos +1][newCnt][newTight][newStarted] + dp[pos][cnt][tight][started]) % MOD;
                        }
                    }
                }
            }
        }

        
        
        long total = 0;
        for(int m : validMs) {
            total = (total + dp[len][m][0][1]) % MOD;
        }

        return (int) total;
    }

    
    private int computeT(int m, int[] t, int MAX_M){
        if(m ==1){
            return 0;
        }
        if(m <1){
            return Integer.MAX_VALUE;
        }
        int popcount = countSetBits(m);
        if(popcount > MAX_M){
            return Integer.MAX_VALUE;
        }
        if(t[popcount] == -1){
            t[popcount] = computeT(popcount, t, MAX_M);
        }
        if(t[popcount] == Integer.MAX_VALUE){
            return Integer.MAX_VALUE;
        }
        return t[popcount] + 1;
    }

    
    private int countSetBits(int m){
        int count=0;
        while(m >0){
            count += (m &1);
            m >>=1;
        }
        return count;
    }

    
    public static void main(String[] args) throws IOException {
        Solution sol = new Solution();
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String line;
        while((line = br.readLine()) != null && !line.trim().isEmpty()){
            String[] parts = line.trim().split(""\\s+"");
            if(parts.length !=2){
                System.out.println(""Invalid input format. Expected: <binary_string> <k>"");
                continue;
            }
            String s = parts[0];
            int k = Integer.parseInt(parts[1]);
            int res = sol.countKReducibleNumbers(s, k);
            System.out.println(res);
        }
    }
}
",1448310415
jeremykalilin,jeremykalilin,523,3646,java,"import java.util.*;

class Solution {
    public int sumOfGoodSubsequences(int[] nums) {
        final int MOD = 1_000_000_007;
        int maxNum = 100_000; 

        
        long[] count = new long[maxNum + 2]; 
        long[] sum = new long[maxNum + 2];

        long result = 0;

        for (int num : nums) {
            
            long newCount = 1;
            long newSum = num;

            
            if (num > 0) {
                newCount = (newCount + count[num - 1]) % MOD;
                newSum = (newSum + sum[num - 1] + (count[num - 1] * num) % MOD) % MOD;
            }

            
            if (num < maxNum) {
                newCount = (newCount + count[num + 1]) % MOD;
                newSum = (newSum + sum[num + 1] + (count[num + 1] * num) % MOD) % MOD;
            }

            
            count[num] = (count[num] + newCount) % MOD;
            sum[num] = (sum[num] + newSum) % MOD;

            
            result = (result + newSum) % MOD;
        }

        return (int) result;
    }
}
",1448304143
Ujjwal Agnihotri,Java_Programmer_Ujjwal,524,3612,java,"import java.util.List;

class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        int n = nums.size();
        int[] a = new int[n];
        for (int i = 0; i < n; ++i) a[i] = nums.get(i);
        for (int i = 0, j = k - 1, x = k, y = 2 * k - 1; y < n; ++i, ++j, ++x, ++y) {
            if (check(a, i, j) && check(a, x, y)) return true;
        }
        return false;
    }

    private boolean check(int[] a, int st, int end) {
        int prev = a[st];
        for (int i = st + 1; i <= end; ++i) {
            if (a[i] <= prev) return false;
            prev = a[i];
        }
        return true;
    }
}",1448193289
Ujjwal Agnihotri,Java_Programmer_Ujjwal,524,3619,java,"import java.util.ArrayList;
import java.util.List;

class Solution {
    public int maxIncreasingSubarrays(List<Integer> nums) {
        int n = nums.size();
        assert n >= 2;
        int[] a = new int[n];
        for (int i = 0; i < n; ++i) a[i] = nums.get(i);
        List<Integer> l = new ArrayList<>();
        l.add(1);
        for (int i = 1; i < n; ++i) {
            if (a[i] > a[i - 1]) {
                l.set(l.size() - 1, l.getLast() + 1);
            } else {
                l.add(1);
            }
        }
        int res = 1, m = l.size();
        for (int i = 0; i < m; ++i) {
            int oneWay = l.get(i) / 2, otherWay = 0;
            if (i + 1 < m) {
                otherWay = Math.min(l.get(i), l.get(i + 1));
            }
            res = Math.max(res, Math.max(oneWay, otherWay));
        }
        return res;
    }
}",1448230093
Ujjwal Agnihotri,Java_Programmer_Ujjwal,524,3631,java,"class Solution {
    static final int N = 850;
    static final int MOD = (int) (1e9 + 7);
    Modular M;
    int K;
    static int[] costs;

    static {
        costs = new int[N];
        costs[0] = 500000;
        costs[1] = 1;
        for (int i = 2; i < N; ++i) {
            int temp = i, res = 0;
            while (temp != 1) {
                temp = Integer.bitCount(temp);
                ++res;
            }
            costs[i] = res + 1;
            costs[i] %= MOD;
        }
    }

    public int countKReducibleNumbers(String s, int k) {
        int n = s.length();
        char[] a = s.toCharArray();
        int ones = 0;
        for (char ch : a) if (ch == '1') ones++;
        this.K = k;
        M = new Modular();
        Long[][][] dp = new Long[2][n + 1][n];
        long res = dfs(1, 0, 0, a, n, dp);
        if (costs[ones] <= K) res = M.subtract(res, 1, MOD);
        return (int) (res % MOD);
    }

    private long dfs(int tight, int setBits, int index,
                     final char[] a, final int n,
                     Long[][][] dp) {
        if (index == n) {
            return costs[setBits] <= K ? 1 : 0;
        }
        if (dp[tight][setBits][index] != null) return dp[tight][setBits][index];
        long res = 0L;
        if (tight == 1) {
            if (a[index] == '0') {
                res = M.add(res, dfs(1, setBits, index + 1, a, n, dp), MOD);
            } else {
                res = M.add(res, dfs(1, setBits + 1, index + 1, a, n, dp), MOD);
                res = M.add(res, dfs(0, setBits, index + 1, a, n, dp), MOD);
            }
        } else {
            res = M.add(res, dfs(0, setBits + 1, index + 1, a, n, dp), MOD);
            res = M.add(res, dfs(0, setBits, index + 1, a, n, dp), MOD);
        }
        return dp[tight][setBits][index] = res;
    }
}

class Modular {

    private long modularAbs(long n, final long mod) {
        n %= mod;
        if (n < 0)
            n += mod;
        return n;
    }


    /**
     * Adds two numbers in modulo arithmetic.
     * This function is safe for large numbers and won't overflow long.
     *
     * @param a
     * @param b
     * @param mod grater than 0
     * @return (a + b)%mod
     */
    public long add(long a, long b, final long mod) {
        if (mod <= 0)
            throw new IllegalArgumentException(""Mod argument is not grater then 0"");
        a = modularAbs(a, mod);
        b = modularAbs(b, mod);
        if (b > mod - a) {
            return b - (mod - a);
        }
        return (a + b) % mod;
    }

    /**
     * Subtract two numbers in modulo arithmetic.
     * This function is safe for large numbers and won't overflow or underflow long.
     *
     * @param a
     * @param b
     * @param mod grater than 0
     * @return (a - b)%mod
     */
    public long subtract(long a, long b, final long mod) {
        if (mod <= 0)
            throw new IllegalArgumentException(""Mod argument is not grater then 0"");
        return add(a, -b, mod);
    }

    /**
     * Multiply two numbers in modulo arithmetic.
     * This function is safe for large numbers and won't overflow or underflow long.
     * <p>
     *
     * @param a
     * @param b
     * @param mod grater than 0
     * @return (a * b)%mod
     */

    public long multiply(long a, long b, final long mod) {
        if (mod <= 0)
            throw new IllegalArgumentException(""Mod argument is not grater then 0"");
        a = modularAbs(a, mod);
        b = modularAbs(b, mod);
        if (b == 0) return 0;
        return (a * b) % mod;
    }

    /**
     * Calculate power in modulo arithmetic.
     * This function is safe for large numbers and won't overflow or underflow long.
     * <p>
     *
     * @param a
     * @param b   integer grater or equal to zero
     * @param mod grater than 0
     * @return (a ^ b)%mod
     */
    public long pow(long a, long b, final long mod) {
        if (mod <= 0)
            throw new IllegalArgumentException(""Mod argument is not grater then 0"");
        if (b < 0)
            throw new IllegalArgumentException(""Exponent have to be grater or equal to zero"");
        a = modularAbs(a, mod);
        if (a == 0 && b == 0)
            throw new IllegalArgumentException(""0^0 expression"");
        if (a == 0)
            return 0;
        long res = 1;
        while (b > 0) {
            if (b % 2 == 1) res = multiply(res, a, mod);
            a = multiply(a, a, mod);
            b /= 2;
        }
        return res;
    }
}
",1448259679
Raghu Prasad Babu,RamKumarSharma,525,3612,cpp,"class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n=nums.size();

        for(int i=0;i<n;i++){
            //i-i+k-1 i+k-i+2*k-1
            if(i+2*k-1>=n) return false;
            bool ans=true;
            for(int j=i;j<i+k-1;j++){
                if(nums[j]>=nums[j+1]){
                    ans=false;
                    break;
                }
            }
            for(int j=i+k;j<i+2*k-1;j++){
                if(nums[j]>=nums[j+1]){
                    ans=false;
                    break;
                }
            }
            if(ans==true) return true;
        }
        return false;
    }
};",1448183490
Raghu Prasad Babu,RamKumarSharma,525,3619,cpp,"class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n=nums.size();
        vector<int>pre(n,1);
        for(int i=n-2;i>=0;i--){
            if(nums[i+1]>nums[i]) pre[i]=pre[i+1]+1;
        }

        // for(auto x:pre) cout<<x<<"" "";
        int ans=0;
        for(int i=0;i<n;i++){
            int k=pre[i];
            ans=max(ans,k/2);
            if(i+k<n && pre[i+k]>=k) ans=max(ans,k);
        }
        return ans;
    }
};",1448193713
Raghu Prasad Babu,RamKumarSharma,525,3631,cpp,"vector<int>v(801,0);
bool done=false;
void pre(){
    if(done) return;
    done=true;
    v[1]=0;
    for(int i=2;i<800;i++){
        v[i]=1+v[__builtin_popcount(i)];
    }
}
class Solution {
public:
    int mod=1e9+7;
    int check(string &s,int k){
        int nct=0;
        for(auto x:s) nct+=(x=='1');
        return 1+v[nct]<=k;
    }

    int dp[2][801][800];
    int solve(int i,int tight,string &s,int n,int cnt,int k){
        if(i==n){
            if(1+v[cnt]<=k) return 1;
            return 0;
        }
        
        if(dp[tight][cnt][i]!=-1) return dp[tight][cnt][i];
        long long ans=0;
        if(tight){
            if(s[i]=='1'){
                ans+=solve(i+1,0,s,n,cnt,k);
                ans%=mod;
                ans+=solve(i+1,1,s,n,cnt+1,k);
                ans%=mod;
            }
            else{
                ans+=solve(i+1,1,s,n,cnt,k);
                ans%=mod;
            }
        }
        else{
            ans+=solve(i+1,0,s,n,cnt,k);
            ans%=mod;
            ans+=solve(i+1,0,s,n,cnt+1,k);
            ans%=mod;
        }
        return dp[tight][cnt][i]=ans%mod;
    }
    int countKReducibleNumbers(string s, int k) {
        int n=s.size();
        pre();
        // for(auto x:v) cout<<x<<"" "";
        memset(dp,-1,sizeof dp);
        int ans=((solve(0,1,s,n,0,k)-check(s,k)+mod)%mod-1+mod)%mod;
        return ans;
    }
};",1448246414
